package IPXACT2009ScalaCases

// Generated by <a href="http://IPXACT2009scalaxb.org/">IPXACT2009scalaxb</a>.


case class AbstractorMode(value: AbstractorModeType,
  attributes: Map[String, IPXACT2009scalaxb.DataRecord[Any]] = Map.empty) {
  lazy val group = attributes.get("@group") map { _.as[String]}
}

      
      


case class AbstractorInterfaces(abstractorInterface: Seq[AbstractorBusInterfaceType] = Nil)
      
      


/** Abstractor-specific extension to abstractorType
*/
case class AbstractorType(versionedIdentifierSequence1: VersionedIdentifierSequence,
  abstractorMode: AbstractorMode,
  busType: LibraryRefType,
  abstractorInterfaces: AbstractorInterfaces,
  model: Option[AbstractorModelType] = None,
  abstractorGenerators: Option[AbstractorGenerators] = None,
  choices: Option[Choices] = None,
  fileSets: Option[FileSets] = None,
  description: Option[String] = None,
  parameters: Option[Parameters] = None,
  vendorExtensions: Option[VendorExtensions] = None) extends IPXACTDocumentTypesOption
      
      

sealed trait AbstractorModeType

object AbstractorModeType {
  def fromString(value: String, scope: scala.xml.NamespaceBinding)(implicit fmt: IPXACT2009scalaxb.XMLFormat[AbstractorModeType]): AbstractorModeType = fmt.reads(scala.xml.Text(value), Nil) match {
    case Right(x: AbstractorModeType) => x
    case x => throw new RuntimeException(s"fromString returned unexpected value $x for input $value")
  }
  lazy val values: Seq[AbstractorModeType] = Seq(MasterValue, SlaveValue, Direct, SystemValue)
}

case object MasterValue extends AbstractorModeType { override def toString = "master" }
case object SlaveValue extends AbstractorModeType { override def toString = "slave" }
case object Direct extends AbstractorModeType { override def toString = "direct" }
case object SystemValue extends AbstractorModeType { override def toString = "system" }


// Generated by <a href="http://IPXACT2022scalaxb.org/">IPXACT2022scalaxb</a>.
package IPXACT2022ScalaCases

sealed trait AccessType

object AccessType {
  def fromString(value: String, scope: scala.xml.NamespaceBinding)(implicit fmt: IPXACT2022scalaxb.XMLFormat[IPXACT2022ScalaCases.AccessType]): AccessType = fmt.reads(scala.xml.Text(value), Nil) match {
    case Right(x: AccessType) => x
    case x => throw new RuntimeException(s"fromString returned unexpected value $x for input $value")
  }
  lazy val values: Seq[AccessType] = Seq(Readu45only, Writeu45only, Readu45write, WriteOnce, Readu45writeOnce, Nou45access)
}

case object Readu45only extends AccessType { override def toString = "read-only" }
case object Writeu45only extends AccessType { override def toString = "write-only" }
case object Readu45write extends AccessType { override def toString = "read-write" }
case object WriteOnce extends AccessType { override def toString = "writeOnce" }
case object Readu45writeOnce extends AccessType { override def toString = "read-writeOnce" }
case object Nou45access extends AccessType { override def toString = "no-access" }

sealed trait SharedType

object SharedType {
  def fromString(value: String, scope: scala.xml.NamespaceBinding)(implicit fmt: IPXACT2022scalaxb.XMLFormat[IPXACT2022ScalaCases.SharedType]): SharedType = fmt.reads(scala.xml.Text(value), Nil) match {
    case Right(x: SharedType) => x
    case x => throw new RuntimeException(s"fromString returned unexpected value $x for input $value")
  }
  lazy val values: Seq[SharedType] = Seq(Yes, No, Undefined)
}

case object Yes extends SharedType { override def toString = "yes" }
case object No extends SharedType { override def toString = "no" }
case object Undefined extends SharedType { override def toString = "undefined" }

sealed trait BankAlignmentType

object BankAlignmentType {
  def fromString(value: String, scope: scala.xml.NamespaceBinding)(implicit fmt: IPXACT2022scalaxb.XMLFormat[IPXACT2022ScalaCases.BankAlignmentType]): BankAlignmentType = fmt.reads(scala.xml.Text(value), Nil) match {
    case Right(x: BankAlignmentType) => x
    case x => throw new RuntimeException(s"fromString returned unexpected value $x for input $value")
  }
  lazy val values: Seq[BankAlignmentType] = Seq(Serial, Parallel)
}

case object Serial extends BankAlignmentType { override def toString = "serial" }
case object Parallel extends BankAlignmentType { override def toString = "parallel" }

sealed trait UsageType

object UsageType {
  def fromString(value: String, scope: scala.xml.NamespaceBinding)(implicit fmt: IPXACT2022scalaxb.XMLFormat[IPXACT2022ScalaCases.UsageType]): UsageType = fmt.reads(scala.xml.Text(value), Nil) match {
    case Right(x: UsageType) => x
    case x => throw new RuntimeException(s"fromString returned unexpected value $x for input $value")
  }
  lazy val values: Seq[UsageType] = Seq(Memory, RegisterValue, Reserved)
}

case object Memory extends UsageType { override def toString = "memory" }
case object RegisterValue extends UsageType { override def toString = "register" }
case object Reserved extends UsageType { override def toString = "reserved" }


case class AccessHandles(accesshandlessequence1: Seq[IPXACT2022ScalaCases.AccessHandlesSequence1] = Nil)
      
      

case class AccessHandlesSequence1(accessHandle: IPXACT2022ScalaCases.SimpleAccessHandle)
      

case class BankDefinitionRef(value: String,
  attributes: Map[String, IPXACT2022scalaxb.DataRecord[Any]] = Map.empty) extends AddressBankTypeOption {
  lazy val typeDefinitions = attributes("@typeDefinitions").as[String]
}

      
      


/** Top level bank the specify an address
*/
case class AddressBankType(nameGroupSequence1: IPXACT2022ScalaCases.NameGroupSequence,
  accessHandles: Option[IPXACT2022ScalaCases.AccessHandles] = None,
  addressSpecifierSequence3: IPXACT2022ScalaCases.AddressSpecifierSequence,
  addressbanktypeoption: IPXACT2022scalaxb.DataRecord[Any],
  vendorExtensions: Option[IPXACT2022ScalaCases.VendorExtensions] = None,
  attributes: Map[String, IPXACT2022scalaxb.DataRecord[Any]] = Map.empty) extends MemoryMapOption with MemoryMapDefinitionGroupOption1 {
  lazy val bankAlignment = attributes("@bankAlignment").as[BankAlignmentType]
  lazy val xmlid = attributes.get("@{http://www.w3.org/XML/1998/namespace}id") map { _.as[String]}
}

      
      

trait AddressBankTypeOption

case class AccessHandles2(accesshandles2sequence1: Seq[IPXACT2022ScalaCases.AccessHandles2Sequence1] = Nil)
      
      

case class AccessHandles2Sequence1(accessHandle: IPXACT2022ScalaCases.SimpleAccessHandle)
      

case class BankDefinitionRef2(value: String,
  attributes: Map[String, IPXACT2022scalaxb.DataRecord[Any]] = Map.empty) extends AddressBankDefinitionTypeOption {
  lazy val typeDefinitions = attributes("@typeDefinitions").as[String]
}

      
      


/** Top level bank the specify an address
*/
case class AddressBankDefinitionType(nameGroupSequence1: IPXACT2022ScalaCases.NameGroupSequence,
  accessHandles: Option[IPXACT2022ScalaCases.AccessHandles2] = None,
  addressSpecifierSequence3: IPXACT2022ScalaCases.AddressSpecifierSequence,
  addressbankdefinitiontypeoption: IPXACT2022scalaxb.DataRecord[Any],
  vendorExtensions: Option[IPXACT2022ScalaCases.VendorExtensions] = None,
  attributes: Map[String, IPXACT2022scalaxb.DataRecord[Any]] = Map.empty) extends MemoryMapDefinitionTypeGroupOption1 with MemoryRemapDefinitionOption {
  lazy val bankAlignment = attributes("@bankAlignment").as[BankAlignmentType]
  lazy val xmlid = attributes.get("@{http://www.w3.org/XML/1998/namespace}id") map { _.as[String]}
}

      
      

trait AddressBankDefinitionTypeOption

case class AccessHandles3(accesshandles3sequence1: Seq[IPXACT2022ScalaCases.AccessHandles3Sequence1] = Nil)
      
      

case class AccessHandles3Sequence1(accessHandle: IPXACT2022ScalaCases.SimpleAccessHandle)
      

/** Top level bank the specify an address
*/
case class LocalAddressBankType(nameGroupSequence1: IPXACT2022ScalaCases.NameGroupSequence,
  accessHandles: Option[IPXACT2022ScalaCases.AccessHandles3] = None,
  addressSpecifierSequence3: IPXACT2022ScalaCases.AddressSpecifierSequence,
  localBankBaseSequence4: IPXACT2022ScalaCases.LocalBankBaseSequence,
  attributes: Map[String, IPXACT2022scalaxb.DataRecord[Any]] = Map.empty) extends LocalMemoryMapTypeOption {
  lazy val bankAlignment = attributes("@bankAlignment").as[BankAlignmentType]
  lazy val xmlid = attributes.get("@{http://www.w3.org/XML/1998/namespace}id") map { _.as[String]}
}

      
      


case class AccessHandles4(accesshandles4sequence1: Seq[IPXACT2022ScalaCases.AccessHandles4Sequence1] = Nil)
      
      

case class AccessHandles4Sequence1(accessHandle: IPXACT2022ScalaCases.SlicedAccessHandle)
      

case class AddressBlockDefinitionRef(value: String,
  attributes: Map[String, IPXACT2022scalaxb.DataRecord[Any]] = Map.empty) extends AddressBlockTypeOption {
  lazy val typeDefinitions = attributes("@typeDefinitions").as[String]
}

      
      


/** Top level address block that specify an address
*/
case class AddressBlockType(nameGroupSequence1: IPXACT2022ScalaCases.NameGroupSequence,
  accessHandles: Option[IPXACT2022ScalaCases.AccessHandles4] = None,
  array: Option[IPXACT2022ScalaCases.ArrayType4] = None,
  addressSpecifierSequence4: IPXACT2022ScalaCases.AddressSpecifierSequence,
  addressblocktypeoption: IPXACT2022scalaxb.DataRecord[Any],
  vendorExtensions: Option[IPXACT2022ScalaCases.VendorExtensions] = None,
  attributes: Map[String, IPXACT2022scalaxb.DataRecord[Any]] = Map.empty) extends MemoryMapOption with MemoryMapDefinitionGroupOption1 with MemoryMapDefinitionTypeGroupOption1 with MemoryRemapDefinitionTypeOption2 with LocalMemoryMapTypeOption with MemoryRemapDefinitionOption {
  lazy val xmlid = attributes.get("@{http://www.w3.org/XML/1998/namespace}id") map { _.as[String]}
  lazy val misalignmentAllowed = attributes("@misalignmentAllowed").as[Boolean]
}

      
      

trait AddressBlockTypeOption

/** Base type for an element which references an address space.  Reference is kept in an attribute rather than the text value, so that the type may be extended with child elements if necessary.
*/
trait AddrSpaceRefTypable {
  def vendorExtensions: Option[IPXACT2022ScalaCases.VendorExtensions]
  def addressSpaceRef: String
  def xmlid: Option[String]
}


/** Base type for an element which references an address space.  Reference is kept in an attribute rather than the text value, so that the type may be extended with child elements if necessary.
*/
case class AddrSpaceRefType(vendorExtensions: Option[IPXACT2022ScalaCases.VendorExtensions] = None,
  attributes: Map[String, IPXACT2022scalaxb.DataRecord[Any]] = Map.empty) extends AddrSpaceRefTypable {
  lazy val addressSpaceRef = attributes("@addressSpaceRef").as[String]
  lazy val xmlid = attributes.get("@{http://www.w3.org/XML/1998/namespace}id") map { _.as[String]}
}

      
      


/** A reference to a mode.
*/
case class ModeRef2(value: String,
  attributes: Map[String, IPXACT2022scalaxb.DataRecord[Any]] = Map.empty) {
  lazy val xmlid = attributes.get("@{http://www.w3.org/XML/1998/namespace}id") map { _.as[String]}
}

      
      


/** Base type for an element which references an memory map.  Reference is kept in an attribute rather than the text value, so that the type may be extended with child elements if necessary.
*/
case class MemoryMapRefType(modeRef: Seq[IPXACT2022ScalaCases.ModeRef2] = Nil,
  attributes: Map[String, IPXACT2022scalaxb.DataRecord[Any]] = Map.empty) extends TargetOption {
  lazy val memoryMapRef = attributes("@memoryMapRef").as[String]
}

      
      


case class AccessHandles5(accesshandles5sequence1: Seq[IPXACT2022ScalaCases.AccessHandles5Sequence1] = Nil)
      
      

case class AccessHandles5Sequence1(accessHandle: IPXACT2022ScalaCases.SimpleAccessHandle)
      

case class BankDefinitionRef3(value: String,
  attributes: Map[String, IPXACT2022scalaxb.DataRecord[Any]] = Map.empty) extends BankedBankTypableOption {
  lazy val typeDefinitions = attributes("@typeDefinitions").as[String]
}

      
      


/** Banks nested inside a bank do not specify address.
*/
trait BankedBankTypable {
  def nameGroupSequence1: IPXACT2022ScalaCases.NameGroupSequence
  def accessHandles: Option[IPXACT2022ScalaCases.AccessHandles5]
  def bankedbanktypableoption: IPXACT2022scalaxb.DataRecord[Any]
  def bankAlignment: IPXACT2022ScalaCases.BankAlignmentType
  def xmlid: Option[String]
}


/** Banks nested inside a bank do not specify address.
*/
case class BankedBankType(nameGroupSequence1: IPXACT2022ScalaCases.NameGroupSequence,
  accessHandles: Option[IPXACT2022ScalaCases.AccessHandles5] = None,
  bankedbanktypableoption: IPXACT2022scalaxb.DataRecord[Any],
  attributes: Map[String, IPXACT2022scalaxb.DataRecord[Any]] = Map.empty) extends BankedBankTypable {
  lazy val bankAlignment = attributes("@bankAlignment").as[BankAlignmentType]
  lazy val xmlid = attributes.get("@{http://www.w3.org/XML/1998/namespace}id") map { _.as[String]}
}

      
      

trait BankedBankTypableOption

case class AccessHandles6(accesshandles6sequence1: Seq[IPXACT2022ScalaCases.AccessHandles6Sequence1] = Nil)
      
      

case class AccessHandles6Sequence1(accessHandle: IPXACT2022ScalaCases.SimpleAccessHandle)
      

case class BankDefinitionRef4(value: String,
  attributes: Map[String, IPXACT2022scalaxb.DataRecord[Any]] = Map.empty) extends BankedDefinitionBankTypableOption {
  lazy val typeDefinitions = attributes("@typeDefinitions").as[String]
}

      
      


/** Banks nested inside a bank do not specify address.
*/
trait BankedDefinitionBankTypable {
  def nameGroupSequence1: IPXACT2022ScalaCases.NameGroupSequence
  def accessHandles: Option[IPXACT2022ScalaCases.AccessHandles6]
  def bankeddefinitionbanktypableoption: IPXACT2022scalaxb.DataRecord[Any]
  def bankAlignment: IPXACT2022ScalaCases.BankAlignmentType
  def xmlid: Option[String]
}


/** Banks nested inside a bank do not specify address.
*/
case class BankedDefinitionBankType(nameGroupSequence1: IPXACT2022ScalaCases.NameGroupSequence,
  accessHandles: Option[IPXACT2022ScalaCases.AccessHandles6] = None,
  bankeddefinitionbanktypableoption: IPXACT2022scalaxb.DataRecord[Any],
  attributes: Map[String, IPXACT2022scalaxb.DataRecord[Any]] = Map.empty) extends BankedDefinitionBankTypable {
  lazy val bankAlignment = attributes("@bankAlignment").as[BankAlignmentType]
  lazy val xmlid = attributes.get("@{http://www.w3.org/XML/1998/namespace}id") map { _.as[String]}
}

      
      

trait BankedDefinitionBankTypableOption

case class AccessHandles7(accesshandles7sequence1: Seq[IPXACT2022ScalaCases.AccessHandles7Sequence1] = Nil)
      
      

case class AccessHandles7Sequence1(accessHandle: IPXACT2022ScalaCases.SimpleAccessHandle)
      

/** Banks nested inside a bank do not specify address.
*/
case class LocalBankedBankType(nameGroupSequence1: IPXACT2022ScalaCases.NameGroupSequence,
  accessHandles: Option[IPXACT2022ScalaCases.AccessHandles7] = None,
  localBankBaseSequence3: IPXACT2022ScalaCases.LocalBankBaseSequence,
  attributes: Map[String, IPXACT2022scalaxb.DataRecord[Any]] = Map.empty) extends LocalBankBaseOption1 {
  lazy val bankAlignment = attributes("@bankAlignment").as[BankAlignmentType]
  lazy val xmlid = attributes.get("@{http://www.w3.org/XML/1998/namespace}id") map { _.as[String]}
}

      
      


case class AccessHandles8(accesshandles8sequence1: Seq[IPXACT2022ScalaCases.AccessHandles8Sequence1] = Nil)
      
      

case class AccessHandles8Sequence1(accessHandle: IPXACT2022ScalaCases.SlicedAccessHandle)
      

/** Address blocks inside a bank do not specify address.
*/
case class BankedBlockType(nameGroupSequence1: IPXACT2022ScalaCases.NameGroupSequence,
  accessHandles: Option[IPXACT2022ScalaCases.AccessHandles8] = None,
  blockSizeSequence3: IPXACT2022ScalaCases.BlockSizeSequence,
  addressBlockExtensionsSequence4: IPXACT2022ScalaCases.AddressBlockExtensionsSequence,
  vendorExtensions: Option[IPXACT2022ScalaCases.VendorExtensions] = None,
  attributes: Map[String, IPXACT2022scalaxb.DataRecord[Any]] = Map.empty) extends BankBaseOption1 with BankDefinitionBaseOption1 with LocalBankBaseOption1 {
  lazy val xmlid = attributes.get("@{http://www.w3.org/XML/1998/namespace}id") map { _.as[String]}
}

      
      


/** Subspace references inside banks do not specify an address.
*/
case class BankedSubspaceType(nameGroupOptionalSequence1: IPXACT2022ScalaCases.NameGroupOptionalSequence,
  parameters: Option[IPXACT2022ScalaCases.Parameters] = None,
  vendorExtensions: Option[IPXACT2022ScalaCases.VendorExtensions] = None,
  attributes: Map[String, IPXACT2022scalaxb.DataRecord[Any]] = Map.empty) extends BankBaseOption1 {
  lazy val initiatorRef = attributes("@initiatorRef").as[String]
  lazy val xmlid = attributes.get("@{http://www.w3.org/XML/1998/namespace}id") map { _.as[String]}
}

      
      


case class AccessHandles9(accesshandles9sequence1: Seq[IPXACT2022ScalaCases.AccessHandles9Sequence1] = Nil)
      
      

case class AccessHandles9Sequence1(accessHandle: IPXACT2022ScalaCases.SlicedAccessHandle)
      

case class ArrayType3(dim: Seq[IPXACT2022ScalaCases.Dim] = Nil,
  bitStride: Option[IPXACT2022ScalaCases.BitStride] = None)
      
      


case class FieldDefinitionRef(value: String,
  attributes: Map[String, IPXACT2022scalaxb.DataRecord[Any]] = Map.empty) extends FieldTypeOption {
  lazy val typeDefinitions = attributes("@typeDefinitions").as[String]
}

      
      


/** A field within a register
*/
case class FieldType(nameGroupSequence1: IPXACT2022ScalaCases.NameGroupSequence,
  accessHandles: Option[IPXACT2022ScalaCases.AccessHandles9] = None,
  array: Option[IPXACT2022ScalaCases.ArrayType3] = None,
  bitOffset: IPXACT2022ScalaCases.UnsignedIntExpressionable,
  fieldtypeoption: IPXACT2022scalaxb.DataRecord[Any],
  parameters: Option[IPXACT2022ScalaCases.Parameters] = None,
  vendorExtensions: Option[IPXACT2022ScalaCases.VendorExtensions] = None,
  attributes: Map[String, IPXACT2022scalaxb.DataRecord[Any]] = Map.empty) {
  lazy val xmlid = attributes.get("@{http://www.w3.org/XML/1998/namespace}id") map { _.as[String]}
}

      
      

trait FieldTypeOption

case class MemoryMapDefinitionRef(value: String,
  attributes: Map[String, IPXACT2022scalaxb.DataRecord[Any]] = Map.empty) extends MemoryMapTypeOption {
  lazy val typeDefinitions = attributes("@typeDefinitions").as[String]
}

      
      


/** Map of address space blocks on target target bus interface.
*/
case class MemoryMapType(nameGroupSequence1: IPXACT2022ScalaCases.NameGroupSequence,
  memorymaptypeoption: Option[IPXACT2022scalaxb.DataRecord[Any]] = None,
  vendorExtensions: Option[IPXACT2022ScalaCases.VendorExtensions] = None,
  attributes: Map[String, IPXACT2022scalaxb.DataRecord[Any]] = Map.empty) {
  lazy val xmlid = attributes.get("@{http://www.w3.org/XML/1998/namespace}id") map { _.as[String]}
}

      
      

trait MemoryMapTypeOption

case class RemapDefinitionRef(value: String,
  attributes: Map[String, IPXACT2022scalaxb.DataRecord[Any]] = Map.empty) extends MemoryRemapTypeOption {
  lazy val typeDefinitions = attributes("@typeDefinitions").as[String]
}

      
      


/** Map of address space blocks on a target bus interface in a specific remap state.
*/
case class MemoryRemapType(nameGroupSequence1: IPXACT2022ScalaCases.NameGroupSequence,
  modeRef: Seq[IPXACT2022ScalaCases.ModeRef3] = Nil,
  memoryremaptypeoption: Seq[IPXACT2022scalaxb.DataRecord[Any]] = Nil,
  vendorExtensions: Option[IPXACT2022ScalaCases.VendorExtensions] = None,
  attributes: Map[String, IPXACT2022scalaxb.DataRecord[Any]] = Map.empty) {
  lazy val xmlid = attributes.get("@{http://www.w3.org/XML/1998/namespace}id") map { _.as[String]}
}

      
      

trait MemoryRemapTypeOption

case class RemapDefinitionRef2(value: String,
  attributes: Map[String, IPXACT2022scalaxb.DataRecord[Any]] = Map.empty) extends MemoryRemapDefinitionTypeOption {
  lazy val typeDefinitions = attributes("@typeDefinitions").as[String]
}

      
      


case class Bank(nameGroupSequence1: IPXACT2022ScalaCases.NameGroupSequence,
  accessHandles: Option[IPXACT2022ScalaCases.AccessHandles6] = None,
  bankeddefinitionbanktypableoption: IPXACT2022scalaxb.DataRecord[Any],
  vendorExtensions: Option[IPXACT2022ScalaCases.VendorExtensions] = None,
  attributes: Map[String, IPXACT2022scalaxb.DataRecord[Any]] = Map.empty) extends BankedDefinitionBankTypable with MemoryRemapDefinitionTypeOption2 {
  lazy val bankAlignment = attributes("@bankAlignment").as[BankAlignmentType]
  lazy val xmlid = attributes.get("@{http://www.w3.org/XML/1998/namespace}id") map { _.as[String]}
}

      
      


/** Map of address space blocks on a target bus interface in a specific remap state.
*/
case class MemoryRemapDefinitionType(nameGroupSequence1: IPXACT2022ScalaCases.NameGroupSequence,
  modeRef: Seq[IPXACT2022ScalaCases.ModeRef3] = Nil,
  memoryremapdefinitiontypeoption: Seq[IPXACT2022scalaxb.DataRecord[IPXACT2022ScalaCases.MemoryRemapDefinitionTypeOption]] = Nil,
  vendorExtensions: Option[IPXACT2022ScalaCases.VendorExtensions] = None,
  attributes: Map[String, IPXACT2022scalaxb.DataRecord[Any]] = Map.empty) {
  lazy val xmlid = attributes.get("@{http://www.w3.org/XML/1998/namespace}id") map { _.as[String]}
}

      
      

trait MemoryRemapDefinitionTypeOption2 extends MemoryRemapDefinitionTypeOption
trait MemoryRemapDefinitionTypeOption

/** Map of address space blocks on the local memory map of a initiator bus interface.
*/
case class LocalMemoryMapType(nameGroupSequence1: IPXACT2022ScalaCases.NameGroupSequence,
  localmemorymaptypeoption: Seq[IPXACT2022scalaxb.DataRecord[IPXACT2022ScalaCases.LocalMemoryMapTypeOption]] = Nil,
  vendorExtensions: Option[IPXACT2022ScalaCases.VendorExtensions] = None,
  attributes: Map[String, IPXACT2022scalaxb.DataRecord[Any]] = Map.empty) {
  lazy val xmlid = attributes.get("@{http://www.w3.org/XML/1998/namespace}id") map { _.as[String]}
}

      
      

trait LocalMemoryMapTypeOption

/** Address subspace type.  Its subspaceReference attribute references the subspace from which the dimensions are taken.
*/
case class SubspaceRefType(nameGroupSequence1: IPXACT2022ScalaCases.NameGroupSequence,
  baseAddress: IPXACT2022ScalaCases.SignedLongintExpression,
  parameters: Option[IPXACT2022ScalaCases.Parameters] = None,
  vendorExtensions: Option[IPXACT2022ScalaCases.VendorExtensions] = None,
  attributes: Map[String, IPXACT2022scalaxb.DataRecord[Any]] = Map.empty) extends MemoryMapOption {
  lazy val initiatorRef = attributes("@initiatorRef").as[String]
  lazy val segmentRef = attributes.get("@segmentRef") map { _.as[String]}
  lazy val xmlid = attributes.get("@{http://www.w3.org/XML/1998/namespace}id") map { _.as[String]}
}

      
      


case class FieldAccessPolicyDefinitionRef(value: String,
  attributes: Map[String, IPXACT2022scalaxb.DataRecord[Any]] = Map.empty) extends FieldAccessPolicyOption {
  lazy val typeDefinitions = attributes("@typeDefinitions").as[String]
}

      
      


case class Segment(nameGroupSequence1: IPXACT2022ScalaCases.NameGroupSequence,
  addressOffset: IPXACT2022ScalaCases.UnsignedLongintExpressionable,
  range: IPXACT2022ScalaCases.UnsignedPositiveLongintExpressionable,
  vendorExtensions: Option[IPXACT2022ScalaCases.VendorExtensions] = None,
  attributes: Map[String, IPXACT2022scalaxb.DataRecord[Any]] = Map.empty) {
  lazy val xmlid = attributes.get("@{http://www.w3.org/XML/1998/namespace}id") map { _.as[String]}
}

      
      


case class Segments(segment: Seq[IPXACT2022ScalaCases.Segment] = Nil)
      
      


case class AddressSpace(nameGroupSequence1: IPXACT2022ScalaCases.NameGroupSequence,
  blockSizeSequence2: IPXACT2022ScalaCases.BlockSizeSequence,
  segments: Option[IPXACT2022ScalaCases.Segments] = None,
  addressUnitBits: Option[IPXACT2022ScalaCases.UnsignedPositiveLongintExpressionable] = None,
  localMemoryMap: Option[IPXACT2022ScalaCases.LocalMemoryMapType] = None,
  parameters: Option[IPXACT2022ScalaCases.Parameters] = None,
  vendorExtensions: Option[IPXACT2022ScalaCases.VendorExtensions] = None,
  attributes: Map[String, IPXACT2022scalaxb.DataRecord[Any]] = Map.empty) {
  lazy val xmlid = attributes.get("@{http://www.w3.org/XML/1998/namespace}id") map { _.as[String]}
}

      
      


case class AddressSpaces(addressSpace: Seq[IPXACT2022ScalaCases.AddressSpace] = Nil)
      
      


case class MemoryMaps(memoryMap: Seq[IPXACT2022ScalaCases.MemoryMapType] = Nil)
      
      


case class Bank2(nameGroupSequence1: IPXACT2022ScalaCases.NameGroupSequence,
  accessHandles: Option[IPXACT2022ScalaCases.AccessHandles5] = None,
  bankedbanktypableoption: IPXACT2022scalaxb.DataRecord[Any],
  vendorExtensions: Option[IPXACT2022ScalaCases.VendorExtensions] = None,
  attributes: Map[String, IPXACT2022scalaxb.DataRecord[Any]] = Map.empty) extends BankedBankTypable with BankBaseOption1 {
  lazy val bankAlignment = attributes("@bankAlignment").as[BankAlignmentType]
  lazy val xmlid = attributes.get("@{http://www.w3.org/XML/1998/namespace}id") map { _.as[String]}
}

      
      


case class Bank3(nameGroupSequence1: IPXACT2022ScalaCases.NameGroupSequence,
  accessHandles: Option[IPXACT2022ScalaCases.AccessHandles6] = None,
  bankeddefinitionbanktypableoption: IPXACT2022scalaxb.DataRecord[Any],
  vendorExtensions: Option[IPXACT2022ScalaCases.VendorExtensions] = None,
  attributes: Map[String, IPXACT2022scalaxb.DataRecord[Any]] = Map.empty) extends BankedDefinitionBankTypable with BankDefinitionBaseOption1 {
  lazy val bankAlignment = attributes("@bankAlignment").as[BankAlignmentType]
  lazy val xmlid = attributes.get("@{http://www.w3.org/XML/1998/namespace}id") map { _.as[String]}
}

      
      


case class Dim(value: String,
  attributes: Map[String, IPXACT2022scalaxb.DataRecord[Any]] = Map.empty) extends UnsignedPositiveLongintExpressionable {
  lazy val minimum = attributes.get("@minimum") map { _.as[Int]}
  lazy val maximum = attributes.get("@maximum") map { _.as[Int]}
  lazy val xmlid = attributes.get("@{http://www.w3.org/XML/1998/namespace}id") map { _.as[String]}
  lazy val indexVar = attributes.get("@indexVar") map { _.as[String]}
}

      
      


case class Stride(value: String,
  attributes: Map[String, IPXACT2022scalaxb.DataRecord[Any]] = Map.empty) extends UnsignedPositiveLongintExpressionable {
  lazy val minimum = attributes.get("@minimum") map { _.as[Int]}
  lazy val maximum = attributes.get("@maximum") map { _.as[Int]}
  lazy val xmlid = attributes.get("@{http://www.w3.org/XML/1998/namespace}id") map { _.as[String]}
}

      
      


case class BitStride(value: String,
  attributes: Map[String, IPXACT2022scalaxb.DataRecord[Any]] = Map.empty) extends UnsignedPositiveLongintExpressionable {
  lazy val minimum = attributes.get("@minimum") map { _.as[Int]}
  lazy val maximum = attributes.get("@maximum") map { _.as[Int]}
  lazy val xmlid = attributes.get("@{http://www.w3.org/XML/1998/namespace}id") map { _.as[String]}
}

      
      


case class AccessHandles10(accesshandles10sequence1: Seq[IPXACT2022ScalaCases.AccessHandles10Sequence1] = Nil)
      
      

case class AccessHandles10Sequence1(accessHandle: IPXACT2022ScalaCases.SimpleAccessHandle)
      

case class RegisterDefinitionRef(value: String,
  attributes: Map[String, IPXACT2022scalaxb.DataRecord[Any]] = Map.empty) extends RegisterOption {
  lazy val typeDefinitions = attributes("@typeDefinitions").as[String]
}

      
      


case class Register(nameGroupSequence1: IPXACT2022ScalaCases.NameGroupSequence,
  accessHandles: Option[IPXACT2022ScalaCases.AccessHandles10] = None,
  array: Option[IPXACT2022ScalaCases.ArrayType4] = None,
  addressOffset: IPXACT2022ScalaCases.UnsignedLongintExpressionable,
  registeroption: IPXACT2022scalaxb.DataRecord[Any],
  alternateRegisters: Option[IPXACT2022ScalaCases.AlternateRegisters] = None,
  parameters: Option[IPXACT2022ScalaCases.Parameters] = None,
  vendorExtensions: Option[IPXACT2022ScalaCases.VendorExtensions] = None,
  attributes: Map[String, IPXACT2022scalaxb.DataRecord[Any]] = Map.empty) extends RegisterDataOption {
  lazy val xmlid = attributes.get("@{http://www.w3.org/XML/1998/namespace}id") map { _.as[String]}
}

      
      

trait RegisterOption

case class AccessHandles11(accesshandles11sequence1: Seq[IPXACT2022ScalaCases.AccessHandles11Sequence1] = Nil)
      
      

case class AccessHandles11Sequence1(accessHandle: IPXACT2022ScalaCases.SimpleAccessHandle)
      

case class AlternateRegister(nameGroupSequence1: IPXACT2022ScalaCases.NameGroupSequence,
  accessHandles: Option[IPXACT2022ScalaCases.AccessHandles11] = None,
  modeRef: Seq[IPXACT2022ScalaCases.ModeRef3] = Nil,
  alternateRegisterDefinitionGroupSequence4: IPXACT2022ScalaCases.AlternateRegisterDefinitionGroupSequence,
  parameters: Option[IPXACT2022ScalaCases.Parameters] = None,
  vendorExtensions: Option[IPXACT2022ScalaCases.VendorExtensions] = None,
  attributes: Map[String, IPXACT2022scalaxb.DataRecord[Any]] = Map.empty) {
  lazy val xmlid = attributes.get("@{http://www.w3.org/XML/1998/namespace}id") map { _.as[String]}
}

      
      


case class AlternateRegisters(alternateRegister: Seq[IPXACT2022ScalaCases.AlternateRegister] = Nil)
      
      


case class EnumerationDefinitionRef(value: String,
  attributes: Map[String, IPXACT2022scalaxb.DataRecord[Any]] = Map.empty) extends EnumeratedValuesOption {
  lazy val typeDefinitions = attributes("@typeDefinitions").as[String]
}

      
      


case class EnumeratedValues(enumeratedvaluesoption: Seq[IPXACT2022scalaxb.DataRecord[IPXACT2022ScalaCases.EnumeratedValuesOption]] = Nil)
      
      

trait EnumeratedValuesOption
sealed trait Usage

object Usage {
  def fromString(value: String, scope: scala.xml.NamespaceBinding)(implicit fmt: IPXACT2022scalaxb.XMLFormat[IPXACT2022ScalaCases.Usage]): Usage = fmt.reads(scala.xml.Text(value), Nil) match {
    case Right(x: Usage) => x
    case x => throw new RuntimeException(s"fromString returned unexpected value $x for input $value")
  }
  lazy val values: Seq[Usage] = Seq(Read, Write, Readu45writeValue)
}

case object Read extends Usage { override def toString = "read" }
case object Write extends Usage { override def toString = "write" }
case object Readu45writeValue extends Usage { override def toString = "read-write" }


/** Enumerates specific values that can be assigned to the bit field. The name of this enumerated value. This may be used as a token in generating code.
*/
case class EnumeratedValueType(nameGroupSequence1: IPXACT2022ScalaCases.NameGroupSequence,
  value: IPXACT2022ScalaCases.UnsignedBitVectorExpressionable,
  vendorExtensions: Option[IPXACT2022ScalaCases.VendorExtensions] = None,
  attributes: Map[String, IPXACT2022scalaxb.DataRecord[Any]] = Map.empty) extends EnumeratedValuesOption {
  lazy val usage = attributes("@usage").as[Usage]
  lazy val xmlid = attributes.get("@{http://www.w3.org/XML/1998/namespace}id") map { _.as[String]}
}

      
      

sealed trait ModifiedWriteValueType

object ModifiedWriteValueType {
  def fromString(value: String, scope: scala.xml.NamespaceBinding)(implicit fmt: IPXACT2022scalaxb.XMLFormat[IPXACT2022ScalaCases.ModifiedWriteValueType]): ModifiedWriteValueType = fmt.reads(scala.xml.Text(value), Nil) match {
    case Right(x: ModifiedWriteValueType) => x
    case x => throw new RuntimeException(s"fromString returned unexpected value $x for input $value")
  }
  lazy val values: Seq[ModifiedWriteValueType] = Seq(OneToClear, OneToSet, OneToToggle, ZeroToClear, ZeroToSet, ZeroToToggle, Clear, SetType, Modify)
}

case object OneToClear extends ModifiedWriteValueType { override def toString = "oneToClear" }
case object OneToSet extends ModifiedWriteValueType { override def toString = "oneToSet" }
case object OneToToggle extends ModifiedWriteValueType { override def toString = "oneToToggle" }
case object ZeroToClear extends ModifiedWriteValueType { override def toString = "zeroToClear" }
case object ZeroToSet extends ModifiedWriteValueType { override def toString = "zeroToSet" }
case object ZeroToToggle extends ModifiedWriteValueType { override def toString = "zeroToToggle" }
case object Clear extends ModifiedWriteValueType { override def toString = "clear" }
case object SetType extends ModifiedWriteValueType { override def toString = "set" }
case object Modify extends ModifiedWriteValueType { override def toString = "modify" }

sealed trait ReadActionType

object ReadActionType {
  def fromString(value: String, scope: scala.xml.NamespaceBinding)(implicit fmt: IPXACT2022scalaxb.XMLFormat[IPXACT2022ScalaCases.ReadActionType]): ReadActionType = fmt.reads(scala.xml.Text(value), Nil) match {
    case Right(x: ReadActionType) => x
    case x => throw new RuntimeException(s"fromString returned unexpected value $x for input $value")
  }
  lazy val values: Seq[ReadActionType] = Seq(ClearValue, SetTypeValue, ModifyValue)
}

case object ClearValue extends ReadActionType { override def toString = "clear" }
case object SetTypeValue extends ReadActionType { override def toString = "set" }
case object ModifyValue extends ReadActionType { override def toString = "modify" }


case class AccessRestrictionType(modeRef: Seq[IPXACT2022ScalaCases.ModeRef3] = Nil,
  readAccessMask: Option[IPXACT2022ScalaCases.UnsignedBitVectorExpressionable] = None,
  writeAccessMask: Option[IPXACT2022ScalaCases.UnsignedBitVectorExpressionable] = None,
  attributes: Map[String, IPXACT2022scalaxb.DataRecord[Any]] = Map.empty) {
  lazy val xmlid = attributes.get("@{http://www.w3.org/XML/1998/namespace}id") map { _.as[String]}
}

      
      


case class AccessRestrictionsType(accessRestriction: Seq[IPXACT2022ScalaCases.AccessRestrictionType] = Nil)
      
      


trait FieldAccessPropertiesTypable {
  def xmlid: Option[String]
}


case class FieldAccessPropertiesType(attributes: Map[String, IPXACT2022scalaxb.DataRecord[Any]] = Map.empty) extends FieldAccessPropertiesTypable {
  lazy val xmlid = attributes.get("@{http://www.w3.org/XML/1998/namespace}id") map { _.as[String]}
}

      
      


case class AccessPropertiesType(attributes: Map[String, IPXACT2022scalaxb.DataRecord[Any]] = Map.empty) {
  lazy val accessEntryTypeRef = attributes.get("@accessEntryTypeRef") map { _.as[String]}
  lazy val xmlid = attributes.get("@{http://www.w3.org/XML/1998/namespace}id") map { _.as[String]}
}

      
      


case class BroadcastTo(fieldReferenceGroupSequence1: IPXACT2022ScalaCases.FieldReferenceGroupSequence,
  attributes: Map[String, IPXACT2022scalaxb.DataRecord[Any]] = Map.empty) {
  lazy val xmlid = attributes.get("@{http://www.w3.org/XML/1998/namespace}id") map { _.as[String]}
}

      
      


case class Broadcasts(broadcastTo: Seq[IPXACT2022ScalaCases.BroadcastTo] = Nil)
      
      

sealed trait TestConstraint

object TestConstraint {
  def fromString(value: String, scope: scala.xml.NamespaceBinding)(implicit fmt: IPXACT2022scalaxb.XMLFormat[IPXACT2022ScalaCases.TestConstraint]): TestConstraint = fmt.reads(scala.xml.Text(value), Nil) match {
    case Right(x: TestConstraint) => x
    case x => throw new RuntimeException(s"fromString returned unexpected value $x for input $value")
  }
  lazy val values: Seq[TestConstraint] = Seq(Unconstrained, Restore, WriteAsRead, ReadOnly)
}

case object Unconstrained extends TestConstraint { override def toString = "unconstrained" }
case object Restore extends TestConstraint { override def toString = "restore" }
case object WriteAsRead extends TestConstraint { override def toString = "writeAsRead" }
case object ReadOnly extends TestConstraint { override def toString = "readOnly" }


case class Testable(value: Boolean,
  attributes: Map[String, IPXACT2022scalaxb.DataRecord[Any]] = Map.empty) {
  lazy val testConstraint = attributes("@testConstraint").as[TestConstraint]
}

      
      


case class FieldAccessPolicy(modeRef: Seq[IPXACT2022ScalaCases.ModeRef3] = Nil,
  fieldaccesspolicyoption: Option[IPXACT2022scalaxb.DataRecord[IPXACT2022ScalaCases.FieldAccessPolicyOption]] = None,
  broadcasts: Option[IPXACT2022ScalaCases.Broadcasts] = None,
  accessRestrictions: Option[IPXACT2022ScalaCases.AccessRestrictionsType] = None,
  testable: Option[IPXACT2022ScalaCases.Testable] = None,
  reserved: Option[IPXACT2022ScalaCases.UnsignedBitExpression] = None,
  vendorExtensions: Option[IPXACT2022ScalaCases.VendorExtensions] = None,
  attributes: Map[String, IPXACT2022scalaxb.DataRecord[Any]] = Map.empty) {
  lazy val xmlid = attributes.get("@{http://www.w3.org/XML/1998/namespace}id") map { _.as[String]}
}

      
      

case class FieldAccessPolicySequence1(access: Option[IPXACT2022ScalaCases.AccessType] = None,
  modifiedWriteValue: Option[IPXACT2022ScalaCases.ModifiedWriteValue] = None,
  writeValueConstraint: Option[IPXACT2022ScalaCases.WriteValueConstraintType] = None,
  readAction: Option[IPXACT2022ScalaCases.ReadAction] = None,
  readResponse: Option[IPXACT2022ScalaCases.UnsignedBitVectorExpressionable] = None) extends FieldAccessPolicyOption
      

trait FieldAccessPolicyOption

case class FieldAccessPolicies(fieldAccessPolicy: Seq[IPXACT2022ScalaCases.FieldAccessPolicy] = Nil,
  attributes: Map[String, IPXACT2022scalaxb.DataRecord[Any]] = Map.empty) extends FieldAccessPropertiesTypable {
  lazy val xmlid = attributes.get("@{http://www.w3.org/XML/1998/namespace}id") map { _.as[String]}
}

      
      


/** A constraint on the values that can be written to this field. Absence of this element implies that any value that fits can be written to it.
*/
case class WriteValueConstraintType(writevalueconstrainttypeoption: IPXACT2022scalaxb.DataRecord[Any])
      
      

case class WriteValueConstraintTypeSequence1(minimum: IPXACT2022ScalaCases.UnsignedBitVectorExpressionable,
  maximum: IPXACT2022ScalaCases.UnsignedBitVectorExpressionable)
      

trait WriteValueConstraintTypeOption

case class AccessHandles12(accesshandles12sequence1: Seq[IPXACT2022ScalaCases.AccessHandles12Sequence1] = Nil)
      
      

case class AccessHandles12Sequence1(accessHandle: IPXACT2022ScalaCases.SimpleAccessHandle)
      

case class RegisterFileDefinitionRef(value: String,
  attributes: Map[String, IPXACT2022scalaxb.DataRecord[Any]] = Map.empty) extends RegisterFileOption {
  lazy val typeDefinitions = attributes("@typeDefinitions").as[String]
}

      
      


case class RegisterFile(nameGroupSequence1: IPXACT2022ScalaCases.NameGroupSequence,
  accessHandles: Option[IPXACT2022ScalaCases.AccessHandles12] = None,
  array: Option[IPXACT2022ScalaCases.ArrayType4] = None,
  addressOffset: IPXACT2022ScalaCases.UnsignedLongintExpressionable,
  registerfileoption: IPXACT2022scalaxb.DataRecord[Any],
  parameters: Option[IPXACT2022ScalaCases.Parameters] = None,
  vendorExtensions: Option[IPXACT2022ScalaCases.VendorExtensions] = None,
  attributes: Map[String, IPXACT2022scalaxb.DataRecord[Any]] = Map.empty) extends RegisterDataOption {
  lazy val xmlid = attributes.get("@{http://www.w3.org/XML/1998/namespace}id") map { _.as[String]}
}

      
      

trait RegisterFileOption

case class Resets(reset: Seq[IPXACT2022ScalaCases.Reset] = Nil)
      
      


case class AliasOf(fieldReferenceGroupSequence1: IPXACT2022ScalaCases.FieldReferenceGroupSequence) extends FieldDefinitionGroupOption1
      
      


case class Reset(value: IPXACT2022ScalaCases.UnsignedBitVectorExpressionable,
  mask: Option[IPXACT2022ScalaCases.UnsignedBitVectorExpressionable] = None,
  attributes: Map[String, IPXACT2022scalaxb.DataRecord[Any]] = Map.empty) {
  lazy val resetTypeRef = attributes.get("@resetTypeRef") map { _.as[String]}
  lazy val xmlid = attributes.get("@{http://www.w3.org/XML/1998/namespace}id") map { _.as[String]}
}

      
      


case class ExternalTypeDefinitions(nameGroupSequence1: IPXACT2022ScalaCases.NameGroupSequence,
  typeDefinitionsRef: IPXACT2022ScalaCases.ConfigurableLibraryRefType,
  viewLinks: Option[IPXACT2022ScalaCases.ViewLinks] = None,
  modeLinks: Option[IPXACT2022ScalaCases.ModeLinks] = None,
  resetTypeLinks: Option[IPXACT2022ScalaCases.ResetTypeLinks] = None,
  vendorExtensions: Option[IPXACT2022ScalaCases.VendorExtensions] = None,
  attributes: Map[String, IPXACT2022scalaxb.DataRecord[Any]] = Map.empty) {
  lazy val xmlid = attributes.get("@{http://www.w3.org/XML/1998/namespace}id") map { _.as[String]}
}

      
      


case class EnumerationDefinition(nameGroupSequence1: IPXACT2022ScalaCases.NameGroupSequence,
  width: IPXACT2022ScalaCases.UnsignedPositiveIntExpressionable,
  enumeratedValue: Seq[IPXACT2022ScalaCases.EnumeratedValueType] = Nil,
  vendorExtensions: Option[IPXACT2022ScalaCases.VendorExtensions] = None,
  attributes: Map[String, IPXACT2022scalaxb.DataRecord[Any]] = Map.empty) {
  lazy val xmlid = attributes.get("@{http://www.w3.org/XML/1998/namespace}id") map { _.as[String]}
}

      
      


case class EnumerationDefinitions(enumerationDefinition: Seq[IPXACT2022ScalaCases.EnumerationDefinition] = Nil)
      
      


case class FieldAccessPolicyDefinition(nameGroupSequence1: IPXACT2022ScalaCases.NameGroupSequence,
  access: Option[IPXACT2022ScalaCases.AccessType] = None,
  modifiedWriteValue: Option[IPXACT2022ScalaCases.ModifiedWriteValue] = None,
  writeValueConstraint: Option[IPXACT2022ScalaCases.WriteValueConstraintType] = None,
  readAction: Option[IPXACT2022ScalaCases.ReadAction] = None,
  readResponse: Option[IPXACT2022ScalaCases.UnsignedBitVectorExpressionable] = None,
  vendorExtensions: Option[IPXACT2022ScalaCases.VendorExtensions] = None,
  attributes: Map[String, IPXACT2022scalaxb.DataRecord[Any]] = Map.empty) {
  lazy val xmlid = attributes.get("@{http://www.w3.org/XML/1998/namespace}id") map { _.as[String]}
}

      
      


case class FieldAccessPolicyDefinitions(fieldAccessPolicyDefinition: Seq[IPXACT2022ScalaCases.FieldAccessPolicyDefinition] = Nil)
      
      


case class Resets2(reset: Seq[IPXACT2022ScalaCases.Reset] = Nil)
      
      


case class FieldDefinition(nameGroupSequence1: IPXACT2022ScalaCases.NameGroupSequence,
  typeIdentifier: Option[String] = None,
  bitWidth: IPXACT2022ScalaCases.UnsignedPositiveIntExpressionable,
  volatile: Option[Boolean] = None,
  resets: Option[IPXACT2022ScalaCases.Resets2] = None,
  fieldDataSequence6: IPXACT2022ScalaCases.FieldDataSequence,
  vendorExtensions: Option[IPXACT2022ScalaCases.VendorExtensions] = None,
  attributes: Map[String, IPXACT2022scalaxb.DataRecord[Any]] = Map.empty) {
  lazy val xmlid = attributes.get("@{http://www.w3.org/XML/1998/namespace}id") map { _.as[String]}
}

      
      


case class FieldDefinitions(fieldDefinition: Seq[IPXACT2022ScalaCases.FieldDefinition] = Nil)
      
      


case class RegisterDefinition(nameGroupSequence1: IPXACT2022ScalaCases.NameGroupSequence,
  registerDefinitionGroupSequence2: IPXACT2022ScalaCases.RegisterDefinitionGroupSequence,
  vendorExtensions: Option[IPXACT2022ScalaCases.VendorExtensions] = None,
  attributes: Map[String, IPXACT2022scalaxb.DataRecord[Any]] = Map.empty) {
  lazy val xmlid = attributes.get("@{http://www.w3.org/XML/1998/namespace}id") map { _.as[String]}
}

      
      


case class RegisterDefinitions(registerDefinition: Seq[IPXACT2022ScalaCases.RegisterDefinition] = Nil)
      
      


case class RegisterFileDefinition(nameGroupSequence1: IPXACT2022ScalaCases.NameGroupSequence,
  registerFileDefinitionGroupSequence2: IPXACT2022ScalaCases.RegisterFileDefinitionGroupSequence,
  addressUnitBits: Option[IPXACT2022ScalaCases.UnsignedPositiveLongintExpressionable] = None,
  vendorExtensions: Option[IPXACT2022ScalaCases.VendorExtensions] = None,
  attributes: Map[String, IPXACT2022scalaxb.DataRecord[Any]] = Map.empty) {
  lazy val xmlid = attributes.get("@{http://www.w3.org/XML/1998/namespace}id") map { _.as[String]}
}

      
      


case class RegisterFileDefinitions(registerFileDefinition: Seq[IPXACT2022ScalaCases.RegisterFileDefinition] = Nil)
      
      


case class AddressBlockDefinition(nameGroupSequence1: IPXACT2022ScalaCases.NameGroupSequence,
  addressBlockDefinitionGroupSequence2: IPXACT2022ScalaCases.AddressBlockDefinitionGroupSequence,
  addressUnitBits: Option[IPXACT2022ScalaCases.UnsignedPositiveLongintExpressionable] = None,
  vendorExtensions: Option[IPXACT2022ScalaCases.VendorExtensions] = None,
  attributes: Map[String, IPXACT2022scalaxb.DataRecord[Any]] = Map.empty) {
  lazy val xmlid = attributes.get("@{http://www.w3.org/XML/1998/namespace}id") map { _.as[String]}
}

      
      


case class AddressBlockDefinitions(addressBlockDefinition: Seq[IPXACT2022ScalaCases.AddressBlockDefinition] = Nil)
      
      


case class BankDefinition(nameGroupSequence1: IPXACT2022ScalaCases.NameGroupSequence,
  bankDefinitionBaseSequence2: IPXACT2022ScalaCases.BankDefinitionBaseSequence,
  addressUnitBits: Option[IPXACT2022ScalaCases.UnsignedPositiveLongintExpressionable] = None,
  vendorExtensions: Option[IPXACT2022ScalaCases.VendorExtensions] = None,
  attributes: Map[String, IPXACT2022scalaxb.DataRecord[Any]] = Map.empty) {
  lazy val xmlid = attributes.get("@{http://www.w3.org/XML/1998/namespace}id") map { _.as[String]}
}

      
      


case class BankDefinitions(bankDefinition: Seq[IPXACT2022ScalaCases.BankDefinition] = Nil)
      
      


case class MemoryMapDefinition(nameGroupSequence1: IPXACT2022ScalaCases.NameGroupSequence,
  memoryMapDefinitionTypeGroupSequence2: Option[IPXACT2022ScalaCases.MemoryMapDefinitionTypeGroupSequence] = None,
  vendorExtensions: Option[IPXACT2022ScalaCases.VendorExtensions] = None,
  attributes: Map[String, IPXACT2022scalaxb.DataRecord[Any]] = Map.empty) {
  lazy val xmlid = attributes.get("@{http://www.w3.org/XML/1998/namespace}id") map { _.as[String]}
}

      
      


case class MemoryMapDefinitions(memoryMapDefinition: Seq[IPXACT2022ScalaCases.MemoryMapDefinition] = Nil)
      
      


case class MemoryRemapDefinition(nameGroupSequence1: IPXACT2022ScalaCases.NameGroupSequence,
  memoryremapdefinitionoption: Seq[IPXACT2022scalaxb.DataRecord[IPXACT2022ScalaCases.MemoryRemapDefinitionOption]] = Nil,
  addressUnitBits: Option[IPXACT2022ScalaCases.UnsignedPositiveLongintExpressionable] = None,
  vendorExtensions: Option[IPXACT2022ScalaCases.VendorExtensions] = None,
  attributes: Map[String, IPXACT2022scalaxb.DataRecord[Any]] = Map.empty) {
  lazy val xmlid = attributes.get("@{http://www.w3.org/XML/1998/namespace}id") map { _.as[String]}
}

      
      

trait MemoryRemapDefinitionOption

case class MemoryRemapDefinitions(memoryRemapDefinition: Seq[IPXACT2022ScalaCases.MemoryRemapDefinition] = Nil)
      
      


case class ModeRef3(value: String,
  attributes: Map[String, IPXACT2022scalaxb.DataRecord[Any]] = Map.empty) {
  lazy val priority = attributes("@priority").as[BigInt]
  lazy val xmlid = attributes.get("@{http://www.w3.org/XML/1998/namespace}id") map { _.as[String]}
}

      
      


case class ArrayType4(dim: Seq[IPXACT2022ScalaCases.Dim] = Nil,
  stride: Option[IPXACT2022ScalaCases.Stride] = None)
      
      


case class ModifiedWriteValue(value: IPXACT2022ScalaCases.ModifiedWriteValueType,
  attributes: Map[String, IPXACT2022scalaxb.DataRecord[Any]] = Map.empty) {
  lazy val modify = attributes.get("@modify") map { _.as[String]}
}

      
      


case class ReadAction(value: IPXACT2022ScalaCases.ReadActionType,
  attributes: Map[String, IPXACT2022scalaxb.DataRecord[Any]] = Map.empty) {
  lazy val modify = attributes.get("@modify") map { _.as[String]}
}

      
      


case class AccessPolicy(modeRef: Seq[IPXACT2022ScalaCases.ModeRef3] = Nil,
  access: Option[IPXACT2022ScalaCases.AccessType] = None,
  vendorExtensions: Option[IPXACT2022ScalaCases.VendorExtensions] = None,
  attributes: Map[String, IPXACT2022scalaxb.DataRecord[Any]] = Map.empty) {
  lazy val xmlid = attributes.get("@{http://www.w3.org/XML/1998/namespace}id") map { _.as[String]}
}

      
      


case class AccessPolicies(accessPolicy: Seq[IPXACT2022ScalaCases.AccessPolicy] = Nil)
      
      

case class AlternateRegisterDefinitionGroupSequence(typeIdentifier: Option[String] = None,
  volatile: Option[Boolean] = None,
  accessPolicies: Option[IPXACT2022ScalaCases.AccessPolicies] = None,
  alternateregisterdefinitiongroupsequence2: Seq[IPXACT2022ScalaCases.AlternateRegisterDefinitionGroupSequence2] = Nil)
      

case class AlternateRegisterDefinitionGroupSequence2(field: IPXACT2022ScalaCases.FieldType)
      
case class AddressBlockDefinitionGroupSequence(typeIdentifier: Option[String] = None,
  blockSizeSequence2: IPXACT2022ScalaCases.BlockSizeSequence,
  memoryBlockDataSequence3: IPXACT2022ScalaCases.MemoryBlockDataSequence,
  registerDataOption4: Seq[IPXACT2022scalaxb.DataRecord[IPXACT2022ScalaCases.RegisterDataOption]] = Nil)
      

trait FieldDefinitionGroupOption1
case class FieldDefinitionGroupSequence2(bitWidth: IPXACT2022ScalaCases.UnsignedPositiveIntExpressionable,
  volatile: Option[Boolean] = None,
  resets: Option[IPXACT2022ScalaCases.Resets] = None) extends FieldDefinitionGroupOption1
      

case class FieldDefinitionGroupSequence(typeIdentifier: Option[String] = None,
  fielddefinitiongroupoption1: IPXACT2022scalaxb.DataRecord[IPXACT2022ScalaCases.FieldDefinitionGroupOption1],
  fieldDataSequence3: IPXACT2022ScalaCases.FieldDataSequence)
      

trait RegisterDataOption
case class BlockSizeSequence(range: IPXACT2022ScalaCases.UnsignedPositiveLongintExpressionable,
  width: IPXACT2022ScalaCases.UnsignedPositiveIntExpressionable)
      

case class BankDefinitionBaseSequence(bankdefinitionbaseoption1: Seq[IPXACT2022scalaxb.DataRecord[IPXACT2022ScalaCases.BankDefinitionBaseOption1]] = Nil,
  memoryBlockDataSequence2: IPXACT2022ScalaCases.MemoryBlockDataSequence)
      

trait BankDefinitionBaseOption1
case class AddressSpecifierSequence(baseAddress: IPXACT2022ScalaCases.UnsignedLongintExpressionable)
      
case class MemoryMapGroupSequence(memoryMapOption1: Seq[IPXACT2022scalaxb.DataRecord[IPXACT2022ScalaCases.MemoryMapOption]] = Nil,
  memoryRemap: Seq[IPXACT2022ScalaCases.MemoryRemapType] = Nil,
  addressUnitBits: Option[IPXACT2022ScalaCases.UnsignedPositiveLongintExpressionable] = None,
  shared: Option[IPXACT2022ScalaCases.SharedType] = None)
      

case class MemoryMapDefinitionGroupSequence(memorymapdefinitiongroupoption1: Option[IPXACT2022scalaxb.DataRecord[IPXACT2022ScalaCases.MemoryMapDefinitionGroupOption1]] = None,
  addressUnitBits: Option[IPXACT2022ScalaCases.UnsignedPositiveLongintExpressionable] = None,
  shared: Option[IPXACT2022ScalaCases.SharedType] = None)
      

trait MemoryMapDefinitionGroupOption1
trait MemoryMapOption
trait MemoryMapDefinitionTypeGroupOption1
case class MemoryMapDefinitionTypeGroupSequence(memorymapdefinitiontypegroupoption1: Seq[IPXACT2022scalaxb.DataRecord[IPXACT2022ScalaCases.MemoryMapDefinitionTypeGroupOption1]] = Nil,
  memoryRemap: Seq[IPXACT2022ScalaCases.MemoryRemapDefinitionType] = Nil,
  addressUnitBits: Option[IPXACT2022ScalaCases.UnsignedPositiveLongintExpressionable] = None,
  shared: Option[IPXACT2022ScalaCases.SharedType] = None)
      

case class AddressBlockExtensionsSequence(memoryBlockDataSequence1: IPXACT2022ScalaCases.MemoryBlockDataSequence,
  registerDataOption2: Seq[IPXACT2022scalaxb.DataRecord[IPXACT2022ScalaCases.RegisterDataOption]] = Nil)
      

case class BankBaseSequence(bankbaseoption1: Seq[IPXACT2022scalaxb.DataRecord[IPXACT2022ScalaCases.BankBaseOption1]] = Nil,
  memoryBlockDataSequence2: IPXACT2022ScalaCases.MemoryBlockDataSequence)
      

trait BankBaseOption1
case class LocalBankBaseSequence(localbankbaseoption1: Seq[IPXACT2022scalaxb.DataRecord[IPXACT2022ScalaCases.LocalBankBaseOption1]] = Nil,
  memoryBlockDataSequence2: IPXACT2022ScalaCases.MemoryBlockDataSequence,
  vendorExtensions: Option[IPXACT2022ScalaCases.VendorExtensions] = None)
      

trait LocalBankBaseOption1
case class MemoryBlockDataSequence(usage: Option[IPXACT2022ScalaCases.UsageType] = None,
  volatile: Option[Boolean] = None,
  accessPolicies: Option[IPXACT2022ScalaCases.AccessPolicies] = None,
  parameters: Option[IPXACT2022ScalaCases.Parameters] = None)
      

case class FieldDataSequence(fieldAccessPolicies: Option[IPXACT2022ScalaCases.FieldAccessPolicies] = None,
  enumeratedValues: Option[IPXACT2022ScalaCases.EnumeratedValues] = None)
      

case class RegisterFileDefinitionGroupSequence(typeIdentifier: Option[String] = None,
  range: IPXACT2022ScalaCases.UnsignedPositiveLongintExpressionable,
  accessPolicies: Option[IPXACT2022ScalaCases.AccessPolicies] = None,
  registerDataOption4: Seq[IPXACT2022scalaxb.DataRecord[IPXACT2022ScalaCases.RegisterDataOption]] = Nil)
      

case class RegisterDefinitionGroupSequence2(field: IPXACT2022ScalaCases.FieldType)
      
case class RegisterDefinitionGroupSequence(typeIdentifier: Option[String] = None,
  size: IPXACT2022ScalaCases.UnsignedPositiveIntExpressionable,
  volatile: Option[Boolean] = None,
  accessPolicies: Option[IPXACT2022ScalaCases.AccessPolicies] = None,
  registerdefinitiongroupsequence2: Seq[IPXACT2022ScalaCases.RegisterDefinitionGroupSequence2] = Nil)
      


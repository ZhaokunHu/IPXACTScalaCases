// Generated by <a href="http://IPXACT2022scalaxb.org/">IPXACT2022scalaxb</a>.
package IPXACT2022ScalaCases

import scala.concurrent.{ Future, ExecutionContext }


/**
usage:
val obj = IPXACT2022scalaxb.fromXML[IPXACT2022ScalaCases.Foo](node)
val document = IPXACT2022scalaxb.toXML[IPXACT2022ScalaCases.Foo](obj, "foo", IPXACT2022ScalaCases.defaultScope)
**/
object `package` extends XMLProtocol { }

trait XMLProtocol extends IPXACT2022scalaxb.XMLStandardTypes {
  val defaultScope = IPXACT2022scalaxb.toScope(Some("ipxact") -> "http://www.accellera.org/XMLSchema/IPXACT/1685-2022",
    Some("xml") -> "http://www.w3.org/XML/1998/namespace",
    Some("xs") -> "http://www.w3.org/2001/XMLSchema",
    Some("xsi") -> "http://www.w3.org/2001/XMLSchema-instance")
  implicit lazy val IPXACT2022ScalaCases_PresenceTypeFormat: IPXACT2022scalaxb.XMLFormat[IPXACT2022ScalaCases.PresenceType] = new DefaultIPXACT2022ScalaCases_PresenceTypeFormat {}
  implicit lazy val IPXACT2022ScalaCases_DirectionFormat: IPXACT2022scalaxb.XMLFormat[IPXACT2022ScalaCases.Direction] = new DefaultIPXACT2022ScalaCases_DirectionFormat {}
  implicit lazy val IPXACT2022ScalaCases_InitiativeFormat: IPXACT2022scalaxb.XMLFormat[IPXACT2022ScalaCases.Initiative] = new DefaultIPXACT2022ScalaCases_InitiativeFormat {}
  implicit lazy val IPXACT2022ScalaCases_WidthFormat: IPXACT2022scalaxb.XMLFormat[IPXACT2022ScalaCases.Width] = new DefaultIPXACT2022ScalaCases_WidthFormat {}
  implicit lazy val IPXACT2022ScalaCases_OnSystemFormat: IPXACT2022scalaxb.XMLFormat[IPXACT2022ScalaCases.OnSystem] = new DefaultIPXACT2022ScalaCases_OnSystemFormat {}
  implicit lazy val IPXACT2022ScalaCases_OnInitiatorFormat: IPXACT2022scalaxb.XMLFormat[IPXACT2022ScalaCases.OnInitiator] = new DefaultIPXACT2022ScalaCases_OnInitiatorFormat {}
  implicit lazy val IPXACT2022ScalaCases_OnTargetFormat: IPXACT2022scalaxb.XMLFormat[IPXACT2022ScalaCases.OnTarget] = new DefaultIPXACT2022ScalaCases_OnTargetFormat {}
  implicit lazy val IPXACT2022ScalaCases_TransactionalFormat: IPXACT2022scalaxb.XMLFormat[IPXACT2022ScalaCases.Transactional] = new DefaultIPXACT2022ScalaCases_TransactionalFormat {}
  implicit lazy val IPXACT2022ScalaCases_PortFormat: IPXACT2022scalaxb.XMLFormat[IPXACT2022ScalaCases.Port] = new DefaultIPXACT2022ScalaCases_PortFormat {}
  implicit lazy val IPXACT2022ScalaCases_PortSequence1Format: IPXACT2022scalaxb.XMLFormat[IPXACT2022ScalaCases.PortSequence1] = new DefaultIPXACT2022ScalaCases_PortSequence1Format {}
  implicit lazy val IPXACT2022ScalaCases_Ports3Format: IPXACT2022scalaxb.XMLFormat[IPXACT2022ScalaCases.Ports3] = new DefaultIPXACT2022ScalaCases_Ports3Format {}
  implicit lazy val IPXACT2022ScalaCases_AbstractionDefinitionFormat: IPXACT2022scalaxb.XMLFormat[IPXACT2022ScalaCases.AbstractionDefinition] = new DefaultIPXACT2022ScalaCases_AbstractionDefinitionFormat {}
  implicit lazy val IPXACT2022ScalaCases_OnSystem2Format: IPXACT2022scalaxb.XMLFormat[IPXACT2022ScalaCases.OnSystem2] = new DefaultIPXACT2022ScalaCases_OnSystem2Format {}
  implicit lazy val IPXACT2022ScalaCases_OnInitiator2Format: IPXACT2022scalaxb.XMLFormat[IPXACT2022ScalaCases.OnInitiator2] = new DefaultIPXACT2022ScalaCases_OnInitiator2Format {}
  implicit lazy val IPXACT2022ScalaCases_OnTarget2Format: IPXACT2022scalaxb.XMLFormat[IPXACT2022ScalaCases.OnTarget2] = new DefaultIPXACT2022ScalaCases_OnTarget2Format {}
  implicit lazy val IPXACT2022ScalaCases_WireFormat: IPXACT2022scalaxb.XMLFormat[IPXACT2022ScalaCases.Wire] = new DefaultIPXACT2022ScalaCases_WireFormat {}
  implicit lazy val IPXACT2022ScalaCases_WirePortSequence2Format: IPXACT2022scalaxb.XMLFormat[IPXACT2022ScalaCases.WirePortSequence2] = new DefaultIPXACT2022ScalaCases_WirePortSequence2Format {}
  implicit lazy val IPXACT2022ScalaCases_WirePortSequenceFormat: IPXACT2022scalaxb.XMLFormat[IPXACT2022ScalaCases.WirePortSequence] = new DefaultIPXACT2022ScalaCases_WirePortSequenceFormat {}
  implicit lazy val IPXACT2022ScalaCases_TransactionalPortSequenceFormat: IPXACT2022scalaxb.XMLFormat[IPXACT2022ScalaCases.TransactionalPortSequence] = new DefaultIPXACT2022ScalaCases_TransactionalPortSequenceFormat {}
  implicit lazy val IPXACT2022ScalaCases_AbstractorModeFormat: IPXACT2022scalaxb.XMLFormat[IPXACT2022ScalaCases.AbstractorMode] = new DefaultIPXACT2022ScalaCases_AbstractorModeFormat {}
  implicit lazy val IPXACT2022ScalaCases_AbstractorInterfacesFormat: IPXACT2022scalaxb.XMLFormat[IPXACT2022ScalaCases.AbstractorInterfaces] = new DefaultIPXACT2022ScalaCases_AbstractorInterfacesFormat {}
  implicit lazy val IPXACT2022ScalaCases_AbstractorTypeFormat: IPXACT2022scalaxb.XMLFormat[IPXACT2022ScalaCases.AbstractorType] = new DefaultIPXACT2022ScalaCases_AbstractorTypeFormat {}
  implicit lazy val IPXACT2022ScalaCases_AbstractorModeTypeFormat: IPXACT2022scalaxb.XMLFormat[IPXACT2022ScalaCases.AbstractorModeType] = new DefaultIPXACT2022ScalaCases_AbstractorModeTypeFormat {}
  implicit lazy val IPXACT2022ScalaCases_FormatTypeFormat: IPXACT2022scalaxb.XMLFormat[IPXACT2022ScalaCases.FormatType] = new DefaultIPXACT2022ScalaCases_FormatTypeFormat {}
  implicit lazy val IPXACT2022ScalaCases_SignTypeFormat: IPXACT2022scalaxb.XMLFormat[IPXACT2022ScalaCases.SignType] = new DefaultIPXACT2022ScalaCases_SignTypeFormat {}
  implicit lazy val IPXACT2022ScalaCases_DelayValueUnitTypeFormat: IPXACT2022scalaxb.XMLFormat[IPXACT2022ScalaCases.DelayValueUnitType] = new DefaultIPXACT2022ScalaCases_DelayValueUnitTypeFormat {}
  implicit lazy val IPXACT2022ScalaCases_EnumerationFormat: IPXACT2022scalaxb.XMLFormat[IPXACT2022ScalaCases.Enumeration] = new DefaultIPXACT2022ScalaCases_EnumerationFormat {}
  implicit lazy val IPXACT2022ScalaCases_ChoiceFormat: IPXACT2022scalaxb.XMLFormat[IPXACT2022ScalaCases.Choice] = new DefaultIPXACT2022ScalaCases_ChoiceFormat {}
  implicit lazy val IPXACT2022ScalaCases_ChoicesFormat: IPXACT2022scalaxb.XMLFormat[IPXACT2022ScalaCases.Choices] = new DefaultIPXACT2022ScalaCases_ChoicesFormat {}
  implicit lazy val IPXACT2022ScalaCases_Idu46attFormat: IPXACT2022scalaxb.AttributeGroupFormat[IPXACT2022ScalaCases.Idu46att] = new DefaultIPXACT2022ScalaCases_Idu46attFormat {}
  implicit lazy val IPXACT2022ScalaCases_Anyu46attFormat: IPXACT2022scalaxb.AttributeGroupFormat[IPXACT2022ScalaCases.Anyu46att] = new DefaultIPXACT2022ScalaCases_Anyu46attFormat {}
  implicit lazy val IPXACT2022ScalaCases_SystemGroupNameFormat: IPXACT2022scalaxb.XMLFormat[IPXACT2022ScalaCases.SystemGroupName] = new DefaultIPXACT2022ScalaCases_SystemGroupNameFormat {}
  implicit lazy val IPXACT2022ScalaCases_SystemGroupNamesFormat: IPXACT2022scalaxb.XMLFormat[IPXACT2022ScalaCases.SystemGroupNames] = new DefaultIPXACT2022ScalaCases_SystemGroupNamesFormat {}
  implicit lazy val IPXACT2022ScalaCases_BusDefinitionFormat: IPXACT2022scalaxb.XMLFormat[IPXACT2022ScalaCases.BusDefinition] = new DefaultIPXACT2022ScalaCases_BusDefinitionFormat {}
  implicit lazy val IPXACT2022ScalaCases_EndianessTypeFormat: IPXACT2022scalaxb.XMLFormat[IPXACT2022ScalaCases.EndianessType] = new DefaultIPXACT2022ScalaCases_EndianessTypeFormat {}
  implicit lazy val IPXACT2022ScalaCases_ViewRef5Format: IPXACT2022scalaxb.XMLFormat[IPXACT2022ScalaCases.ViewRef5] = new DefaultIPXACT2022ScalaCases_ViewRef5Format {}
  implicit lazy val IPXACT2022ScalaCases_BusInterfacesFormat: IPXACT2022scalaxb.XMLFormat[IPXACT2022ScalaCases.BusInterfaces] = new DefaultIPXACT2022ScalaCases_BusInterfacesFormat {}
  implicit lazy val IPXACT2022ScalaCases_BusInterfaceTypeFormat: IPXACT2022scalaxb.XMLFormat[IPXACT2022ScalaCases.BusInterfaceType] = new DefaultIPXACT2022ScalaCases_BusInterfaceTypeFormat {}
  implicit lazy val IPXACT2022ScalaCases_BusInterfaceRefFormat: IPXACT2022scalaxb.XMLFormat[IPXACT2022ScalaCases.BusInterfaceRef] = new DefaultIPXACT2022ScalaCases_BusInterfaceRefFormat {}
  implicit lazy val IPXACT2022ScalaCases_ChannelFormat: IPXACT2022scalaxb.XMLFormat[IPXACT2022ScalaCases.Channel] = new DefaultIPXACT2022ScalaCases_ChannelFormat {}
  implicit lazy val IPXACT2022ScalaCases_ChannelsFormat: IPXACT2022scalaxb.XMLFormat[IPXACT2022ScalaCases.Channels] = new DefaultIPXACT2022ScalaCases_ChannelsFormat {}
  implicit lazy val IPXACT2022ScalaCases_ModeRefFormat: IPXACT2022scalaxb.XMLFormat[IPXACT2022ScalaCases.ModeRef] = new DefaultIPXACT2022ScalaCases_ModeRefFormat {}
  implicit lazy val IPXACT2022ScalaCases_AddressSpaceRef3Format: IPXACT2022scalaxb.XMLFormat[IPXACT2022ScalaCases.AddressSpaceRef3] = new DefaultIPXACT2022ScalaCases_AddressSpaceRef3Format {}
  implicit lazy val IPXACT2022ScalaCases_InitiatorFormat: IPXACT2022scalaxb.XMLFormat[IPXACT2022ScalaCases.Initiator] = new DefaultIPXACT2022ScalaCases_InitiatorFormat {}
  implicit lazy val IPXACT2022ScalaCases_FileSetRefGroup2Format: IPXACT2022scalaxb.XMLFormat[IPXACT2022ScalaCases.FileSetRefGroup2] = new DefaultIPXACT2022ScalaCases_FileSetRefGroup2Format {}
  implicit lazy val IPXACT2022ScalaCases_TargetFormat: IPXACT2022scalaxb.XMLFormat[IPXACT2022ScalaCases.Target] = new DefaultIPXACT2022ScalaCases_TargetFormat {}
  implicit lazy val IPXACT2022ScalaCases_SystemFormat: IPXACT2022scalaxb.XMLFormat[IPXACT2022ScalaCases.System] = new DefaultIPXACT2022ScalaCases_SystemFormat {}
  implicit lazy val IPXACT2022ScalaCases_RemapAddressFormat: IPXACT2022scalaxb.XMLFormat[IPXACT2022ScalaCases.RemapAddress] = new DefaultIPXACT2022ScalaCases_RemapAddressFormat {}
  implicit lazy val IPXACT2022ScalaCases_RemapAddressesFormat: IPXACT2022scalaxb.XMLFormat[IPXACT2022ScalaCases.RemapAddresses] = new DefaultIPXACT2022ScalaCases_RemapAddressesFormat {}
  implicit lazy val IPXACT2022ScalaCases_BaseAddressesFormat: IPXACT2022scalaxb.XMLFormat[IPXACT2022ScalaCases.BaseAddresses] = new DefaultIPXACT2022ScalaCases_BaseAddressesFormat {}
  implicit lazy val IPXACT2022ScalaCases_MirroredTargetFormat: IPXACT2022scalaxb.XMLFormat[IPXACT2022ScalaCases.MirroredTarget] = new DefaultIPXACT2022ScalaCases_MirroredTargetFormat {}
  implicit lazy val IPXACT2022ScalaCases_MirroredTargetSequence1Format: IPXACT2022scalaxb.XMLFormat[IPXACT2022ScalaCases.MirroredTargetSequence1] = new DefaultIPXACT2022ScalaCases_MirroredTargetSequence1Format {}
  implicit lazy val IPXACT2022ScalaCases_MirroredSystemFormat: IPXACT2022scalaxb.XMLFormat[IPXACT2022ScalaCases.MirroredSystem] = new DefaultIPXACT2022ScalaCases_MirroredSystemFormat {}
  implicit lazy val IPXACT2022ScalaCases_InterfaceModeFormat: IPXACT2022scalaxb.XMLFormat[IPXACT2022ScalaCases.InterfaceMode] = new DefaultIPXACT2022ScalaCases_InterfaceModeFormat {}
  implicit lazy val IPXACT2022ScalaCases_MonitorFormat: IPXACT2022scalaxb.XMLFormat[IPXACT2022ScalaCases.Monitor] = new DefaultIPXACT2022ScalaCases_MonitorFormat {}
  implicit lazy val IPXACT2022ScalaCases_TransparentBridgeFormat: IPXACT2022scalaxb.XMLFormat[IPXACT2022ScalaCases.TransparentBridge] = new DefaultIPXACT2022ScalaCases_TransparentBridgeFormat {}
  implicit lazy val IPXACT2022ScalaCases_System2Format: IPXACT2022scalaxb.XMLFormat[IPXACT2022ScalaCases.System2] = new DefaultIPXACT2022ScalaCases_System2Format {}
  implicit lazy val IPXACT2022ScalaCases_MirroredSystem2Format: IPXACT2022scalaxb.XMLFormat[IPXACT2022ScalaCases.MirroredSystem2] = new DefaultIPXACT2022ScalaCases_MirroredSystem2Format {}
  implicit lazy val IPXACT2022ScalaCases_AbstractorBusInterfaceTypeFormat: IPXACT2022scalaxb.XMLFormat[IPXACT2022ScalaCases.AbstractorBusInterfaceType] = new DefaultIPXACT2022ScalaCases_AbstractorBusInterfaceTypeFormat {}
  implicit lazy val IPXACT2022ScalaCases_IndirectInterfacesFormat: IPXACT2022scalaxb.XMLFormat[IPXACT2022ScalaCases.IndirectInterfaces] = new DefaultIPXACT2022ScalaCases_IndirectInterfacesFormat {}
  implicit lazy val IPXACT2022ScalaCases_IndirectInterfaceTypeFormat: IPXACT2022scalaxb.XMLFormat[IPXACT2022ScalaCases.IndirectInterfaceType] = new DefaultIPXACT2022ScalaCases_IndirectInterfaceTypeFormat {}
  implicit lazy val IPXACT2022ScalaCases_IndirectAddressRefFormat: IPXACT2022scalaxb.XMLFormat[IPXACT2022ScalaCases.IndirectAddressRef] = new DefaultIPXACT2022ScalaCases_IndirectAddressRefFormat {}
  implicit lazy val IPXACT2022ScalaCases_IndirectDataRefFormat: IPXACT2022scalaxb.XMLFormat[IPXACT2022ScalaCases.IndirectDataRef] = new DefaultIPXACT2022ScalaCases_IndirectDataRefFormat {}
  implicit lazy val IPXACT2022ScalaCases_LogicalPortFormat: IPXACT2022scalaxb.XMLFormat[IPXACT2022ScalaCases.LogicalPort] = new DefaultIPXACT2022ScalaCases_LogicalPortFormat {}
  implicit lazy val IPXACT2022ScalaCases_SubPortFormat: IPXACT2022scalaxb.XMLFormat[IPXACT2022ScalaCases.SubPort] = new DefaultIPXACT2022ScalaCases_SubPortFormat {}
  implicit lazy val IPXACT2022ScalaCases_PhysicalPortFormat: IPXACT2022scalaxb.XMLFormat[IPXACT2022ScalaCases.PhysicalPort] = new DefaultIPXACT2022ScalaCases_PhysicalPortFormat {}
  implicit lazy val IPXACT2022ScalaCases_PortMapFormat: IPXACT2022scalaxb.XMLFormat[IPXACT2022ScalaCases.PortMap] = new DefaultIPXACT2022ScalaCases_PortMapFormat {}
  implicit lazy val IPXACT2022ScalaCases_PortMapsFormat: IPXACT2022scalaxb.XMLFormat[IPXACT2022ScalaCases.PortMaps] = new DefaultIPXACT2022ScalaCases_PortMapsFormat {}
  implicit lazy val IPXACT2022ScalaCases_AbstractionTypeFormat: IPXACT2022scalaxb.XMLFormat[IPXACT2022ScalaCases.AbstractionType] = new DefaultIPXACT2022ScalaCases_AbstractionTypeFormat {}
  implicit lazy val IPXACT2022ScalaCases_AbstractionTypesFormat: IPXACT2022scalaxb.XMLFormat[IPXACT2022ScalaCases.AbstractionTypes] = new DefaultIPXACT2022ScalaCases_AbstractionTypesFormat {}
  implicit lazy val IPXACT2022ScalaCases_IpxactFilesTypeFormat: IPXACT2022scalaxb.XMLFormat[IPXACT2022ScalaCases.IpxactFilesType] = new DefaultIPXACT2022ScalaCases_IpxactFilesTypeFormat {}
  implicit lazy val IPXACT2022ScalaCases_CatalogFormat: IPXACT2022scalaxb.XMLFormat[IPXACT2022ScalaCases.Catalog] = new DefaultIPXACT2022ScalaCases_CatalogFormat {}
  implicit lazy val IPXACT2022ScalaCases_IpxactFileTypeFormat: IPXACT2022scalaxb.XMLFormat[IPXACT2022ScalaCases.IpxactFileType] = new DefaultIPXACT2022ScalaCases_IpxactFileTypeFormat {}
  implicit lazy val IPXACT2022ScalaCases_AssertionFormat: IPXACT2022scalaxb.XMLFormat[IPXACT2022ScalaCases.Assertion] = new DefaultIPXACT2022ScalaCases_AssertionFormat {}
  implicit lazy val IPXACT2022ScalaCases_AssertionsFormat: IPXACT2022scalaxb.XMLFormat[IPXACT2022ScalaCases.Assertions] = new DefaultIPXACT2022ScalaCases_AssertionsFormat {}
  implicit lazy val IPXACT2022ScalaCases_LevelFormat: IPXACT2022scalaxb.XMLFormat[IPXACT2022ScalaCases.Level] = new DefaultIPXACT2022ScalaCases_LevelFormat {}
  implicit lazy val IPXACT2022ScalaCases_IsResetFormat: IPXACT2022scalaxb.XMLFormat[IPXACT2022ScalaCases.IsReset] = new DefaultIPXACT2022ScalaCases_IsResetFormat {}
  implicit lazy val IPXACT2022ScalaCases_LevelTypeFormat: IPXACT2022scalaxb.XMLFormat[IPXACT2022ScalaCases.LevelType] = new DefaultIPXACT2022ScalaCases_LevelTypeFormat {}
  implicit lazy val IPXACT2022ScalaCases_IsClockEnFormat: IPXACT2022scalaxb.XMLFormat[IPXACT2022ScalaCases.IsClockEn] = new DefaultIPXACT2022ScalaCases_IsClockEnFormat {}
  implicit lazy val IPXACT2022ScalaCases_LevelType2Format: IPXACT2022scalaxb.XMLFormat[IPXACT2022ScalaCases.LevelType2] = new DefaultIPXACT2022ScalaCases_LevelType2Format {}
  implicit lazy val IPXACT2022ScalaCases_IsPowerEnFormat: IPXACT2022scalaxb.XMLFormat[IPXACT2022ScalaCases.IsPowerEn] = new DefaultIPXACT2022ScalaCases_IsPowerEnFormat {}
  implicit lazy val IPXACT2022ScalaCases_FlowTypeFormat: IPXACT2022scalaxb.XMLFormat[IPXACT2022ScalaCases.FlowType] = new DefaultIPXACT2022ScalaCases_FlowTypeFormat {}
  implicit lazy val IPXACT2022ScalaCases_IsFlowControlFormat: IPXACT2022scalaxb.XMLFormat[IPXACT2022ScalaCases.IsFlowControl] = new DefaultIPXACT2022ScalaCases_IsFlowControlFormat {}
  implicit lazy val IPXACT2022ScalaCases_IsUserFormat: IPXACT2022scalaxb.XMLFormat[IPXACT2022ScalaCases.IsUser] = new DefaultIPXACT2022ScalaCases_IsUserFormat {}
  implicit lazy val IPXACT2022ScalaCases_QualifierTypeFormat: IPXACT2022scalaxb.XMLFormat[IPXACT2022ScalaCases.QualifierType] = new DefaultIPXACT2022ScalaCases_QualifierTypeFormat {}
  implicit lazy val IPXACT2022ScalaCases_ParametersFormat: IPXACT2022scalaxb.XMLFormat[IPXACT2022ScalaCases.Parameters] = new DefaultIPXACT2022ScalaCases_ParametersFormat {}
  implicit lazy val IPXACT2022ScalaCases_VendorExtensionsFormat: IPXACT2022scalaxb.XMLFormat[IPXACT2022ScalaCases.VendorExtensions] = new DefaultIPXACT2022ScalaCases_VendorExtensionsFormat {}
  implicit lazy val IPXACT2022ScalaCases_ViewRef2Format: IPXACT2022scalaxb.XMLFormat[IPXACT2022ScalaCases.ViewRef2] = new DefaultIPXACT2022ScalaCases_ViewRef2Format {}
  implicit lazy val IPXACT2022ScalaCases_IndexFormat: IPXACT2022scalaxb.XMLFormat[IPXACT2022ScalaCases.Index] = new DefaultIPXACT2022ScalaCases_IndexFormat {}
  implicit lazy val IPXACT2022ScalaCases_IndicesFormat: IPXACT2022scalaxb.XMLFormat[IPXACT2022ScalaCases.Indices] = new DefaultIPXACT2022ScalaCases_IndicesFormat {}
  implicit lazy val IPXACT2022ScalaCases_PortAccessHandleFormat: IPXACT2022scalaxb.XMLFormat[IPXACT2022ScalaCases.PortAccessHandle] = new DefaultIPXACT2022ScalaCases_PortAccessHandleFormat {}
  implicit lazy val IPXACT2022ScalaCases_ViewRef3Format: IPXACT2022scalaxb.XMLFormat[IPXACT2022ScalaCases.ViewRef3] = new DefaultIPXACT2022ScalaCases_ViewRef3Format {}
  implicit lazy val IPXACT2022ScalaCases_SlicedAccessHandleFormat: IPXACT2022scalaxb.XMLFormat[IPXACT2022ScalaCases.SlicedAccessHandle] = new DefaultIPXACT2022ScalaCases_SlicedAccessHandleFormat {}
  implicit lazy val IPXACT2022ScalaCases_ViewRef4Format: IPXACT2022scalaxb.XMLFormat[IPXACT2022ScalaCases.ViewRef4] = new DefaultIPXACT2022ScalaCases_ViewRef4Format {}
  implicit lazy val IPXACT2022ScalaCases_PathSegmentsFormat: IPXACT2022scalaxb.XMLFormat[IPXACT2022ScalaCases.PathSegments] = new DefaultIPXACT2022ScalaCases_PathSegmentsFormat {}
  implicit lazy val IPXACT2022ScalaCases_SimpleAccessHandleFormat: IPXACT2022scalaxb.XMLFormat[IPXACT2022ScalaCases.SimpleAccessHandle] = new DefaultIPXACT2022ScalaCases_SimpleAccessHandleFormat {}
  implicit lazy val IPXACT2022ScalaCases_SlicesTypeFormat: IPXACT2022scalaxb.XMLFormat[IPXACT2022ScalaCases.SlicesType] = new DefaultIPXACT2022ScalaCases_SlicesTypeFormat {}
  implicit lazy val IPXACT2022ScalaCases_PathSegments2Format: IPXACT2022scalaxb.XMLFormat[IPXACT2022ScalaCases.PathSegments2] = new DefaultIPXACT2022ScalaCases_PathSegments2Format {}
  implicit lazy val IPXACT2022ScalaCases_SliceTypeFormat: IPXACT2022scalaxb.XMLFormat[IPXACT2022ScalaCases.SliceType] = new DefaultIPXACT2022ScalaCases_SliceTypeFormat {}
  implicit lazy val IPXACT2022ScalaCases_PathSegmentTypeFormat: IPXACT2022scalaxb.XMLFormat[IPXACT2022ScalaCases.PathSegmentType] = new DefaultIPXACT2022ScalaCases_PathSegmentTypeFormat {}
  implicit lazy val IPXACT2022ScalaCases_PortSlicesTypeFormat: IPXACT2022scalaxb.XMLFormat[IPXACT2022ScalaCases.PortSlicesType] = new DefaultIPXACT2022ScalaCases_PortSlicesTypeFormat {}
  implicit lazy val IPXACT2022ScalaCases_PathSegments3Format: IPXACT2022scalaxb.XMLFormat[IPXACT2022ScalaCases.PathSegments3] = new DefaultIPXACT2022ScalaCases_PathSegments3Format {}
  implicit lazy val IPXACT2022ScalaCases_PortSliceTypeFormat: IPXACT2022scalaxb.XMLFormat[IPXACT2022ScalaCases.PortSliceType] = new DefaultIPXACT2022ScalaCases_PortSliceTypeFormat {}
  implicit lazy val IPXACT2022ScalaCases_PortPathSegmentTypeFormat: IPXACT2022scalaxb.XMLFormat[IPXACT2022ScalaCases.PortPathSegmentType] = new DefaultIPXACT2022ScalaCases_PortPathSegmentTypeFormat {}
  implicit lazy val IPXACT2022ScalaCases_ParameterTypeFormat: IPXACT2022scalaxb.XMLFormat[IPXACT2022ScalaCases.ParameterType] = new DefaultIPXACT2022ScalaCases_ParameterTypeFormat {}
  implicit lazy val IPXACT2022ScalaCases_UsageTypeTypeFormat: IPXACT2022scalaxb.XMLFormat[IPXACT2022ScalaCases.UsageTypeType] = new DefaultIPXACT2022ScalaCases_UsageTypeTypeFormat {}
  implicit lazy val IPXACT2022ScalaCases_VectorFormat: IPXACT2022scalaxb.XMLFormat[IPXACT2022ScalaCases.Vector] = new DefaultIPXACT2022ScalaCases_VectorFormat {}
  implicit lazy val IPXACT2022ScalaCases_VectorsFormat: IPXACT2022scalaxb.XMLFormat[IPXACT2022ScalaCases.Vectors] = new DefaultIPXACT2022ScalaCases_VectorsFormat {}
  implicit lazy val IPXACT2022ScalaCases_ModuleParameterTypeFormat: IPXACT2022scalaxb.XMLFormat[IPXACT2022ScalaCases.ModuleParameterType] = new DefaultIPXACT2022ScalaCases_ModuleParameterTypeFormat {}
  implicit lazy val IPXACT2022ScalaCases_NameValuePairTypableFormat: IPXACT2022scalaxb.XMLFormat[IPXACT2022ScalaCases.NameValuePairTypable] = new DefaultIPXACT2022ScalaCases_NameValuePairTypableFormat {}
  implicit lazy val IPXACT2022ScalaCases_NameValuePairTypeFormat: IPXACT2022scalaxb.XMLFormat[IPXACT2022ScalaCases.NameValuePairType] = new DefaultIPXACT2022ScalaCases_NameValuePairTypeFormat {}
  implicit lazy val IPXACT2022ScalaCases_Vector2Format: IPXACT2022scalaxb.XMLFormat[IPXACT2022ScalaCases.Vector2] = new DefaultIPXACT2022ScalaCases_Vector2Format {}
  implicit lazy val IPXACT2022ScalaCases_Vectors2Format: IPXACT2022scalaxb.XMLFormat[IPXACT2022ScalaCases.Vectors2] = new DefaultIPXACT2022ScalaCases_Vectors2Format {}
  implicit lazy val IPXACT2022ScalaCases_RangeTypeFormat: IPXACT2022scalaxb.XMLFormat[IPXACT2022ScalaCases.RangeType] = new DefaultIPXACT2022ScalaCases_RangeTypeFormat {}
  implicit lazy val IPXACT2022ScalaCases_PartSelectFormat: IPXACT2022scalaxb.XMLFormat[IPXACT2022ScalaCases.PartSelect] = new DefaultIPXACT2022ScalaCases_PartSelectFormat {}
  implicit lazy val IPXACT2022ScalaCases_PartSelectSequence1Format: IPXACT2022scalaxb.XMLFormat[IPXACT2022ScalaCases.PartSelectSequence1] = new DefaultIPXACT2022ScalaCases_PartSelectSequence1Format {}
  implicit lazy val IPXACT2022ScalaCases_SubPortReferenceFormat: IPXACT2022scalaxb.XMLFormat[IPXACT2022ScalaCases.SubPortReference] = new DefaultIPXACT2022ScalaCases_SubPortReferenceFormat {}
  implicit lazy val IPXACT2022ScalaCases_AddressBlockRefFormat: IPXACT2022scalaxb.XMLFormat[IPXACT2022ScalaCases.AddressBlockRef] = new DefaultIPXACT2022ScalaCases_AddressBlockRefFormat {}
  implicit lazy val IPXACT2022ScalaCases_RegisterFileRefFormat: IPXACT2022scalaxb.XMLFormat[IPXACT2022ScalaCases.RegisterFileRef] = new DefaultIPXACT2022ScalaCases_RegisterFileRefFormat {}
  implicit lazy val IPXACT2022ScalaCases_RegisterRefFormat: IPXACT2022scalaxb.XMLFormat[IPXACT2022ScalaCases.RegisterRef] = new DefaultIPXACT2022ScalaCases_RegisterRefFormat {}
  implicit lazy val IPXACT2022ScalaCases_AlternateRegisterRefFormat: IPXACT2022scalaxb.XMLFormat[IPXACT2022ScalaCases.AlternateRegisterRef] = new DefaultIPXACT2022ScalaCases_AlternateRegisterRefFormat {}
  implicit lazy val IPXACT2022ScalaCases_FieldRefFormat: IPXACT2022scalaxb.XMLFormat[IPXACT2022ScalaCases.FieldRef] = new DefaultIPXACT2022ScalaCases_FieldRefFormat {}
  implicit lazy val IPXACT2022ScalaCases_BankRefFormat: IPXACT2022scalaxb.XMLFormat[IPXACT2022ScalaCases.BankRef] = new DefaultIPXACT2022ScalaCases_BankRefFormat {}
  implicit lazy val IPXACT2022ScalaCases_MemoryRemapRefFormat: IPXACT2022scalaxb.XMLFormat[IPXACT2022ScalaCases.MemoryRemapRef] = new DefaultIPXACT2022ScalaCases_MemoryRemapRefFormat {}
  implicit lazy val IPXACT2022ScalaCases_AddressSpaceRefFormat: IPXACT2022scalaxb.XMLFormat[IPXACT2022ScalaCases.AddressSpaceRef] = new DefaultIPXACT2022ScalaCases_AddressSpaceRefFormat {}
  implicit lazy val IPXACT2022ScalaCases_MemoryMapRefFormat: IPXACT2022scalaxb.XMLFormat[IPXACT2022ScalaCases.MemoryMapRef] = new DefaultIPXACT2022ScalaCases_MemoryMapRefFormat {}
  implicit lazy val IPXACT2022ScalaCases_AddressSpaceRef2Format: IPXACT2022scalaxb.XMLFormat[IPXACT2022ScalaCases.AddressSpaceRef2] = new DefaultIPXACT2022ScalaCases_AddressSpaceRef2Format {}
  implicit lazy val IPXACT2022ScalaCases_MemoryMapRef2Format: IPXACT2022scalaxb.XMLFormat[IPXACT2022ScalaCases.MemoryMapRef2] = new DefaultIPXACT2022ScalaCases_MemoryMapRef2Format {}
  implicit lazy val IPXACT2022ScalaCases_ArrayTypeFormat: IPXACT2022scalaxb.XMLFormat[IPXACT2022ScalaCases.ArrayType] = new DefaultIPXACT2022ScalaCases_ArrayTypeFormat {}
  implicit lazy val IPXACT2022ScalaCases_ConfigurableArraysFormat: IPXACT2022scalaxb.XMLFormat[IPXACT2022ScalaCases.ConfigurableArrays] = new DefaultIPXACT2022ScalaCases_ConfigurableArraysFormat {}
  implicit lazy val IPXACT2022ScalaCases_ArrayType2Format: IPXACT2022scalaxb.XMLFormat[IPXACT2022ScalaCases.ArrayType2] = new DefaultIPXACT2022ScalaCases_ArrayType2Format {}
  implicit lazy val IPXACT2022ScalaCases_ModuleParameterArraysFormat: IPXACT2022scalaxb.XMLFormat[IPXACT2022ScalaCases.ModuleParameterArrays] = new DefaultIPXACT2022ScalaCases_ModuleParameterArraysFormat {}
  implicit lazy val IPXACT2022ScalaCases_IndicesTypeFormat: IPXACT2022scalaxb.XMLFormat[IPXACT2022ScalaCases.IndicesType] = new DefaultIPXACT2022ScalaCases_IndicesTypeFormat {}
  implicit lazy val IPXACT2022ScalaCases_ExternalModeReferenceFormat: IPXACT2022scalaxb.XMLFormat[IPXACT2022ScalaCases.ExternalModeReference] = new DefaultIPXACT2022ScalaCases_ExternalModeReferenceFormat {}
  implicit lazy val IPXACT2022ScalaCases_ModeReferenceFormat: IPXACT2022scalaxb.XMLFormat[IPXACT2022ScalaCases.ModeReference] = new DefaultIPXACT2022ScalaCases_ModeReferenceFormat {}
  implicit lazy val IPXACT2022ScalaCases_ModeLinkFormat: IPXACT2022scalaxb.XMLFormat[IPXACT2022ScalaCases.ModeLink] = new DefaultIPXACT2022ScalaCases_ModeLinkFormat {}
  implicit lazy val IPXACT2022ScalaCases_ModeLinksFormat: IPXACT2022scalaxb.XMLFormat[IPXACT2022ScalaCases.ModeLinks] = new DefaultIPXACT2022ScalaCases_ModeLinksFormat {}
  implicit lazy val IPXACT2022ScalaCases_ExternalViewReferenceFormat: IPXACT2022scalaxb.XMLFormat[IPXACT2022ScalaCases.ExternalViewReference] = new DefaultIPXACT2022ScalaCases_ExternalViewReferenceFormat {}
  implicit lazy val IPXACT2022ScalaCases_ViewReferenceFormat: IPXACT2022scalaxb.XMLFormat[IPXACT2022ScalaCases.ViewReference] = new DefaultIPXACT2022ScalaCases_ViewReferenceFormat {}
  implicit lazy val IPXACT2022ScalaCases_ViewLinkFormat: IPXACT2022scalaxb.XMLFormat[IPXACT2022ScalaCases.ViewLink] = new DefaultIPXACT2022ScalaCases_ViewLinkFormat {}
  implicit lazy val IPXACT2022ScalaCases_ViewLinksFormat: IPXACT2022scalaxb.XMLFormat[IPXACT2022ScalaCases.ViewLinks] = new DefaultIPXACT2022ScalaCases_ViewLinksFormat {}
  implicit lazy val IPXACT2022ScalaCases_ExternalResetTypeReferenceFormat: IPXACT2022scalaxb.XMLFormat[IPXACT2022ScalaCases.ExternalResetTypeReference] = new DefaultIPXACT2022ScalaCases_ExternalResetTypeReferenceFormat {}
  implicit lazy val IPXACT2022ScalaCases_ResetTypeReferenceFormat: IPXACT2022scalaxb.XMLFormat[IPXACT2022ScalaCases.ResetTypeReference] = new DefaultIPXACT2022ScalaCases_ResetTypeReferenceFormat {}
  implicit lazy val IPXACT2022ScalaCases_ResetTypeLinkFormat: IPXACT2022scalaxb.XMLFormat[IPXACT2022ScalaCases.ResetTypeLink] = new DefaultIPXACT2022ScalaCases_ResetTypeLinkFormat {}
  implicit lazy val IPXACT2022ScalaCases_ResetTypeLinksFormat: IPXACT2022scalaxb.XMLFormat[IPXACT2022ScalaCases.ResetTypeLinks] = new DefaultIPXACT2022ScalaCases_ResetTypeLinksFormat {}
  implicit lazy val IPXACT2022ScalaCases_Index2Format: IPXACT2022scalaxb.XMLFormat[IPXACT2022ScalaCases.Index2] = new DefaultIPXACT2022ScalaCases_Index2Format {}
  implicit lazy val IPXACT2022ScalaCases_PrefixFormat: IPXACT2022scalaxb.XMLFormat[IPXACT2022ScalaCases.Prefix] = new DefaultIPXACT2022ScalaCases_PrefixFormat {}
  implicit lazy val IPXACT2022ScalaCases_UnitTypeFormat: IPXACT2022scalaxb.XMLFormat[IPXACT2022ScalaCases.UnitType] = new DefaultIPXACT2022ScalaCases_UnitTypeFormat {}
  implicit lazy val IPXACT2022ScalaCases_UnitTypeTypeFormat: IPXACT2022scalaxb.XMLFormat[IPXACT2022ScalaCases.UnitTypeType] = new DefaultIPXACT2022ScalaCases_UnitTypeTypeFormat {}
  implicit lazy val IPXACT2022ScalaCases_ResolveFormat: IPXACT2022scalaxb.XMLFormat[IPXACT2022ScalaCases.Resolve] = new DefaultIPXACT2022ScalaCases_ResolveFormat {}
  implicit lazy val IPXACT2022ScalaCases_NameGroupStringSequenceFormat: IPXACT2022scalaxb.XMLFormat[IPXACT2022ScalaCases.NameGroupStringSequence] = new DefaultIPXACT2022ScalaCases_NameGroupStringSequenceFormat {}
  implicit lazy val IPXACT2022ScalaCases_FieldSliceReferenceGroupSequence2Format: IPXACT2022scalaxb.XMLFormat[IPXACT2022ScalaCases.FieldSliceReferenceGroupSequence2] = new DefaultIPXACT2022ScalaCases_FieldSliceReferenceGroupSequence2Format {}
  implicit lazy val IPXACT2022ScalaCases_FieldSliceReferenceGroupSequenceFormat: IPXACT2022scalaxb.XMLFormat[IPXACT2022ScalaCases.FieldSliceReferenceGroupSequence] = new DefaultIPXACT2022ScalaCases_FieldSliceReferenceGroupSequenceFormat {}
  implicit lazy val IPXACT2022ScalaCases_NameGroupNMTOKENSequenceFormat: IPXACT2022scalaxb.XMLFormat[IPXACT2022ScalaCases.NameGroupNMTOKENSequence] = new DefaultIPXACT2022ScalaCases_NameGroupNMTOKENSequenceFormat {}
  implicit lazy val IPXACT2022ScalaCases_NameGroupSequenceFormat: IPXACT2022scalaxb.XMLFormat[IPXACT2022ScalaCases.NameGroupSequence] = new DefaultIPXACT2022ScalaCases_NameGroupSequenceFormat {}
  implicit lazy val IPXACT2022ScalaCases_NameGroupOptionalSequenceFormat: IPXACT2022scalaxb.XMLFormat[IPXACT2022ScalaCases.NameGroupOptionalSequence] = new DefaultIPXACT2022ScalaCases_NameGroupOptionalSequenceFormat {}
  implicit lazy val IPXACT2022ScalaCases_NameGroupPortSequenceFormat: IPXACT2022scalaxb.XMLFormat[IPXACT2022ScalaCases.NameGroupPortSequence] = new DefaultIPXACT2022ScalaCases_NameGroupPortSequenceFormat {}
  implicit lazy val IPXACT2022ScalaCases_FieldReferenceGroupSequence2Format: IPXACT2022scalaxb.XMLFormat[IPXACT2022ScalaCases.FieldReferenceGroupSequence2] = new DefaultIPXACT2022ScalaCases_FieldReferenceGroupSequence2Format {}
  implicit lazy val IPXACT2022ScalaCases_FieldReferenceGroupSequenceFormat: IPXACT2022scalaxb.XMLFormat[IPXACT2022ScalaCases.FieldReferenceGroupSequence] = new DefaultIPXACT2022ScalaCases_FieldReferenceGroupSequenceFormat {}
  implicit lazy val IPXACT2022ScalaCases_Parameteru46resolveu46attFormat: IPXACT2022scalaxb.AttributeGroupFormat[IPXACT2022ScalaCases.Parameteru46resolveu46att] = new DefaultIPXACT2022ScalaCases_Parameteru46resolveu46attFormat {}
  implicit lazy val IPXACT2022ScalaCases_Parameteru46attFormat: IPXACT2022scalaxb.AttributeGroupFormat[IPXACT2022ScalaCases.Parameteru46att] = new DefaultIPXACT2022ScalaCases_Parameteru46attFormat {}
  implicit lazy val IPXACT2022ScalaCases_Parameteru46unitu46attFormat: IPXACT2022scalaxb.AttributeGroupFormat[IPXACT2022ScalaCases.Parameteru46unitu46att] = new DefaultIPXACT2022ScalaCases_Parameteru46unitu46attFormat {}
  implicit lazy val IPXACT2022ScalaCases_TypeDefinitionsFormat: IPXACT2022scalaxb.XMLFormat[IPXACT2022ScalaCases.TypeDefinitions] = new DefaultIPXACT2022ScalaCases_TypeDefinitionsFormat {}
  implicit lazy val IPXACT2022ScalaCases_TypeDefinitionsSequence1Format: IPXACT2022scalaxb.XMLFormat[IPXACT2022ScalaCases.TypeDefinitionsSequence1] = new DefaultIPXACT2022ScalaCases_TypeDefinitionsSequence1Format {}
  implicit lazy val IPXACT2022ScalaCases_PowerDomainFormat: IPXACT2022scalaxb.XMLFormat[IPXACT2022ScalaCases.PowerDomain] = new DefaultIPXACT2022ScalaCases_PowerDomainFormat {}
  implicit lazy val IPXACT2022ScalaCases_PowerDomainsFormat: IPXACT2022scalaxb.XMLFormat[IPXACT2022ScalaCases.PowerDomains] = new DefaultIPXACT2022ScalaCases_PowerDomainsFormat {}
  implicit lazy val IPXACT2022ScalaCases_PortRefFormat: IPXACT2022scalaxb.XMLFormat[IPXACT2022ScalaCases.PortRef] = new DefaultIPXACT2022ScalaCases_PortRefFormat {}
  implicit lazy val IPXACT2022ScalaCases_PortSliceFormat: IPXACT2022scalaxb.XMLFormat[IPXACT2022ScalaCases.PortSlice] = new DefaultIPXACT2022ScalaCases_PortSliceFormat {}
  implicit lazy val IPXACT2022ScalaCases_FieldSliceFormat: IPXACT2022scalaxb.XMLFormat[IPXACT2022ScalaCases.FieldSlice] = new DefaultIPXACT2022ScalaCases_FieldSliceFormat {}
  implicit lazy val IPXACT2022ScalaCases_ModeFormat: IPXACT2022scalaxb.XMLFormat[IPXACT2022ScalaCases.Mode] = new DefaultIPXACT2022ScalaCases_ModeFormat {}
  implicit lazy val IPXACT2022ScalaCases_ModesFormat: IPXACT2022scalaxb.XMLFormat[IPXACT2022ScalaCases.Modes] = new DefaultIPXACT2022ScalaCases_ModesFormat {}
  implicit lazy val IPXACT2022ScalaCases_ClearboxElementsFormat: IPXACT2022scalaxb.XMLFormat[IPXACT2022ScalaCases.ClearboxElements] = new DefaultIPXACT2022ScalaCases_ClearboxElementsFormat {}
  implicit lazy val IPXACT2022ScalaCases_RegionFormat: IPXACT2022scalaxb.XMLFormat[IPXACT2022ScalaCases.Region] = new DefaultIPXACT2022ScalaCases_RegionFormat {}
  implicit lazy val IPXACT2022ScalaCases_RegionsFormat: IPXACT2022scalaxb.XMLFormat[IPXACT2022ScalaCases.Regions] = new DefaultIPXACT2022ScalaCases_RegionsFormat {}
  implicit lazy val IPXACT2022ScalaCases_CpuFormat: IPXACT2022scalaxb.XMLFormat[IPXACT2022ScalaCases.Cpu] = new DefaultIPXACT2022ScalaCases_CpuFormat {}
  implicit lazy val IPXACT2022ScalaCases_CpusFormat: IPXACT2022scalaxb.XMLFormat[IPXACT2022ScalaCases.Cpus] = new DefaultIPXACT2022ScalaCases_CpusFormat {}
  implicit lazy val IPXACT2022ScalaCases_ResetTypeFormat: IPXACT2022scalaxb.XMLFormat[IPXACT2022ScalaCases.ResetType] = new DefaultIPXACT2022ScalaCases_ResetTypeFormat {}
  implicit lazy val IPXACT2022ScalaCases_ResetTypesFormat: IPXACT2022scalaxb.XMLFormat[IPXACT2022ScalaCases.ResetTypes] = new DefaultIPXACT2022ScalaCases_ResetTypesFormat {}
  implicit lazy val IPXACT2022ScalaCases_ComponentTypeFormat: IPXACT2022scalaxb.XMLFormat[IPXACT2022ScalaCases.ComponentType] = new DefaultIPXACT2022ScalaCases_ComponentTypeFormat {}
  implicit lazy val IPXACT2022ScalaCases_SimpleClearboxTypeFormat: IPXACT2022scalaxb.XMLFormat[IPXACT2022ScalaCases.SimpleClearboxType] = new DefaultIPXACT2022ScalaCases_SimpleClearboxTypeFormat {}
  implicit lazy val IPXACT2022ScalaCases_ClearboxElementTypeFormat: IPXACT2022scalaxb.XMLFormat[IPXACT2022ScalaCases.ClearboxElementType] = new DefaultIPXACT2022ScalaCases_ClearboxElementTypeFormat {}
  implicit lazy val IPXACT2022ScalaCases_CellFunctionValueTypeFormat: IPXACT2022scalaxb.XMLFormat[IPXACT2022ScalaCases.CellFunctionValueType] = new DefaultIPXACT2022ScalaCases_CellFunctionValueTypeFormat {}
  implicit lazy val IPXACT2022ScalaCases_CellClassValueTypeFormat: IPXACT2022scalaxb.XMLFormat[IPXACT2022ScalaCases.CellClassValueType] = new DefaultIPXACT2022ScalaCases_CellClassValueTypeFormat {}
  implicit lazy val IPXACT2022ScalaCases_CellStrengthValueTypeFormat: IPXACT2022scalaxb.XMLFormat[IPXACT2022ScalaCases.CellStrengthValueType] = new DefaultIPXACT2022ScalaCases_CellStrengthValueTypeFormat {}
  implicit lazy val IPXACT2022ScalaCases_EdgeValueTypeFormat: IPXACT2022scalaxb.XMLFormat[IPXACT2022ScalaCases.EdgeValueType] = new DefaultIPXACT2022ScalaCases_EdgeValueTypeFormat {}
  implicit lazy val IPXACT2022ScalaCases_DelayValueTypeFormat: IPXACT2022scalaxb.XMLFormat[IPXACT2022ScalaCases.DelayValueType] = new DefaultIPXACT2022ScalaCases_DelayValueTypeFormat {}
  implicit lazy val IPXACT2022ScalaCases_OtherClocksFormat: IPXACT2022scalaxb.XMLFormat[IPXACT2022ScalaCases.OtherClocks] = new DefaultIPXACT2022ScalaCases_OtherClocksFormat {}
  implicit lazy val IPXACT2022ScalaCases_CellFunctionFormat: IPXACT2022scalaxb.XMLFormat[IPXACT2022ScalaCases.CellFunction] = new DefaultIPXACT2022ScalaCases_CellFunctionFormat {}
  implicit lazy val IPXACT2022ScalaCases_CellSpecificationFormat: IPXACT2022scalaxb.XMLFormat[IPXACT2022ScalaCases.CellSpecification] = new DefaultIPXACT2022ScalaCases_CellSpecificationFormat {}
  implicit lazy val IPXACT2022ScalaCases_TimingConstraintFormat: IPXACT2022scalaxb.XMLFormat[IPXACT2022ScalaCases.TimingConstraint] = new DefaultIPXACT2022ScalaCases_TimingConstraintFormat {}
  implicit lazy val IPXACT2022ScalaCases_DriveConstraintFormat: IPXACT2022scalaxb.XMLFormat[IPXACT2022ScalaCases.DriveConstraint] = new DefaultIPXACT2022ScalaCases_DriveConstraintFormat {}
  implicit lazy val IPXACT2022ScalaCases_LoadConstraintFormat: IPXACT2022scalaxb.XMLFormat[IPXACT2022ScalaCases.LoadConstraint] = new DefaultIPXACT2022ScalaCases_LoadConstraintFormat {}
  implicit lazy val IPXACT2022ScalaCases_Vector3Format: IPXACT2022scalaxb.XMLFormat[IPXACT2022ScalaCases.Vector3] = new DefaultIPXACT2022ScalaCases_Vector3Format {}
  implicit lazy val IPXACT2022ScalaCases_ConstraintSetFormat: IPXACT2022scalaxb.XMLFormat[IPXACT2022ScalaCases.ConstraintSet] = new DefaultIPXACT2022ScalaCases_ConstraintSetFormat {}
  implicit lazy val IPXACT2022ScalaCases_ConstraintSetsFormat: IPXACT2022scalaxb.XMLFormat[IPXACT2022ScalaCases.ConstraintSets] = new DefaultIPXACT2022ScalaCases_ConstraintSetsFormat {}
  implicit lazy val IPXACT2022ScalaCases_ConstraintSetRefFormat: IPXACT2022scalaxb.XMLFormat[IPXACT2022ScalaCases.ConstraintSetRef] = new DefaultIPXACT2022ScalaCases_ConstraintSetRefFormat {}
  implicit lazy val IPXACT2022ScalaCases_AbstractionDefPortConstraintsTypeFormat: IPXACT2022scalaxb.XMLFormat[IPXACT2022ScalaCases.AbstractionDefPortConstraintsType] = new DefaultIPXACT2022ScalaCases_AbstractionDefPortConstraintsTypeFormat {}
  implicit lazy val IPXACT2022ScalaCases_AbstractionDefPortConstraintsTypeSequence3Format: IPXACT2022scalaxb.XMLFormat[IPXACT2022ScalaCases.AbstractionDefPortConstraintsTypeSequence3] = new DefaultIPXACT2022ScalaCases_AbstractionDefPortConstraintsTypeSequence3Format {}
  implicit lazy val IPXACT2022ScalaCases_AbstractionDefPortConstraintsTypeSequence2Format: IPXACT2022scalaxb.XMLFormat[IPXACT2022ScalaCases.AbstractionDefPortConstraintsTypeSequence2] = new DefaultIPXACT2022ScalaCases_AbstractionDefPortConstraintsTypeSequence2Format {}
  implicit lazy val IPXACT2022ScalaCases_AbstractionDefPortConstraintsTypeSequence1Format: IPXACT2022scalaxb.XMLFormat[IPXACT2022ScalaCases.AbstractionDefPortConstraintsTypeSequence1] = new DefaultIPXACT2022ScalaCases_AbstractionDefPortConstraintsTypeSequence1Format {}
  implicit lazy val IPXACT2022ScalaCases_DesignFormat: IPXACT2022scalaxb.XMLFormat[IPXACT2022ScalaCases.Design] = new DefaultIPXACT2022ScalaCases_DesignFormat {}
  implicit lazy val IPXACT2022ScalaCases_InterfaceRefFormat: IPXACT2022scalaxb.XMLFormat[IPXACT2022ScalaCases.InterfaceRef] = new DefaultIPXACT2022ScalaCases_InterfaceRefFormat {}
  implicit lazy val IPXACT2022ScalaCases_InterfaceRefSequence1Format: IPXACT2022scalaxb.XMLFormat[IPXACT2022ScalaCases.InterfaceRefSequence1] = new DefaultIPXACT2022ScalaCases_InterfaceRefSequence1Format {}
  implicit lazy val IPXACT2022ScalaCases_AbstractorInstanceFormat: IPXACT2022scalaxb.XMLFormat[IPXACT2022ScalaCases.AbstractorInstance] = new DefaultIPXACT2022ScalaCases_AbstractorInstanceFormat {}
  implicit lazy val IPXACT2022ScalaCases_AbstractorInstancesFormat: IPXACT2022scalaxb.XMLFormat[IPXACT2022ScalaCases.AbstractorInstances] = new DefaultIPXACT2022ScalaCases_AbstractorInstancesFormat {}
  implicit lazy val IPXACT2022ScalaCases_InterconnectionConfigurationFormat: IPXACT2022scalaxb.XMLFormat[IPXACT2022ScalaCases.InterconnectionConfiguration] = new DefaultIPXACT2022ScalaCases_InterconnectionConfigurationFormat {}
  implicit lazy val IPXACT2022ScalaCases_View3Format: IPXACT2022scalaxb.XMLFormat[IPXACT2022ScalaCases.View3] = new DefaultIPXACT2022ScalaCases_View3Format {}
  implicit lazy val IPXACT2022ScalaCases_ViewConfigurationFormat: IPXACT2022scalaxb.XMLFormat[IPXACT2022ScalaCases.ViewConfiguration] = new DefaultIPXACT2022ScalaCases_ViewConfigurationFormat {}
  implicit lazy val IPXACT2022ScalaCases_DesignConfigurationFormat: IPXACT2022scalaxb.XMLFormat[IPXACT2022ScalaCases.DesignConfiguration] = new DefaultIPXACT2022ScalaCases_DesignConfigurationFormat {}
  implicit lazy val IPXACT2022ScalaCases_IsIncludeFileFormat: IPXACT2022scalaxb.XMLFormat[IPXACT2022ScalaCases.IsIncludeFile] = new DefaultIPXACT2022ScalaCases_IsIncludeFileFormat {}
  implicit lazy val IPXACT2022ScalaCases_LogicalNameFormat: IPXACT2022scalaxb.XMLFormat[IPXACT2022ScalaCases.LogicalName] = new DefaultIPXACT2022ScalaCases_LogicalNameFormat {}
  implicit lazy val IPXACT2022ScalaCases_ExportedNameFormat: IPXACT2022scalaxb.XMLFormat[IPXACT2022ScalaCases.ExportedName] = new DefaultIPXACT2022ScalaCases_ExportedNameFormat {}
  implicit lazy val IPXACT2022ScalaCases_FlagsFormat: IPXACT2022scalaxb.XMLFormat[IPXACT2022ScalaCases.Flags] = new DefaultIPXACT2022ScalaCases_FlagsFormat {}
  implicit lazy val IPXACT2022ScalaCases_BuildCommandFormat: IPXACT2022scalaxb.XMLFormat[IPXACT2022ScalaCases.BuildCommand] = new DefaultIPXACT2022ScalaCases_BuildCommandFormat {}
  implicit lazy val IPXACT2022ScalaCases_ImageTypeFormat: IPXACT2022scalaxb.XMLFormat[IPXACT2022ScalaCases.ImageType] = new DefaultIPXACT2022ScalaCases_ImageTypeFormat {}
  implicit lazy val IPXACT2022ScalaCases_FileFormat: IPXACT2022scalaxb.XMLFormat[IPXACT2022ScalaCases.File] = new DefaultIPXACT2022ScalaCases_FileFormat {}
  implicit lazy val IPXACT2022ScalaCases_FileBuilderFormat: IPXACT2022scalaxb.XMLFormat[IPXACT2022ScalaCases.FileBuilder] = new DefaultIPXACT2022ScalaCases_FileBuilderFormat {}
  implicit lazy val IPXACT2022ScalaCases_LanguageToolsFormat: IPXACT2022scalaxb.XMLFormat[IPXACT2022ScalaCases.LanguageTools] = new DefaultIPXACT2022ScalaCases_LanguageToolsFormat {}
  implicit lazy val IPXACT2022ScalaCases_LanguageToolsSequence2Format: IPXACT2022scalaxb.XMLFormat[IPXACT2022ScalaCases.LanguageToolsSequence2] = new DefaultIPXACT2022ScalaCases_LanguageToolsSequence2Format {}
  implicit lazy val IPXACT2022ScalaCases_LanguageToolsSequence1Format: IPXACT2022scalaxb.XMLFormat[IPXACT2022ScalaCases.LanguageToolsSequence1] = new DefaultIPXACT2022ScalaCases_LanguageToolsSequence1Format {}
  implicit lazy val IPXACT2022ScalaCases_FileSetRefGroupFormat: IPXACT2022scalaxb.XMLFormat[IPXACT2022ScalaCases.FileSetRefGroup] = new DefaultIPXACT2022ScalaCases_FileSetRefGroupFormat {}
  implicit lazy val IPXACT2022ScalaCases_ExecutableImageFormat: IPXACT2022scalaxb.XMLFormat[IPXACT2022ScalaCases.ExecutableImage] = new DefaultIPXACT2022ScalaCases_ExecutableImageFormat {}
  implicit lazy val IPXACT2022ScalaCases_LinkerCommandFileFormat: IPXACT2022scalaxb.XMLFormat[IPXACT2022ScalaCases.LinkerCommandFile] = new DefaultIPXACT2022ScalaCases_LinkerCommandFileFormat {}
  implicit lazy val IPXACT2022ScalaCases_FileSetRefFormat: IPXACT2022scalaxb.XMLFormat[IPXACT2022ScalaCases.FileSetRef] = new DefaultIPXACT2022ScalaCases_FileSetRefFormat {}
  implicit lazy val IPXACT2022ScalaCases_DependencyFormat: IPXACT2022scalaxb.XMLFormat[IPXACT2022ScalaCases.Dependency] = new DefaultIPXACT2022ScalaCases_DependencyFormat {}
  implicit lazy val IPXACT2022ScalaCases_FileSetsFormat: IPXACT2022scalaxb.XMLFormat[IPXACT2022ScalaCases.FileSets] = new DefaultIPXACT2022ScalaCases_FileSetsFormat {}
  implicit lazy val IPXACT2022ScalaCases_FileBuilderTypeFormat: IPXACT2022scalaxb.XMLFormat[IPXACT2022ScalaCases.FileBuilderType] = new DefaultIPXACT2022ScalaCases_FileBuilderTypeFormat {}
  implicit lazy val IPXACT2022ScalaCases_ReturnTypeTypeFormat: IPXACT2022scalaxb.XMLFormat[IPXACT2022ScalaCases.ReturnTypeType] = new DefaultIPXACT2022ScalaCases_ReturnTypeTypeFormat {}
  implicit lazy val IPXACT2022ScalaCases_Group2Format: IPXACT2022scalaxb.XMLFormat[IPXACT2022ScalaCases.Group2] = new DefaultIPXACT2022ScalaCases_Group2Format {}
  implicit lazy val IPXACT2022ScalaCases_ArgumentFormat: IPXACT2022scalaxb.XMLFormat[IPXACT2022ScalaCases.Argument] = new DefaultIPXACT2022ScalaCases_ArgumentFormat {}
  implicit lazy val IPXACT2022ScalaCases_SourceFileFormat: IPXACT2022scalaxb.XMLFormat[IPXACT2022ScalaCases.SourceFile] = new DefaultIPXACT2022ScalaCases_SourceFileFormat {}
  implicit lazy val IPXACT2022ScalaCases_FunctionTypeFormat: IPXACT2022scalaxb.XMLFormat[IPXACT2022ScalaCases.FunctionType] = new DefaultIPXACT2022ScalaCases_FunctionTypeFormat {}
  implicit lazy val IPXACT2022ScalaCases_FileSetTypeFormat: IPXACT2022scalaxb.XMLFormat[IPXACT2022ScalaCases.FileSetType] = new DefaultIPXACT2022ScalaCases_FileSetTypeFormat {}
  implicit lazy val IPXACT2022ScalaCases_DataTypeTypeFormat: IPXACT2022scalaxb.XMLFormat[IPXACT2022ScalaCases.DataTypeType] = new DefaultIPXACT2022ScalaCases_DataTypeTypeFormat {}
  implicit lazy val IPXACT2022ScalaCases_GeneratorRefFormat: IPXACT2022scalaxb.XMLFormat[IPXACT2022ScalaCases.GeneratorRef] = new DefaultIPXACT2022ScalaCases_GeneratorRefFormat {}
  implicit lazy val IPXACT2022ScalaCases_SimpleFileTypeFormat: IPXACT2022scalaxb.XMLFormat[IPXACT2022ScalaCases.SimpleFileType] = new DefaultIPXACT2022ScalaCases_SimpleFileTypeFormat {}
  implicit lazy val IPXACT2022ScalaCases_FileTypeFormat: IPXACT2022scalaxb.XMLFormat[IPXACT2022ScalaCases.FileType] = new DefaultIPXACT2022ScalaCases_FileTypeFormat {}
  implicit lazy val IPXACT2022ScalaCases_GeneratorChainSelectorFormat: IPXACT2022scalaxb.XMLFormat[IPXACT2022ScalaCases.GeneratorChainSelector] = new DefaultIPXACT2022ScalaCases_GeneratorChainSelectorFormat {}
  implicit lazy val IPXACT2022ScalaCases_ChainGroupFormat: IPXACT2022scalaxb.XMLFormat[IPXACT2022ScalaCases.ChainGroup] = new DefaultIPXACT2022ScalaCases_ChainGroupFormat {}
  implicit lazy val IPXACT2022ScalaCases_GeneratorChainFormat: IPXACT2022scalaxb.XMLFormat[IPXACT2022ScalaCases.GeneratorChain] = new DefaultIPXACT2022ScalaCases_GeneratorChainFormat {}
  implicit lazy val IPXACT2022ScalaCases_GeneratorFormat: IPXACT2022scalaxb.XMLFormat[IPXACT2022ScalaCases.Generator] = new DefaultIPXACT2022ScalaCases_GeneratorFormat {}
  implicit lazy val IPXACT2022ScalaCases_MultipleGroupSelectionOperatorFormat: IPXACT2022scalaxb.XMLFormat[IPXACT2022ScalaCases.MultipleGroupSelectionOperator] = new DefaultIPXACT2022ScalaCases_MultipleGroupSelectionOperatorFormat {}
  implicit lazy val IPXACT2022ScalaCases_NameFormat: IPXACT2022scalaxb.XMLFormat[IPXACT2022ScalaCases.Name] = new DefaultIPXACT2022ScalaCases_NameFormat {}
  implicit lazy val IPXACT2022ScalaCases_GroupSelectorFormat: IPXACT2022scalaxb.XMLFormat[IPXACT2022ScalaCases.GroupSelector] = new DefaultIPXACT2022ScalaCases_GroupSelectorFormat {}
  implicit lazy val IPXACT2022ScalaCases_GroupFormat: IPXACT2022scalaxb.XMLFormat[IPXACT2022ScalaCases.Group] = new DefaultIPXACT2022ScalaCases_GroupFormat {}
  implicit lazy val IPXACT2022ScalaCases_ScopeFormat: IPXACT2022scalaxb.XMLFormat[IPXACT2022ScalaCases.Scope] = new DefaultIPXACT2022ScalaCases_ScopeFormat {}
  implicit lazy val IPXACT2022ScalaCases_InstanceGeneratorTypeFormat: IPXACT2022scalaxb.XMLFormat[IPXACT2022ScalaCases.InstanceGeneratorType] = new DefaultIPXACT2022ScalaCases_InstanceGeneratorTypeFormat {}
  implicit lazy val IPXACT2022ScalaCases_GeneratorSelectorTypeFormat: IPXACT2022scalaxb.XMLFormat[IPXACT2022ScalaCases.GeneratorSelectorType] = new DefaultIPXACT2022ScalaCases_GeneratorSelectorTypeFormat {}
  implicit lazy val IPXACT2022ScalaCases_ComponentGeneratorsFormat: IPXACT2022scalaxb.XMLFormat[IPXACT2022ScalaCases.ComponentGenerators] = new DefaultIPXACT2022ScalaCases_ComponentGeneratorsFormat {}
  implicit lazy val IPXACT2022ScalaCases_AbstractorGeneratorsFormat: IPXACT2022scalaxb.XMLFormat[IPXACT2022ScalaCases.AbstractorGenerators] = new DefaultIPXACT2022ScalaCases_AbstractorGeneratorsFormat {}
  implicit lazy val IPXACT2022ScalaCases_ApiTypeTypeFormat: IPXACT2022scalaxb.XMLFormat[IPXACT2022ScalaCases.ApiTypeType] = new DefaultIPXACT2022ScalaCases_ApiTypeTypeFormat {}
  implicit lazy val IPXACT2022ScalaCases_TransportMethodTypeFormat: IPXACT2022scalaxb.XMLFormat[IPXACT2022ScalaCases.TransportMethodType] = new DefaultIPXACT2022ScalaCases_TransportMethodTypeFormat {}
  implicit lazy val IPXACT2022ScalaCases_ApiTypeFormat: IPXACT2022scalaxb.XMLFormat[IPXACT2022ScalaCases.ApiType] = new DefaultIPXACT2022ScalaCases_ApiTypeFormat {}
  implicit lazy val IPXACT2022ScalaCases_ApiServiceFormat: IPXACT2022scalaxb.XMLFormat[IPXACT2022ScalaCases.ApiService] = new DefaultIPXACT2022ScalaCases_ApiServiceFormat {}
  implicit lazy val IPXACT2022ScalaCases_TransportMethodFormat: IPXACT2022scalaxb.XMLFormat[IPXACT2022ScalaCases.TransportMethod] = new DefaultIPXACT2022ScalaCases_TransportMethodFormat {}
  implicit lazy val IPXACT2022ScalaCases_TransportMethodsFormat: IPXACT2022scalaxb.XMLFormat[IPXACT2022ScalaCases.TransportMethods] = new DefaultIPXACT2022ScalaCases_TransportMethodsFormat {}
  implicit lazy val IPXACT2022ScalaCases_GeneratorTypableFormat: IPXACT2022scalaxb.XMLFormat[IPXACT2022ScalaCases.GeneratorTypable] = new DefaultIPXACT2022ScalaCases_GeneratorTypableFormat {}
  implicit lazy val IPXACT2022ScalaCases_GeneratorTypeFormat: IPXACT2022scalaxb.XMLFormat[IPXACT2022ScalaCases.GeneratorType] = new DefaultIPXACT2022ScalaCases_GeneratorTypeFormat {}
  implicit lazy val IPXACT2022ScalaCases_LibraryRefTypeFormat: IPXACT2022scalaxb.XMLFormat[IPXACT2022ScalaCases.LibraryRefType] = new DefaultIPXACT2022ScalaCases_LibraryRefTypeFormat {}
  implicit lazy val IPXACT2022ScalaCases_ConfigurableLibraryRefTypeFormat: IPXACT2022scalaxb.XMLFormat[IPXACT2022ScalaCases.ConfigurableLibraryRefType] = new DefaultIPXACT2022ScalaCases_ConfigurableLibraryRefTypeFormat {}
  implicit lazy val IPXACT2022ScalaCases_DocumentNameGroupSequenceFormat: IPXACT2022scalaxb.XMLFormat[IPXACT2022ScalaCases.DocumentNameGroupSequence] = new DefaultIPXACT2022ScalaCases_DocumentNameGroupSequenceFormat {}
  implicit lazy val IPXACT2022ScalaCases_BaseIdentifierSequenceFormat: IPXACT2022scalaxb.XMLFormat[IPXACT2022ScalaCases.BaseIdentifierSequence] = new DefaultIPXACT2022ScalaCases_BaseIdentifierSequenceFormat {}
  implicit lazy val IPXACT2022ScalaCases_VersionedIdentifierSequenceFormat: IPXACT2022scalaxb.XMLFormat[IPXACT2022ScalaCases.VersionedIdentifierSequence] = new DefaultIPXACT2022ScalaCases_VersionedIdentifierSequenceFormat {}
  implicit lazy val IPXACT2022ScalaCases_LibraryRefGroupFormat: IPXACT2022scalaxb.AttributeGroupFormat[IPXACT2022ScalaCases.LibraryRefGroup] = new DefaultIPXACT2022ScalaCases_LibraryRefGroupFormat {}
  implicit lazy val IPXACT2022ScalaCases_AccessTypeFormat: IPXACT2022scalaxb.XMLFormat[IPXACT2022ScalaCases.AccessType] = new DefaultIPXACT2022ScalaCases_AccessTypeFormat {}
  implicit lazy val IPXACT2022ScalaCases_SharedTypeFormat: IPXACT2022scalaxb.XMLFormat[IPXACT2022ScalaCases.SharedType] = new DefaultIPXACT2022ScalaCases_SharedTypeFormat {}
  implicit lazy val IPXACT2022ScalaCases_BankAlignmentTypeFormat: IPXACT2022scalaxb.XMLFormat[IPXACT2022ScalaCases.BankAlignmentType] = new DefaultIPXACT2022ScalaCases_BankAlignmentTypeFormat {}
  implicit lazy val IPXACT2022ScalaCases_UsageTypeFormat: IPXACT2022scalaxb.XMLFormat[IPXACT2022ScalaCases.UsageType] = new DefaultIPXACT2022ScalaCases_UsageTypeFormat {}
  implicit lazy val IPXACT2022ScalaCases_AccessHandlesFormat: IPXACT2022scalaxb.XMLFormat[IPXACT2022ScalaCases.AccessHandles] = new DefaultIPXACT2022ScalaCases_AccessHandlesFormat {}
  implicit lazy val IPXACT2022ScalaCases_AccessHandlesSequence1Format: IPXACT2022scalaxb.XMLFormat[IPXACT2022ScalaCases.AccessHandlesSequence1] = new DefaultIPXACT2022ScalaCases_AccessHandlesSequence1Format {}
  implicit lazy val IPXACT2022ScalaCases_BankDefinitionRefFormat: IPXACT2022scalaxb.XMLFormat[IPXACT2022ScalaCases.BankDefinitionRef] = new DefaultIPXACT2022ScalaCases_BankDefinitionRefFormat {}
  implicit lazy val IPXACT2022ScalaCases_AddressBankTypeFormat: IPXACT2022scalaxb.XMLFormat[IPXACT2022ScalaCases.AddressBankType] = new DefaultIPXACT2022ScalaCases_AddressBankTypeFormat {}
  implicit lazy val IPXACT2022ScalaCases_AccessHandles2Format: IPXACT2022scalaxb.XMLFormat[IPXACT2022ScalaCases.AccessHandles2] = new DefaultIPXACT2022ScalaCases_AccessHandles2Format {}
  implicit lazy val IPXACT2022ScalaCases_AccessHandles2Sequence1Format: IPXACT2022scalaxb.XMLFormat[IPXACT2022ScalaCases.AccessHandles2Sequence1] = new DefaultIPXACT2022ScalaCases_AccessHandles2Sequence1Format {}
  implicit lazy val IPXACT2022ScalaCases_BankDefinitionRef2Format: IPXACT2022scalaxb.XMLFormat[IPXACT2022ScalaCases.BankDefinitionRef2] = new DefaultIPXACT2022ScalaCases_BankDefinitionRef2Format {}
  implicit lazy val IPXACT2022ScalaCases_AddressBankDefinitionTypeFormat: IPXACT2022scalaxb.XMLFormat[IPXACT2022ScalaCases.AddressBankDefinitionType] = new DefaultIPXACT2022ScalaCases_AddressBankDefinitionTypeFormat {}
  implicit lazy val IPXACT2022ScalaCases_AccessHandles3Format: IPXACT2022scalaxb.XMLFormat[IPXACT2022ScalaCases.AccessHandles3] = new DefaultIPXACT2022ScalaCases_AccessHandles3Format {}
  implicit lazy val IPXACT2022ScalaCases_AccessHandles3Sequence1Format: IPXACT2022scalaxb.XMLFormat[IPXACT2022ScalaCases.AccessHandles3Sequence1] = new DefaultIPXACT2022ScalaCases_AccessHandles3Sequence1Format {}
  implicit lazy val IPXACT2022ScalaCases_LocalAddressBankTypeFormat: IPXACT2022scalaxb.XMLFormat[IPXACT2022ScalaCases.LocalAddressBankType] = new DefaultIPXACT2022ScalaCases_LocalAddressBankTypeFormat {}
  implicit lazy val IPXACT2022ScalaCases_AccessHandles4Format: IPXACT2022scalaxb.XMLFormat[IPXACT2022ScalaCases.AccessHandles4] = new DefaultIPXACT2022ScalaCases_AccessHandles4Format {}
  implicit lazy val IPXACT2022ScalaCases_AccessHandles4Sequence1Format: IPXACT2022scalaxb.XMLFormat[IPXACT2022ScalaCases.AccessHandles4Sequence1] = new DefaultIPXACT2022ScalaCases_AccessHandles4Sequence1Format {}
  implicit lazy val IPXACT2022ScalaCases_AddressBlockDefinitionRefFormat: IPXACT2022scalaxb.XMLFormat[IPXACT2022ScalaCases.AddressBlockDefinitionRef] = new DefaultIPXACT2022ScalaCases_AddressBlockDefinitionRefFormat {}
  implicit lazy val IPXACT2022ScalaCases_AddressBlockTypeFormat: IPXACT2022scalaxb.XMLFormat[IPXACT2022ScalaCases.AddressBlockType] = new DefaultIPXACT2022ScalaCases_AddressBlockTypeFormat {}
  implicit lazy val IPXACT2022ScalaCases_AddrSpaceRefTypableFormat: IPXACT2022scalaxb.XMLFormat[IPXACT2022ScalaCases.AddrSpaceRefTypable] = new DefaultIPXACT2022ScalaCases_AddrSpaceRefTypableFormat {}
  implicit lazy val IPXACT2022ScalaCases_AddrSpaceRefTypeFormat: IPXACT2022scalaxb.XMLFormat[IPXACT2022ScalaCases.AddrSpaceRefType] = new DefaultIPXACT2022ScalaCases_AddrSpaceRefTypeFormat {}
  implicit lazy val IPXACT2022ScalaCases_ModeRef2Format: IPXACT2022scalaxb.XMLFormat[IPXACT2022ScalaCases.ModeRef2] = new DefaultIPXACT2022ScalaCases_ModeRef2Format {}
  implicit lazy val IPXACT2022ScalaCases_MemoryMapRefTypeFormat: IPXACT2022scalaxb.XMLFormat[IPXACT2022ScalaCases.MemoryMapRefType] = new DefaultIPXACT2022ScalaCases_MemoryMapRefTypeFormat {}
  implicit lazy val IPXACT2022ScalaCases_AccessHandles5Format: IPXACT2022scalaxb.XMLFormat[IPXACT2022ScalaCases.AccessHandles5] = new DefaultIPXACT2022ScalaCases_AccessHandles5Format {}
  implicit lazy val IPXACT2022ScalaCases_AccessHandles5Sequence1Format: IPXACT2022scalaxb.XMLFormat[IPXACT2022ScalaCases.AccessHandles5Sequence1] = new DefaultIPXACT2022ScalaCases_AccessHandles5Sequence1Format {}
  implicit lazy val IPXACT2022ScalaCases_BankDefinitionRef3Format: IPXACT2022scalaxb.XMLFormat[IPXACT2022ScalaCases.BankDefinitionRef3] = new DefaultIPXACT2022ScalaCases_BankDefinitionRef3Format {}
  implicit lazy val IPXACT2022ScalaCases_BankedBankTypableFormat: IPXACT2022scalaxb.XMLFormat[IPXACT2022ScalaCases.BankedBankTypable] = new DefaultIPXACT2022ScalaCases_BankedBankTypableFormat {}
  implicit lazy val IPXACT2022ScalaCases_BankedBankTypeFormat: IPXACT2022scalaxb.XMLFormat[IPXACT2022ScalaCases.BankedBankType] = new DefaultIPXACT2022ScalaCases_BankedBankTypeFormat {}
  implicit lazy val IPXACT2022ScalaCases_AccessHandles6Format: IPXACT2022scalaxb.XMLFormat[IPXACT2022ScalaCases.AccessHandles6] = new DefaultIPXACT2022ScalaCases_AccessHandles6Format {}
  implicit lazy val IPXACT2022ScalaCases_AccessHandles6Sequence1Format: IPXACT2022scalaxb.XMLFormat[IPXACT2022ScalaCases.AccessHandles6Sequence1] = new DefaultIPXACT2022ScalaCases_AccessHandles6Sequence1Format {}
  implicit lazy val IPXACT2022ScalaCases_BankDefinitionRef4Format: IPXACT2022scalaxb.XMLFormat[IPXACT2022ScalaCases.BankDefinitionRef4] = new DefaultIPXACT2022ScalaCases_BankDefinitionRef4Format {}
  implicit lazy val IPXACT2022ScalaCases_BankedDefinitionBankTypableFormat: IPXACT2022scalaxb.XMLFormat[IPXACT2022ScalaCases.BankedDefinitionBankTypable] = new DefaultIPXACT2022ScalaCases_BankedDefinitionBankTypableFormat {}
  implicit lazy val IPXACT2022ScalaCases_BankedDefinitionBankTypeFormat: IPXACT2022scalaxb.XMLFormat[IPXACT2022ScalaCases.BankedDefinitionBankType] = new DefaultIPXACT2022ScalaCases_BankedDefinitionBankTypeFormat {}
  implicit lazy val IPXACT2022ScalaCases_AccessHandles7Format: IPXACT2022scalaxb.XMLFormat[IPXACT2022ScalaCases.AccessHandles7] = new DefaultIPXACT2022ScalaCases_AccessHandles7Format {}
  implicit lazy val IPXACT2022ScalaCases_AccessHandles7Sequence1Format: IPXACT2022scalaxb.XMLFormat[IPXACT2022ScalaCases.AccessHandles7Sequence1] = new DefaultIPXACT2022ScalaCases_AccessHandles7Sequence1Format {}
  implicit lazy val IPXACT2022ScalaCases_LocalBankedBankTypeFormat: IPXACT2022scalaxb.XMLFormat[IPXACT2022ScalaCases.LocalBankedBankType] = new DefaultIPXACT2022ScalaCases_LocalBankedBankTypeFormat {}
  implicit lazy val IPXACT2022ScalaCases_AccessHandles8Format: IPXACT2022scalaxb.XMLFormat[IPXACT2022ScalaCases.AccessHandles8] = new DefaultIPXACT2022ScalaCases_AccessHandles8Format {}
  implicit lazy val IPXACT2022ScalaCases_AccessHandles8Sequence1Format: IPXACT2022scalaxb.XMLFormat[IPXACT2022ScalaCases.AccessHandles8Sequence1] = new DefaultIPXACT2022ScalaCases_AccessHandles8Sequence1Format {}
  implicit lazy val IPXACT2022ScalaCases_BankedBlockTypeFormat: IPXACT2022scalaxb.XMLFormat[IPXACT2022ScalaCases.BankedBlockType] = new DefaultIPXACT2022ScalaCases_BankedBlockTypeFormat {}
  implicit lazy val IPXACT2022ScalaCases_BankedSubspaceTypeFormat: IPXACT2022scalaxb.XMLFormat[IPXACT2022ScalaCases.BankedSubspaceType] = new DefaultIPXACT2022ScalaCases_BankedSubspaceTypeFormat {}
  implicit lazy val IPXACT2022ScalaCases_AccessHandles9Format: IPXACT2022scalaxb.XMLFormat[IPXACT2022ScalaCases.AccessHandles9] = new DefaultIPXACT2022ScalaCases_AccessHandles9Format {}
  implicit lazy val IPXACT2022ScalaCases_AccessHandles9Sequence1Format: IPXACT2022scalaxb.XMLFormat[IPXACT2022ScalaCases.AccessHandles9Sequence1] = new DefaultIPXACT2022ScalaCases_AccessHandles9Sequence1Format {}
  implicit lazy val IPXACT2022ScalaCases_ArrayType3Format: IPXACT2022scalaxb.XMLFormat[IPXACT2022ScalaCases.ArrayType3] = new DefaultIPXACT2022ScalaCases_ArrayType3Format {}
  implicit lazy val IPXACT2022ScalaCases_FieldDefinitionRefFormat: IPXACT2022scalaxb.XMLFormat[IPXACT2022ScalaCases.FieldDefinitionRef] = new DefaultIPXACT2022ScalaCases_FieldDefinitionRefFormat {}
  implicit lazy val IPXACT2022ScalaCases_FieldTypeFormat: IPXACT2022scalaxb.XMLFormat[IPXACT2022ScalaCases.FieldType] = new DefaultIPXACT2022ScalaCases_FieldTypeFormat {}
  implicit lazy val IPXACT2022ScalaCases_MemoryMapDefinitionRefFormat: IPXACT2022scalaxb.XMLFormat[IPXACT2022ScalaCases.MemoryMapDefinitionRef] = new DefaultIPXACT2022ScalaCases_MemoryMapDefinitionRefFormat {}
  implicit lazy val IPXACT2022ScalaCases_MemoryMapTypeFormat: IPXACT2022scalaxb.XMLFormat[IPXACT2022ScalaCases.MemoryMapType] = new DefaultIPXACT2022ScalaCases_MemoryMapTypeFormat {}
  implicit lazy val IPXACT2022ScalaCases_RemapDefinitionRefFormat: IPXACT2022scalaxb.XMLFormat[IPXACT2022ScalaCases.RemapDefinitionRef] = new DefaultIPXACT2022ScalaCases_RemapDefinitionRefFormat {}
  implicit lazy val IPXACT2022ScalaCases_MemoryRemapTypeFormat: IPXACT2022scalaxb.XMLFormat[IPXACT2022ScalaCases.MemoryRemapType] = new DefaultIPXACT2022ScalaCases_MemoryRemapTypeFormat {}
  implicit lazy val IPXACT2022ScalaCases_RemapDefinitionRef2Format: IPXACT2022scalaxb.XMLFormat[IPXACT2022ScalaCases.RemapDefinitionRef2] = new DefaultIPXACT2022ScalaCases_RemapDefinitionRef2Format {}
  implicit lazy val IPXACT2022ScalaCases_BankFormat: IPXACT2022scalaxb.XMLFormat[IPXACT2022ScalaCases.Bank] = new DefaultIPXACT2022ScalaCases_BankFormat {}
  implicit lazy val IPXACT2022ScalaCases_MemoryRemapDefinitionTypeFormat: IPXACT2022scalaxb.XMLFormat[IPXACT2022ScalaCases.MemoryRemapDefinitionType] = new DefaultIPXACT2022ScalaCases_MemoryRemapDefinitionTypeFormat {}
  implicit lazy val IPXACT2022ScalaCases_LocalMemoryMapTypeFormat: IPXACT2022scalaxb.XMLFormat[IPXACT2022ScalaCases.LocalMemoryMapType] = new DefaultIPXACT2022ScalaCases_LocalMemoryMapTypeFormat {}
  implicit lazy val IPXACT2022ScalaCases_SubspaceRefTypeFormat: IPXACT2022scalaxb.XMLFormat[IPXACT2022ScalaCases.SubspaceRefType] = new DefaultIPXACT2022ScalaCases_SubspaceRefTypeFormat {}
  implicit lazy val IPXACT2022ScalaCases_FieldAccessPolicyDefinitionRefFormat: IPXACT2022scalaxb.XMLFormat[IPXACT2022ScalaCases.FieldAccessPolicyDefinitionRef] = new DefaultIPXACT2022ScalaCases_FieldAccessPolicyDefinitionRefFormat {}
  implicit lazy val IPXACT2022ScalaCases_SegmentFormat: IPXACT2022scalaxb.XMLFormat[IPXACT2022ScalaCases.Segment] = new DefaultIPXACT2022ScalaCases_SegmentFormat {}
  implicit lazy val IPXACT2022ScalaCases_SegmentsFormat: IPXACT2022scalaxb.XMLFormat[IPXACT2022ScalaCases.Segments] = new DefaultIPXACT2022ScalaCases_SegmentsFormat {}
  implicit lazy val IPXACT2022ScalaCases_AddressSpaceFormat: IPXACT2022scalaxb.XMLFormat[IPXACT2022ScalaCases.AddressSpace] = new DefaultIPXACT2022ScalaCases_AddressSpaceFormat {}
  implicit lazy val IPXACT2022ScalaCases_AddressSpacesFormat: IPXACT2022scalaxb.XMLFormat[IPXACT2022ScalaCases.AddressSpaces] = new DefaultIPXACT2022ScalaCases_AddressSpacesFormat {}
  implicit lazy val IPXACT2022ScalaCases_MemoryMapsFormat: IPXACT2022scalaxb.XMLFormat[IPXACT2022ScalaCases.MemoryMaps] = new DefaultIPXACT2022ScalaCases_MemoryMapsFormat {}
  implicit lazy val IPXACT2022ScalaCases_Bank2Format: IPXACT2022scalaxb.XMLFormat[IPXACT2022ScalaCases.Bank2] = new DefaultIPXACT2022ScalaCases_Bank2Format {}
  implicit lazy val IPXACT2022ScalaCases_Bank3Format: IPXACT2022scalaxb.XMLFormat[IPXACT2022ScalaCases.Bank3] = new DefaultIPXACT2022ScalaCases_Bank3Format {}
  implicit lazy val IPXACT2022ScalaCases_DimFormat: IPXACT2022scalaxb.XMLFormat[IPXACT2022ScalaCases.Dim] = new DefaultIPXACT2022ScalaCases_DimFormat {}
  implicit lazy val IPXACT2022ScalaCases_StrideFormat: IPXACT2022scalaxb.XMLFormat[IPXACT2022ScalaCases.Stride] = new DefaultIPXACT2022ScalaCases_StrideFormat {}
  implicit lazy val IPXACT2022ScalaCases_BitStrideFormat: IPXACT2022scalaxb.XMLFormat[IPXACT2022ScalaCases.BitStride] = new DefaultIPXACT2022ScalaCases_BitStrideFormat {}
  implicit lazy val IPXACT2022ScalaCases_AccessHandles10Format: IPXACT2022scalaxb.XMLFormat[IPXACT2022ScalaCases.AccessHandles10] = new DefaultIPXACT2022ScalaCases_AccessHandles10Format {}
  implicit lazy val IPXACT2022ScalaCases_AccessHandles10Sequence1Format: IPXACT2022scalaxb.XMLFormat[IPXACT2022ScalaCases.AccessHandles10Sequence1] = new DefaultIPXACT2022ScalaCases_AccessHandles10Sequence1Format {}
  implicit lazy val IPXACT2022ScalaCases_RegisterDefinitionRefFormat: IPXACT2022scalaxb.XMLFormat[IPXACT2022ScalaCases.RegisterDefinitionRef] = new DefaultIPXACT2022ScalaCases_RegisterDefinitionRefFormat {}
  implicit lazy val IPXACT2022ScalaCases_RegisterFormat: IPXACT2022scalaxb.XMLFormat[IPXACT2022ScalaCases.Register] = new DefaultIPXACT2022ScalaCases_RegisterFormat {}
  implicit lazy val IPXACT2022ScalaCases_AccessHandles11Format: IPXACT2022scalaxb.XMLFormat[IPXACT2022ScalaCases.AccessHandles11] = new DefaultIPXACT2022ScalaCases_AccessHandles11Format {}
  implicit lazy val IPXACT2022ScalaCases_AccessHandles11Sequence1Format: IPXACT2022scalaxb.XMLFormat[IPXACT2022ScalaCases.AccessHandles11Sequence1] = new DefaultIPXACT2022ScalaCases_AccessHandles11Sequence1Format {}
  implicit lazy val IPXACT2022ScalaCases_AlternateRegisterFormat: IPXACT2022scalaxb.XMLFormat[IPXACT2022ScalaCases.AlternateRegister] = new DefaultIPXACT2022ScalaCases_AlternateRegisterFormat {}
  implicit lazy val IPXACT2022ScalaCases_AlternateRegistersFormat: IPXACT2022scalaxb.XMLFormat[IPXACT2022ScalaCases.AlternateRegisters] = new DefaultIPXACT2022ScalaCases_AlternateRegistersFormat {}
  implicit lazy val IPXACT2022ScalaCases_EnumerationDefinitionRefFormat: IPXACT2022scalaxb.XMLFormat[IPXACT2022ScalaCases.EnumerationDefinitionRef] = new DefaultIPXACT2022ScalaCases_EnumerationDefinitionRefFormat {}
  implicit lazy val IPXACT2022ScalaCases_EnumeratedValuesFormat: IPXACT2022scalaxb.XMLFormat[IPXACT2022ScalaCases.EnumeratedValues] = new DefaultIPXACT2022ScalaCases_EnumeratedValuesFormat {}
  implicit lazy val IPXACT2022ScalaCases_UsageFormat: IPXACT2022scalaxb.XMLFormat[IPXACT2022ScalaCases.Usage] = new DefaultIPXACT2022ScalaCases_UsageFormat {}
  implicit lazy val IPXACT2022ScalaCases_EnumeratedValueTypeFormat: IPXACT2022scalaxb.XMLFormat[IPXACT2022ScalaCases.EnumeratedValueType] = new DefaultIPXACT2022ScalaCases_EnumeratedValueTypeFormat {}
  implicit lazy val IPXACT2022ScalaCases_ModifiedWriteValueTypeFormat: IPXACT2022scalaxb.XMLFormat[IPXACT2022ScalaCases.ModifiedWriteValueType] = new DefaultIPXACT2022ScalaCases_ModifiedWriteValueTypeFormat {}
  implicit lazy val IPXACT2022ScalaCases_ReadActionTypeFormat: IPXACT2022scalaxb.XMLFormat[IPXACT2022ScalaCases.ReadActionType] = new DefaultIPXACT2022ScalaCases_ReadActionTypeFormat {}
  implicit lazy val IPXACT2022ScalaCases_AccessRestrictionTypeFormat: IPXACT2022scalaxb.XMLFormat[IPXACT2022ScalaCases.AccessRestrictionType] = new DefaultIPXACT2022ScalaCases_AccessRestrictionTypeFormat {}
  implicit lazy val IPXACT2022ScalaCases_AccessRestrictionsTypeFormat: IPXACT2022scalaxb.XMLFormat[IPXACT2022ScalaCases.AccessRestrictionsType] = new DefaultIPXACT2022ScalaCases_AccessRestrictionsTypeFormat {}
  implicit lazy val IPXACT2022ScalaCases_FieldAccessPropertiesTypableFormat: IPXACT2022scalaxb.XMLFormat[IPXACT2022ScalaCases.FieldAccessPropertiesTypable] = new DefaultIPXACT2022ScalaCases_FieldAccessPropertiesTypableFormat {}
  implicit lazy val IPXACT2022ScalaCases_FieldAccessPropertiesTypeFormat: IPXACT2022scalaxb.XMLFormat[IPXACT2022ScalaCases.FieldAccessPropertiesType] = new DefaultIPXACT2022ScalaCases_FieldAccessPropertiesTypeFormat {}
  implicit lazy val IPXACT2022ScalaCases_AccessPropertiesTypeFormat: IPXACT2022scalaxb.XMLFormat[IPXACT2022ScalaCases.AccessPropertiesType] = new DefaultIPXACT2022ScalaCases_AccessPropertiesTypeFormat {}
  implicit lazy val IPXACT2022ScalaCases_BroadcastToFormat: IPXACT2022scalaxb.XMLFormat[IPXACT2022ScalaCases.BroadcastTo] = new DefaultIPXACT2022ScalaCases_BroadcastToFormat {}
  implicit lazy val IPXACT2022ScalaCases_BroadcastsFormat: IPXACT2022scalaxb.XMLFormat[IPXACT2022ScalaCases.Broadcasts] = new DefaultIPXACT2022ScalaCases_BroadcastsFormat {}
  implicit lazy val IPXACT2022ScalaCases_TestConstraintFormat: IPXACT2022scalaxb.XMLFormat[IPXACT2022ScalaCases.TestConstraint] = new DefaultIPXACT2022ScalaCases_TestConstraintFormat {}
  implicit lazy val IPXACT2022ScalaCases_TestableFormat: IPXACT2022scalaxb.XMLFormat[IPXACT2022ScalaCases.Testable] = new DefaultIPXACT2022ScalaCases_TestableFormat {}
  implicit lazy val IPXACT2022ScalaCases_FieldAccessPolicyFormat: IPXACT2022scalaxb.XMLFormat[IPXACT2022ScalaCases.FieldAccessPolicy] = new DefaultIPXACT2022ScalaCases_FieldAccessPolicyFormat {}
  implicit lazy val IPXACT2022ScalaCases_FieldAccessPolicySequence1Format: IPXACT2022scalaxb.XMLFormat[IPXACT2022ScalaCases.FieldAccessPolicySequence1] = new DefaultIPXACT2022ScalaCases_FieldAccessPolicySequence1Format {}
  implicit lazy val IPXACT2022ScalaCases_FieldAccessPoliciesFormat: IPXACT2022scalaxb.XMLFormat[IPXACT2022ScalaCases.FieldAccessPolicies] = new DefaultIPXACT2022ScalaCases_FieldAccessPoliciesFormat {}
  implicit lazy val IPXACT2022ScalaCases_WriteValueConstraintTypeFormat: IPXACT2022scalaxb.XMLFormat[IPXACT2022ScalaCases.WriteValueConstraintType] = new DefaultIPXACT2022ScalaCases_WriteValueConstraintTypeFormat {}
  implicit lazy val IPXACT2022ScalaCases_WriteValueConstraintTypeSequence1Format: IPXACT2022scalaxb.XMLFormat[IPXACT2022ScalaCases.WriteValueConstraintTypeSequence1] = new DefaultIPXACT2022ScalaCases_WriteValueConstraintTypeSequence1Format {}
  implicit lazy val IPXACT2022ScalaCases_AccessHandles12Format: IPXACT2022scalaxb.XMLFormat[IPXACT2022ScalaCases.AccessHandles12] = new DefaultIPXACT2022ScalaCases_AccessHandles12Format {}
  implicit lazy val IPXACT2022ScalaCases_AccessHandles12Sequence1Format: IPXACT2022scalaxb.XMLFormat[IPXACT2022ScalaCases.AccessHandles12Sequence1] = new DefaultIPXACT2022ScalaCases_AccessHandles12Sequence1Format {}
  implicit lazy val IPXACT2022ScalaCases_RegisterFileDefinitionRefFormat: IPXACT2022scalaxb.XMLFormat[IPXACT2022ScalaCases.RegisterFileDefinitionRef] = new DefaultIPXACT2022ScalaCases_RegisterFileDefinitionRefFormat {}
  implicit lazy val IPXACT2022ScalaCases_RegisterFileFormat: IPXACT2022scalaxb.XMLFormat[IPXACT2022ScalaCases.RegisterFile] = new DefaultIPXACT2022ScalaCases_RegisterFileFormat {}
  implicit lazy val IPXACT2022ScalaCases_ResetsFormat: IPXACT2022scalaxb.XMLFormat[IPXACT2022ScalaCases.Resets] = new DefaultIPXACT2022ScalaCases_ResetsFormat {}
  implicit lazy val IPXACT2022ScalaCases_AliasOfFormat: IPXACT2022scalaxb.XMLFormat[IPXACT2022ScalaCases.AliasOf] = new DefaultIPXACT2022ScalaCases_AliasOfFormat {}
  implicit lazy val IPXACT2022ScalaCases_ResetFormat: IPXACT2022scalaxb.XMLFormat[IPXACT2022ScalaCases.Reset] = new DefaultIPXACT2022ScalaCases_ResetFormat {}
  implicit lazy val IPXACT2022ScalaCases_ExternalTypeDefinitionsFormat: IPXACT2022scalaxb.XMLFormat[IPXACT2022ScalaCases.ExternalTypeDefinitions] = new DefaultIPXACT2022ScalaCases_ExternalTypeDefinitionsFormat {}
  implicit lazy val IPXACT2022ScalaCases_EnumerationDefinitionFormat: IPXACT2022scalaxb.XMLFormat[IPXACT2022ScalaCases.EnumerationDefinition] = new DefaultIPXACT2022ScalaCases_EnumerationDefinitionFormat {}
  implicit lazy val IPXACT2022ScalaCases_EnumerationDefinitionsFormat: IPXACT2022scalaxb.XMLFormat[IPXACT2022ScalaCases.EnumerationDefinitions] = new DefaultIPXACT2022ScalaCases_EnumerationDefinitionsFormat {}
  implicit lazy val IPXACT2022ScalaCases_FieldAccessPolicyDefinitionFormat: IPXACT2022scalaxb.XMLFormat[IPXACT2022ScalaCases.FieldAccessPolicyDefinition] = new DefaultIPXACT2022ScalaCases_FieldAccessPolicyDefinitionFormat {}
  implicit lazy val IPXACT2022ScalaCases_FieldAccessPolicyDefinitionsFormat: IPXACT2022scalaxb.XMLFormat[IPXACT2022ScalaCases.FieldAccessPolicyDefinitions] = new DefaultIPXACT2022ScalaCases_FieldAccessPolicyDefinitionsFormat {}
  implicit lazy val IPXACT2022ScalaCases_Resets2Format: IPXACT2022scalaxb.XMLFormat[IPXACT2022ScalaCases.Resets2] = new DefaultIPXACT2022ScalaCases_Resets2Format {}
  implicit lazy val IPXACT2022ScalaCases_FieldDefinitionFormat: IPXACT2022scalaxb.XMLFormat[IPXACT2022ScalaCases.FieldDefinition] = new DefaultIPXACT2022ScalaCases_FieldDefinitionFormat {}
  implicit lazy val IPXACT2022ScalaCases_FieldDefinitionsFormat: IPXACT2022scalaxb.XMLFormat[IPXACT2022ScalaCases.FieldDefinitions] = new DefaultIPXACT2022ScalaCases_FieldDefinitionsFormat {}
  implicit lazy val IPXACT2022ScalaCases_RegisterDefinitionFormat: IPXACT2022scalaxb.XMLFormat[IPXACT2022ScalaCases.RegisterDefinition] = new DefaultIPXACT2022ScalaCases_RegisterDefinitionFormat {}
  implicit lazy val IPXACT2022ScalaCases_RegisterDefinitionsFormat: IPXACT2022scalaxb.XMLFormat[IPXACT2022ScalaCases.RegisterDefinitions] = new DefaultIPXACT2022ScalaCases_RegisterDefinitionsFormat {}
  implicit lazy val IPXACT2022ScalaCases_RegisterFileDefinitionFormat: IPXACT2022scalaxb.XMLFormat[IPXACT2022ScalaCases.RegisterFileDefinition] = new DefaultIPXACT2022ScalaCases_RegisterFileDefinitionFormat {}
  implicit lazy val IPXACT2022ScalaCases_RegisterFileDefinitionsFormat: IPXACT2022scalaxb.XMLFormat[IPXACT2022ScalaCases.RegisterFileDefinitions] = new DefaultIPXACT2022ScalaCases_RegisterFileDefinitionsFormat {}
  implicit lazy val IPXACT2022ScalaCases_AddressBlockDefinitionFormat: IPXACT2022scalaxb.XMLFormat[IPXACT2022ScalaCases.AddressBlockDefinition] = new DefaultIPXACT2022ScalaCases_AddressBlockDefinitionFormat {}
  implicit lazy val IPXACT2022ScalaCases_AddressBlockDefinitionsFormat: IPXACT2022scalaxb.XMLFormat[IPXACT2022ScalaCases.AddressBlockDefinitions] = new DefaultIPXACT2022ScalaCases_AddressBlockDefinitionsFormat {}
  implicit lazy val IPXACT2022ScalaCases_BankDefinitionFormat: IPXACT2022scalaxb.XMLFormat[IPXACT2022ScalaCases.BankDefinition] = new DefaultIPXACT2022ScalaCases_BankDefinitionFormat {}
  implicit lazy val IPXACT2022ScalaCases_BankDefinitionsFormat: IPXACT2022scalaxb.XMLFormat[IPXACT2022ScalaCases.BankDefinitions] = new DefaultIPXACT2022ScalaCases_BankDefinitionsFormat {}
  implicit lazy val IPXACT2022ScalaCases_MemoryMapDefinitionFormat: IPXACT2022scalaxb.XMLFormat[IPXACT2022ScalaCases.MemoryMapDefinition] = new DefaultIPXACT2022ScalaCases_MemoryMapDefinitionFormat {}
  implicit lazy val IPXACT2022ScalaCases_MemoryMapDefinitionsFormat: IPXACT2022scalaxb.XMLFormat[IPXACT2022ScalaCases.MemoryMapDefinitions] = new DefaultIPXACT2022ScalaCases_MemoryMapDefinitionsFormat {}
  implicit lazy val IPXACT2022ScalaCases_MemoryRemapDefinitionFormat: IPXACT2022scalaxb.XMLFormat[IPXACT2022ScalaCases.MemoryRemapDefinition] = new DefaultIPXACT2022ScalaCases_MemoryRemapDefinitionFormat {}
  implicit lazy val IPXACT2022ScalaCases_MemoryRemapDefinitionsFormat: IPXACT2022scalaxb.XMLFormat[IPXACT2022ScalaCases.MemoryRemapDefinitions] = new DefaultIPXACT2022ScalaCases_MemoryRemapDefinitionsFormat {}
  implicit lazy val IPXACT2022ScalaCases_ModeRef3Format: IPXACT2022scalaxb.XMLFormat[IPXACT2022ScalaCases.ModeRef3] = new DefaultIPXACT2022ScalaCases_ModeRef3Format {}
  implicit lazy val IPXACT2022ScalaCases_ArrayType4Format: IPXACT2022scalaxb.XMLFormat[IPXACT2022ScalaCases.ArrayType4] = new DefaultIPXACT2022ScalaCases_ArrayType4Format {}
  implicit lazy val IPXACT2022ScalaCases_ModifiedWriteValueFormat: IPXACT2022scalaxb.XMLFormat[IPXACT2022ScalaCases.ModifiedWriteValue] = new DefaultIPXACT2022ScalaCases_ModifiedWriteValueFormat {}
  implicit lazy val IPXACT2022ScalaCases_ReadActionFormat: IPXACT2022scalaxb.XMLFormat[IPXACT2022ScalaCases.ReadAction] = new DefaultIPXACT2022ScalaCases_ReadActionFormat {}
  implicit lazy val IPXACT2022ScalaCases_AccessPolicyFormat: IPXACT2022scalaxb.XMLFormat[IPXACT2022ScalaCases.AccessPolicy] = new DefaultIPXACT2022ScalaCases_AccessPolicyFormat {}
  implicit lazy val IPXACT2022ScalaCases_AccessPoliciesFormat: IPXACT2022scalaxb.XMLFormat[IPXACT2022ScalaCases.AccessPolicies] = new DefaultIPXACT2022ScalaCases_AccessPoliciesFormat {}
  implicit lazy val IPXACT2022ScalaCases_AlternateRegisterDefinitionGroupSequenceFormat: IPXACT2022scalaxb.XMLFormat[IPXACT2022ScalaCases.AlternateRegisterDefinitionGroupSequence] = new DefaultIPXACT2022ScalaCases_AlternateRegisterDefinitionGroupSequenceFormat {}
  implicit lazy val IPXACT2022ScalaCases_AlternateRegisterDefinitionGroupSequence2Format: IPXACT2022scalaxb.XMLFormat[IPXACT2022ScalaCases.AlternateRegisterDefinitionGroupSequence2] = new DefaultIPXACT2022ScalaCases_AlternateRegisterDefinitionGroupSequence2Format {}
  implicit lazy val IPXACT2022ScalaCases_AddressBlockDefinitionGroupSequenceFormat: IPXACT2022scalaxb.XMLFormat[IPXACT2022ScalaCases.AddressBlockDefinitionGroupSequence] = new DefaultIPXACT2022ScalaCases_AddressBlockDefinitionGroupSequenceFormat {}
  implicit lazy val IPXACT2022ScalaCases_FieldDefinitionGroupSequence2Format: IPXACT2022scalaxb.XMLFormat[IPXACT2022ScalaCases.FieldDefinitionGroupSequence2] = new DefaultIPXACT2022ScalaCases_FieldDefinitionGroupSequence2Format {}
  implicit lazy val IPXACT2022ScalaCases_FieldDefinitionGroupSequenceFormat: IPXACT2022scalaxb.XMLFormat[IPXACT2022ScalaCases.FieldDefinitionGroupSequence] = new DefaultIPXACT2022ScalaCases_FieldDefinitionGroupSequenceFormat {}
  implicit lazy val IPXACT2022ScalaCases_BlockSizeSequenceFormat: IPXACT2022scalaxb.XMLFormat[IPXACT2022ScalaCases.BlockSizeSequence] = new DefaultIPXACT2022ScalaCases_BlockSizeSequenceFormat {}
  implicit lazy val IPXACT2022ScalaCases_BankDefinitionBaseSequenceFormat: IPXACT2022scalaxb.XMLFormat[IPXACT2022ScalaCases.BankDefinitionBaseSequence] = new DefaultIPXACT2022ScalaCases_BankDefinitionBaseSequenceFormat {}
  implicit lazy val IPXACT2022ScalaCases_AddressSpecifierSequenceFormat: IPXACT2022scalaxb.XMLFormat[IPXACT2022ScalaCases.AddressSpecifierSequence] = new DefaultIPXACT2022ScalaCases_AddressSpecifierSequenceFormat {}
  implicit lazy val IPXACT2022ScalaCases_MemoryMapGroupSequenceFormat: IPXACT2022scalaxb.XMLFormat[IPXACT2022ScalaCases.MemoryMapGroupSequence] = new DefaultIPXACT2022ScalaCases_MemoryMapGroupSequenceFormat {}
  implicit lazy val IPXACT2022ScalaCases_MemoryMapDefinitionGroupSequenceFormat: IPXACT2022scalaxb.XMLFormat[IPXACT2022ScalaCases.MemoryMapDefinitionGroupSequence] = new DefaultIPXACT2022ScalaCases_MemoryMapDefinitionGroupSequenceFormat {}
  implicit lazy val IPXACT2022ScalaCases_MemoryMapDefinitionTypeGroupSequenceFormat: IPXACT2022scalaxb.XMLFormat[IPXACT2022ScalaCases.MemoryMapDefinitionTypeGroupSequence] = new DefaultIPXACT2022ScalaCases_MemoryMapDefinitionTypeGroupSequenceFormat {}
  implicit lazy val IPXACT2022ScalaCases_AddressBlockExtensionsSequenceFormat: IPXACT2022scalaxb.XMLFormat[IPXACT2022ScalaCases.AddressBlockExtensionsSequence] = new DefaultIPXACT2022ScalaCases_AddressBlockExtensionsSequenceFormat {}
  implicit lazy val IPXACT2022ScalaCases_BankBaseSequenceFormat: IPXACT2022scalaxb.XMLFormat[IPXACT2022ScalaCases.BankBaseSequence] = new DefaultIPXACT2022ScalaCases_BankBaseSequenceFormat {}
  implicit lazy val IPXACT2022ScalaCases_LocalBankBaseSequenceFormat: IPXACT2022scalaxb.XMLFormat[IPXACT2022ScalaCases.LocalBankBaseSequence] = new DefaultIPXACT2022ScalaCases_LocalBankBaseSequenceFormat {}
  implicit lazy val IPXACT2022ScalaCases_MemoryBlockDataSequenceFormat: IPXACT2022scalaxb.XMLFormat[IPXACT2022ScalaCases.MemoryBlockDataSequence] = new DefaultIPXACT2022ScalaCases_MemoryBlockDataSequenceFormat {}
  implicit lazy val IPXACT2022ScalaCases_FieldDataSequenceFormat: IPXACT2022scalaxb.XMLFormat[IPXACT2022ScalaCases.FieldDataSequence] = new DefaultIPXACT2022ScalaCases_FieldDataSequenceFormat {}
  implicit lazy val IPXACT2022ScalaCases_RegisterFileDefinitionGroupSequenceFormat: IPXACT2022scalaxb.XMLFormat[IPXACT2022ScalaCases.RegisterFileDefinitionGroupSequence] = new DefaultIPXACT2022ScalaCases_RegisterFileDefinitionGroupSequenceFormat {}
  implicit lazy val IPXACT2022ScalaCases_RegisterDefinitionGroupSequence2Format: IPXACT2022scalaxb.XMLFormat[IPXACT2022ScalaCases.RegisterDefinitionGroupSequence2] = new DefaultIPXACT2022ScalaCases_RegisterDefinitionGroupSequence2Format {}
  implicit lazy val IPXACT2022ScalaCases_RegisterDefinitionGroupSequenceFormat: IPXACT2022scalaxb.XMLFormat[IPXACT2022ScalaCases.RegisterDefinitionGroupSequence] = new DefaultIPXACT2022ScalaCases_RegisterDefinitionGroupSequenceFormat {}
  implicit lazy val IPXACT2022ScalaCases_DesignInstantiationTypeFormat: IPXACT2022scalaxb.XMLFormat[IPXACT2022ScalaCases.DesignInstantiationType] = new DefaultIPXACT2022ScalaCases_DesignInstantiationTypeFormat {}
  implicit lazy val IPXACT2022ScalaCases_DesignConfigurationInstantiationTypeFormat: IPXACT2022scalaxb.XMLFormat[IPXACT2022ScalaCases.DesignConfigurationInstantiationType] = new DefaultIPXACT2022ScalaCases_DesignConfigurationInstantiationTypeFormat {}
  implicit lazy val IPXACT2022ScalaCases_ModuleParametersFormat: IPXACT2022scalaxb.XMLFormat[IPXACT2022ScalaCases.ModuleParameters] = new DefaultIPXACT2022ScalaCases_ModuleParametersFormat {}
  implicit lazy val IPXACT2022ScalaCases_ClearboxElementRefsFormat: IPXACT2022scalaxb.XMLFormat[IPXACT2022ScalaCases.ClearboxElementRefs] = new DefaultIPXACT2022ScalaCases_ClearboxElementRefsFormat {}
  implicit lazy val IPXACT2022ScalaCases_ComponentInstantiationTypeFormat: IPXACT2022scalaxb.XMLFormat[IPXACT2022ScalaCases.ComponentInstantiationType] = new DefaultIPXACT2022ScalaCases_ComponentInstantiationTypeFormat {}
  implicit lazy val IPXACT2022ScalaCases_EnvIdentifierFormat: IPXACT2022scalaxb.XMLFormat[IPXACT2022ScalaCases.EnvIdentifier] = new DefaultIPXACT2022ScalaCases_EnvIdentifierFormat {}
  implicit lazy val IPXACT2022ScalaCases_ViewFormat: IPXACT2022scalaxb.XMLFormat[IPXACT2022ScalaCases.View] = new DefaultIPXACT2022ScalaCases_ViewFormat {}
  implicit lazy val IPXACT2022ScalaCases_ViewsFormat: IPXACT2022scalaxb.XMLFormat[IPXACT2022ScalaCases.Views] = new DefaultIPXACT2022ScalaCases_ViewsFormat {}
  implicit lazy val IPXACT2022ScalaCases_InstantiationsFormat: IPXACT2022scalaxb.XMLFormat[IPXACT2022ScalaCases.Instantiations] = new DefaultIPXACT2022ScalaCases_InstantiationsFormat {}
  implicit lazy val IPXACT2022ScalaCases_PortsFormat: IPXACT2022scalaxb.XMLFormat[IPXACT2022ScalaCases.Ports] = new DefaultIPXACT2022ScalaCases_PortsFormat {}
  implicit lazy val IPXACT2022ScalaCases_ModelTypeFormat: IPXACT2022scalaxb.XMLFormat[IPXACT2022ScalaCases.ModelType] = new DefaultIPXACT2022ScalaCases_ModelTypeFormat {}
  implicit lazy val IPXACT2022ScalaCases_EnvIdentifier2Format: IPXACT2022scalaxb.XMLFormat[IPXACT2022ScalaCases.EnvIdentifier2] = new DefaultIPXACT2022ScalaCases_EnvIdentifier2Format {}
  implicit lazy val IPXACT2022ScalaCases_View2Format: IPXACT2022scalaxb.XMLFormat[IPXACT2022ScalaCases.View2] = new DefaultIPXACT2022ScalaCases_View2Format {}
  implicit lazy val IPXACT2022ScalaCases_Views2Format: IPXACT2022scalaxb.XMLFormat[IPXACT2022ScalaCases.Views2] = new DefaultIPXACT2022ScalaCases_Views2Format {}
  implicit lazy val IPXACT2022ScalaCases_Instantiations2Format: IPXACT2022scalaxb.XMLFormat[IPXACT2022ScalaCases.Instantiations2] = new DefaultIPXACT2022ScalaCases_Instantiations2Format {}
  implicit lazy val IPXACT2022ScalaCases_Ports2Format: IPXACT2022scalaxb.XMLFormat[IPXACT2022ScalaCases.Ports2] = new DefaultIPXACT2022ScalaCases_Ports2Format {}
  implicit lazy val IPXACT2022ScalaCases_AbstractorModelTypeFormat: IPXACT2022scalaxb.XMLFormat[IPXACT2022ScalaCases.AbstractorModelType] = new DefaultIPXACT2022ScalaCases_AbstractorModelTypeFormat {}
  implicit lazy val IPXACT2022ScalaCases_ClearboxElementRefTypeFormat: IPXACT2022scalaxb.XMLFormat[IPXACT2022ScalaCases.ClearboxElementRefType] = new DefaultIPXACT2022ScalaCases_ClearboxElementRefTypeFormat {}
  implicit lazy val IPXACT2022ScalaCases_LanguageTypeFormat: IPXACT2022scalaxb.XMLFormat[IPXACT2022ScalaCases.LanguageType] = new DefaultIPXACT2022ScalaCases_LanguageTypeFormat {}
  implicit lazy val IPXACT2022ScalaCases_ComponentPortDirectionTypeFormat: IPXACT2022scalaxb.XMLFormat[IPXACT2022ScalaCases.ComponentPortDirectionType] = new DefaultIPXACT2022ScalaCases_ComponentPortDirectionTypeFormat {}
  implicit lazy val IPXACT2022ScalaCases_PortTypableFormat: IPXACT2022scalaxb.XMLFormat[IPXACT2022ScalaCases.PortTypable] = new DefaultIPXACT2022ScalaCases_PortTypableFormat {}
  implicit lazy val IPXACT2022ScalaCases_PortTypeFormat: IPXACT2022scalaxb.XMLFormat[IPXACT2022ScalaCases.PortType] = new DefaultIPXACT2022ScalaCases_PortTypeFormat {}
  implicit lazy val IPXACT2022ScalaCases_AbstractorPortTypeFormat: IPXACT2022scalaxb.XMLFormat[IPXACT2022ScalaCases.AbstractorPortType] = new DefaultIPXACT2022ScalaCases_AbstractorPortTypeFormat {}
  implicit lazy val IPXACT2022ScalaCases_InitiativeTypeFormat: IPXACT2022scalaxb.XMLFormat[IPXACT2022ScalaCases.InitiativeType] = new DefaultIPXACT2022ScalaCases_InitiativeTypeFormat {}
  implicit lazy val IPXACT2022ScalaCases_ProtocolTypeFormat: IPXACT2022scalaxb.XMLFormat[IPXACT2022ScalaCases.ProtocolType] = new DefaultIPXACT2022ScalaCases_ProtocolTypeFormat {}
  implicit lazy val IPXACT2022ScalaCases_ProtocolFormat: IPXACT2022scalaxb.XMLFormat[IPXACT2022ScalaCases.Protocol] = new DefaultIPXACT2022ScalaCases_ProtocolFormat {}
  implicit lazy val IPXACT2022ScalaCases_ProtocolTypeTypeFormat: IPXACT2022scalaxb.XMLFormat[IPXACT2022ScalaCases.ProtocolTypeType] = new DefaultIPXACT2022ScalaCases_ProtocolTypeTypeFormat {}
  implicit lazy val IPXACT2022ScalaCases_KindTypeFormat: IPXACT2022scalaxb.XMLFormat[IPXACT2022ScalaCases.KindType] = new DefaultIPXACT2022ScalaCases_KindTypeFormat {}
  implicit lazy val IPXACT2022ScalaCases_KindFormat: IPXACT2022scalaxb.XMLFormat[IPXACT2022ScalaCases.Kind] = new DefaultIPXACT2022ScalaCases_KindFormat {}
  implicit lazy val IPXACT2022ScalaCases_SimplePortAccessTypeFormat: IPXACT2022scalaxb.XMLFormat[IPXACT2022ScalaCases.SimplePortAccessType] = new DefaultIPXACT2022ScalaCases_SimplePortAccessTypeFormat {}
  implicit lazy val IPXACT2022ScalaCases_TypeFormat: IPXACT2022scalaxb.XMLFormat[IPXACT2022ScalaCases.Type] = new DefaultIPXACT2022ScalaCases_TypeFormat {}
  implicit lazy val IPXACT2022ScalaCases_ExtensionFormat: IPXACT2022scalaxb.XMLFormat[IPXACT2022ScalaCases.Extension] = new DefaultIPXACT2022ScalaCases_ExtensionFormat {}
  implicit lazy val IPXACT2022ScalaCases_PayloadFormat: IPXACT2022scalaxb.XMLFormat[IPXACT2022ScalaCases.Payload] = new DefaultIPXACT2022ScalaCases_PayloadFormat {}
  implicit lazy val IPXACT2022ScalaCases_TypeParametersFormat: IPXACT2022scalaxb.XMLFormat[IPXACT2022ScalaCases.TypeParameters] = new DefaultIPXACT2022ScalaCases_TypeParametersFormat {}
  implicit lazy val IPXACT2022ScalaCases_TypeNameFormat: IPXACT2022scalaxb.XMLFormat[IPXACT2022ScalaCases.TypeName] = new DefaultIPXACT2022ScalaCases_TypeNameFormat {}
  implicit lazy val IPXACT2022ScalaCases_TypeDefinitionFormat: IPXACT2022scalaxb.XMLFormat[IPXACT2022ScalaCases.TypeDefinition] = new DefaultIPXACT2022ScalaCases_TypeDefinitionFormat {}
  implicit lazy val IPXACT2022ScalaCases_ViewRef6Format: IPXACT2022scalaxb.XMLFormat[IPXACT2022ScalaCases.ViewRef6] = new DefaultIPXACT2022ScalaCases_ViewRef6Format {}
  implicit lazy val IPXACT2022ScalaCases_TransTypeDefFormat: IPXACT2022scalaxb.XMLFormat[IPXACT2022ScalaCases.TransTypeDef] = new DefaultIPXACT2022ScalaCases_TransTypeDefFormat {}
  implicit lazy val IPXACT2022ScalaCases_TypeName2Format: IPXACT2022scalaxb.XMLFormat[IPXACT2022ScalaCases.TypeName2] = new DefaultIPXACT2022ScalaCases_TypeName2Format {}
  implicit lazy val IPXACT2022ScalaCases_TypeDefinition2Format: IPXACT2022scalaxb.XMLFormat[IPXACT2022ScalaCases.TypeDefinition2] = new DefaultIPXACT2022ScalaCases_TypeDefinition2Format {}
  implicit lazy val IPXACT2022ScalaCases_ServiceTypeDefFormat: IPXACT2022scalaxb.XMLFormat[IPXACT2022ScalaCases.ServiceTypeDef] = new DefaultIPXACT2022ScalaCases_ServiceTypeDefFormat {}
  implicit lazy val IPXACT2022ScalaCases_TypeName3Format: IPXACT2022scalaxb.XMLFormat[IPXACT2022ScalaCases.TypeName3] = new DefaultIPXACT2022ScalaCases_TypeName3Format {}
  implicit lazy val IPXACT2022ScalaCases_TypeDefinition3Format: IPXACT2022scalaxb.XMLFormat[IPXACT2022ScalaCases.TypeDefinition3] = new DefaultIPXACT2022ScalaCases_TypeDefinition3Format {}
  implicit lazy val IPXACT2022ScalaCases_ViewRef7Format: IPXACT2022scalaxb.XMLFormat[IPXACT2022ScalaCases.ViewRef7] = new DefaultIPXACT2022ScalaCases_ViewRef7Format {}
  implicit lazy val IPXACT2022ScalaCases_WireTypeDefFormat: IPXACT2022scalaxb.XMLFormat[IPXACT2022ScalaCases.WireTypeDef] = new DefaultIPXACT2022ScalaCases_WireTypeDefFormat {}
  implicit lazy val IPXACT2022ScalaCases_WireTypeDefsFormat: IPXACT2022scalaxb.XMLFormat[IPXACT2022ScalaCases.WireTypeDefs] = new DefaultIPXACT2022ScalaCases_WireTypeDefsFormat {}
  implicit lazy val IPXACT2022ScalaCases_TransTypeDefsFormat: IPXACT2022scalaxb.XMLFormat[IPXACT2022ScalaCases.TransTypeDefs] = new DefaultIPXACT2022ScalaCases_TransTypeDefsFormat {}
  implicit lazy val IPXACT2022ScalaCases_Port2Format: IPXACT2022scalaxb.XMLFormat[IPXACT2022ScalaCases.Port2] = new DefaultIPXACT2022ScalaCases_Port2Format {}
  implicit lazy val IPXACT2022ScalaCases_FieldSlice2Format: IPXACT2022scalaxb.XMLFormat[IPXACT2022ScalaCases.FieldSlice2] = new DefaultIPXACT2022ScalaCases_FieldSlice2Format {}
  implicit lazy val IPXACT2022ScalaCases_ModeRef4Format: IPXACT2022scalaxb.XMLFormat[IPXACT2022ScalaCases.ModeRef4] = new DefaultIPXACT2022ScalaCases_ModeRef4Format {}
  implicit lazy val IPXACT2022ScalaCases_FieldMapFormat: IPXACT2022scalaxb.XMLFormat[IPXACT2022ScalaCases.FieldMap] = new DefaultIPXACT2022ScalaCases_FieldMapFormat {}
  implicit lazy val IPXACT2022ScalaCases_FieldMapsFormat: IPXACT2022scalaxb.XMLFormat[IPXACT2022ScalaCases.FieldMaps] = new DefaultIPXACT2022ScalaCases_FieldMapsFormat {}
  implicit lazy val IPXACT2022ScalaCases_PowerConstraintsFormat: IPXACT2022scalaxb.XMLFormat[IPXACT2022ScalaCases.PowerConstraints] = new DefaultIPXACT2022ScalaCases_PowerConstraintsFormat {}
  implicit lazy val IPXACT2022ScalaCases_PortWireTypableFormat: IPXACT2022scalaxb.XMLFormat[IPXACT2022ScalaCases.PortWireTypable] = new DefaultIPXACT2022ScalaCases_PortWireTypableFormat {}
  implicit lazy val IPXACT2022ScalaCases_PortWireTypeFormat: IPXACT2022scalaxb.XMLFormat[IPXACT2022ScalaCases.PortWireType] = new DefaultIPXACT2022ScalaCases_PortWireTypeFormat {}
  implicit lazy val IPXACT2022ScalaCases_ConnectionFormat: IPXACT2022scalaxb.XMLFormat[IPXACT2022ScalaCases.Connection] = new DefaultIPXACT2022ScalaCases_ConnectionFormat {}
  implicit lazy val IPXACT2022ScalaCases_PowerConstraints2Format: IPXACT2022scalaxb.XMLFormat[IPXACT2022ScalaCases.PowerConstraints2] = new DefaultIPXACT2022ScalaCases_PowerConstraints2Format {}
  implicit lazy val IPXACT2022ScalaCases_PortTransactionalTypeFormat: IPXACT2022scalaxb.XMLFormat[IPXACT2022ScalaCases.PortTransactionalType] = new DefaultIPXACT2022ScalaCases_PortTransactionalTypeFormat {}
  implicit lazy val IPXACT2022ScalaCases_Connection2Format: IPXACT2022scalaxb.XMLFormat[IPXACT2022ScalaCases.Connection2] = new DefaultIPXACT2022ScalaCases_Connection2Format {}
  implicit lazy val IPXACT2022ScalaCases_AbstractorPortTransactionalTypeFormat: IPXACT2022scalaxb.XMLFormat[IPXACT2022ScalaCases.AbstractorPortTransactionalType] = new DefaultIPXACT2022ScalaCases_AbstractorPortTransactionalTypeFormat {}
  implicit lazy val IPXACT2022ScalaCases_AbstractorPortWireTypeFormat: IPXACT2022scalaxb.XMLFormat[IPXACT2022ScalaCases.AbstractorPortWireType] = new DefaultIPXACT2022ScalaCases_AbstractorPortWireTypeFormat {}
  implicit lazy val IPXACT2022ScalaCases_Vector4Format: IPXACT2022scalaxb.XMLFormat[IPXACT2022ScalaCases.Vector4] = new DefaultIPXACT2022ScalaCases_Vector4Format {}
  implicit lazy val IPXACT2022ScalaCases_ExtendedVectorsTypeFormat: IPXACT2022scalaxb.XMLFormat[IPXACT2022ScalaCases.ExtendedVectorsType] = new DefaultIPXACT2022ScalaCases_ExtendedVectorsTypeFormat {}
  implicit lazy val IPXACT2022ScalaCases_AccessHandles13Format: IPXACT2022scalaxb.XMLFormat[IPXACT2022ScalaCases.AccessHandles13] = new DefaultIPXACT2022ScalaCases_AccessHandles13Format {}
  implicit lazy val IPXACT2022ScalaCases_AccessHandles13Sequence1Format: IPXACT2022scalaxb.XMLFormat[IPXACT2022ScalaCases.AccessHandles13Sequence1] = new DefaultIPXACT2022ScalaCases_AccessHandles13Sequence1Format {}
  implicit lazy val IPXACT2022ScalaCases_PortAccessTypeFormat: IPXACT2022scalaxb.XMLFormat[IPXACT2022ScalaCases.PortAccessType] = new DefaultIPXACT2022ScalaCases_PortAccessTypeFormat {}
  implicit lazy val IPXACT2022ScalaCases_SignalTypeFormat: IPXACT2022scalaxb.XMLFormat[IPXACT2022ScalaCases.SignalType] = new DefaultIPXACT2022ScalaCases_SignalTypeFormat {}
  implicit lazy val IPXACT2022ScalaCases_ViewRef8Format: IPXACT2022scalaxb.XMLFormat[IPXACT2022ScalaCases.ViewRef8] = new DefaultIPXACT2022ScalaCases_ViewRef8Format {}
  implicit lazy val IPXACT2022ScalaCases_SignalTypeDefFormat: IPXACT2022scalaxb.XMLFormat[IPXACT2022ScalaCases.SignalTypeDef] = new DefaultIPXACT2022ScalaCases_SignalTypeDefFormat {}
  implicit lazy val IPXACT2022ScalaCases_TypeName4Format: IPXACT2022scalaxb.XMLFormat[IPXACT2022ScalaCases.TypeName4] = new DefaultIPXACT2022ScalaCases_TypeName4Format {}
  implicit lazy val IPXACT2022ScalaCases_TypeDefinition4Format: IPXACT2022scalaxb.XMLFormat[IPXACT2022ScalaCases.TypeDefinition4] = new DefaultIPXACT2022ScalaCases_TypeDefinition4Format {}
  implicit lazy val IPXACT2022ScalaCases_ViewRef9Format: IPXACT2022scalaxb.XMLFormat[IPXACT2022ScalaCases.ViewRef9] = new DefaultIPXACT2022ScalaCases_ViewRef9Format {}
  implicit lazy val IPXACT2022ScalaCases_DomainTypeDefFormat: IPXACT2022scalaxb.XMLFormat[IPXACT2022ScalaCases.DomainTypeDef] = new DefaultIPXACT2022ScalaCases_DomainTypeDefFormat {}
  implicit lazy val IPXACT2022ScalaCases_DomainTypeDefsFormat: IPXACT2022scalaxb.XMLFormat[IPXACT2022ScalaCases.DomainTypeDefs] = new DefaultIPXACT2022ScalaCases_DomainTypeDefsFormat {}
  implicit lazy val IPXACT2022ScalaCases_SignalTypeDefsFormat: IPXACT2022scalaxb.XMLFormat[IPXACT2022ScalaCases.SignalTypeDefs] = new DefaultIPXACT2022ScalaCases_SignalTypeDefsFormat {}
  implicit lazy val IPXACT2022ScalaCases_PortPacketsTypeFormat: IPXACT2022scalaxb.XMLFormat[IPXACT2022ScalaCases.PortPacketsType] = new DefaultIPXACT2022ScalaCases_PortPacketsTypeFormat {}
  implicit lazy val IPXACT2022ScalaCases_PortPacketTypeFormat: IPXACT2022scalaxb.XMLFormat[IPXACT2022ScalaCases.PortPacketType] = new DefaultIPXACT2022ScalaCases_PortPacketTypeFormat {}
  implicit lazy val IPXACT2022ScalaCases_PortPacketFieldsTypeFormat: IPXACT2022scalaxb.XMLFormat[IPXACT2022ScalaCases.PortPacketFieldsType] = new DefaultIPXACT2022ScalaCases_PortPacketFieldsTypeFormat {}
  implicit lazy val IPXACT2022ScalaCases_PortPacketFieldTypeFormat: IPXACT2022scalaxb.XMLFormat[IPXACT2022ScalaCases.PortPacketFieldType] = new DefaultIPXACT2022ScalaCases_PortPacketFieldTypeFormat {}
  implicit lazy val IPXACT2022ScalaCases_ArrayType5Format: IPXACT2022scalaxb.XMLFormat[IPXACT2022ScalaCases.ArrayType5] = new DefaultIPXACT2022ScalaCases_ArrayType5Format {}
  implicit lazy val IPXACT2022ScalaCases_ArraysFormat: IPXACT2022scalaxb.XMLFormat[IPXACT2022ScalaCases.Arrays] = new DefaultIPXACT2022ScalaCases_ArraysFormat {}
  implicit lazy val IPXACT2022ScalaCases_TypeName5Format: IPXACT2022scalaxb.XMLFormat[IPXACT2022ScalaCases.TypeName5] = new DefaultIPXACT2022ScalaCases_TypeName5Format {}
  implicit lazy val IPXACT2022ScalaCases_TypeDefinition5Format: IPXACT2022scalaxb.XMLFormat[IPXACT2022ScalaCases.TypeDefinition5] = new DefaultIPXACT2022ScalaCases_TypeDefinition5Format {}
  implicit lazy val IPXACT2022ScalaCases_TypeParameters2Format: IPXACT2022scalaxb.XMLFormat[IPXACT2022ScalaCases.TypeParameters2] = new DefaultIPXACT2022ScalaCases_TypeParameters2Format {}
  implicit lazy val IPXACT2022ScalaCases_ViewRef10Format: IPXACT2022scalaxb.XMLFormat[IPXACT2022ScalaCases.ViewRef10] = new DefaultIPXACT2022ScalaCases_ViewRef10Format {}
  implicit lazy val IPXACT2022ScalaCases_StructPortTypeDefFormat: IPXACT2022scalaxb.XMLFormat[IPXACT2022ScalaCases.StructPortTypeDef] = new DefaultIPXACT2022ScalaCases_StructPortTypeDefFormat {}
  implicit lazy val IPXACT2022ScalaCases_StructPortTypeDefsFormat: IPXACT2022scalaxb.XMLFormat[IPXACT2022ScalaCases.StructPortTypeDefs] = new DefaultIPXACT2022ScalaCases_StructPortTypeDefsFormat {}
  implicit lazy val IPXACT2022ScalaCases_SubPortTypeFormat: IPXACT2022scalaxb.XMLFormat[IPXACT2022ScalaCases.SubPortType] = new DefaultIPXACT2022ScalaCases_SubPortTypeFormat {}
  implicit lazy val IPXACT2022ScalaCases_AbstractorSubPortTypeFormat: IPXACT2022scalaxb.XMLFormat[IPXACT2022ScalaCases.AbstractorSubPortType] = new DefaultIPXACT2022ScalaCases_AbstractorSubPortTypeFormat {}
  implicit lazy val IPXACT2022ScalaCases_SubPortsFormat: IPXACT2022scalaxb.XMLFormat[IPXACT2022ScalaCases.SubPorts] = new DefaultIPXACT2022ScalaCases_SubPortsFormat {}
  implicit lazy val IPXACT2022ScalaCases_PortStructuredTypeFormat: IPXACT2022scalaxb.XMLFormat[IPXACT2022ScalaCases.PortStructuredType] = new DefaultIPXACT2022ScalaCases_PortStructuredTypeFormat {}
  implicit lazy val IPXACT2022ScalaCases_SubPorts2Format: IPXACT2022scalaxb.XMLFormat[IPXACT2022ScalaCases.SubPorts2] = new DefaultIPXACT2022ScalaCases_SubPorts2Format {}
  implicit lazy val IPXACT2022ScalaCases_AbstractorPortStructuredTypeFormat: IPXACT2022scalaxb.XMLFormat[IPXACT2022ScalaCases.AbstractorPortStructuredType] = new DefaultIPXACT2022ScalaCases_AbstractorPortStructuredTypeFormat {}
  implicit lazy val IPXACT2022ScalaCases_WirePowerConstraintTypeFormat: IPXACT2022scalaxb.XMLFormat[IPXACT2022ScalaCases.WirePowerConstraintType] = new DefaultIPXACT2022ScalaCases_WirePowerConstraintTypeFormat {}
  implicit lazy val IPXACT2022ScalaCases_TransactionalPowerConstraintTypeFormat: IPXACT2022scalaxb.XMLFormat[IPXACT2022ScalaCases.TransactionalPowerConstraintType] = new DefaultIPXACT2022ScalaCases_TransactionalPowerConstraintTypeFormat {}
  implicit lazy val IPXACT2022ScalaCases_StructFormat: IPXACT2022scalaxb.XMLFormat[IPXACT2022ScalaCases.Struct] = new DefaultIPXACT2022ScalaCases_StructFormat {}
  implicit lazy val IPXACT2022ScalaCases_UnionFormat: IPXACT2022scalaxb.XMLFormat[IPXACT2022ScalaCases.Union] = new DefaultIPXACT2022ScalaCases_UnionFormat {}
  implicit lazy val IPXACT2022ScalaCases_InterfaceFormat: IPXACT2022scalaxb.XMLFormat[IPXACT2022ScalaCases.Interface] = new DefaultIPXACT2022ScalaCases_InterfaceFormat {}
  implicit lazy val IPXACT2022ScalaCases_ClockDriverFormat: IPXACT2022scalaxb.XMLFormat[IPXACT2022ScalaCases.ClockDriver] = new DefaultIPXACT2022ScalaCases_ClockDriverFormat {}
  implicit lazy val IPXACT2022ScalaCases_SingleShotOffsetFormat: IPXACT2022scalaxb.XMLFormat[IPXACT2022ScalaCases.SingleShotOffset] = new DefaultIPXACT2022ScalaCases_SingleShotOffsetFormat {}
  implicit lazy val IPXACT2022ScalaCases_SingleShotValueFormat: IPXACT2022scalaxb.XMLFormat[IPXACT2022ScalaCases.SingleShotValue] = new DefaultIPXACT2022ScalaCases_SingleShotValueFormat {}
  implicit lazy val IPXACT2022ScalaCases_SingleShotDurationFormat: IPXACT2022scalaxb.XMLFormat[IPXACT2022ScalaCases.SingleShotDuration] = new DefaultIPXACT2022ScalaCases_SingleShotDurationFormat {}
  implicit lazy val IPXACT2022ScalaCases_SingleShotDriverFormat: IPXACT2022scalaxb.XMLFormat[IPXACT2022ScalaCases.SingleShotDriver] = new DefaultIPXACT2022ScalaCases_SingleShotDriverFormat {}
  implicit lazy val IPXACT2022ScalaCases_DriverTypeTypeFormat: IPXACT2022scalaxb.XMLFormat[IPXACT2022ScalaCases.DriverTypeType] = new DefaultIPXACT2022ScalaCases_DriverTypeTypeFormat {}
  implicit lazy val IPXACT2022ScalaCases_RequiresDriverFormat: IPXACT2022scalaxb.XMLFormat[IPXACT2022ScalaCases.RequiresDriver] = new DefaultIPXACT2022ScalaCases_RequiresDriverFormat {}
  implicit lazy val IPXACT2022ScalaCases_ViewRefFormat: IPXACT2022scalaxb.XMLFormat[IPXACT2022ScalaCases.ViewRef] = new DefaultIPXACT2022ScalaCases_ViewRefFormat {}
  implicit lazy val IPXACT2022ScalaCases_DriverTypeFormat: IPXACT2022scalaxb.XMLFormat[IPXACT2022ScalaCases.DriverType] = new DefaultIPXACT2022ScalaCases_DriverTypeFormat {}
  implicit lazy val IPXACT2022ScalaCases_DriverTypeSequence1Format: IPXACT2022scalaxb.XMLFormat[IPXACT2022ScalaCases.DriverTypeSequence1] = new DefaultIPXACT2022ScalaCases_DriverTypeSequence1Format {}
  implicit lazy val IPXACT2022ScalaCases_DriversFormat: IPXACT2022scalaxb.XMLFormat[IPXACT2022ScalaCases.Drivers] = new DefaultIPXACT2022ScalaCases_DriversFormat {}
  implicit lazy val IPXACT2022ScalaCases_ClockPeriodFormat: IPXACT2022scalaxb.XMLFormat[IPXACT2022ScalaCases.ClockPeriod] = new DefaultIPXACT2022ScalaCases_ClockPeriodFormat {}
  implicit lazy val IPXACT2022ScalaCases_ClockPulseOffsetFormat: IPXACT2022scalaxb.XMLFormat[IPXACT2022ScalaCases.ClockPulseOffset] = new DefaultIPXACT2022ScalaCases_ClockPulseOffsetFormat {}
  implicit lazy val IPXACT2022ScalaCases_ClockPulseDurationFormat: IPXACT2022scalaxb.XMLFormat[IPXACT2022ScalaCases.ClockPulseDuration] = new DefaultIPXACT2022ScalaCases_ClockPulseDurationFormat {}
  implicit lazy val IPXACT2022ScalaCases_ClockDriverTypableFormat: IPXACT2022scalaxb.XMLFormat[IPXACT2022ScalaCases.ClockDriverTypable] = new DefaultIPXACT2022ScalaCases_ClockDriverTypableFormat {}
  implicit lazy val IPXACT2022ScalaCases_ClockDriverTypeFormat: IPXACT2022scalaxb.XMLFormat[IPXACT2022ScalaCases.ClockDriverType] = new DefaultIPXACT2022ScalaCases_ClockDriverTypeFormat {}
  implicit lazy val IPXACT2022ScalaCases_OtherClockDriverFormat: IPXACT2022scalaxb.XMLFormat[IPXACT2022ScalaCases.OtherClockDriver] = new DefaultIPXACT2022ScalaCases_OtherClockDriverFormat {}
  implicit lazy val IPXACT2022ScalaCases_UnsignedLongintExpressionableFormat: IPXACT2022scalaxb.XMLFormat[IPXACT2022ScalaCases.UnsignedLongintExpressionable] = new DefaultIPXACT2022ScalaCases_UnsignedLongintExpressionableFormat {}
  implicit lazy val IPXACT2022ScalaCases_UnsignedLongintExpressionFormat: IPXACT2022scalaxb.XMLFormat[IPXACT2022ScalaCases.UnsignedLongintExpression] = new DefaultIPXACT2022ScalaCases_UnsignedLongintExpressionFormat {}
  implicit lazy val IPXACT2022ScalaCases_UnsignedPositiveLongintExpressionableFormat: IPXACT2022scalaxb.XMLFormat[IPXACT2022ScalaCases.UnsignedPositiveLongintExpressionable] = new DefaultIPXACT2022ScalaCases_UnsignedPositiveLongintExpressionableFormat {}
  implicit lazy val IPXACT2022ScalaCases_UnsignedPositiveLongintExpressionFormat: IPXACT2022scalaxb.XMLFormat[IPXACT2022ScalaCases.UnsignedPositiveLongintExpression] = new DefaultIPXACT2022ScalaCases_UnsignedPositiveLongintExpressionFormat {}
  implicit lazy val IPXACT2022ScalaCases_SignedLongintExpressionFormat: IPXACT2022scalaxb.XMLFormat[IPXACT2022ScalaCases.SignedLongintExpression] = new DefaultIPXACT2022ScalaCases_SignedLongintExpressionFormat {}
  implicit lazy val IPXACT2022ScalaCases_UnsignedIntExpressionableFormat: IPXACT2022scalaxb.XMLFormat[IPXACT2022ScalaCases.UnsignedIntExpressionable] = new DefaultIPXACT2022ScalaCases_UnsignedIntExpressionableFormat {}
  implicit lazy val IPXACT2022ScalaCases_UnsignedIntExpressionFormat: IPXACT2022scalaxb.XMLFormat[IPXACT2022ScalaCases.UnsignedIntExpression] = new DefaultIPXACT2022ScalaCases_UnsignedIntExpressionFormat {}
  implicit lazy val IPXACT2022ScalaCases_UnsignedPositiveIntExpressionableFormat: IPXACT2022scalaxb.XMLFormat[IPXACT2022ScalaCases.UnsignedPositiveIntExpressionable] = new DefaultIPXACT2022ScalaCases_UnsignedPositiveIntExpressionableFormat {}
  implicit lazy val IPXACT2022ScalaCases_UnsignedPositiveIntExpressionFormat: IPXACT2022scalaxb.XMLFormat[IPXACT2022ScalaCases.UnsignedPositiveIntExpression] = new DefaultIPXACT2022ScalaCases_UnsignedPositiveIntExpressionFormat {}
  implicit lazy val IPXACT2022ScalaCases_UnresolvedUnsignedPositiveIntExpressionFormat: IPXACT2022scalaxb.XMLFormat[IPXACT2022ScalaCases.UnresolvedUnsignedPositiveIntExpression] = new DefaultIPXACT2022ScalaCases_UnresolvedUnsignedPositiveIntExpressionFormat {}
  implicit lazy val IPXACT2022ScalaCases_RealExpressionableFormat: IPXACT2022scalaxb.XMLFormat[IPXACT2022ScalaCases.RealExpressionable] = new DefaultIPXACT2022ScalaCases_RealExpressionableFormat {}
  implicit lazy val IPXACT2022ScalaCases_RealExpressionFormat: IPXACT2022scalaxb.XMLFormat[IPXACT2022ScalaCases.RealExpression] = new DefaultIPXACT2022ScalaCases_RealExpressionFormat {}
  implicit lazy val IPXACT2022ScalaCases_UnresolvedStringExpressionableFormat: IPXACT2022scalaxb.XMLFormat[IPXACT2022ScalaCases.UnresolvedStringExpressionable] = new DefaultIPXACT2022ScalaCases_UnresolvedStringExpressionableFormat {}
  implicit lazy val IPXACT2022ScalaCases_UnresolvedStringExpressionFormat: IPXACT2022scalaxb.XMLFormat[IPXACT2022ScalaCases.UnresolvedStringExpression] = new DefaultIPXACT2022ScalaCases_UnresolvedStringExpressionFormat {}
  implicit lazy val IPXACT2022ScalaCases_StringExpressionableFormat: IPXACT2022scalaxb.XMLFormat[IPXACT2022ScalaCases.StringExpressionable] = new DefaultIPXACT2022ScalaCases_StringExpressionableFormat {}
  implicit lazy val IPXACT2022ScalaCases_StringExpressionFormat: IPXACT2022scalaxb.XMLFormat[IPXACT2022ScalaCases.StringExpression] = new DefaultIPXACT2022ScalaCases_StringExpressionFormat {}
  implicit lazy val IPXACT2022ScalaCases_UnsignedBitExpressionFormat: IPXACT2022scalaxb.XMLFormat[IPXACT2022ScalaCases.UnsignedBitExpression] = new DefaultIPXACT2022ScalaCases_UnsignedBitExpressionFormat {}
  implicit lazy val IPXACT2022ScalaCases_QualifiedExpressionFormat: IPXACT2022scalaxb.XMLFormat[IPXACT2022ScalaCases.QualifiedExpression] = new DefaultIPXACT2022ScalaCases_QualifiedExpressionFormat {}
  implicit lazy val IPXACT2022ScalaCases_UnsignedBitVectorExpressionableFormat: IPXACT2022scalaxb.XMLFormat[IPXACT2022ScalaCases.UnsignedBitVectorExpressionable] = new DefaultIPXACT2022ScalaCases_UnsignedBitVectorExpressionableFormat {}
  implicit lazy val IPXACT2022ScalaCases_UnsignedBitVectorExpressionFormat: IPXACT2022scalaxb.XMLFormat[IPXACT2022ScalaCases.UnsignedBitVectorExpression] = new DefaultIPXACT2022ScalaCases_UnsignedBitVectorExpressionFormat {}
  implicit lazy val IPXACT2022ScalaCases_ComplexBaseExpressionableFormat: IPXACT2022scalaxb.XMLFormat[IPXACT2022ScalaCases.ComplexBaseExpressionable] = new DefaultIPXACT2022ScalaCases_ComplexBaseExpressionableFormat {}
  implicit lazy val IPXACT2022ScalaCases_ComplexBaseExpressionFormat: IPXACT2022scalaxb.XMLFormat[IPXACT2022ScalaCases.ComplexBaseExpression] = new DefaultIPXACT2022ScalaCases_ComplexBaseExpressionFormat {}
  implicit lazy val IPXACT2022ScalaCases_IpxactURIableFormat: IPXACT2022scalaxb.XMLFormat[IPXACT2022ScalaCases.IpxactURIable] = new DefaultIPXACT2022ScalaCases_IpxactURIableFormat {}
  implicit lazy val IPXACT2022ScalaCases_IpxactURIFormat: IPXACT2022scalaxb.XMLFormat[IPXACT2022ScalaCases.IpxactURI] = new DefaultIPXACT2022ScalaCases_IpxactURIFormat {}
  implicit lazy val IPXACT2022ScalaCases_UnresolvedUnsignedBitExpressionFormat: IPXACT2022scalaxb.XMLFormat[IPXACT2022ScalaCases.UnresolvedUnsignedBitExpression] = new DefaultIPXACT2022ScalaCases_UnresolvedUnsignedBitExpressionFormat {}
  implicit lazy val IPXACT2022ScalaCases_ComplexTiedValueExpressionFormat: IPXACT2022scalaxb.XMLFormat[IPXACT2022ScalaCases.ComplexTiedValueExpression] = new DefaultIPXACT2022ScalaCases_ComplexTiedValueExpressionFormat {}
  implicit lazy val IPXACT2022ScalaCases_ConfigurableElementValuesFormat: IPXACT2022scalaxb.XMLFormat[IPXACT2022ScalaCases.ConfigurableElementValues] = new DefaultIPXACT2022ScalaCases_ConfigurableElementValuesFormat {}
  implicit lazy val IPXACT2022ScalaCases_ConfigurableElementValuesSequence1Format: IPXACT2022scalaxb.XMLFormat[IPXACT2022ScalaCases.ConfigurableElementValuesSequence1] = new DefaultIPXACT2022ScalaCases_ConfigurableElementValuesSequence1Format {}
  implicit lazy val IPXACT2022ScalaCases_ConfigurableElementValueFormat: IPXACT2022scalaxb.XMLFormat[IPXACT2022ScalaCases.ConfigurableElementValue] = new DefaultIPXACT2022ScalaCases_ConfigurableElementValueFormat {}
  implicit lazy val IPXACT2022ScalaCases_ComponentInstanceFormat: IPXACT2022scalaxb.XMLFormat[IPXACT2022ScalaCases.ComponentInstance] = new DefaultIPXACT2022ScalaCases_ComponentInstanceFormat {}
  implicit lazy val IPXACT2022ScalaCases_ComponentInstancesFormat: IPXACT2022scalaxb.XMLFormat[IPXACT2022ScalaCases.ComponentInstances] = new DefaultIPXACT2022ScalaCases_ComponentInstancesFormat {}
  implicit lazy val IPXACT2022ScalaCases_InternalPortReferenceFormat: IPXACT2022scalaxb.XMLFormat[IPXACT2022ScalaCases.InternalPortReference] = new DefaultIPXACT2022ScalaCases_InternalPortReferenceFormat {}
  implicit lazy val IPXACT2022ScalaCases_PortReferencesFormat: IPXACT2022scalaxb.XMLFormat[IPXACT2022ScalaCases.PortReferences] = new DefaultIPXACT2022ScalaCases_PortReferencesFormat {}
  implicit lazy val IPXACT2022ScalaCases_PortReferencesSequence1Format: IPXACT2022scalaxb.XMLFormat[IPXACT2022ScalaCases.PortReferencesSequence1] = new DefaultIPXACT2022ScalaCases_PortReferencesSequence1Format {}
  implicit lazy val IPXACT2022ScalaCases_AdHocConnectionFormat: IPXACT2022scalaxb.XMLFormat[IPXACT2022ScalaCases.AdHocConnection] = new DefaultIPXACT2022ScalaCases_AdHocConnectionFormat {}
  implicit lazy val IPXACT2022ScalaCases_AdHocConnectionsFormat: IPXACT2022scalaxb.XMLFormat[IPXACT2022ScalaCases.AdHocConnections] = new DefaultIPXACT2022ScalaCases_AdHocConnectionsFormat {}
  implicit lazy val IPXACT2022ScalaCases_InterconnectionFormat: IPXACT2022scalaxb.XMLFormat[IPXACT2022ScalaCases.Interconnection] = new DefaultIPXACT2022ScalaCases_InterconnectionFormat {}
  implicit lazy val IPXACT2022ScalaCases_InterconnectionSequence1Format: IPXACT2022scalaxb.XMLFormat[IPXACT2022ScalaCases.InterconnectionSequence1] = new DefaultIPXACT2022ScalaCases_InterconnectionSequence1Format {}
  implicit lazy val IPXACT2022ScalaCases_MonitorInterconnectionFormat: IPXACT2022scalaxb.XMLFormat[IPXACT2022ScalaCases.MonitorInterconnection] = new DefaultIPXACT2022ScalaCases_MonitorInterconnectionFormat {}
  implicit lazy val IPXACT2022ScalaCases_InterconnectionsFormat: IPXACT2022scalaxb.XMLFormat[IPXACT2022ScalaCases.Interconnections] = new DefaultIPXACT2022ScalaCases_InterconnectionsFormat {}
  implicit lazy val IPXACT2022ScalaCases_InterfaceTypableFormat: IPXACT2022scalaxb.XMLFormat[IPXACT2022ScalaCases.InterfaceTypable] = new DefaultIPXACT2022ScalaCases_InterfaceTypableFormat {}
  implicit lazy val IPXACT2022ScalaCases_InterfaceTypeFormat: IPXACT2022scalaxb.XMLFormat[IPXACT2022ScalaCases.InterfaceType] = new DefaultIPXACT2022ScalaCases_InterfaceTypeFormat {}
  implicit lazy val IPXACT2022ScalaCases_HierInterfaceTypeFormat: IPXACT2022scalaxb.XMLFormat[IPXACT2022ScalaCases.HierInterfaceType] = new DefaultIPXACT2022ScalaCases_HierInterfaceTypeFormat {}
  implicit lazy val IPXACT2022ScalaCases_MonitorInterfaceTypeFormat: IPXACT2022scalaxb.XMLFormat[IPXACT2022ScalaCases.MonitorInterfaceType] = new DefaultIPXACT2022ScalaCases_MonitorInterfaceTypeFormat {}
  implicit lazy val IPXACT2022ScalaCases_ExternalPortReferenceFormat: IPXACT2022scalaxb.XMLFormat[IPXACT2022ScalaCases.ExternalPortReference] = new DefaultIPXACT2022ScalaCases_ExternalPortReferenceFormat {}
  implicit lazy val IPXACT2022ScalaCases_ExcludePortFormat: IPXACT2022scalaxb.XMLFormat[IPXACT2022ScalaCases.ExcludePort] = new DefaultIPXACT2022ScalaCases_ExcludePortFormat {}
  implicit lazy val IPXACT2022ScalaCases_ExcludePortsFormat: IPXACT2022scalaxb.XMLFormat[IPXACT2022ScalaCases.ExcludePorts] = new DefaultIPXACT2022ScalaCases_ExcludePortsFormat {}
  implicit lazy val IPXACT2022ScalaCases_ActiveInterfaceFormat: IPXACT2022scalaxb.XMLFormat[IPXACT2022ScalaCases.ActiveInterface] = new DefaultIPXACT2022ScalaCases_ActiveInterfaceFormat {}
  implicit lazy val IPXACT2022ScalaCases_InternalPowerDomainReferenceFormat: IPXACT2022scalaxb.XMLFormat[IPXACT2022ScalaCases.InternalPowerDomainReference] = new DefaultIPXACT2022ScalaCases_InternalPowerDomainReferenceFormat {}
  implicit lazy val IPXACT2022ScalaCases_PowerDomainLinkFormat: IPXACT2022scalaxb.XMLFormat[IPXACT2022ScalaCases.PowerDomainLink] = new DefaultIPXACT2022ScalaCases_PowerDomainLinkFormat {}
  implicit lazy val IPXACT2022ScalaCases_PowerDomainLinksFormat: IPXACT2022scalaxb.XMLFormat[IPXACT2022ScalaCases.PowerDomainLinks] = new DefaultIPXACT2022ScalaCases_PowerDomainLinksFormat {}
  implicit lazy val IPXACT2022ScalaCases_Mode2Format: IPXACT2022scalaxb.XMLFormat[IPXACT2022ScalaCases.Mode2] = new DefaultIPXACT2022ScalaCases_Mode2Format {}
  implicit lazy val IPXACT2022ScalaCases_Modes2Format: IPXACT2022scalaxb.XMLFormat[IPXACT2022ScalaCases.Modes2] = new DefaultIPXACT2022ScalaCases_Modes2Format {}
  implicit lazy val IPXACT2022ScalaCases_View4Format: IPXACT2022scalaxb.XMLFormat[IPXACT2022ScalaCases.View4] = new DefaultIPXACT2022ScalaCases_View4Format {}
  implicit lazy val IPXACT2022ScalaCases_Views3Format: IPXACT2022scalaxb.XMLFormat[IPXACT2022ScalaCases.Views3] = new DefaultIPXACT2022ScalaCases_Views3Format {}
  implicit lazy val IPXACT2022ScalaCases_ResetType2Format: IPXACT2022scalaxb.XMLFormat[IPXACT2022ScalaCases.ResetType2] = new DefaultIPXACT2022ScalaCases_ResetType2Format {}
  implicit lazy val IPXACT2022ScalaCases_ResetTypes2Format: IPXACT2022scalaxb.XMLFormat[IPXACT2022ScalaCases.ResetTypes2] = new DefaultIPXACT2022ScalaCases_ResetTypes2Format {}
  implicit lazy val IPXACT2022ScalaCases_TypeDefinitions2Format: IPXACT2022scalaxb.XMLFormat[IPXACT2022ScalaCases.TypeDefinitions2] = new DefaultIPXACT2022ScalaCases_TypeDefinitions2Format {}
  implicit lazy val IPXACT2022ScalaCases_TypeDefinitions2Sequence1Format: IPXACT2022scalaxb.XMLFormat[IPXACT2022ScalaCases.TypeDefinitions2Sequence1] = new DefaultIPXACT2022ScalaCases_TypeDefinitions2Sequence1Format {}


  implicit val fromAnySchemaType: scala.xml.Elem => Option[IPXACT2022scalaxb.DataRecord[Any]] = {elem =>
    import IPXACT2022scalaxb.{Helper, DataRecord, fromXML}

    val ns = Helper.nullOrEmpty(elem.scope.getURI(elem.prefix))
    val key = Some(elem.label)
    val (xsns, xstype) = Helper.instanceType(elem)

    (key, ns) match {
      case (Some("wire"), Some("http://www.accellera.org/XMLSchema/IPXACT/1685-2022") | None) => Some(DataRecord(ns, key, xsns, xstype, fromXML[IPXACT2022ScalaCases.Wire](elem)))
      case (Some("abstractionDefinition"), Some("http://www.accellera.org/XMLSchema/IPXACT/1685-2022") | None) => Some(DataRecord(ns, key, xsns, xstype, fromXML[IPXACT2022ScalaCases.AbstractionDefinition](elem)))
      case (Some("presence"), Some("http://www.accellera.org/XMLSchema/IPXACT/1685-2022") | None) => Some(DataRecord(ns, key, xsns, xstype, fromXML[IPXACT2022ScalaCases.PresenceType](elem)))
      case (Some("packets"), Some("http://www.accellera.org/XMLSchema/IPXACT/1685-2022") | None) => Some(DataRecord(ns, key, xsns, xstype, fromXML[IPXACT2022ScalaCases.PortPacketsType](elem)))
      case (Some("abstractor"), Some("http://www.accellera.org/XMLSchema/IPXACT/1685-2022") | None) => Some(DataRecord(ns, key, xsns, xstype, fromXML[IPXACT2022ScalaCases.AbstractorType](elem)))
      case (Some("choices"), Some("http://www.accellera.org/XMLSchema/IPXACT/1685-2022") | None) => Some(DataRecord(ns, key, xsns, xstype, fromXML[IPXACT2022ScalaCases.Choices](elem)))
      case (Some("busDefinition"), Some("http://www.accellera.org/XMLSchema/IPXACT/1685-2022") | None) => Some(DataRecord(ns, key, xsns, xstype, fromXML[IPXACT2022ScalaCases.BusDefinition](elem)))
      case (Some("abstractionTypes"), Some("http://www.accellera.org/XMLSchema/IPXACT/1685-2022") | None) => Some(DataRecord(ns, key, xsns, xstype, fromXML[IPXACT2022ScalaCases.AbstractionTypes](elem)))
      case (Some("indirectAddressRef"), Some("http://www.accellera.org/XMLSchema/IPXACT/1685-2022") | None) => Some(DataRecord(ns, key, xsns, xstype, fromXML[IPXACT2022ScalaCases.IndirectAddressRef](elem)))
      case (Some("indirectInterface"), Some("http://www.accellera.org/XMLSchema/IPXACT/1685-2022") | None) => Some(DataRecord(ns, key, xsns, xstype, fromXML[IPXACT2022ScalaCases.IndirectInterfaceType](elem)))
      case (Some("channels"), Some("http://www.accellera.org/XMLSchema/IPXACT/1685-2022") | None) => Some(DataRecord(ns, key, xsns, xstype, fromXML[IPXACT2022ScalaCases.Channels](elem)))
      case (Some("busInterfaces"), Some("http://www.accellera.org/XMLSchema/IPXACT/1685-2022") | None) => Some(DataRecord(ns, key, xsns, xstype, fromXML[IPXACT2022ScalaCases.BusInterfaces](elem)))
      case (Some("viewRef"), Some("http://www.accellera.org/XMLSchema/IPXACT/1685-2022") | None) => Some(DataRecord(ns, key, xsns, xstype, fromXML[IPXACT2022ScalaCases.ViewRef5](elem)))
      case (Some("bitsInLau"), Some("http://www.accellera.org/XMLSchema/IPXACT/1685-2022") | None) => Some(DataRecord(ns, key, xsns, xstype, fromXML[IPXACT2022ScalaCases.UnsignedPositiveLongintExpressionable](elem)))
      case (Some("busInterface"), Some("http://www.accellera.org/XMLSchema/IPXACT/1685-2022") | None) => Some(DataRecord(ns, key, xsns, xstype, fromXML[IPXACT2022ScalaCases.BusInterfaceType](elem)))
      case (Some("group"), Some("http://www.accellera.org/XMLSchema/IPXACT/1685-2022") | None) => Some(DataRecord(ns, key, xsns, xstype, fromXML[String](elem)))
      case (Some("transparentBridge"), Some("http://www.accellera.org/XMLSchema/IPXACT/1685-2022") | None) => Some(DataRecord(ns, key, xsns, xstype, fromXML[IPXACT2022ScalaCases.TransparentBridge](elem)))
      case (Some("indirectInterfaces"), Some("http://www.accellera.org/XMLSchema/IPXACT/1685-2022") | None) => Some(DataRecord(ns, key, xsns, xstype, fromXML[IPXACT2022ScalaCases.IndirectInterfaces](elem)))
      case (Some("indirectDataRef"), Some("http://www.accellera.org/XMLSchema/IPXACT/1685-2022") | None) => Some(DataRecord(ns, key, xsns, xstype, fromXML[IPXACT2022ScalaCases.IndirectDataRef](elem)))
      case (Some("catalog"), Some("http://www.accellera.org/XMLSchema/IPXACT/1685-2022") | None) => Some(DataRecord(ns, key, xsns, xstype, fromXML[IPXACT2022ScalaCases.Catalog](elem)))
      case (Some("indices"), Some("http://www.accellera.org/XMLSchema/IPXACT/1685-2022") | None) => Some(DataRecord(ns, key, xsns, xstype, fromXML[IPXACT2022ScalaCases.IndicesType](elem)))
      case (Some("resetTypeLinks"), Some("http://www.accellera.org/XMLSchema/IPXACT/1685-2022") | None) => Some(DataRecord(ns, key, xsns, xstype, fromXML[IPXACT2022ScalaCases.ResetTypeLinks](elem)))
      case (Some("modeLinks"), Some("http://www.accellera.org/XMLSchema/IPXACT/1685-2022") | None) => Some(DataRecord(ns, key, xsns, xstype, fromXML[IPXACT2022ScalaCases.ModeLinks](elem)))
      case (Some("shortDescription"), Some("http://www.accellera.org/XMLSchema/IPXACT/1685-2022") | None) => Some(DataRecord(ns, key, xsns, xstype, fromXML[String](elem)))
      case (Some("value"), Some("http://www.accellera.org/XMLSchema/IPXACT/1685-2022") | None) => Some(DataRecord(ns, key, xsns, xstype, fromXML[IPXACT2022ScalaCases.StringExpressionable](elem)))
      case (Some("bankRef"), Some("http://www.accellera.org/XMLSchema/IPXACT/1685-2022") | None) => Some(DataRecord(ns, key, xsns, xstype, fromXML[IPXACT2022ScalaCases.BankRef](elem)))
      case (Some("alternateRegisterRef"), Some("http://www.accellera.org/XMLSchema/IPXACT/1685-2022") | None) => Some(DataRecord(ns, key, xsns, xstype, fromXML[IPXACT2022ScalaCases.AlternateRegisterRef](elem)))
      case (Some("registerFileRef"), Some("http://www.accellera.org/XMLSchema/IPXACT/1685-2022") | None) => Some(DataRecord(ns, key, xsns, xstype, fromXML[IPXACT2022ScalaCases.RegisterFileRef](elem)))
      case (Some("subPortReference"), Some("http://www.accellera.org/XMLSchema/IPXACT/1685-2022") | None) => Some(DataRecord(ns, key, xsns, xstype, fromXML[IPXACT2022ScalaCases.SubPortReference](elem)))
      case (Some("range"), Some("http://www.accellera.org/XMLSchema/IPXACT/1685-2022") | None) => Some(DataRecord(ns, key, xsns, xstype, fromXML[IPXACT2022ScalaCases.RangeType](elem)))
      case (Some("vector"), Some("http://www.accellera.org/XMLSchema/IPXACT/1685-2022") | None) => Some(DataRecord(ns, key, xsns, xstype, fromXML[IPXACT2022ScalaCases.Vector2](elem)))
      case (Some("right"), Some("http://www.accellera.org/XMLSchema/IPXACT/1685-2022") | None) => Some(DataRecord(ns, key, xsns, xstype, fromXML[IPXACT2022ScalaCases.UnsignedIntExpressionable](elem)))
      case (Some("parameters"), Some("http://www.accellera.org/XMLSchema/IPXACT/1685-2022") | None) => Some(DataRecord(ns, key, xsns, xstype, fromXML[IPXACT2022ScalaCases.Parameters](elem)))
      case (Some("assertion"), Some("http://www.accellera.org/XMLSchema/IPXACT/1685-2022") | None) => Some(DataRecord(ns, key, xsns, xstype, fromXML[IPXACT2022ScalaCases.Assertion](elem)))
      case (Some("parameter"), Some("http://www.accellera.org/XMLSchema/IPXACT/1685-2022") | None) => Some(DataRecord(ns, key, xsns, xstype, fromXML[IPXACT2022ScalaCases.ParameterType](elem)))
      case (Some("assertions"), Some("http://www.accellera.org/XMLSchema/IPXACT/1685-2022") | None) => Some(DataRecord(ns, key, xsns, xstype, fromXML[IPXACT2022ScalaCases.Assertions](elem)))
      case (Some("vendorExtensions"), Some("http://www.accellera.org/XMLSchema/IPXACT/1685-2022") | None) => Some(DataRecord(ns, key, xsns, xstype, fromXML[IPXACT2022ScalaCases.VendorExtensions](elem)))
      case (Some("left"), Some("http://www.accellera.org/XMLSchema/IPXACT/1685-2022") | None) => Some(DataRecord(ns, key, xsns, xstype, fromXML[IPXACT2022ScalaCases.UnsignedIntExpressionable](elem)))
      case (Some("vectors"), Some("http://www.accellera.org/XMLSchema/IPXACT/1685-2022") | None) => Some(DataRecord(ns, key, xsns, xstype, fromXML[IPXACT2022ScalaCases.Vectors2](elem)))
      case (Some("partSelect"), Some("http://www.accellera.org/XMLSchema/IPXACT/1685-2022") | None) => Some(DataRecord(ns, key, xsns, xstype, fromXML[IPXACT2022ScalaCases.PartSelect](elem)))
      case (Some("addressBlockRef"), Some("http://www.accellera.org/XMLSchema/IPXACT/1685-2022") | None) => Some(DataRecord(ns, key, xsns, xstype, fromXML[IPXACT2022ScalaCases.AddressBlockRef](elem)))
      case (Some("registerRef"), Some("http://www.accellera.org/XMLSchema/IPXACT/1685-2022") | None) => Some(DataRecord(ns, key, xsns, xstype, fromXML[IPXACT2022ScalaCases.RegisterRef](elem)))
      case (Some("fieldRef"), Some("http://www.accellera.org/XMLSchema/IPXACT/1685-2022") | None) => Some(DataRecord(ns, key, xsns, xstype, fromXML[IPXACT2022ScalaCases.FieldRef](elem)))
      case (Some("memoryRemapRef"), Some("http://www.accellera.org/XMLSchema/IPXACT/1685-2022") | None) => Some(DataRecord(ns, key, xsns, xstype, fromXML[IPXACT2022ScalaCases.MemoryRemapRef](elem)))
      case (Some("displayName"), Some("http://www.accellera.org/XMLSchema/IPXACT/1685-2022") | None) => Some(DataRecord(ns, key, xsns, xstype, fromXML[String](elem)))
      case (Some("description"), Some("http://www.accellera.org/XMLSchema/IPXACT/1685-2022") | None) => Some(DataRecord(ns, key, xsns, xstype, fromXML[String](elem)))
      case (Some("viewLinks"), Some("http://www.accellera.org/XMLSchema/IPXACT/1685-2022") | None) => Some(DataRecord(ns, key, xsns, xstype, fromXML[IPXACT2022ScalaCases.ViewLinks](elem)))
      case (Some("index"), Some("http://www.accellera.org/XMLSchema/IPXACT/1685-2022") | None) => Some(DataRecord(ns, key, xsns, xstype, fromXML[IPXACT2022ScalaCases.Index2](elem)))
      case (Some("component"), Some("http://www.accellera.org/XMLSchema/IPXACT/1685-2022") | None) => Some(DataRecord(ns, key, xsns, xstype, fromXML[IPXACT2022ScalaCases.ComponentType](elem)))
      case (Some("constraintSetRef"), Some("http://www.accellera.org/XMLSchema/IPXACT/1685-2022") | None) => Some(DataRecord(ns, key, xsns, xstype, fromXML[IPXACT2022ScalaCases.ConstraintSetRef](elem)))
      case (Some("constraintSet"), Some("http://www.accellera.org/XMLSchema/IPXACT/1685-2022") | None) => Some(DataRecord(ns, key, xsns, xstype, fromXML[IPXACT2022ScalaCases.ConstraintSet](elem)))
      case (Some("driveConstraint"), Some("http://www.accellera.org/XMLSchema/IPXACT/1685-2022") | None) => Some(DataRecord(ns, key, xsns, xstype, fromXML[IPXACT2022ScalaCases.DriveConstraint](elem)))
      case (Some("cellSpecification"), Some("http://www.accellera.org/XMLSchema/IPXACT/1685-2022") | None) => Some(DataRecord(ns, key, xsns, xstype, fromXML[IPXACT2022ScalaCases.CellSpecification](elem)))
      case (Some("timingConstraint"), Some("http://www.accellera.org/XMLSchema/IPXACT/1685-2022") | None) => Some(DataRecord(ns, key, xsns, xstype, fromXML[IPXACT2022ScalaCases.TimingConstraint](elem)))
      case (Some("loadConstraint"), Some("http://www.accellera.org/XMLSchema/IPXACT/1685-2022") | None) => Some(DataRecord(ns, key, xsns, xstype, fromXML[IPXACT2022ScalaCases.LoadConstraint](elem)))
      case (Some("constraintSets"), Some("http://www.accellera.org/XMLSchema/IPXACT/1685-2022") | None) => Some(DataRecord(ns, key, xsns, xstype, fromXML[IPXACT2022ScalaCases.ConstraintSets](elem)))
      case (Some("design"), Some("http://www.accellera.org/XMLSchema/IPXACT/1685-2022") | None) => Some(DataRecord(ns, key, xsns, xstype, fromXML[IPXACT2022ScalaCases.Design](elem)))
      case (Some("designConfiguration"), Some("http://www.accellera.org/XMLSchema/IPXACT/1685-2022") | None) => Some(DataRecord(ns, key, xsns, xstype, fromXML[IPXACT2022ScalaCases.DesignConfiguration](elem)))
      case (Some("generatorRef"), Some("http://www.accellera.org/XMLSchema/IPXACT/1685-2022") | None) => Some(DataRecord(ns, key, xsns, xstype, fromXML[IPXACT2022ScalaCases.GeneratorRef](elem)))
      case (Some("dependency"), Some("http://www.accellera.org/XMLSchema/IPXACT/1685-2022") | None) => Some(DataRecord(ns, key, xsns, xstype, fromXML[IPXACT2022ScalaCases.Dependency](elem)))
      case (Some("linkerCommandFile"), Some("http://www.accellera.org/XMLSchema/IPXACT/1685-2022") | None) => Some(DataRecord(ns, key, xsns, xstype, fromXML[IPXACT2022ScalaCases.LinkerCommandFile](elem)))
      case (Some("fileSet"), Some("http://www.accellera.org/XMLSchema/IPXACT/1685-2022") | None) => Some(DataRecord(ns, key, xsns, xstype, fromXML[IPXACT2022ScalaCases.FileSetType](elem)))
      case (Some("file"), Some("http://www.accellera.org/XMLSchema/IPXACT/1685-2022") | None) => Some(DataRecord(ns, key, xsns, xstype, fromXML[IPXACT2022ScalaCases.File](elem)))
      case (Some("executableImage"), Some("http://www.accellera.org/XMLSchema/IPXACT/1685-2022") | None) => Some(DataRecord(ns, key, xsns, xstype, fromXML[IPXACT2022ScalaCases.ExecutableImage](elem)))
      case (Some("fileSetRef"), Some("http://www.accellera.org/XMLSchema/IPXACT/1685-2022") | None) => Some(DataRecord(ns, key, xsns, xstype, fromXML[IPXACT2022ScalaCases.FileSetRef](elem)))
      case (Some("fileSets"), Some("http://www.accellera.org/XMLSchema/IPXACT/1685-2022") | None) => Some(DataRecord(ns, key, xsns, xstype, fromXML[IPXACT2022ScalaCases.FileSets](elem)))
      case (Some("fileType"), Some("http://www.accellera.org/XMLSchema/IPXACT/1685-2022") | None) => Some(DataRecord(ns, key, xsns, xstype, fromXML[IPXACT2022ScalaCases.FileType](elem)))
      case (Some("abstractorGenerators"), Some("http://www.accellera.org/XMLSchema/IPXACT/1685-2022") | None) => Some(DataRecord(ns, key, xsns, xstype, fromXML[IPXACT2022ScalaCases.AbstractorGenerators](elem)))
      case (Some("phase"), Some("http://www.accellera.org/XMLSchema/IPXACT/1685-2022") | None) => Some(DataRecord(ns, key, xsns, xstype, fromXML[IPXACT2022ScalaCases.RealExpressionable](elem)))
      case (Some("abstractorGenerator"), Some("http://www.accellera.org/XMLSchema/IPXACT/1685-2022") | None) => Some(DataRecord(ns, key, xsns, xstype, fromXML[IPXACT2022ScalaCases.InstanceGeneratorType](elem)))
      case (Some("generator"), Some("http://www.accellera.org/XMLSchema/IPXACT/1685-2022") | None) => Some(DataRecord(ns, key, xsns, xstype, fromXML[IPXACT2022ScalaCases.Generator](elem)))
      case (Some("generatorChain"), Some("http://www.accellera.org/XMLSchema/IPXACT/1685-2022") | None) => Some(DataRecord(ns, key, xsns, xstype, fromXML[IPXACT2022ScalaCases.GeneratorChain](elem)))
      case (Some("componentGenerator"), Some("http://www.accellera.org/XMLSchema/IPXACT/1685-2022") | None) => Some(DataRecord(ns, key, xsns, xstype, fromXML[IPXACT2022ScalaCases.InstanceGeneratorType](elem)))
      case (Some("groupSelector"), Some("http://www.accellera.org/XMLSchema/IPXACT/1685-2022") | None) => Some(DataRecord(ns, key, xsns, xstype, fromXML[IPXACT2022ScalaCases.GroupSelector](elem)))
      case (Some("componentGenerators"), Some("http://www.accellera.org/XMLSchema/IPXACT/1685-2022") | None) => Some(DataRecord(ns, key, xsns, xstype, fromXML[IPXACT2022ScalaCases.ComponentGenerators](elem)))
      case (Some("accessPolicies"), Some("http://www.accellera.org/XMLSchema/IPXACT/1685-2022") | None) => Some(DataRecord(ns, key, xsns, xstype, fromXML[IPXACT2022ScalaCases.AccessPolicies](elem)))
      case (Some("readResponse"), Some("http://www.accellera.org/XMLSchema/IPXACT/1685-2022") | None) => Some(DataRecord(ns, key, xsns, xstype, fromXML[IPXACT2022ScalaCases.UnsignedBitVectorExpressionable](elem)))
      case (Some("writeValueConstraint"), Some("http://www.accellera.org/XMLSchema/IPXACT/1685-2022") | None) => Some(DataRecord(ns, key, xsns, xstype, fromXML[IPXACT2022ScalaCases.WriteValueConstraintType](elem)))
      case (Some("access"), Some("http://www.accellera.org/XMLSchema/IPXACT/1685-2022") | None) => Some(DataRecord(ns, key, xsns, xstype, fromXML[IPXACT2022ScalaCases.AccessType](elem)))
      case (Some("modeRef"), Some("http://www.accellera.org/XMLSchema/IPXACT/1685-2022") | None) => Some(DataRecord(ns, key, xsns, xstype, fromXML[IPXACT2022ScalaCases.ModeRef3](elem)))
      case (Some("memoryMapDefinitions"), Some("http://www.accellera.org/XMLSchema/IPXACT/1685-2022") | None) => Some(DataRecord(ns, key, xsns, xstype, fromXML[IPXACT2022ScalaCases.MemoryMapDefinitions](elem)))
      case (Some("addressBlockDefinitions"), Some("http://www.accellera.org/XMLSchema/IPXACT/1685-2022") | None) => Some(DataRecord(ns, key, xsns, xstype, fromXML[IPXACT2022ScalaCases.AddressBlockDefinitions](elem)))
      case (Some("registerDefinitions"), Some("http://www.accellera.org/XMLSchema/IPXACT/1685-2022") | None) => Some(DataRecord(ns, key, xsns, xstype, fromXML[IPXACT2022ScalaCases.RegisterDefinitions](elem)))
      case (Some("fieldAccessPolicyDefinitions"), Some("http://www.accellera.org/XMLSchema/IPXACT/1685-2022") | None) => Some(DataRecord(ns, key, xsns, xstype, fromXML[IPXACT2022ScalaCases.FieldAccessPolicyDefinitions](elem)))
      case (Some("externalTypeDefinitions"), Some("http://www.accellera.org/XMLSchema/IPXACT/1685-2022") | None) => Some(DataRecord(ns, key, xsns, xstype, fromXML[IPXACT2022ScalaCases.ExternalTypeDefinitions](elem)))
      case (Some("registerFile"), Some("http://www.accellera.org/XMLSchema/IPXACT/1685-2022") | None) => Some(DataRecord(ns, key, xsns, xstype, fromXML[IPXACT2022ScalaCases.RegisterFile](elem)))
      case (Some("alternateRegisters"), Some("http://www.accellera.org/XMLSchema/IPXACT/1685-2022") | None) => Some(DataRecord(ns, key, xsns, xstype, fromXML[IPXACT2022ScalaCases.AlternateRegisters](elem)))
      case (Some("stride"), Some("http://www.accellera.org/XMLSchema/IPXACT/1685-2022") | None) => Some(DataRecord(ns, key, xsns, xstype, fromXML[IPXACT2022ScalaCases.Stride](elem)))
      case (Some("addressUnitBits"), Some("http://www.accellera.org/XMLSchema/IPXACT/1685-2022") | None) => Some(DataRecord(ns, key, xsns, xstype, fromXML[IPXACT2022ScalaCases.UnsignedPositiveLongintExpressionable](elem)))
      case (Some("bank"), Some("http://www.accellera.org/XMLSchema/IPXACT/1685-2022") | None) => Some(DataRecord(ns, key, xsns, xstype, fromXML[IPXACT2022ScalaCases.AddressBankType](elem)))
      case (Some("memoryMapRef"), Some("http://www.accellera.org/XMLSchema/IPXACT/1685-2022") | None) => Some(DataRecord(ns, key, xsns, xstype, fromXML[IPXACT2022ScalaCases.MemoryMapRefType](elem)))
      case (Some("addressBlock"), Some("http://www.accellera.org/XMLSchema/IPXACT/1685-2022") | None) => Some(DataRecord(ns, key, xsns, xstype, fromXML[IPXACT2022ScalaCases.AddressBlockType](elem)))
      case (Some("volatile"), Some("http://www.accellera.org/XMLSchema/IPXACT/1685-2022") | None) => Some(DataRecord(ns, key, xsns, xstype, fromXML[Boolean](elem)))
      case (Some("subspaceMap"), Some("http://www.accellera.org/XMLSchema/IPXACT/1685-2022") | None) => Some(DataRecord(ns, key, xsns, xstype, fromXML[IPXACT2022ScalaCases.SubspaceRefType](elem)))
      case (Some("memoryRemap"), Some("http://www.accellera.org/XMLSchema/IPXACT/1685-2022") | None) => Some(DataRecord(ns, key, xsns, xstype, fromXML[IPXACT2022ScalaCases.MemoryRemapType](elem)))
      case (Some("fieldAccessPolicyDefinitionRef"), Some("http://www.accellera.org/XMLSchema/IPXACT/1685-2022") | None) => Some(DataRecord(ns, key, xsns, xstype, fromXML[IPXACT2022ScalaCases.FieldAccessPolicyDefinitionRef](elem)))
      case (Some("addressSpaces"), Some("http://www.accellera.org/XMLSchema/IPXACT/1685-2022") | None) => Some(DataRecord(ns, key, xsns, xstype, fromXML[IPXACT2022ScalaCases.AddressSpaces](elem)))
      case (Some("memoryMaps"), Some("http://www.accellera.org/XMLSchema/IPXACT/1685-2022") | None) => Some(DataRecord(ns, key, xsns, xstype, fromXML[IPXACT2022ScalaCases.MemoryMaps](elem)))
      case (Some("baseAddress"), Some("http://www.accellera.org/XMLSchema/IPXACT/1685-2022") | None) => Some(DataRecord(ns, key, xsns, xstype, fromXML[IPXACT2022ScalaCases.UnsignedLongintExpressionable](elem)))
      case (Some("dim"), Some("http://www.accellera.org/XMLSchema/IPXACT/1685-2022") | None) => Some(DataRecord(ns, key, xsns, xstype, fromXML[IPXACT2022ScalaCases.Dim](elem)))
      case (Some("bitStride"), Some("http://www.accellera.org/XMLSchema/IPXACT/1685-2022") | None) => Some(DataRecord(ns, key, xsns, xstype, fromXML[IPXACT2022ScalaCases.BitStride](elem)))
      case (Some("enumeratedValues"), Some("http://www.accellera.org/XMLSchema/IPXACT/1685-2022") | None) => Some(DataRecord(ns, key, xsns, xstype, fromXML[IPXACT2022ScalaCases.EnumeratedValues](elem)))
      case (Some("reset"), Some("http://www.accellera.org/XMLSchema/IPXACT/1685-2022") | None) => Some(DataRecord(ns, key, xsns, xstype, fromXML[IPXACT2022ScalaCases.Reset](elem)))
      case (Some("enumerationDefinitions"), Some("http://www.accellera.org/XMLSchema/IPXACT/1685-2022") | None) => Some(DataRecord(ns, key, xsns, xstype, fromXML[IPXACT2022ScalaCases.EnumerationDefinitions](elem)))
      case (Some("fieldDefinitions"), Some("http://www.accellera.org/XMLSchema/IPXACT/1685-2022") | None) => Some(DataRecord(ns, key, xsns, xstype, fromXML[IPXACT2022ScalaCases.FieldDefinitions](elem)))
      case (Some("registerFileDefinitions"), Some("http://www.accellera.org/XMLSchema/IPXACT/1685-2022") | None) => Some(DataRecord(ns, key, xsns, xstype, fromXML[IPXACT2022ScalaCases.RegisterFileDefinitions](elem)))
      case (Some("bankDefinitions"), Some("http://www.accellera.org/XMLSchema/IPXACT/1685-2022") | None) => Some(DataRecord(ns, key, xsns, xstype, fromXML[IPXACT2022ScalaCases.BankDefinitions](elem)))
      case (Some("memoryRemapDefinitions"), Some("http://www.accellera.org/XMLSchema/IPXACT/1685-2022") | None) => Some(DataRecord(ns, key, xsns, xstype, fromXML[IPXACT2022ScalaCases.MemoryRemapDefinitions](elem)))
      case (Some("array"), Some("http://www.accellera.org/XMLSchema/IPXACT/1685-2022") | None) => Some(DataRecord(ns, key, xsns, xstype, fromXML[IPXACT2022ScalaCases.ArrayType4](elem)))
      case (Some("modifiedWriteValue"), Some("http://www.accellera.org/XMLSchema/IPXACT/1685-2022") | None) => Some(DataRecord(ns, key, xsns, xstype, fromXML[IPXACT2022ScalaCases.ModifiedWriteValue](elem)))
      case (Some("readAction"), Some("http://www.accellera.org/XMLSchema/IPXACT/1685-2022") | None) => Some(DataRecord(ns, key, xsns, xstype, fromXML[IPXACT2022ScalaCases.ReadAction](elem)))
      case (Some("accessRestrictions"), Some("http://www.accellera.org/XMLSchema/IPXACT/1685-2022") | None) => Some(DataRecord(ns, key, xsns, xstype, fromXML[IPXACT2022ScalaCases.AccessRestrictionsType](elem)))
      case (Some("model"), Some("http://www.accellera.org/XMLSchema/IPXACT/1685-2022") | None) => Some(DataRecord(ns, key, xsns, xstype, fromXML[IPXACT2022ScalaCases.ModelType](elem)))
      case (Some("alwaysOn"), Some("http://www.accellera.org/XMLSchema/IPXACT/1685-2022") | None) => Some(DataRecord(ns, key, xsns, xstype, fromXML[IPXACT2022ScalaCases.UnsignedBitExpression](elem)))
      case (Some("structPortTypeDefs"), Some("http://www.accellera.org/XMLSchema/IPXACT/1685-2022") | None) => Some(DataRecord(ns, key, xsns, xstype, fromXML[IPXACT2022ScalaCases.StructPortTypeDefs](elem)))
      case (Some("signalTypeDefs"), Some("http://www.accellera.org/XMLSchema/IPXACT/1685-2022") | None) => Some(DataRecord(ns, key, xsns, xstype, fromXML[IPXACT2022ScalaCases.SignalTypeDefs](elem)))
      case (Some("domainTypeDef"), Some("http://www.accellera.org/XMLSchema/IPXACT/1685-2022") | None) => Some(DataRecord(ns, key, xsns, xstype, fromXML[IPXACT2022ScalaCases.DomainTypeDef](elem)))
      case (Some("fieldMaps"), Some("http://www.accellera.org/XMLSchema/IPXACT/1685-2022") | None) => Some(DataRecord(ns, key, xsns, xstype, fromXML[IPXACT2022ScalaCases.FieldMaps](elem)))
      case (Some("port"), Some("http://www.accellera.org/XMLSchema/IPXACT/1685-2022") | None) => Some(DataRecord(ns, key, xsns, xstype, fromXML[IPXACT2022ScalaCases.Port2](elem)))
      case (Some("wireTypeDefs"), Some("http://www.accellera.org/XMLSchema/IPXACT/1685-2022") | None) => Some(DataRecord(ns, key, xsns, xstype, fromXML[IPXACT2022ScalaCases.WireTypeDefs](elem)))
      case (Some("serviceTypeDef"), Some("http://www.accellera.org/XMLSchema/IPXACT/1685-2022") | None) => Some(DataRecord(ns, key, xsns, xstype, fromXML[IPXACT2022ScalaCases.ServiceTypeDef](elem)))
      case (Some("typeParameter"), Some("http://www.accellera.org/XMLSchema/IPXACT/1685-2022") | None) => Some(DataRecord(ns, key, xsns, xstype, fromXML[IPXACT2022ScalaCases.ModuleParameterType](elem)))
      case (Some("payload"), Some("http://www.accellera.org/XMLSchema/IPXACT/1685-2022") | None) => Some(DataRecord(ns, key, xsns, xstype, fromXML[IPXACT2022ScalaCases.Payload](elem)))
      case (Some("kind"), Some("http://www.accellera.org/XMLSchema/IPXACT/1685-2022") | None) => Some(DataRecord(ns, key, xsns, xstype, fromXML[IPXACT2022ScalaCases.Kind](elem)))
      case (Some("busWidth"), Some("http://www.accellera.org/XMLSchema/IPXACT/1685-2022") | None) => Some(DataRecord(ns, key, xsns, xstype, fromXML[IPXACT2022ScalaCases.UnsignedIntExpressionable](elem)))
      case (Some("initiative"), Some("http://www.accellera.org/XMLSchema/IPXACT/1685-2022") | None) => Some(DataRecord(ns, key, xsns, xstype, fromXML[IPXACT2022ScalaCases.InitiativeType](elem)))
      case (Some("protocol"), Some("http://www.accellera.org/XMLSchema/IPXACT/1685-2022") | None) => Some(DataRecord(ns, key, xsns, xstype, fromXML[IPXACT2022ScalaCases.Protocol](elem)))
      case (Some("portAccessType"), Some("http://www.accellera.org/XMLSchema/IPXACT/1685-2022") | None) => Some(DataRecord(ns, key, xsns, xstype, fromXML[IPXACT2022ScalaCases.SimplePortAccessType](elem)))
      case (Some("typeParameters"), Some("http://www.accellera.org/XMLSchema/IPXACT/1685-2022") | None) => Some(DataRecord(ns, key, xsns, xstype, fromXML[IPXACT2022ScalaCases.TypeParameters](elem)))
      case (Some("transTypeDef"), Some("http://www.accellera.org/XMLSchema/IPXACT/1685-2022") | None) => Some(DataRecord(ns, key, xsns, xstype, fromXML[IPXACT2022ScalaCases.TransTypeDef](elem)))
      case (Some("wireTypeDef"), Some("http://www.accellera.org/XMLSchema/IPXACT/1685-2022") | None) => Some(DataRecord(ns, key, xsns, xstype, fromXML[IPXACT2022ScalaCases.WireTypeDef](elem)))
      case (Some("transTypeDefs"), Some("http://www.accellera.org/XMLSchema/IPXACT/1685-2022") | None) => Some(DataRecord(ns, key, xsns, xstype, fromXML[IPXACT2022ScalaCases.TransTypeDefs](elem)))
      case (Some("fieldMap"), Some("http://www.accellera.org/XMLSchema/IPXACT/1685-2022") | None) => Some(DataRecord(ns, key, xsns, xstype, fromXML[IPXACT2022ScalaCases.FieldMap](elem)))
      case (Some("signalTypeDef"), Some("http://www.accellera.org/XMLSchema/IPXACT/1685-2022") | None) => Some(DataRecord(ns, key, xsns, xstype, fromXML[IPXACT2022ScalaCases.SignalTypeDef](elem)))
      case (Some("domainTypeDefs"), Some("http://www.accellera.org/XMLSchema/IPXACT/1685-2022") | None) => Some(DataRecord(ns, key, xsns, xstype, fromXML[IPXACT2022ScalaCases.DomainTypeDefs](elem)))
      case (Some("arrays"), Some("http://www.accellera.org/XMLSchema/IPXACT/1685-2022") | None) => Some(DataRecord(ns, key, xsns, xstype, fromXML[IPXACT2022ScalaCases.Arrays](elem)))
      case (Some("powerDomainRef"), Some("http://www.accellera.org/XMLSchema/IPXACT/1685-2022") | None) => Some(DataRecord(ns, key, xsns, xstype, fromXML[String](elem)))
      case (Some("otherClockDriver"), Some("http://www.accellera.org/XMLSchema/IPXACT/1685-2022") | None) => Some(DataRecord(ns, key, xsns, xstype, fromXML[IPXACT2022ScalaCases.OtherClockDriver](elem)))
      case (Some("drivers"), Some("http://www.accellera.org/XMLSchema/IPXACT/1685-2022") | None) => Some(DataRecord(ns, key, xsns, xstype, fromXML[IPXACT2022ScalaCases.Drivers](elem)))
      case (Some("singleShotDriver"), Some("http://www.accellera.org/XMLSchema/IPXACT/1685-2022") | None) => Some(DataRecord(ns, key, xsns, xstype, fromXML[IPXACT2022ScalaCases.SingleShotDriver](elem)))
      case (Some("defaultValue"), Some("http://www.accellera.org/XMLSchema/IPXACT/1685-2022") | None) => Some(DataRecord(ns, key, xsns, xstype, fromXML[IPXACT2022ScalaCases.QualifiedExpression](elem)))
      case (Some("clockDriver"), Some("http://www.accellera.org/XMLSchema/IPXACT/1685-2022") | None) => Some(DataRecord(ns, key, xsns, xstype, fromXML[IPXACT2022ScalaCases.ClockDriver](elem)))
      case (Some("requiresDriver"), Some("http://www.accellera.org/XMLSchema/IPXACT/1685-2022") | None) => Some(DataRecord(ns, key, xsns, xstype, fromXML[IPXACT2022ScalaCases.RequiresDriver](elem)))
      case (Some("driver"), Some("http://www.accellera.org/XMLSchema/IPXACT/1685-2022") | None) => Some(DataRecord(ns, key, xsns, xstype, fromXML[IPXACT2022ScalaCases.DriverType](elem)))
      case (Some("powerDomainLinks"), Some("http://www.accellera.org/XMLSchema/IPXACT/1685-2022") | None) => Some(DataRecord(ns, key, xsns, xstype, fromXML[IPXACT2022ScalaCases.PowerDomainLinks](elem)))
      case (Some("externalPortReference"), Some("http://www.accellera.org/XMLSchema/IPXACT/1685-2022") | None) => Some(DataRecord(ns, key, xsns, xstype, fromXML[IPXACT2022ScalaCases.ExternalPortReference](elem)))
      case (Some("monitorInterconnection"), Some("http://www.accellera.org/XMLSchema/IPXACT/1685-2022") | None) => Some(DataRecord(ns, key, xsns, xstype, fromXML[IPXACT2022ScalaCases.MonitorInterconnection](elem)))
      case (Some("adHocConnections"), Some("http://www.accellera.org/XMLSchema/IPXACT/1685-2022") | None) => Some(DataRecord(ns, key, xsns, xstype, fromXML[IPXACT2022ScalaCases.AdHocConnections](elem)))
      case (Some("componentInstances"), Some("http://www.accellera.org/XMLSchema/IPXACT/1685-2022") | None) => Some(DataRecord(ns, key, xsns, xstype, fromXML[IPXACT2022ScalaCases.ComponentInstances](elem)))
      case (Some("instanceName"), Some("http://www.accellera.org/XMLSchema/IPXACT/1685-2022") | None) => Some(DataRecord(ns, key, xsns, xstype, fromXML[String](elem)))
      case (Some("configurableElementValues"), Some("http://www.accellera.org/XMLSchema/IPXACT/1685-2022") | None) => Some(DataRecord(ns, key, xsns, xstype, fromXML[IPXACT2022ScalaCases.ConfigurableElementValues](elem)))
      case (Some("configurableElementValue"), Some("http://www.accellera.org/XMLSchema/IPXACT/1685-2022") | None) => Some(DataRecord(ns, key, xsns, xstype, fromXML[IPXACT2022ScalaCases.ConfigurableElementValue](elem)))
      case (Some("componentInstance"), Some("http://www.accellera.org/XMLSchema/IPXACT/1685-2022") | None) => Some(DataRecord(ns, key, xsns, xstype, fromXML[IPXACT2022ScalaCases.ComponentInstance](elem)))
      case (Some("adHocConnection"), Some("http://www.accellera.org/XMLSchema/IPXACT/1685-2022") | None) => Some(DataRecord(ns, key, xsns, xstype, fromXML[IPXACT2022ScalaCases.AdHocConnection](elem)))
      case (Some("interconnection"), Some("http://www.accellera.org/XMLSchema/IPXACT/1685-2022") | None) => Some(DataRecord(ns, key, xsns, xstype, fromXML[IPXACT2022ScalaCases.Interconnection](elem)))
      case (Some("interconnections"), Some("http://www.accellera.org/XMLSchema/IPXACT/1685-2022") | None) => Some(DataRecord(ns, key, xsns, xstype, fromXML[IPXACT2022ScalaCases.Interconnections](elem)))
      case (Some("activeInterface"), Some("http://www.accellera.org/XMLSchema/IPXACT/1685-2022") | None) => Some(DataRecord(ns, key, xsns, xstype, fromXML[IPXACT2022ScalaCases.ActiveInterface](elem)))
      case (Some("typeDefinitions"), Some("http://www.accellera.org/XMLSchema/IPXACT/1685-2022") | None) => Some(DataRecord(ns, key, xsns, xstype, fromXML[IPXACT2022ScalaCases.TypeDefinitions2](elem)))

      case _ => None
    }

  }

  def buildIPXACT2022ScalaCases_PresenceTypeFormat = new DefaultIPXACT2022ScalaCases_PresenceTypeFormat {}
  trait DefaultIPXACT2022ScalaCases_PresenceTypeFormat extends IPXACT2022scalaxb.XMLFormat[IPXACT2022ScalaCases.PresenceType] {
    val targetNamespace: Option[String] = Some("http://www.accellera.org/XMLSchema/IPXACT/1685-2022")
    
    def fromString(value: String, scope: scala.xml.NamespaceBinding): IPXACT2022ScalaCases.PresenceType =
        (fromString0(value, scope)).apply(IPXACT2022scalaxb.fromXML[String](scala.xml.Text(value)))

    private def fromString0(value: String, scope: scala.xml.NamespaceBinding): PartialFunction[Any, IPXACT2022ScalaCases.PresenceType] = {
      case x: String if x == IPXACT2022scalaxb.fromXML[String](scala.xml.Text("required")) => IPXACT2022ScalaCases.Required
      case x: String if x == IPXACT2022scalaxb.fromXML[String](scala.xml.Text("illegal")) => IPXACT2022ScalaCases.Illegal
      case x: String if x == IPXACT2022scalaxb.fromXML[String](scala.xml.Text("optional")) => IPXACT2022ScalaCases.Optional

    }



    def reads(seq: scala.xml.NodeSeq, stack: List[IPXACT2022scalaxb.ElemName]): Either[String, IPXACT2022ScalaCases.PresenceType] = seq match {
      case elem: scala.xml.Elem => Right(fromString(elem.text, elem.scope))
      case _ => Right(fromString(seq.text, scala.xml.TopScope))
    }
    
    def writes(__obj: IPXACT2022ScalaCases.PresenceType, __namespace: Option[String], __elementLabel: Option[String],
        __scope: scala.xml.NamespaceBinding, __typeAttribute: Boolean): scala.xml.NodeSeq =
      scala.xml.Elem(IPXACT2022scalaxb.Helper.getPrefix(__namespace, __scope).orNull,
        __elementLabel getOrElse { sys.error("missing element label.") },
        scala.xml.Null, __scope, true, scala.xml.Text(__obj.toString))
  }
  def buildIPXACT2022ScalaCases_DirectionFormat = new DefaultIPXACT2022ScalaCases_DirectionFormat {}
  trait DefaultIPXACT2022ScalaCases_DirectionFormat extends IPXACT2022scalaxb.XMLFormat[IPXACT2022ScalaCases.Direction] {
    val targetNamespace: Option[String] = Some("http://www.accellera.org/XMLSchema/IPXACT/1685-2022")
    
    def fromString(value: String, scope: scala.xml.NamespaceBinding): IPXACT2022ScalaCases.Direction =
        (fromString0(value, scope)).apply(IPXACT2022scalaxb.fromXML[String](scala.xml.Text(value)))

    private def fromString0(value: String, scope: scala.xml.NamespaceBinding): PartialFunction[Any, IPXACT2022ScalaCases.Direction] = {
      case x: String if x == IPXACT2022scalaxb.fromXML[String](scala.xml.Text("in")) => IPXACT2022ScalaCases.In
      case x: String if x == IPXACT2022scalaxb.fromXML[String](scala.xml.Text("out")) => IPXACT2022ScalaCases.Out
      case x: String if x == IPXACT2022scalaxb.fromXML[String](scala.xml.Text("inout")) => IPXACT2022ScalaCases.Inout

    }



    def reads(seq: scala.xml.NodeSeq, stack: List[IPXACT2022scalaxb.ElemName]): Either[String, IPXACT2022ScalaCases.Direction] = seq match {
      case elem: scala.xml.Elem => Right(fromString(elem.text, elem.scope))
      case _ => Right(fromString(seq.text, scala.xml.TopScope))
    }
    
    def writes(__obj: IPXACT2022ScalaCases.Direction, __namespace: Option[String], __elementLabel: Option[String],
        __scope: scala.xml.NamespaceBinding, __typeAttribute: Boolean): scala.xml.NodeSeq =
      scala.xml.Elem(IPXACT2022scalaxb.Helper.getPrefix(__namespace, __scope).orNull,
        __elementLabel getOrElse { sys.error("missing element label.") },
        scala.xml.Null, __scope, true, scala.xml.Text(__obj.toString))
  }
  def buildIPXACT2022ScalaCases_InitiativeFormat = new DefaultIPXACT2022ScalaCases_InitiativeFormat {}
  trait DefaultIPXACT2022ScalaCases_InitiativeFormat extends IPXACT2022scalaxb.XMLFormat[IPXACT2022ScalaCases.Initiative] {
    val targetNamespace: Option[String] = Some("http://www.accellera.org/XMLSchema/IPXACT/1685-2022")
    
    def fromString(value: String, scope: scala.xml.NamespaceBinding): IPXACT2022ScalaCases.Initiative =
        (fromString0(value, scope)).apply(IPXACT2022scalaxb.fromXML[String](scala.xml.Text(value)))

    private def fromString0(value: String, scope: scala.xml.NamespaceBinding): PartialFunction[Any, IPXACT2022ScalaCases.Initiative] = {
      case x: String if x == IPXACT2022scalaxb.fromXML[String](scala.xml.Text("requires")) => IPXACT2022ScalaCases.RequiresValue
      case x: String if x == IPXACT2022scalaxb.fromXML[String](scala.xml.Text("provides")) => IPXACT2022ScalaCases.ProvidesValue
      case x: String if x == IPXACT2022scalaxb.fromXML[String](scala.xml.Text("both")) => IPXACT2022ScalaCases.BothValue

    }



    def reads(seq: scala.xml.NodeSeq, stack: List[IPXACT2022scalaxb.ElemName]): Either[String, IPXACT2022ScalaCases.Initiative] = seq match {
      case elem: scala.xml.Elem => Right(fromString(elem.text, elem.scope))
      case _ => Right(fromString(seq.text, scala.xml.TopScope))
    }
    
    def writes(__obj: IPXACT2022ScalaCases.Initiative, __namespace: Option[String], __elementLabel: Option[String],
        __scope: scala.xml.NamespaceBinding, __typeAttribute: Boolean): scala.xml.NodeSeq =
      scala.xml.Elem(IPXACT2022scalaxb.Helper.getPrefix(__namespace, __scope).orNull,
        __elementLabel getOrElse { sys.error("missing element label.") },
        scala.xml.Null, __scope, true, scala.xml.Text(__obj.toString))
  }
  trait DefaultIPXACT2022ScalaCases_WidthFormat extends IPXACT2022scalaxb.ElemNameParser[IPXACT2022ScalaCases.Width] {
    val targetNamespace: Option[String] = Some("http://www.accellera.org/XMLSchema/IPXACT/1685-2022")
    
    def parser(node: scala.xml.Node, stack: List[IPXACT2022scalaxb.ElemName]): Parser[IPXACT2022ScalaCases.Width] =
      phrase((IPXACT2022scalaxb.ElemName(None, "value")) ^^
      { case p1 =>
      IPXACT2022ScalaCases.Width(IPXACT2022scalaxb.fromXML[String](p1, IPXACT2022scalaxb.ElemName(node) :: stack),
        scala.collection.immutable.ListMap(List(
        (node \ "@minimum").headOption map { x => IPXACT2022scalaxb.DataRecord(x, node, IPXACT2022scalaxb.fromXML[Int](x, IPXACT2022scalaxb.ElemName(node) :: stack)) } map { "@minimum" -> _ },
        (node \ "@maximum").headOption map { x => IPXACT2022scalaxb.DataRecord(x, node, IPXACT2022scalaxb.fromXML[Int](x, IPXACT2022scalaxb.ElemName(node) :: stack)) } map { "@maximum" -> _ },
        (node \ "@allBits").headOption map { x => IPXACT2022scalaxb.DataRecord(x, node, IPXACT2022scalaxb.fromXML[Boolean](x, IPXACT2022scalaxb.ElemName(node) :: stack)) } orElse Some(IPXACT2022scalaxb.DataRecord(None, None, IPXACT2022scalaxb.fromXML[Boolean](scala.xml.Text("false"), IPXACT2022scalaxb.ElemName(node) :: stack))) map { "@allBits" -> _ }
        ).flatten[(String, IPXACT2022scalaxb.DataRecord[Any])] ::: (node match {
          case elem: scala.xml.Elem =>
            elem.attributes.toList flatMap {
              case scala.xml.UnprefixedAttribute(key, value, _) if key == "minimum" => Nil
              case scala.xml.UnprefixedAttribute(key, value, _) if key == "maximum" => Nil
              case scala.xml.UnprefixedAttribute(key, value, _) if key == "allBits" => Nil
              case scala.xml.UnprefixedAttribute(key, value, _) =>
                List(("@" + key, IPXACT2022scalaxb.DataRecord(None, Some(key), value.text)))
              case scala.xml.PrefixedAttribute(pre, key, value, _) =>
                val ns = elem.scope.getURI(pre)
                List(("@{" + ns + "}" + key, IPXACT2022scalaxb.DataRecord(Option[String](ns), Some(key), value.text)))
              case _ => Nil
            }
          case _ => Nil
        }): _*)) })
    
    override def writesAttribute(__obj: IPXACT2022ScalaCases.Width, __scope: scala.xml.NamespaceBinding): scala.xml.MetaData = {
      var attr: scala.xml.MetaData  = scala.xml.Null
      __obj.attributes.toList map {
        case ("@minimum", _) => __obj.minimum foreach { x => attr = scala.xml.Attribute(null, "minimum", x.toString, attr) }
        case ("@maximum", _) => __obj.maximum foreach { x => attr = scala.xml.Attribute(null, "maximum", x.toString, attr) }
        case ("@allBits", _) => if (__obj.allBits.toString != "false") attr = scala.xml.Attribute(null, "allBits", __obj.allBits.toString, attr)
        case (key, x) => attr = scala.xml.Attribute((x.namespace map { __scope.getPrefix(_) }).orNull, x.key.orNull, x.value.toString, attr)
      }
      attr
    }

    def writesChildNodes(__obj: IPXACT2022ScalaCases.Width, __scope: scala.xml.NamespaceBinding): Seq[scala.xml.Node] =
      (IPXACT2022scalaxb.toXML[String](__obj.value, None, Some("value"), __scope, false))
  }

  trait DefaultIPXACT2022ScalaCases_OnSystemFormat extends IPXACT2022scalaxb.ElemNameParser[IPXACT2022ScalaCases.OnSystem] with IPXACT2022ScalaCases_TransactionalPortGroupFormat {
    val targetNamespace: Option[String] = Some("http://www.accellera.org/XMLSchema/IPXACT/1685-2022")
    
    def parser(node: scala.xml.Node, stack: List[IPXACT2022scalaxb.ElemName]): Parser[IPXACT2022ScalaCases.OnSystem] =
      phrase((IPXACT2022scalaxb.ElemName(Some("http://www.accellera.org/XMLSchema/IPXACT/1685-2022"), "group")) ~
      (parseTransactionalPortGroup(node, IPXACT2022scalaxb.ElemName(node) :: stack)) ^^
      { case p1 ~ p2 =>
      IPXACT2022ScalaCases.OnSystem(IPXACT2022scalaxb.fromXML[String](p1, IPXACT2022scalaxb.ElemName(node) :: stack),
        p2,
        scala.collection.immutable.ListMap(List(
        (node \ "@{http://www.w3.org/XML/1998/namespace}id").headOption map { x => IPXACT2022scalaxb.DataRecord(x, node, IPXACT2022scalaxb.fromXML[String](x, IPXACT2022scalaxb.ElemName(node) :: stack)) } map { "@{http://www.w3.org/XML/1998/namespace}id" -> _ }
        ).flatten[(String, IPXACT2022scalaxb.DataRecord[Any])]: _*)) })
    
    override def writesAttribute(__obj: IPXACT2022ScalaCases.OnSystem, __scope: scala.xml.NamespaceBinding): scala.xml.MetaData = {
      var attr: scala.xml.MetaData  = scala.xml.Null
      __obj.attributes.toList map {
        case ("@{http://www.w3.org/XML/1998/namespace}id", _) => __obj.xmlid foreach { x => attr = scala.xml.Attribute(__scope.getPrefix("http://www.w3.org/XML/1998/namespace"), "id", x.toString, attr) }
        case (key, x) => attr = scala.xml.Attribute((x.namespace map { __scope.getPrefix(_) }).orNull, x.key.orNull, x.value.toString, attr)
      }
      attr
    }

    def writesChildNodes(__obj: IPXACT2022ScalaCases.OnSystem, __scope: scala.xml.NamespaceBinding): Seq[scala.xml.Node] =
      Seq.concat(IPXACT2022scalaxb.toXML[String](__obj.group, Some("http://www.accellera.org/XMLSchema/IPXACT/1685-2022"), Some("group"), __scope, false),
        IPXACT2022scalaxb.toXML[IPXACT2022ScalaCases.TransactionalPortSequence](__obj.transactionalPortSequence2, None, Some("transactionalPortSequence2"), __scope, false))

  }

  trait DefaultIPXACT2022ScalaCases_OnInitiatorFormat extends IPXACT2022scalaxb.ElemNameParser[IPXACT2022ScalaCases.OnInitiator] with IPXACT2022ScalaCases_TransactionalPortGroupFormat {
    val targetNamespace: Option[String] = Some("http://www.accellera.org/XMLSchema/IPXACT/1685-2022")
    
    def parser(node: scala.xml.Node, stack: List[IPXACT2022scalaxb.ElemName]): Parser[IPXACT2022ScalaCases.OnInitiator] =
      phrase((parseTransactionalPortGroup(node, IPXACT2022scalaxb.ElemName(node) :: stack)) ^^
      { case p1 =>
      IPXACT2022ScalaCases.OnInitiator(p1) })
    
    def writesChildNodes(__obj: IPXACT2022ScalaCases.OnInitiator, __scope: scala.xml.NamespaceBinding): Seq[scala.xml.Node] =
      (IPXACT2022scalaxb.toXML[IPXACT2022ScalaCases.TransactionalPortSequence](__obj.transactionalPortSequence1, None, Some("transactionalPortSequence1"), __scope, false))
  }
  trait DefaultIPXACT2022ScalaCases_OnTargetFormat extends IPXACT2022scalaxb.ElemNameParser[IPXACT2022ScalaCases.OnTarget] with IPXACT2022ScalaCases_TransactionalPortGroupFormat {
    val targetNamespace: Option[String] = Some("http://www.accellera.org/XMLSchema/IPXACT/1685-2022")
    
    def parser(node: scala.xml.Node, stack: List[IPXACT2022scalaxb.ElemName]): Parser[IPXACT2022ScalaCases.OnTarget] =
      phrase((parseTransactionalPortGroup(node, IPXACT2022scalaxb.ElemName(node) :: stack)) ^^
      { case p1 =>
      IPXACT2022ScalaCases.OnTarget(p1) })
    
    def writesChildNodes(__obj: IPXACT2022ScalaCases.OnTarget, __scope: scala.xml.NamespaceBinding): Seq[scala.xml.Node] =
      (IPXACT2022scalaxb.toXML[IPXACT2022ScalaCases.TransactionalPortSequence](__obj.transactionalPortSequence1, None, Some("transactionalPortSequence1"), __scope, false))
  }
  trait DefaultIPXACT2022ScalaCases_TransactionalFormat extends IPXACT2022scalaxb.ElemNameParser[IPXACT2022ScalaCases.Transactional] {
    val targetNamespace: Option[String] = Some("http://www.accellera.org/XMLSchema/IPXACT/1685-2022")
    
    def parser(node: scala.xml.Node, stack: List[IPXACT2022scalaxb.ElemName]): Parser[IPXACT2022ScalaCases.Transactional] =
      phrase(opt(IPXACT2022scalaxb.ElemName(Some("http://www.accellera.org/XMLSchema/IPXACT/1685-2022"), "qualifier")) ~
      safeRep(IPXACT2022scalaxb.ElemName(Some("http://www.accellera.org/XMLSchema/IPXACT/1685-2022"), "onSystem")) ~
      opt(IPXACT2022scalaxb.ElemName(Some("http://www.accellera.org/XMLSchema/IPXACT/1685-2022"), "onInitiator")) ~
      opt(IPXACT2022scalaxb.ElemName(Some("http://www.accellera.org/XMLSchema/IPXACT/1685-2022"), "onTarget")) ^^
      { case p1 ~ p2 ~ p3 ~ p4 =>
      IPXACT2022ScalaCases.Transactional(p1.headOption map { IPXACT2022scalaxb.fromXML[IPXACT2022ScalaCases.QualifierType](_, IPXACT2022scalaxb.ElemName(node) :: stack) },
        p2 map { IPXACT2022scalaxb.fromXML[IPXACT2022ScalaCases.OnSystem](_, IPXACT2022scalaxb.ElemName(node) :: stack) },
        p3.headOption map { IPXACT2022scalaxb.fromXML[IPXACT2022ScalaCases.OnInitiator](_, IPXACT2022scalaxb.ElemName(node) :: stack) },
        p4.headOption map { IPXACT2022scalaxb.fromXML[IPXACT2022ScalaCases.OnTarget](_, IPXACT2022scalaxb.ElemName(node) :: stack) }) })
    
    def writesChildNodes(__obj: IPXACT2022ScalaCases.Transactional, __scope: scala.xml.NamespaceBinding): Seq[scala.xml.Node] =
      Seq.concat(__obj.qualifier map { IPXACT2022scalaxb.toXML[IPXACT2022ScalaCases.QualifierType](_, Some("http://www.accellera.org/XMLSchema/IPXACT/1685-2022"), Some("qualifier"), __scope, false) } getOrElse {Nil},
        __obj.onSystem flatMap { IPXACT2022scalaxb.toXML[IPXACT2022ScalaCases.OnSystem](_, Some("http://www.accellera.org/XMLSchema/IPXACT/1685-2022"), Some("onSystem"), __scope, false) },
        __obj.onInitiator map { IPXACT2022scalaxb.toXML[IPXACT2022ScalaCases.OnInitiator](_, Some("http://www.accellera.org/XMLSchema/IPXACT/1685-2022"), Some("onInitiator"), __scope, false) } getOrElse {Nil},
        __obj.onTarget map { IPXACT2022scalaxb.toXML[IPXACT2022ScalaCases.OnTarget](_, Some("http://www.accellera.org/XMLSchema/IPXACT/1685-2022"), Some("onTarget"), __scope, false) } getOrElse {Nil})

  }

  trait DefaultIPXACT2022ScalaCases_PortFormat extends IPXACT2022scalaxb.ElemNameParser[IPXACT2022ScalaCases.Port] {
    val targetNamespace: Option[String] = Some("http://www.accellera.org/XMLSchema/IPXACT/1685-2022")
    
    def parser(node: scala.xml.Node, stack: List[IPXACT2022scalaxb.ElemName]): Parser[IPXACT2022ScalaCases.Port] =
      phrase((IPXACT2022scalaxb.ElemName(Some("http://www.accellera.org/XMLSchema/IPXACT/1685-2022"), "logicalName")) ~
      opt(IPXACT2022scalaxb.ElemName(Some("http://www.accellera.org/XMLSchema/IPXACT/1685-2022"), "displayName")) ~
      opt(IPXACT2022scalaxb.ElemName(Some("http://www.accellera.org/XMLSchema/IPXACT/1685-2022"), "shortDescription")) ~
      opt(IPXACT2022scalaxb.ElemName(Some("http://www.accellera.org/XMLSchema/IPXACT/1685-2022"), "description")) ~
      opt(IPXACT2022scalaxb.ElemName(Some("http://www.accellera.org/XMLSchema/IPXACT/1685-2022"), "match")) ~
      (((((IPXACT2022scalaxb.ElemName(Some("http://www.accellera.org/XMLSchema/IPXACT/1685-2022"), "wire")) ^^
      (x => IPXACT2022scalaxb.DataRecord(x.namespace, Some(x.name), IPXACT2022scalaxb.fromXML[IPXACT2022ScalaCases.Wire](x, IPXACT2022scalaxb.ElemName(node) :: stack)))) |
      ((IPXACT2022scalaxb.ElemName(Some("http://www.accellera.org/XMLSchema/IPXACT/1685-2022"), "transactional")) ^^
      (x => IPXACT2022scalaxb.DataRecord(x.namespace, Some(x.name), IPXACT2022scalaxb.fromXML[IPXACT2022ScalaCases.Transactional](x, IPXACT2022scalaxb.ElemName(node) :: stack))))) ~
      opt(IPXACT2022scalaxb.ElemName(Some("http://www.accellera.org/XMLSchema/IPXACT/1685-2022"), "packets"))) ^^
        { case p1 ~ p2 => IPXACT2022ScalaCases.PortSequence1(p1,
        p2.headOption map { IPXACT2022scalaxb.fromXML[IPXACT2022ScalaCases.PortPacketsType](_, IPXACT2022scalaxb.ElemName(node) :: stack) }) }) ~
      opt(IPXACT2022scalaxb.ElemName(Some("http://www.accellera.org/XMLSchema/IPXACT/1685-2022"), "vendorExtensions")) ^^
      { case p1 ~ p2 ~ p3 ~ p4 ~ p5 ~ p6 ~ p7 =>
      IPXACT2022ScalaCases.Port(IPXACT2022scalaxb.fromXML[String](p1, IPXACT2022scalaxb.ElemName(node) :: stack),
        p2.headOption map { IPXACT2022scalaxb.fromXML[String](_, IPXACT2022scalaxb.ElemName(node) :: stack) },
        p3.headOption map { IPXACT2022scalaxb.fromXML[String](_, IPXACT2022scalaxb.ElemName(node) :: stack) },
        p4.headOption map { IPXACT2022scalaxb.fromXML[String](_, IPXACT2022scalaxb.ElemName(node) :: stack) },
        p5.headOption map { IPXACT2022scalaxb.fromXML[Boolean](_, IPXACT2022scalaxb.ElemName(node) :: stack) },
        p6,
        p7.headOption map { IPXACT2022scalaxb.fromXML[IPXACT2022ScalaCases.VendorExtensions](_, IPXACT2022scalaxb.ElemName(node) :: stack) },
        scala.collection.immutable.ListMap(List(
        (node \ "@{http://www.w3.org/XML/1998/namespace}id").headOption map { x => IPXACT2022scalaxb.DataRecord(x, node, IPXACT2022scalaxb.fromXML[String](x, IPXACT2022scalaxb.ElemName(node) :: stack)) } map { "@{http://www.w3.org/XML/1998/namespace}id" -> _ }
        ).flatten[(String, IPXACT2022scalaxb.DataRecord[Any])]: _*)) })
    
    override def writesAttribute(__obj: IPXACT2022ScalaCases.Port, __scope: scala.xml.NamespaceBinding): scala.xml.MetaData = {
      var attr: scala.xml.MetaData  = scala.xml.Null
      __obj.attributes.toList map {
        case ("@{http://www.w3.org/XML/1998/namespace}id", _) => __obj.xmlid foreach { x => attr = scala.xml.Attribute(__scope.getPrefix("http://www.w3.org/XML/1998/namespace"), "id", x.toString, attr) }
        case (key, x) => attr = scala.xml.Attribute((x.namespace map { __scope.getPrefix(_) }).orNull, x.key.orNull, x.value.toString, attr)
      }
      attr
    }

    def writesChildNodes(__obj: IPXACT2022ScalaCases.Port, __scope: scala.xml.NamespaceBinding): Seq[scala.xml.Node] =
      Seq.concat(IPXACT2022scalaxb.toXML[String](__obj.logicalName, Some("http://www.accellera.org/XMLSchema/IPXACT/1685-2022"), Some("logicalName"), __scope, false),
        __obj.displayName map { IPXACT2022scalaxb.toXML[String](_, Some("http://www.accellera.org/XMLSchema/IPXACT/1685-2022"), Some("displayName"), __scope, false) } getOrElse {Nil},
        __obj.shortDescription map { IPXACT2022scalaxb.toXML[String](_, Some("http://www.accellera.org/XMLSchema/IPXACT/1685-2022"), Some("shortDescription"), __scope, false) } getOrElse {Nil},
        __obj.description map { IPXACT2022scalaxb.toXML[String](_, Some("http://www.accellera.org/XMLSchema/IPXACT/1685-2022"), Some("description"), __scope, false) } getOrElse {Nil},
        __obj.matchValue map { IPXACT2022scalaxb.toXML[Boolean](_, Some("http://www.accellera.org/XMLSchema/IPXACT/1685-2022"), Some("match"), __scope, false) } getOrElse {Nil},
        IPXACT2022scalaxb.toXML[IPXACT2022ScalaCases.PortSequence1](__obj.portsequence1, None, Some("portsequence1"), __scope, false),
        __obj.vendorExtensions map { IPXACT2022scalaxb.toXML[IPXACT2022ScalaCases.VendorExtensions](_, Some("http://www.accellera.org/XMLSchema/IPXACT/1685-2022"), Some("vendorExtensions"), __scope, false) } getOrElse {Nil})

  }

  trait DefaultIPXACT2022ScalaCases_PortSequence1Format extends IPXACT2022scalaxb.XMLFormat[IPXACT2022ScalaCases.PortSequence1] {
    def reads(seq: scala.xml.NodeSeq, stack: List[IPXACT2022scalaxb.ElemName]): Either[String, IPXACT2022ScalaCases.PortSequence1] = Left("don't call me.")
    
    def writes(__obj: IPXACT2022ScalaCases.PortSequence1, __namespace: Option[String], __elementLabel: Option[String],
        __scope: scala.xml.NamespaceBinding, __typeAttribute: Boolean): scala.xml.NodeSeq =
      Seq.concat((Some(__obj.portoption) map {x => IPXACT2022scalaxb.toXML[IPXACT2022scalaxb.DataRecord[IPXACT2022ScalaCases.PortOption]](x, x.namespace, x.key, __scope, false)}).get,
        __obj.packets map { IPXACT2022scalaxb.toXML[IPXACT2022ScalaCases.PortPacketsType](_, Some("http://www.accellera.org/XMLSchema/IPXACT/1685-2022"), Some("packets"), __scope, false) } getOrElse {Nil})


  }

  trait DefaultIPXACT2022ScalaCases_Ports3Format extends IPXACT2022scalaxb.ElemNameParser[IPXACT2022ScalaCases.Ports3] {
    val targetNamespace: Option[String] = Some("http://www.accellera.org/XMLSchema/IPXACT/1685-2022")
    
    def parser(node: scala.xml.Node, stack: List[IPXACT2022scalaxb.ElemName]): Parser[IPXACT2022ScalaCases.Ports3] =
      phrase(safeRep(IPXACT2022scalaxb.ElemName(Some("http://www.accellera.org/XMLSchema/IPXACT/1685-2022"), "port")) ^^
      { case p1 =>
      IPXACT2022ScalaCases.Ports3(p1 map { IPXACT2022scalaxb.fromXML[IPXACT2022ScalaCases.Port](_, IPXACT2022scalaxb.ElemName(node) :: stack) }) })
    
    def writesChildNodes(__obj: IPXACT2022ScalaCases.Ports3, __scope: scala.xml.NamespaceBinding): Seq[scala.xml.Node] =
      (__obj.port flatMap { IPXACT2022scalaxb.toXML[IPXACT2022ScalaCases.Port](_, Some("http://www.accellera.org/XMLSchema/IPXACT/1685-2022"), Some("port"), __scope, false) })
  }
  trait DefaultIPXACT2022ScalaCases_AbstractionDefinitionFormat extends IPXACT2022scalaxb.ElemNameParser[IPXACT2022ScalaCases.AbstractionDefinition] with IPXACT2022ScalaCases_DocumentNameGroupGroupFormat {
    val targetNamespace: Option[String] = Some("http://www.accellera.org/XMLSchema/IPXACT/1685-2022")
    
    def parser(node: scala.xml.Node, stack: List[IPXACT2022scalaxb.ElemName]): Parser[IPXACT2022ScalaCases.AbstractionDefinition] =
      phrase((parseDocumentNameGroupGroup(node, IPXACT2022scalaxb.ElemName(node) :: stack)) ~
      (IPXACT2022scalaxb.ElemName(Some("http://www.accellera.org/XMLSchema/IPXACT/1685-2022"), "busType")) ~
      opt(IPXACT2022scalaxb.ElemName(Some("http://www.accellera.org/XMLSchema/IPXACT/1685-2022"), "extends")) ~
      (IPXACT2022scalaxb.ElemName(Some("http://www.accellera.org/XMLSchema/IPXACT/1685-2022"), "ports")) ~
      opt(IPXACT2022scalaxb.ElemName(Some("http://www.accellera.org/XMLSchema/IPXACT/1685-2022"), "choices")) ~
      opt(IPXACT2022scalaxb.ElemName(Some("http://www.accellera.org/XMLSchema/IPXACT/1685-2022"), "parameters")) ~
      opt(IPXACT2022scalaxb.ElemName(Some("http://www.accellera.org/XMLSchema/IPXACT/1685-2022"), "assertions")) ~
      opt(IPXACT2022scalaxb.ElemName(Some("http://www.accellera.org/XMLSchema/IPXACT/1685-2022"), "vendorExtensions")) ^^
      { case p1 ~ p2 ~ p3 ~ p4 ~ p5 ~ p6 ~ p7 ~ p8 =>
      IPXACT2022ScalaCases.AbstractionDefinition(p1,
        IPXACT2022scalaxb.fromXML[IPXACT2022ScalaCases.LibraryRefType](p2, IPXACT2022scalaxb.ElemName(node) :: stack),
        p3.headOption map { IPXACT2022scalaxb.fromXML[IPXACT2022ScalaCases.LibraryRefType](_, IPXACT2022scalaxb.ElemName(node) :: stack) },
        IPXACT2022scalaxb.fromXML[IPXACT2022ScalaCases.Ports3](p4, IPXACT2022scalaxb.ElemName(node) :: stack),
        p5.headOption map { IPXACT2022scalaxb.fromXML[IPXACT2022ScalaCases.Choices](_, IPXACT2022scalaxb.ElemName(node) :: stack) },
        p6.headOption map { IPXACT2022scalaxb.fromXML[IPXACT2022ScalaCases.Parameters](_, IPXACT2022scalaxb.ElemName(node) :: stack) },
        p7.headOption map { IPXACT2022scalaxb.fromXML[IPXACT2022ScalaCases.Assertions](_, IPXACT2022scalaxb.ElemName(node) :: stack) },
        p8.headOption map { IPXACT2022scalaxb.fromXML[IPXACT2022ScalaCases.VendorExtensions](_, IPXACT2022scalaxb.ElemName(node) :: stack) },
        scala.collection.immutable.ListMap(List(
        (node \ "@{http://www.w3.org/XML/1998/namespace}id").headOption map { x => IPXACT2022scalaxb.DataRecord(x, node, IPXACT2022scalaxb.fromXML[String](x, IPXACT2022scalaxb.ElemName(node) :: stack)) } map { "@{http://www.w3.org/XML/1998/namespace}id" -> _ }
        ).flatten[(String, IPXACT2022scalaxb.DataRecord[Any])]: _*)) })
    
    override def writesAttribute(__obj: IPXACT2022ScalaCases.AbstractionDefinition, __scope: scala.xml.NamespaceBinding): scala.xml.MetaData = {
      var attr: scala.xml.MetaData  = scala.xml.Null
      __obj.attributes.toList map {
        case ("@{http://www.w3.org/XML/1998/namespace}id", _) => __obj.xmlid foreach { x => attr = scala.xml.Attribute(__scope.getPrefix("http://www.w3.org/XML/1998/namespace"), "id", x.toString, attr) }
        case (key, x) => attr = scala.xml.Attribute((x.namespace map { __scope.getPrefix(_) }).orNull, x.key.orNull, x.value.toString, attr)
      }
      attr
    }

    def writesChildNodes(__obj: IPXACT2022ScalaCases.AbstractionDefinition, __scope: scala.xml.NamespaceBinding): Seq[scala.xml.Node] =
      Seq.concat(IPXACT2022scalaxb.toXML[IPXACT2022ScalaCases.DocumentNameGroupSequence](__obj.documentNameGroupSequence1, None, Some("documentNameGroupSequence1"), __scope, false),
        IPXACT2022scalaxb.toXML[IPXACT2022ScalaCases.LibraryRefType](__obj.busType, Some("http://www.accellera.org/XMLSchema/IPXACT/1685-2022"), Some("busType"), __scope, false),
        __obj.extendsValue map { IPXACT2022scalaxb.toXML[IPXACT2022ScalaCases.LibraryRefType](_, Some("http://www.accellera.org/XMLSchema/IPXACT/1685-2022"), Some("extends"), __scope, false) } getOrElse {Nil},
        IPXACT2022scalaxb.toXML[IPXACT2022ScalaCases.Ports3](__obj.ports, Some("http://www.accellera.org/XMLSchema/IPXACT/1685-2022"), Some("ports"), __scope, false),
        __obj.choices map { IPXACT2022scalaxb.toXML[IPXACT2022ScalaCases.Choices](_, Some("http://www.accellera.org/XMLSchema/IPXACT/1685-2022"), Some("choices"), __scope, false) } getOrElse {Nil},
        __obj.parameters map { IPXACT2022scalaxb.toXML[IPXACT2022ScalaCases.Parameters](_, Some("http://www.accellera.org/XMLSchema/IPXACT/1685-2022"), Some("parameters"), __scope, false) } getOrElse {Nil},
        __obj.assertions map { IPXACT2022scalaxb.toXML[IPXACT2022ScalaCases.Assertions](_, Some("http://www.accellera.org/XMLSchema/IPXACT/1685-2022"), Some("assertions"), __scope, false) } getOrElse {Nil},
        __obj.vendorExtensions map { IPXACT2022scalaxb.toXML[IPXACT2022ScalaCases.VendorExtensions](_, Some("http://www.accellera.org/XMLSchema/IPXACT/1685-2022"), Some("vendorExtensions"), __scope, false) } getOrElse {Nil})

  }

  trait DefaultIPXACT2022ScalaCases_OnSystem2Format extends IPXACT2022scalaxb.ElemNameParser[IPXACT2022ScalaCases.OnSystem2] with IPXACT2022ScalaCases_WirePortGroupFormat {
    val targetNamespace: Option[String] = Some("http://www.accellera.org/XMLSchema/IPXACT/1685-2022")
    
    def parser(node: scala.xml.Node, stack: List[IPXACT2022scalaxb.ElemName]): Parser[IPXACT2022ScalaCases.OnSystem2] =
      phrase((IPXACT2022scalaxb.ElemName(Some("http://www.accellera.org/XMLSchema/IPXACT/1685-2022"), "group")) ~
      (parseWirePortGroup(node, IPXACT2022scalaxb.ElemName(node) :: stack)) ^^
      { case p1 ~ p2 =>
      IPXACT2022ScalaCases.OnSystem2(IPXACT2022scalaxb.fromXML[String](p1, IPXACT2022scalaxb.ElemName(node) :: stack),
        p2,
        scala.collection.immutable.ListMap(List(
        (node \ "@{http://www.w3.org/XML/1998/namespace}id").headOption map { x => IPXACT2022scalaxb.DataRecord(x, node, IPXACT2022scalaxb.fromXML[String](x, IPXACT2022scalaxb.ElemName(node) :: stack)) } map { "@{http://www.w3.org/XML/1998/namespace}id" -> _ }
        ).flatten[(String, IPXACT2022scalaxb.DataRecord[Any])]: _*)) })
    
    override def writesAttribute(__obj: IPXACT2022ScalaCases.OnSystem2, __scope: scala.xml.NamespaceBinding): scala.xml.MetaData = {
      var attr: scala.xml.MetaData  = scala.xml.Null
      __obj.attributes.toList map {
        case ("@{http://www.w3.org/XML/1998/namespace}id", _) => __obj.xmlid foreach { x => attr = scala.xml.Attribute(__scope.getPrefix("http://www.w3.org/XML/1998/namespace"), "id", x.toString, attr) }
        case (key, x) => attr = scala.xml.Attribute((x.namespace map { __scope.getPrefix(_) }).orNull, x.key.orNull, x.value.toString, attr)
      }
      attr
    }

    def writesChildNodes(__obj: IPXACT2022ScalaCases.OnSystem2, __scope: scala.xml.NamespaceBinding): Seq[scala.xml.Node] =
      Seq.concat(IPXACT2022scalaxb.toXML[String](__obj.group, Some("http://www.accellera.org/XMLSchema/IPXACT/1685-2022"), Some("group"), __scope, false),
        IPXACT2022scalaxb.toXML[IPXACT2022ScalaCases.WirePortSequence](__obj.wirePortSequence2, None, Some("wirePortSequence2"), __scope, false))

  }

  trait DefaultIPXACT2022ScalaCases_OnInitiator2Format extends IPXACT2022scalaxb.ElemNameParser[IPXACT2022ScalaCases.OnInitiator2] with IPXACT2022ScalaCases_WirePortGroupFormat {
    val targetNamespace: Option[String] = Some("http://www.accellera.org/XMLSchema/IPXACT/1685-2022")
    
    def parser(node: scala.xml.Node, stack: List[IPXACT2022scalaxb.ElemName]): Parser[IPXACT2022ScalaCases.OnInitiator2] =
      phrase((parseWirePortGroup(node, IPXACT2022scalaxb.ElemName(node) :: stack)) ^^
      { case p1 =>
      IPXACT2022ScalaCases.OnInitiator2(p1) })
    
    def writesChildNodes(__obj: IPXACT2022ScalaCases.OnInitiator2, __scope: scala.xml.NamespaceBinding): Seq[scala.xml.Node] =
      (IPXACT2022scalaxb.toXML[IPXACT2022ScalaCases.WirePortSequence](__obj.wirePortSequence1, None, Some("wirePortSequence1"), __scope, false))
  }
  trait DefaultIPXACT2022ScalaCases_OnTarget2Format extends IPXACT2022scalaxb.ElemNameParser[IPXACT2022ScalaCases.OnTarget2] with IPXACT2022ScalaCases_WirePortGroupFormat {
    val targetNamespace: Option[String] = Some("http://www.accellera.org/XMLSchema/IPXACT/1685-2022")
    
    def parser(node: scala.xml.Node, stack: List[IPXACT2022scalaxb.ElemName]): Parser[IPXACT2022ScalaCases.OnTarget2] =
      phrase((parseWirePortGroup(node, IPXACT2022scalaxb.ElemName(node) :: stack)) ^^
      { case p1 =>
      IPXACT2022ScalaCases.OnTarget2(p1) })
    
    def writesChildNodes(__obj: IPXACT2022ScalaCases.OnTarget2, __scope: scala.xml.NamespaceBinding): Seq[scala.xml.Node] =
      (IPXACT2022scalaxb.toXML[IPXACT2022ScalaCases.WirePortSequence](__obj.wirePortSequence1, None, Some("wirePortSequence1"), __scope, false))
  }
  trait DefaultIPXACT2022ScalaCases_WireFormat extends IPXACT2022scalaxb.ElemNameParser[IPXACT2022ScalaCases.Wire] {
    val targetNamespace: Option[String] = Some("http://www.accellera.org/XMLSchema/IPXACT/1685-2022")
    
    def parser(node: scala.xml.Node, stack: List[IPXACT2022scalaxb.ElemName]): Parser[IPXACT2022ScalaCases.Wire] =
      phrase(opt(IPXACT2022scalaxb.ElemName(Some("http://www.accellera.org/XMLSchema/IPXACT/1685-2022"), "qualifier")) ~
      safeRep(IPXACT2022scalaxb.ElemName(Some("http://www.accellera.org/XMLSchema/IPXACT/1685-2022"), "onSystem")) ~
      opt(IPXACT2022scalaxb.ElemName(Some("http://www.accellera.org/XMLSchema/IPXACT/1685-2022"), "onInitiator")) ~
      opt(IPXACT2022scalaxb.ElemName(Some("http://www.accellera.org/XMLSchema/IPXACT/1685-2022"), "onTarget")) ~
      opt(((IPXACT2022scalaxb.ElemName(Some("http://www.accellera.org/XMLSchema/IPXACT/1685-2022"), "defaultValue")) ^^
      (x => IPXACT2022scalaxb.DataRecord(x.namespace, Some(x.name), IPXACT2022scalaxb.fromXML[IPXACT2022ScalaCases.UnsignedBitVectorExpressionable](x, IPXACT2022scalaxb.ElemName(node) :: stack)))) |
      ((IPXACT2022scalaxb.ElemName(Some("http://www.accellera.org/XMLSchema/IPXACT/1685-2022"), "requiresDriver")) ^^
      (x => IPXACT2022scalaxb.DataRecord(x.namespace, Some(x.name), IPXACT2022scalaxb.fromXML[IPXACT2022ScalaCases.RequiresDriver](x, IPXACT2022scalaxb.ElemName(node) :: stack))))) ^^
      { case p1 ~ p2 ~ p3 ~ p4 ~ p5 =>
      IPXACT2022ScalaCases.Wire(p1.headOption map { IPXACT2022scalaxb.fromXML[IPXACT2022ScalaCases.QualifierType](_, IPXACT2022scalaxb.ElemName(node) :: stack) },
        p2 map { IPXACT2022scalaxb.fromXML[IPXACT2022ScalaCases.OnSystem2](_, IPXACT2022scalaxb.ElemName(node) :: stack) },
        p3.headOption map { IPXACT2022scalaxb.fromXML[IPXACT2022ScalaCases.OnInitiator2](_, IPXACT2022scalaxb.ElemName(node) :: stack) },
        p4.headOption map { IPXACT2022scalaxb.fromXML[IPXACT2022ScalaCases.OnTarget2](_, IPXACT2022scalaxb.ElemName(node) :: stack) },
        p5) })
    
    def writesChildNodes(__obj: IPXACT2022ScalaCases.Wire, __scope: scala.xml.NamespaceBinding): Seq[scala.xml.Node] =
      Seq.concat(__obj.qualifier map { IPXACT2022scalaxb.toXML[IPXACT2022ScalaCases.QualifierType](_, Some("http://www.accellera.org/XMLSchema/IPXACT/1685-2022"), Some("qualifier"), __scope, false) } getOrElse {Nil},
        __obj.onSystem flatMap { IPXACT2022scalaxb.toXML[IPXACT2022ScalaCases.OnSystem2](_, Some("http://www.accellera.org/XMLSchema/IPXACT/1685-2022"), Some("onSystem"), __scope, false) },
        __obj.onInitiator map { IPXACT2022scalaxb.toXML[IPXACT2022ScalaCases.OnInitiator2](_, Some("http://www.accellera.org/XMLSchema/IPXACT/1685-2022"), Some("onInitiator"), __scope, false) } getOrElse {Nil},
        __obj.onTarget map { IPXACT2022scalaxb.toXML[IPXACT2022ScalaCases.OnTarget2](_, Some("http://www.accellera.org/XMLSchema/IPXACT/1685-2022"), Some("onTarget"), __scope, false) } getOrElse {Nil},
        __obj.wireoption map { x => IPXACT2022scalaxb.toXML[IPXACT2022scalaxb.DataRecord[IPXACT2022ScalaCases.WireOption]](x, x.namespace, x.key, __scope, false) } getOrElse {Nil})

  }


/** Group of elements used in a wire port.
*/
  trait IPXACT2022ScalaCases_WirePortGroupFormat extends IPXACT2022scalaxb.AnyElemNameParser {
    def parseWirePortGroup(node: scala.xml.Node, stack: List[IPXACT2022scalaxb.ElemName]): Parser[IPXACT2022ScalaCases.WirePortSequence] =
      ((opt(IPXACT2022scalaxb.ElemName(Some("http://www.accellera.org/XMLSchema/IPXACT/1685-2022"), "presence")) ~
      opt(IPXACT2022scalaxb.ElemName(Some("http://www.accellera.org/XMLSchema/IPXACT/1685-2022"), "width")) ~
      opt(IPXACT2022scalaxb.ElemName(Some("http://www.accellera.org/XMLSchema/IPXACT/1685-2022"), "direction")) ~
      opt(((IPXACT2022scalaxb.ElemName(Some("http://www.accellera.org/XMLSchema/IPXACT/1685-2022"), "modeConstraints")) ~
      opt(IPXACT2022scalaxb.ElemName(Some("http://www.accellera.org/XMLSchema/IPXACT/1685-2022"), "mirroredModeConstraints"))) ^^
        { case p1 ~ p2 => IPXACT2022ScalaCases.WirePortSequence2(IPXACT2022scalaxb.fromXML[IPXACT2022ScalaCases.AbstractionDefPortConstraintsType](p1, IPXACT2022scalaxb.ElemName(node) :: stack),
        p2.headOption map { IPXACT2022scalaxb.fromXML[IPXACT2022ScalaCases.AbstractionDefPortConstraintsType](_, IPXACT2022scalaxb.ElemName(node) :: stack) }) })) ^^
        { case p1 ~ p2 ~ p3 ~ p4 => IPXACT2022ScalaCases.WirePortSequence(p1.headOption map { IPXACT2022scalaxb.fromXML[IPXACT2022ScalaCases.PresenceType](_, IPXACT2022scalaxb.ElemName(node) :: stack) },
        p2.headOption map { IPXACT2022scalaxb.fromXML[String](_, IPXACT2022scalaxb.ElemName(node) :: stack) },
        p3.headOption map { IPXACT2022scalaxb.fromXML[IPXACT2022ScalaCases.Direction](_, IPXACT2022scalaxb.ElemName(node) :: stack) },
        p4) })
  
    def parseWirePortGroup(node: scala.xml.Node, stack: List[IPXACT2022scalaxb.ElemName], wrap: Boolean): Parser[IPXACT2022scalaxb.DataRecord[Any]] =
      ((opt(IPXACT2022scalaxb.ElemName(Some("http://www.accellera.org/XMLSchema/IPXACT/1685-2022"), "presence")) ~
      opt(IPXACT2022scalaxb.ElemName(Some("http://www.accellera.org/XMLSchema/IPXACT/1685-2022"), "width")) ~
      opt(IPXACT2022scalaxb.ElemName(Some("http://www.accellera.org/XMLSchema/IPXACT/1685-2022"), "direction")) ~
      opt(((IPXACT2022scalaxb.ElemName(Some("http://www.accellera.org/XMLSchema/IPXACT/1685-2022"), "modeConstraints")) ~
      opt(IPXACT2022scalaxb.ElemName(Some("http://www.accellera.org/XMLSchema/IPXACT/1685-2022"), "mirroredModeConstraints"))) ^^
        { case p1 ~ p2 => IPXACT2022ScalaCases.WirePortSequence2(IPXACT2022scalaxb.fromXML[IPXACT2022ScalaCases.AbstractionDefPortConstraintsType](p1, IPXACT2022scalaxb.ElemName(node) :: stack),
        p2.headOption map { IPXACT2022scalaxb.fromXML[IPXACT2022ScalaCases.AbstractionDefPortConstraintsType](_, IPXACT2022scalaxb.ElemName(node) :: stack) }) })) ^^
        { case p1 ~ p2 ~ p3 ~ p4 => IPXACT2022scalaxb.DataRecord(IPXACT2022ScalaCases.WirePortSequence(p1.headOption map { IPXACT2022scalaxb.fromXML[IPXACT2022ScalaCases.PresenceType](_, IPXACT2022scalaxb.ElemName(node) :: stack) },
        p2.headOption map { IPXACT2022scalaxb.fromXML[String](_, IPXACT2022scalaxb.ElemName(node) :: stack) },
        p3.headOption map { IPXACT2022scalaxb.fromXML[IPXACT2022ScalaCases.Direction](_, IPXACT2022scalaxb.ElemName(node) :: stack) },
        p4)) })
    
    def parsemixedWirePortGroup(node: scala.xml.Node, stack: List[IPXACT2022scalaxb.ElemName]): Parser[Seq[IPXACT2022scalaxb.DataRecord[Any]]] =
      (((opt(IPXACT2022scalaxb.ElemName(Some("http://www.accellera.org/XMLSchema/IPXACT/1685-2022"), "presence")) ^^
      (_ map { x => IPXACT2022scalaxb.DataRecord(x.namespace, Some(x.name), IPXACT2022scalaxb.fromXML[String](x, IPXACT2022scalaxb.ElemName(node) :: stack)) })) ~
      optTextRecord ~ 
      (opt(IPXACT2022scalaxb.ElemName(Some("http://www.accellera.org/XMLSchema/IPXACT/1685-2022"), "width")) ^^
      (_ map { x => IPXACT2022scalaxb.DataRecord(x.namespace, Some(x.name), IPXACT2022scalaxb.fromXML[IPXACT2022ScalaCases.Width](x, IPXACT2022scalaxb.ElemName(node) :: stack)) })) ~
      optTextRecord ~ 
      (opt(IPXACT2022scalaxb.ElemName(Some("http://www.accellera.org/XMLSchema/IPXACT/1685-2022"), "direction")) ^^
      (_ map { x => IPXACT2022scalaxb.DataRecord(x.namespace, Some(x.name), IPXACT2022scalaxb.fromXML[String](x, IPXACT2022scalaxb.ElemName(node) :: stack)) })) ~
      optTextRecord ~ 
      opt((((IPXACT2022scalaxb.ElemName(Some("http://www.accellera.org/XMLSchema/IPXACT/1685-2022"), "modeConstraints")) ^^
      (x => IPXACT2022scalaxb.DataRecord(x.namespace, Some(x.name), IPXACT2022scalaxb.fromXML[IPXACT2022ScalaCases.AbstractionDefPortConstraintsType](x, IPXACT2022scalaxb.ElemName(node) :: stack)))) ~
      optTextRecord ~ 
      (opt(IPXACT2022scalaxb.ElemName(Some("http://www.accellera.org/XMLSchema/IPXACT/1685-2022"), "mirroredModeConstraints")) ^^
      (_ map { x => IPXACT2022scalaxb.DataRecord(x.namespace, Some(x.name), IPXACT2022scalaxb.fromXML[IPXACT2022ScalaCases.AbstractionDefPortConstraintsType](x, IPXACT2022scalaxb.ElemName(node) :: stack)) })) ~
      optTextRecord) ^^ 
        { case p1 ~ p2 ~ p3 ~ p4 => Seq.concat(Seq(p1),
        p2.toList,
        p3.toList,
        p4.toList) }) ~ 
      optTextRecord) ^^ 
        { case p1 ~ p2 ~ p3 ~ p4 ~ p5 ~ p6 ~ p7 ~ p8 => Seq.concat(p1.toList,
        p2.toList,
        p3.toList,
        p4.toList,
        p5.toList,
        p6.toList,
        p7 getOrElse {Nil},
        p8.toList) })
  }

  trait DefaultIPXACT2022ScalaCases_WirePortSequence2Format extends IPXACT2022scalaxb.XMLFormat[IPXACT2022ScalaCases.WirePortSequence2] {
    def reads(seq: scala.xml.NodeSeq, stack: List[IPXACT2022scalaxb.ElemName]): Either[String, IPXACT2022ScalaCases.WirePortSequence2] = Left("don't call me.")
    
    def writes(__obj: IPXACT2022ScalaCases.WirePortSequence2, __namespace: Option[String], __elementLabel: Option[String],
        __scope: scala.xml.NamespaceBinding, __typeAttribute: Boolean): scala.xml.NodeSeq =
      Seq.concat(IPXACT2022scalaxb.toXML[IPXACT2022ScalaCases.AbstractionDefPortConstraintsType](__obj.modeConstraints, Some("http://www.accellera.org/XMLSchema/IPXACT/1685-2022"), Some("modeConstraints"), __scope, false),
        __obj.mirroredModeConstraints map { IPXACT2022scalaxb.toXML[IPXACT2022ScalaCases.AbstractionDefPortConstraintsType](_, Some("http://www.accellera.org/XMLSchema/IPXACT/1685-2022"), Some("mirroredModeConstraints"), __scope, false) } getOrElse {Nil})


  }

  trait DefaultIPXACT2022ScalaCases_WirePortSequenceFormat extends IPXACT2022scalaxb.XMLFormat[IPXACT2022ScalaCases.WirePortSequence] {
    def reads(seq: scala.xml.NodeSeq, stack: List[IPXACT2022scalaxb.ElemName]): Either[String, IPXACT2022ScalaCases.WirePortSequence] = Left("don't call me.")
    
    def writes(__obj: IPXACT2022ScalaCases.WirePortSequence, __namespace: Option[String], __elementLabel: Option[String],
        __scope: scala.xml.NamespaceBinding, __typeAttribute: Boolean): scala.xml.NodeSeq =
      Seq.concat(__obj.presence map { IPXACT2022scalaxb.toXML[IPXACT2022ScalaCases.PresenceType](_, Some("http://www.accellera.org/XMLSchema/IPXACT/1685-2022"), Some("presence"), __scope, false) } getOrElse {Nil},
        __obj.width map { IPXACT2022scalaxb.toXML[String](_, Some("http://www.accellera.org/XMLSchema/IPXACT/1685-2022"), Some("width"), __scope, false) } getOrElse {Nil},
        __obj.direction map { IPXACT2022scalaxb.toXML[IPXACT2022ScalaCases.Direction](_, Some("http://www.accellera.org/XMLSchema/IPXACT/1685-2022"), Some("direction"), __scope, false) } getOrElse {Nil},
        __obj.wireportsequence2 map { IPXACT2022scalaxb.toXML[IPXACT2022ScalaCases.WirePortSequence2](_, None, Some("wireportsequence2"), __scope, false) } getOrElse {Nil})


  }


/** Group of elements used in a transactional port.
*/
  trait IPXACT2022ScalaCases_TransactionalPortGroupFormat extends IPXACT2022scalaxb.AnyElemNameParser {
    def parseTransactionalPortGroup(node: scala.xml.Node, stack: List[IPXACT2022scalaxb.ElemName]): Parser[IPXACT2022ScalaCases.TransactionalPortSequence] =
      ((opt(IPXACT2022scalaxb.ElemName(Some("http://www.accellera.org/XMLSchema/IPXACT/1685-2022"), "presence")) ~
      opt(IPXACT2022scalaxb.ElemName(Some("http://www.accellera.org/XMLSchema/IPXACT/1685-2022"), "initiative")) ~
      opt(IPXACT2022scalaxb.ElemName(Some("http://www.accellera.org/XMLSchema/IPXACT/1685-2022"), "kind")) ~
      opt(IPXACT2022scalaxb.ElemName(Some("http://www.accellera.org/XMLSchema/IPXACT/1685-2022"), "busWidth")) ~
      opt(IPXACT2022scalaxb.ElemName(Some("http://www.accellera.org/XMLSchema/IPXACT/1685-2022"), "protocol"))) ^^
        { case p1 ~ p2 ~ p3 ~ p4 ~ p5 => IPXACT2022ScalaCases.TransactionalPortSequence(p1.headOption map { IPXACT2022scalaxb.fromXML[IPXACT2022ScalaCases.PresenceType](_, IPXACT2022scalaxb.ElemName(node) :: stack) },
        p2.headOption map { IPXACT2022scalaxb.fromXML[IPXACT2022ScalaCases.Initiative](_, IPXACT2022scalaxb.ElemName(node) :: stack) },
        p3.headOption map { IPXACT2022scalaxb.fromXML[IPXACT2022ScalaCases.Kind](_, IPXACT2022scalaxb.ElemName(node) :: stack) },
        p4.headOption map { IPXACT2022scalaxb.fromXML[IPXACT2022ScalaCases.UnsignedPositiveIntExpressionable](_, IPXACT2022scalaxb.ElemName(node) :: stack) },
        p5.headOption map { IPXACT2022scalaxb.fromXML[IPXACT2022ScalaCases.Protocol](_, IPXACT2022scalaxb.ElemName(node) :: stack) }) })
  
    def parseTransactionalPortGroup(node: scala.xml.Node, stack: List[IPXACT2022scalaxb.ElemName], wrap: Boolean): Parser[IPXACT2022scalaxb.DataRecord[Any]] =
      ((opt(IPXACT2022scalaxb.ElemName(Some("http://www.accellera.org/XMLSchema/IPXACT/1685-2022"), "presence")) ~
      opt(IPXACT2022scalaxb.ElemName(Some("http://www.accellera.org/XMLSchema/IPXACT/1685-2022"), "initiative")) ~
      opt(IPXACT2022scalaxb.ElemName(Some("http://www.accellera.org/XMLSchema/IPXACT/1685-2022"), "kind")) ~
      opt(IPXACT2022scalaxb.ElemName(Some("http://www.accellera.org/XMLSchema/IPXACT/1685-2022"), "busWidth")) ~
      opt(IPXACT2022scalaxb.ElemName(Some("http://www.accellera.org/XMLSchema/IPXACT/1685-2022"), "protocol"))) ^^
        { case p1 ~ p2 ~ p3 ~ p4 ~ p5 => IPXACT2022scalaxb.DataRecord(IPXACT2022ScalaCases.TransactionalPortSequence(p1.headOption map { IPXACT2022scalaxb.fromXML[IPXACT2022ScalaCases.PresenceType](_, IPXACT2022scalaxb.ElemName(node) :: stack) },
        p2.headOption map { IPXACT2022scalaxb.fromXML[IPXACT2022ScalaCases.Initiative](_, IPXACT2022scalaxb.ElemName(node) :: stack) },
        p3.headOption map { IPXACT2022scalaxb.fromXML[IPXACT2022ScalaCases.Kind](_, IPXACT2022scalaxb.ElemName(node) :: stack) },
        p4.headOption map { IPXACT2022scalaxb.fromXML[IPXACT2022ScalaCases.UnsignedPositiveIntExpressionable](_, IPXACT2022scalaxb.ElemName(node) :: stack) },
        p5.headOption map { IPXACT2022scalaxb.fromXML[IPXACT2022ScalaCases.Protocol](_, IPXACT2022scalaxb.ElemName(node) :: stack) })) })
    
    def parsemixedTransactionalPortGroup(node: scala.xml.Node, stack: List[IPXACT2022scalaxb.ElemName]): Parser[Seq[IPXACT2022scalaxb.DataRecord[Any]]] =
      (((opt(IPXACT2022scalaxb.ElemName(Some("http://www.accellera.org/XMLSchema/IPXACT/1685-2022"), "presence")) ^^
      (_ map { x => IPXACT2022scalaxb.DataRecord(x.namespace, Some(x.name), IPXACT2022scalaxb.fromXML[String](x, IPXACT2022scalaxb.ElemName(node) :: stack)) })) ~
      optTextRecord ~ 
      (opt(IPXACT2022scalaxb.ElemName(Some("http://www.accellera.org/XMLSchema/IPXACT/1685-2022"), "initiative")) ^^
      (_ map { x => IPXACT2022scalaxb.DataRecord(x.namespace, Some(x.name), IPXACT2022scalaxb.fromXML[String](x, IPXACT2022scalaxb.ElemName(node) :: stack)) })) ~
      optTextRecord ~ 
      (opt(IPXACT2022scalaxb.ElemName(Some("http://www.accellera.org/XMLSchema/IPXACT/1685-2022"), "kind")) ^^
      (_ map { x => IPXACT2022scalaxb.DataRecord(x.namespace, Some(x.name), IPXACT2022scalaxb.fromXML[IPXACT2022ScalaCases.Kind](x, IPXACT2022scalaxb.ElemName(node) :: stack)) })) ~
      optTextRecord ~ 
      (opt(IPXACT2022scalaxb.ElemName(Some("http://www.accellera.org/XMLSchema/IPXACT/1685-2022"), "busWidth")) ^^
      (_ map { x => IPXACT2022scalaxb.DataRecord(x.namespace, Some(x.name), IPXACT2022scalaxb.fromXML[IPXACT2022ScalaCases.UnsignedPositiveIntExpressionable](x, IPXACT2022scalaxb.ElemName(node) :: stack)) })) ~
      optTextRecord ~ 
      (opt(IPXACT2022scalaxb.ElemName(Some("http://www.accellera.org/XMLSchema/IPXACT/1685-2022"), "protocol")) ^^
      (_ map { x => IPXACT2022scalaxb.DataRecord(x.namespace, Some(x.name), IPXACT2022scalaxb.fromXML[IPXACT2022ScalaCases.Protocol](x, IPXACT2022scalaxb.ElemName(node) :: stack)) })) ~
      optTextRecord) ^^ 
        { case p1 ~ p2 ~ p3 ~ p4 ~ p5 ~ p6 ~ p7 ~ p8 ~ p9 ~ p10 => Seq.concat(p1.toList,
        p2.toList,
        p3.toList,
        p4.toList,
        p5.toList,
        p6.toList,
        p7.toList,
        p8.toList,
        p9.toList,
        p10.toList) })
  }

  trait DefaultIPXACT2022ScalaCases_TransactionalPortSequenceFormat extends IPXACT2022scalaxb.XMLFormat[IPXACT2022ScalaCases.TransactionalPortSequence] {
    def reads(seq: scala.xml.NodeSeq, stack: List[IPXACT2022scalaxb.ElemName]): Either[String, IPXACT2022ScalaCases.TransactionalPortSequence] = Left("don't call me.")
    
    def writes(__obj: IPXACT2022ScalaCases.TransactionalPortSequence, __namespace: Option[String], __elementLabel: Option[String],
        __scope: scala.xml.NamespaceBinding, __typeAttribute: Boolean): scala.xml.NodeSeq =
      Seq.concat(__obj.presence map { IPXACT2022scalaxb.toXML[IPXACT2022ScalaCases.PresenceType](_, Some("http://www.accellera.org/XMLSchema/IPXACT/1685-2022"), Some("presence"), __scope, false) } getOrElse {Nil},
        __obj.initiative map { IPXACT2022scalaxb.toXML[IPXACT2022ScalaCases.Initiative](_, Some("http://www.accellera.org/XMLSchema/IPXACT/1685-2022"), Some("initiative"), __scope, false) } getOrElse {Nil},
        __obj.kind map { IPXACT2022scalaxb.toXML[IPXACT2022ScalaCases.Kind](_, Some("http://www.accellera.org/XMLSchema/IPXACT/1685-2022"), Some("kind"), __scope, false) } getOrElse {Nil},
        __obj.busWidth map { IPXACT2022scalaxb.toXML[IPXACT2022ScalaCases.UnsignedPositiveIntExpressionable](_, Some("http://www.accellera.org/XMLSchema/IPXACT/1685-2022"), Some("busWidth"), __scope, false) } getOrElse {Nil},
        __obj.protocol map { IPXACT2022scalaxb.toXML[IPXACT2022ScalaCases.Protocol](_, Some("http://www.accellera.org/XMLSchema/IPXACT/1685-2022"), Some("protocol"), __scope, false) } getOrElse {Nil})


  }

  trait DefaultIPXACT2022ScalaCases_AbstractorModeFormat extends IPXACT2022scalaxb.XMLFormat[IPXACT2022ScalaCases.AbstractorMode] with IPXACT2022scalaxb.CanWriteChildNodes[IPXACT2022ScalaCases.AbstractorMode] {
    val targetNamespace: Option[String] = Some("http://www.accellera.org/XMLSchema/IPXACT/1685-2022")
    def reads(seq: scala.xml.NodeSeq, stack: List[IPXACT2022scalaxb.ElemName]): Either[String, IPXACT2022ScalaCases.AbstractorMode] = seq match {
      case node: scala.xml.Node => Right(IPXACT2022ScalaCases.AbstractorMode(IPXACT2022scalaxb.fromXML[IPXACT2022ScalaCases.AbstractorModeType](node, IPXACT2022scalaxb.ElemName(node) :: stack),
        scala.collection.immutable.ListMap(List(
        (node \ "@group").headOption map { x => IPXACT2022scalaxb.DataRecord(x, node, IPXACT2022scalaxb.fromXML[String](x, IPXACT2022scalaxb.ElemName(node) :: stack)) } map { "@group" -> _ }
        ).flatten[(String, IPXACT2022scalaxb.DataRecord[Any])]: _*)))
      case _ => Left("reads failed: seq must be scala.xml.Node")
    }
    
    override def writesAttribute(__obj: IPXACT2022ScalaCases.AbstractorMode, __scope: scala.xml.NamespaceBinding): scala.xml.MetaData = {
      var attr: scala.xml.MetaData  = scala.xml.Null
      __obj.attributes.toList map {
        case ("@group", _) => __obj.group foreach { x => attr = scala.xml.Attribute(null, "group", x.toString, attr) }
        case (key, x) => attr = scala.xml.Attribute((x.namespace map { __scope.getPrefix(_) }).orNull, x.key.orNull, x.value.toString, attr)
      }
      attr
    }

    def writesChildNodes(__obj: IPXACT2022ScalaCases.AbstractorMode, __scope: scala.xml.NamespaceBinding): Seq[scala.xml.Node] =
      Seq(scala.xml.Text(__obj.value.toString))

  }

  trait DefaultIPXACT2022ScalaCases_AbstractorInterfacesFormat extends IPXACT2022scalaxb.ElemNameParser[IPXACT2022ScalaCases.AbstractorInterfaces] {
    val targetNamespace: Option[String] = Some("http://www.accellera.org/XMLSchema/IPXACT/1685-2022")
    
    def parser(node: scala.xml.Node, stack: List[IPXACT2022scalaxb.ElemName]): Parser[IPXACT2022ScalaCases.AbstractorInterfaces] =
      phrase(safeRep(IPXACT2022scalaxb.ElemName(Some("http://www.accellera.org/XMLSchema/IPXACT/1685-2022"), "abstractorInterface")) ^^
      { case p1 =>
      IPXACT2022ScalaCases.AbstractorInterfaces(p1 map { IPXACT2022scalaxb.fromXML[IPXACT2022ScalaCases.AbstractorBusInterfaceType](_, IPXACT2022scalaxb.ElemName(node) :: stack) }) })
    
    def writesChildNodes(__obj: IPXACT2022ScalaCases.AbstractorInterfaces, __scope: scala.xml.NamespaceBinding): Seq[scala.xml.Node] =
      (__obj.abstractorInterface flatMap { IPXACT2022scalaxb.toXML[IPXACT2022ScalaCases.AbstractorBusInterfaceType](_, Some("http://www.accellera.org/XMLSchema/IPXACT/1685-2022"), Some("abstractorInterface"), __scope, false) })
  }
  trait DefaultIPXACT2022ScalaCases_AbstractorTypeFormat extends IPXACT2022scalaxb.ElemNameParser[IPXACT2022ScalaCases.AbstractorType] with IPXACT2022ScalaCases_DocumentNameGroupGroupFormat {
    val targetNamespace: Option[String] = Some("http://www.accellera.org/XMLSchema/IPXACT/1685-2022")
    
    override def typeName: Option[String] = Some("abstractorType")

    def parser(node: scala.xml.Node, stack: List[IPXACT2022scalaxb.ElemName]): Parser[IPXACT2022ScalaCases.AbstractorType] =
      phrase((parseDocumentNameGroupGroup(node, IPXACT2022scalaxb.ElemName(node) :: stack)) ~
      (IPXACT2022scalaxb.ElemName(Some("http://www.accellera.org/XMLSchema/IPXACT/1685-2022"), "abstractorMode")) ~
      (IPXACT2022scalaxb.ElemName(Some("http://www.accellera.org/XMLSchema/IPXACT/1685-2022"), "busType")) ~
      (IPXACT2022scalaxb.ElemName(Some("http://www.accellera.org/XMLSchema/IPXACT/1685-2022"), "abstractorInterfaces")) ~
      opt(IPXACT2022scalaxb.ElemName(Some("http://www.accellera.org/XMLSchema/IPXACT/1685-2022"), "model")) ~
      opt(IPXACT2022scalaxb.ElemName(Some("http://www.accellera.org/XMLSchema/IPXACT/1685-2022"), "abstractorGenerators")) ~
      opt(IPXACT2022scalaxb.ElemName(Some("http://www.accellera.org/XMLSchema/IPXACT/1685-2022"), "choices")) ~
      opt(IPXACT2022scalaxb.ElemName(Some("http://www.accellera.org/XMLSchema/IPXACT/1685-2022"), "fileSets")) ~
      opt(IPXACT2022scalaxb.ElemName(Some("http://www.accellera.org/XMLSchema/IPXACT/1685-2022"), "parameters")) ~
      opt(IPXACT2022scalaxb.ElemName(Some("http://www.accellera.org/XMLSchema/IPXACT/1685-2022"), "assertions")) ~
      opt(IPXACT2022scalaxb.ElemName(Some("http://www.accellera.org/XMLSchema/IPXACT/1685-2022"), "vendorExtensions")) ^^
      { case p1 ~ p2 ~ p3 ~ p4 ~ p5 ~ p6 ~ p7 ~ p8 ~ p9 ~ p10 ~ p11 =>
      IPXACT2022ScalaCases.AbstractorType(p1,
        IPXACT2022scalaxb.fromXML[IPXACT2022ScalaCases.AbstractorMode](p2, IPXACT2022scalaxb.ElemName(node) :: stack),
        IPXACT2022scalaxb.fromXML[IPXACT2022ScalaCases.LibraryRefType](p3, IPXACT2022scalaxb.ElemName(node) :: stack),
        IPXACT2022scalaxb.fromXML[IPXACT2022ScalaCases.AbstractorInterfaces](p4, IPXACT2022scalaxb.ElemName(node) :: stack),
        p5.headOption map { IPXACT2022scalaxb.fromXML[IPXACT2022ScalaCases.AbstractorModelType](_, IPXACT2022scalaxb.ElemName(node) :: stack) },
        p6.headOption map { IPXACT2022scalaxb.fromXML[IPXACT2022ScalaCases.AbstractorGenerators](_, IPXACT2022scalaxb.ElemName(node) :: stack) },
        p7.headOption map { IPXACT2022scalaxb.fromXML[IPXACT2022ScalaCases.Choices](_, IPXACT2022scalaxb.ElemName(node) :: stack) },
        p8.headOption map { IPXACT2022scalaxb.fromXML[IPXACT2022ScalaCases.FileSets](_, IPXACT2022scalaxb.ElemName(node) :: stack) },
        p9.headOption map { IPXACT2022scalaxb.fromXML[IPXACT2022ScalaCases.Parameters](_, IPXACT2022scalaxb.ElemName(node) :: stack) },
        p10.headOption map { IPXACT2022scalaxb.fromXML[IPXACT2022ScalaCases.Assertions](_, IPXACT2022scalaxb.ElemName(node) :: stack) },
        p11.headOption map { IPXACT2022scalaxb.fromXML[IPXACT2022ScalaCases.VendorExtensions](_, IPXACT2022scalaxb.ElemName(node) :: stack) },
        scala.collection.immutable.ListMap(List(
        (node \ "@{http://www.w3.org/XML/1998/namespace}id").headOption map { x => IPXACT2022scalaxb.DataRecord(x, node, IPXACT2022scalaxb.fromXML[String](x, IPXACT2022scalaxb.ElemName(node) :: stack)) } map { "@{http://www.w3.org/XML/1998/namespace}id" -> _ }
        ).flatten[(String, IPXACT2022scalaxb.DataRecord[Any])]: _*)) })
    
    override def writesAttribute(__obj: IPXACT2022ScalaCases.AbstractorType, __scope: scala.xml.NamespaceBinding): scala.xml.MetaData = {
      var attr: scala.xml.MetaData  = scala.xml.Null
      __obj.attributes.toList map {
        case ("@{http://www.w3.org/XML/1998/namespace}id", _) => __obj.xmlid foreach { x => attr = scala.xml.Attribute(__scope.getPrefix("http://www.w3.org/XML/1998/namespace"), "id", x.toString, attr) }
        case (key, x) => attr = scala.xml.Attribute((x.namespace map { __scope.getPrefix(_) }).orNull, x.key.orNull, x.value.toString, attr)
      }
      attr
    }

    def writesChildNodes(__obj: IPXACT2022ScalaCases.AbstractorType, __scope: scala.xml.NamespaceBinding): Seq[scala.xml.Node] =
      Seq.concat(IPXACT2022scalaxb.toXML[IPXACT2022ScalaCases.DocumentNameGroupSequence](__obj.documentNameGroupSequence1, None, Some("documentNameGroupSequence1"), __scope, false),
        IPXACT2022scalaxb.toXML[IPXACT2022ScalaCases.AbstractorMode](__obj.abstractorMode, Some("http://www.accellera.org/XMLSchema/IPXACT/1685-2022"), Some("abstractorMode"), __scope, false),
        IPXACT2022scalaxb.toXML[IPXACT2022ScalaCases.LibraryRefType](__obj.busType, Some("http://www.accellera.org/XMLSchema/IPXACT/1685-2022"), Some("busType"), __scope, false),
        IPXACT2022scalaxb.toXML[IPXACT2022ScalaCases.AbstractorInterfaces](__obj.abstractorInterfaces, Some("http://www.accellera.org/XMLSchema/IPXACT/1685-2022"), Some("abstractorInterfaces"), __scope, false),
        __obj.model map { IPXACT2022scalaxb.toXML[IPXACT2022ScalaCases.AbstractorModelType](_, Some("http://www.accellera.org/XMLSchema/IPXACT/1685-2022"), Some("model"), __scope, false) } getOrElse {Nil},
        __obj.abstractorGenerators map { IPXACT2022scalaxb.toXML[IPXACT2022ScalaCases.AbstractorGenerators](_, Some("http://www.accellera.org/XMLSchema/IPXACT/1685-2022"), Some("abstractorGenerators"), __scope, false) } getOrElse {Nil},
        __obj.choices map { IPXACT2022scalaxb.toXML[IPXACT2022ScalaCases.Choices](_, Some("http://www.accellera.org/XMLSchema/IPXACT/1685-2022"), Some("choices"), __scope, false) } getOrElse {Nil},
        __obj.fileSets map { IPXACT2022scalaxb.toXML[IPXACT2022ScalaCases.FileSets](_, Some("http://www.accellera.org/XMLSchema/IPXACT/1685-2022"), Some("fileSets"), __scope, false) } getOrElse {Nil},
        __obj.parameters map { IPXACT2022scalaxb.toXML[IPXACT2022ScalaCases.Parameters](_, Some("http://www.accellera.org/XMLSchema/IPXACT/1685-2022"), Some("parameters"), __scope, false) } getOrElse {Nil},
        __obj.assertions map { IPXACT2022scalaxb.toXML[IPXACT2022ScalaCases.Assertions](_, Some("http://www.accellera.org/XMLSchema/IPXACT/1685-2022"), Some("assertions"), __scope, false) } getOrElse {Nil},
        __obj.vendorExtensions map { IPXACT2022scalaxb.toXML[IPXACT2022ScalaCases.VendorExtensions](_, Some("http://www.accellera.org/XMLSchema/IPXACT/1685-2022"), Some("vendorExtensions"), __scope, false) } getOrElse {Nil})

  }

  def buildIPXACT2022ScalaCases_AbstractorModeTypeFormat = new DefaultIPXACT2022ScalaCases_AbstractorModeTypeFormat {}
  trait DefaultIPXACT2022ScalaCases_AbstractorModeTypeFormat extends IPXACT2022scalaxb.XMLFormat[IPXACT2022ScalaCases.AbstractorModeType] {
    val targetNamespace: Option[String] = Some("http://www.accellera.org/XMLSchema/IPXACT/1685-2022")
    
    def fromString(value: String, scope: scala.xml.NamespaceBinding): IPXACT2022ScalaCases.AbstractorModeType =
        (fromString0(value, scope)).apply(IPXACT2022scalaxb.fromXML[String](scala.xml.Text(value)))

    private def fromString0(value: String, scope: scala.xml.NamespaceBinding): PartialFunction[Any, IPXACT2022ScalaCases.AbstractorModeType] = {
      case x: String if x == IPXACT2022scalaxb.fromXML[String](scala.xml.Text("initiator")) => IPXACT2022ScalaCases.InitiatorValue
      case x: String if x == IPXACT2022scalaxb.fromXML[String](scala.xml.Text("target")) => IPXACT2022ScalaCases.TargetValue
      case x: String if x == IPXACT2022scalaxb.fromXML[String](scala.xml.Text("direct")) => IPXACT2022ScalaCases.Direct
      case x: String if x == IPXACT2022scalaxb.fromXML[String](scala.xml.Text("system")) => IPXACT2022ScalaCases.SystemValue

    }



    def reads(seq: scala.xml.NodeSeq, stack: List[IPXACT2022scalaxb.ElemName]): Either[String, IPXACT2022ScalaCases.AbstractorModeType] = seq match {
      case elem: scala.xml.Elem => Right(fromString(elem.text, elem.scope))
      case _ => Right(fromString(seq.text, scala.xml.TopScope))
    }
    
    def writes(__obj: IPXACT2022ScalaCases.AbstractorModeType, __namespace: Option[String], __elementLabel: Option[String],
        __scope: scala.xml.NamespaceBinding, __typeAttribute: Boolean): scala.xml.NodeSeq =
      scala.xml.Elem(IPXACT2022scalaxb.Helper.getPrefix(__namespace, __scope).orNull,
        __elementLabel getOrElse { sys.error("missing element label.") },
        scala.xml.Null, __scope, true, scala.xml.Text(__obj.toString))
  }
  def buildIPXACT2022ScalaCases_FormatTypeFormat = new DefaultIPXACT2022ScalaCases_FormatTypeFormat {}
  trait DefaultIPXACT2022ScalaCases_FormatTypeFormat extends IPXACT2022scalaxb.XMLFormat[IPXACT2022ScalaCases.FormatType] {
    val targetNamespace: Option[String] = Some("http://www.accellera.org/XMLSchema/IPXACT/1685-2022")
    
    def fromString(value: String, scope: scala.xml.NamespaceBinding): IPXACT2022ScalaCases.FormatType =
        (fromString0(value, scope)).apply(IPXACT2022scalaxb.fromXML[String](scala.xml.Text(value)))

    private def fromString0(value: String, scope: scala.xml.NamespaceBinding): PartialFunction[Any, IPXACT2022ScalaCases.FormatType] = {
      case x: String if x == IPXACT2022scalaxb.fromXML[String](scala.xml.Text("bit")) => IPXACT2022ScalaCases.Bit
      case x: String if x == IPXACT2022scalaxb.fromXML[String](scala.xml.Text("byte")) => IPXACT2022ScalaCases.ByteType
      case x: String if x == IPXACT2022scalaxb.fromXML[String](scala.xml.Text("shortint")) => IPXACT2022ScalaCases.Shortint
      case x: String if x == IPXACT2022scalaxb.fromXML[String](scala.xml.Text("int")) => IPXACT2022ScalaCases.IntTypeValue2
      case x: String if x == IPXACT2022scalaxb.fromXML[String](scala.xml.Text("longint")) => IPXACT2022ScalaCases.Longint
      case x: String if x == IPXACT2022scalaxb.fromXML[String](scala.xml.Text("shortreal")) => IPXACT2022ScalaCases.Shortreal
      case x: String if x == IPXACT2022scalaxb.fromXML[String](scala.xml.Text("real")) => IPXACT2022ScalaCases.Real
      case x: String if x == IPXACT2022scalaxb.fromXML[String](scala.xml.Text("string")) => IPXACT2022ScalaCases.StringType

    }



    def reads(seq: scala.xml.NodeSeq, stack: List[IPXACT2022scalaxb.ElemName]): Either[String, IPXACT2022ScalaCases.FormatType] = seq match {
      case elem: scala.xml.Elem => Right(fromString(elem.text, elem.scope))
      case _ => Right(fromString(seq.text, scala.xml.TopScope))
    }
    
    def writes(__obj: IPXACT2022ScalaCases.FormatType, __namespace: Option[String], __elementLabel: Option[String],
        __scope: scala.xml.NamespaceBinding, __typeAttribute: Boolean): scala.xml.NodeSeq =
      scala.xml.Elem(IPXACT2022scalaxb.Helper.getPrefix(__namespace, __scope).orNull,
        __elementLabel getOrElse { sys.error("missing element label.") },
        scala.xml.Null, __scope, true, scala.xml.Text(__obj.toString))
  }
  def buildIPXACT2022ScalaCases_SignTypeFormat = new DefaultIPXACT2022ScalaCases_SignTypeFormat {}
  trait DefaultIPXACT2022ScalaCases_SignTypeFormat extends IPXACT2022scalaxb.XMLFormat[IPXACT2022ScalaCases.SignType] {
    val targetNamespace: Option[String] = Some("http://www.accellera.org/XMLSchema/IPXACT/1685-2022")
    
    def fromString(value: String, scope: scala.xml.NamespaceBinding): IPXACT2022ScalaCases.SignType =
        (fromString0(value, scope)).apply(IPXACT2022scalaxb.fromXML[String](scala.xml.Text(value)))

    private def fromString0(value: String, scope: scala.xml.NamespaceBinding): PartialFunction[Any, IPXACT2022ScalaCases.SignType] = {
      case x: String if x == IPXACT2022scalaxb.fromXML[String](scala.xml.Text("signed")) => IPXACT2022ScalaCases.Signed
      case x: String if x == IPXACT2022scalaxb.fromXML[String](scala.xml.Text("unsigned")) => IPXACT2022ScalaCases.Unsigned

    }



    def reads(seq: scala.xml.NodeSeq, stack: List[IPXACT2022scalaxb.ElemName]): Either[String, IPXACT2022ScalaCases.SignType] = seq match {
      case elem: scala.xml.Elem => Right(fromString(elem.text, elem.scope))
      case _ => Right(fromString(seq.text, scala.xml.TopScope))
    }
    
    def writes(__obj: IPXACT2022ScalaCases.SignType, __namespace: Option[String], __elementLabel: Option[String],
        __scope: scala.xml.NamespaceBinding, __typeAttribute: Boolean): scala.xml.NodeSeq =
      scala.xml.Elem(IPXACT2022scalaxb.Helper.getPrefix(__namespace, __scope).orNull,
        __elementLabel getOrElse { sys.error("missing element label.") },
        scala.xml.Null, __scope, true, scala.xml.Text(__obj.toString))
  }
  def buildIPXACT2022ScalaCases_DelayValueUnitTypeFormat = new DefaultIPXACT2022ScalaCases_DelayValueUnitTypeFormat {}
  trait DefaultIPXACT2022ScalaCases_DelayValueUnitTypeFormat extends IPXACT2022scalaxb.XMLFormat[IPXACT2022ScalaCases.DelayValueUnitType] {
    val targetNamespace: Option[String] = Some("http://www.accellera.org/XMLSchema/IPXACT/1685-2022")
    
    def fromString(value: String, scope: scala.xml.NamespaceBinding): IPXACT2022ScalaCases.DelayValueUnitType =
        (fromString0(value, scope)).apply(IPXACT2022scalaxb.fromXML[String](scala.xml.Text(value)))

    private def fromString0(value: String, scope: scala.xml.NamespaceBinding): PartialFunction[Any, IPXACT2022ScalaCases.DelayValueUnitType] = {
      case x: String if x == IPXACT2022scalaxb.fromXML[String](scala.xml.Text("ps")) => IPXACT2022ScalaCases.Ps
      case x: String if x == IPXACT2022scalaxb.fromXML[String](scala.xml.Text("ns")) => IPXACT2022ScalaCases.Ns

    }



    def reads(seq: scala.xml.NodeSeq, stack: List[IPXACT2022scalaxb.ElemName]): Either[String, IPXACT2022ScalaCases.DelayValueUnitType] = seq match {
      case elem: scala.xml.Elem => Right(fromString(elem.text, elem.scope))
      case _ => Right(fromString(seq.text, scala.xml.TopScope))
    }
    
    def writes(__obj: IPXACT2022ScalaCases.DelayValueUnitType, __namespace: Option[String], __elementLabel: Option[String],
        __scope: scala.xml.NamespaceBinding, __typeAttribute: Boolean): scala.xml.NodeSeq =
      scala.xml.Elem(IPXACT2022scalaxb.Helper.getPrefix(__namespace, __scope).orNull,
        __elementLabel getOrElse { sys.error("missing element label.") },
        scala.xml.Null, __scope, true, scala.xml.Text(__obj.toString))
  }
  trait DefaultIPXACT2022ScalaCases_EnumerationFormat extends IPXACT2022scalaxb.XMLFormat[IPXACT2022ScalaCases.Enumeration] with IPXACT2022scalaxb.CanWriteChildNodes[IPXACT2022ScalaCases.Enumeration] {
    val targetNamespace: Option[String] = Some("http://www.accellera.org/XMLSchema/IPXACT/1685-2022")
    def reads(seq: scala.xml.NodeSeq, stack: List[IPXACT2022scalaxb.ElemName]): Either[String, IPXACT2022ScalaCases.Enumeration] = seq match {
      case node: scala.xml.Node => Right(IPXACT2022ScalaCases.Enumeration(IPXACT2022scalaxb.fromXML[String](node, IPXACT2022scalaxb.ElemName(node) :: stack),
        scala.collection.immutable.ListMap(List(
        (node \ "@text").headOption map { x => IPXACT2022scalaxb.DataRecord(x, node, IPXACT2022scalaxb.fromXML[String](x, IPXACT2022scalaxb.ElemName(node) :: stack)) } map { "@text" -> _ },
        (node \ "@help").headOption map { x => IPXACT2022scalaxb.DataRecord(x, node, IPXACT2022scalaxb.fromXML[String](x, IPXACT2022scalaxb.ElemName(node) :: stack)) } map { "@help" -> _ },
        (node \ "@{http://www.w3.org/XML/1998/namespace}id").headOption map { x => IPXACT2022scalaxb.DataRecord(x, node, IPXACT2022scalaxb.fromXML[String](x, IPXACT2022scalaxb.ElemName(node) :: stack)) } map { "@{http://www.w3.org/XML/1998/namespace}id" -> _ }
        ).flatten[(String, IPXACT2022scalaxb.DataRecord[Any])] ::: (node match {
          case elem: scala.xml.Elem =>
            elem.attributes.toList flatMap {
              case scala.xml.UnprefixedAttribute(key, value, _) if key == "text" => Nil
              case scala.xml.UnprefixedAttribute(key, value, _) if key == "help" => Nil
              case scala.xml.PrefixedAttribute(pre, key, value, _) if pre == elem.scope.getPrefix("http://www.w3.org/XML/1998/namespace") &&
                key == "id" => Nil
              case scala.xml.UnprefixedAttribute(key, value, _) =>
                List(("@" + key, IPXACT2022scalaxb.DataRecord(None, Some(key), value.text)))
              case scala.xml.PrefixedAttribute(pre, key, value, _) =>
                val ns = elem.scope.getURI(pre)
                List(("@{" + ns + "}" + key, IPXACT2022scalaxb.DataRecord(Option[String](ns), Some(key), value.text)))
              case _ => Nil
            }
          case _ => Nil
        }): _*)))
      case _ => Left("reads failed: seq must be scala.xml.Node")
    }
    
    override def writesAttribute(__obj: IPXACT2022ScalaCases.Enumeration, __scope: scala.xml.NamespaceBinding): scala.xml.MetaData = {
      var attr: scala.xml.MetaData  = scala.xml.Null
      __obj.attributes.toList map {
        case ("@text", _) => __obj.text foreach { x => attr = scala.xml.Attribute(null, "text", x.toString, attr) }
        case ("@help", _) => __obj.help foreach { x => attr = scala.xml.Attribute(null, "help", x.toString, attr) }
        case ("@{http://www.w3.org/XML/1998/namespace}id", _) => __obj.xmlid foreach { x => attr = scala.xml.Attribute(__scope.getPrefix("http://www.w3.org/XML/1998/namespace"), "id", x.toString, attr) }
        case (key, x) => attr = scala.xml.Attribute((x.namespace map { __scope.getPrefix(_) }).orNull, x.key.orNull, x.value.toString, attr)
      }
      attr
    }

    def writesChildNodes(__obj: IPXACT2022ScalaCases.Enumeration, __scope: scala.xml.NamespaceBinding): Seq[scala.xml.Node] =
      Seq(scala.xml.Text(__obj.value.toString))

  }

  trait DefaultIPXACT2022ScalaCases_ChoiceFormat extends IPXACT2022scalaxb.ElemNameParser[IPXACT2022ScalaCases.Choice] {
    val targetNamespace: Option[String] = Some("http://www.accellera.org/XMLSchema/IPXACT/1685-2022")
    
    def parser(node: scala.xml.Node, stack: List[IPXACT2022scalaxb.ElemName]): Parser[IPXACT2022ScalaCases.Choice] =
      phrase((IPXACT2022scalaxb.ElemName(Some("http://www.accellera.org/XMLSchema/IPXACT/1685-2022"), "name")) ~
      safeRep(IPXACT2022scalaxb.ElemName(Some("http://www.accellera.org/XMLSchema/IPXACT/1685-2022"), "enumeration")) ^^
      { case p1 ~ p2 =>
      IPXACT2022ScalaCases.Choice(IPXACT2022scalaxb.fromXML[String](p1, IPXACT2022scalaxb.ElemName(node) :: stack),
        p2 map { IPXACT2022scalaxb.fromXML[IPXACT2022ScalaCases.Enumeration](_, IPXACT2022scalaxb.ElemName(node) :: stack) },
        scala.collection.immutable.ListMap(List(
        (node \ "@{http://www.w3.org/XML/1998/namespace}id").headOption map { x => IPXACT2022scalaxb.DataRecord(x, node, IPXACT2022scalaxb.fromXML[String](x, IPXACT2022scalaxb.ElemName(node) :: stack)) } map { "@{http://www.w3.org/XML/1998/namespace}id" -> _ }
        ).flatten[(String, IPXACT2022scalaxb.DataRecord[Any])]: _*)) })
    
    override def writesAttribute(__obj: IPXACT2022ScalaCases.Choice, __scope: scala.xml.NamespaceBinding): scala.xml.MetaData = {
      var attr: scala.xml.MetaData  = scala.xml.Null
      __obj.attributes.toList map {
        case ("@{http://www.w3.org/XML/1998/namespace}id", _) => __obj.xmlid foreach { x => attr = scala.xml.Attribute(__scope.getPrefix("http://www.w3.org/XML/1998/namespace"), "id", x.toString, attr) }
        case (key, x) => attr = scala.xml.Attribute((x.namespace map { __scope.getPrefix(_) }).orNull, x.key.orNull, x.value.toString, attr)
      }
      attr
    }

    def writesChildNodes(__obj: IPXACT2022ScalaCases.Choice, __scope: scala.xml.NamespaceBinding): Seq[scala.xml.Node] =
      Seq.concat(IPXACT2022scalaxb.toXML[String](__obj.name, Some("http://www.accellera.org/XMLSchema/IPXACT/1685-2022"), Some("name"), __scope, false),
        __obj.enumeration flatMap { IPXACT2022scalaxb.toXML[IPXACT2022ScalaCases.Enumeration](_, Some("http://www.accellera.org/XMLSchema/IPXACT/1685-2022"), Some("enumeration"), __scope, false) })

  }

  trait DefaultIPXACT2022ScalaCases_ChoicesFormat extends IPXACT2022scalaxb.ElemNameParser[IPXACT2022ScalaCases.Choices] {
    val targetNamespace: Option[String] = Some("http://www.accellera.org/XMLSchema/IPXACT/1685-2022")
    
    def parser(node: scala.xml.Node, stack: List[IPXACT2022scalaxb.ElemName]): Parser[IPXACT2022ScalaCases.Choices] =
      phrase(safeRep(IPXACT2022scalaxb.ElemName(Some("http://www.accellera.org/XMLSchema/IPXACT/1685-2022"), "choice")) ^^
      { case p1 =>
      IPXACT2022ScalaCases.Choices(p1 map { IPXACT2022scalaxb.fromXML[IPXACT2022ScalaCases.Choice](_, IPXACT2022scalaxb.ElemName(node) :: stack) }) })
    
    def writesChildNodes(__obj: IPXACT2022ScalaCases.Choices, __scope: scala.xml.NamespaceBinding): Seq[scala.xml.Node] =
      (__obj.choice flatMap { IPXACT2022scalaxb.toXML[IPXACT2022ScalaCases.Choice](_, Some("http://www.accellera.org/XMLSchema/IPXACT/1685-2022"), Some("choice"), __scope, false) })
  }
  trait DefaultIPXACT2022ScalaCases_Idu46attFormat extends IPXACT2022scalaxb.AttributeGroupFormat[IPXACT2022ScalaCases.Idu46att] {
    val targetNamespace: Option[String] = Some("http://www.accellera.org/XMLSchema/IPXACT/1685-2022")
    
    def reads(seq: scala.xml.NodeSeq, stack: List[IPXACT2022scalaxb.ElemName]): Either[String, IPXACT2022ScalaCases.Idu46att] = seq match {
      case node: scala.xml.Node => Right(IPXACT2022ScalaCases.Idu46att((node \ "@{http://www.w3.org/XML/1998/namespace}id").headOption map { IPXACT2022scalaxb.fromXML[String](_, IPXACT2022scalaxb.ElemName(node) :: stack) }))
      case _ => Left("reads failed: seq must be scala.xml.Node")
    }
    
    def toAttribute(__obj: IPXACT2022ScalaCases.Idu46att, __attr: scala.xml.MetaData, __scope: scala.xml.NamespaceBinding): scala.xml.MetaData = {
      var attr: scala.xml.MetaData  = __attr
      __obj.xmlid foreach { x => attr = scala.xml.Attribute(__scope.getPrefix("http://www.w3.org/XML/1998/namespace"), "id", x.toString, attr) }
      attr
    }
  }
  trait DefaultIPXACT2022ScalaCases_Anyu46attFormat extends IPXACT2022scalaxb.AttributeGroupFormat[IPXACT2022ScalaCases.Anyu46att] {
    val targetNamespace: Option[String] = Some("http://www.accellera.org/XMLSchema/IPXACT/1685-2022")
    
    def reads(seq: scala.xml.NodeSeq, stack: List[IPXACT2022scalaxb.ElemName]): Either[String, IPXACT2022ScalaCases.Anyu46att] = seq match {
      case node: scala.xml.Node => Right(IPXACT2022ScalaCases.Anyu46att(scala.collection.immutable.ListMap((node match {
          case elem: scala.xml.Elem =>
            elem.attributes.toList flatMap {
              
              case scala.xml.UnprefixedAttribute(key, value, _) =>
                List(("@" + key, IPXACT2022scalaxb.DataRecord(None, Some(key), value.text)))
              case scala.xml.PrefixedAttribute(pre, key, value, _) =>
                val ns = elem.scope.getURI(pre)
                List(("@{" + ns + "}" + key, IPXACT2022scalaxb.DataRecord(Option[String](ns), Some(key), value.text)))
              case _ => Nil
            }
          case _ => Nil
        }): _*)))
      case _ => Left("reads failed: seq must be scala.xml.Node")
    }
    
    def toAttribute(__obj: IPXACT2022ScalaCases.Anyu46att, __attr: scala.xml.MetaData, __scope: scala.xml.NamespaceBinding): scala.xml.MetaData = {
      var attr: scala.xml.MetaData  = __attr
      __obj.attributes.toList map {
        case (key, x) => attr = scala.xml.Attribute((x.namespace map { __scope.getPrefix(_) }).orNull, x.key.orNull, x.value.toString, attr) }
      attr
    }
  }

  trait DefaultIPXACT2022ScalaCases_SystemGroupNameFormat extends IPXACT2022scalaxb.XMLFormat[IPXACT2022ScalaCases.SystemGroupName] with IPXACT2022scalaxb.CanWriteChildNodes[IPXACT2022ScalaCases.SystemGroupName] {
    val targetNamespace: Option[String] = Some("http://www.accellera.org/XMLSchema/IPXACT/1685-2022")
    def reads(seq: scala.xml.NodeSeq, stack: List[IPXACT2022scalaxb.ElemName]): Either[String, IPXACT2022ScalaCases.SystemGroupName] = seq match {
      case node: scala.xml.Node => Right(IPXACT2022ScalaCases.SystemGroupName(IPXACT2022scalaxb.fromXML[String](node, IPXACT2022scalaxb.ElemName(node) :: stack),
        scala.collection.immutable.ListMap(List(
        (node \ "@{http://www.w3.org/XML/1998/namespace}id").headOption map { x => IPXACT2022scalaxb.DataRecord(x, node, IPXACT2022scalaxb.fromXML[String](x, IPXACT2022scalaxb.ElemName(node) :: stack)) } map { "@{http://www.w3.org/XML/1998/namespace}id" -> _ }
        ).flatten[(String, IPXACT2022scalaxb.DataRecord[Any])]: _*)))
      case _ => Left("reads failed: seq must be scala.xml.Node")
    }
    
    override def writesAttribute(__obj: IPXACT2022ScalaCases.SystemGroupName, __scope: scala.xml.NamespaceBinding): scala.xml.MetaData = {
      var attr: scala.xml.MetaData  = scala.xml.Null
      __obj.attributes.toList map {
        case ("@{http://www.w3.org/XML/1998/namespace}id", _) => __obj.xmlid foreach { x => attr = scala.xml.Attribute(__scope.getPrefix("http://www.w3.org/XML/1998/namespace"), "id", x.toString, attr) }
        case (key, x) => attr = scala.xml.Attribute((x.namespace map { __scope.getPrefix(_) }).orNull, x.key.orNull, x.value.toString, attr)
      }
      attr
    }

    def writesChildNodes(__obj: IPXACT2022ScalaCases.SystemGroupName, __scope: scala.xml.NamespaceBinding): Seq[scala.xml.Node] =
      Seq(scala.xml.Text(__obj.value.toString))

  }

  trait DefaultIPXACT2022ScalaCases_SystemGroupNamesFormat extends IPXACT2022scalaxb.ElemNameParser[IPXACT2022ScalaCases.SystemGroupNames] {
    val targetNamespace: Option[String] = Some("http://www.accellera.org/XMLSchema/IPXACT/1685-2022")
    
    def parser(node: scala.xml.Node, stack: List[IPXACT2022scalaxb.ElemName]): Parser[IPXACT2022ScalaCases.SystemGroupNames] =
      phrase(safeRep(IPXACT2022scalaxb.ElemName(Some("http://www.accellera.org/XMLSchema/IPXACT/1685-2022"), "systemGroupName")) ^^
      { case p1 =>
      IPXACT2022ScalaCases.SystemGroupNames(p1 map { IPXACT2022scalaxb.fromXML[IPXACT2022ScalaCases.SystemGroupName](_, IPXACT2022scalaxb.ElemName(node) :: stack) }) })
    
    def writesChildNodes(__obj: IPXACT2022ScalaCases.SystemGroupNames, __scope: scala.xml.NamespaceBinding): Seq[scala.xml.Node] =
      (__obj.systemGroupName flatMap { IPXACT2022scalaxb.toXML[IPXACT2022ScalaCases.SystemGroupName](_, Some("http://www.accellera.org/XMLSchema/IPXACT/1685-2022"), Some("systemGroupName"), __scope, false) })
  }
  trait DefaultIPXACT2022ScalaCases_BusDefinitionFormat extends IPXACT2022scalaxb.ElemNameParser[IPXACT2022ScalaCases.BusDefinition] with IPXACT2022ScalaCases_DocumentNameGroupGroupFormat {
    val targetNamespace: Option[String] = Some("http://www.accellera.org/XMLSchema/IPXACT/1685-2022")
    
    def parser(node: scala.xml.Node, stack: List[IPXACT2022scalaxb.ElemName]): Parser[IPXACT2022ScalaCases.BusDefinition] =
      phrase((parseDocumentNameGroupGroup(node, IPXACT2022scalaxb.ElemName(node) :: stack)) ~
      (IPXACT2022scalaxb.ElemName(Some("http://www.accellera.org/XMLSchema/IPXACT/1685-2022"), "directConnection")) ~
      opt(IPXACT2022scalaxb.ElemName(Some("http://www.accellera.org/XMLSchema/IPXACT/1685-2022"), "broadcast")) ~
      (IPXACT2022scalaxb.ElemName(Some("http://www.accellera.org/XMLSchema/IPXACT/1685-2022"), "isAddressable")) ~
      opt(IPXACT2022scalaxb.ElemName(Some("http://www.accellera.org/XMLSchema/IPXACT/1685-2022"), "extends")) ~
      opt(IPXACT2022scalaxb.ElemName(Some("http://www.accellera.org/XMLSchema/IPXACT/1685-2022"), "maxInitiators")) ~
      opt(IPXACT2022scalaxb.ElemName(Some("http://www.accellera.org/XMLSchema/IPXACT/1685-2022"), "maxTargets")) ~
      opt(IPXACT2022scalaxb.ElemName(Some("http://www.accellera.org/XMLSchema/IPXACT/1685-2022"), "systemGroupNames")) ~
      opt(IPXACT2022scalaxb.ElemName(Some("http://www.accellera.org/XMLSchema/IPXACT/1685-2022"), "choices")) ~
      opt(IPXACT2022scalaxb.ElemName(Some("http://www.accellera.org/XMLSchema/IPXACT/1685-2022"), "parameters")) ~
      opt(IPXACT2022scalaxb.ElemName(Some("http://www.accellera.org/XMLSchema/IPXACT/1685-2022"), "assertions")) ~
      opt(IPXACT2022scalaxb.ElemName(Some("http://www.accellera.org/XMLSchema/IPXACT/1685-2022"), "vendorExtensions")) ^^
      { case p1 ~ p2 ~ p3 ~ p4 ~ p5 ~ p6 ~ p7 ~ p8 ~ p9 ~ p10 ~ p11 ~ p12 =>
      IPXACT2022ScalaCases.BusDefinition(p1,
        IPXACT2022scalaxb.fromXML[Boolean](p2, IPXACT2022scalaxb.ElemName(node) :: stack),
        p3.headOption map { IPXACT2022scalaxb.fromXML[Boolean](_, IPXACT2022scalaxb.ElemName(node) :: stack) },
        IPXACT2022scalaxb.fromXML[Boolean](p4, IPXACT2022scalaxb.ElemName(node) :: stack),
        p5.headOption map { IPXACT2022scalaxb.fromXML[IPXACT2022ScalaCases.LibraryRefType](_, IPXACT2022scalaxb.ElemName(node) :: stack) },
        p6.headOption map { IPXACT2022scalaxb.fromXML[IPXACT2022ScalaCases.UnsignedIntExpressionable](_, IPXACT2022scalaxb.ElemName(node) :: stack) },
        p7.headOption map { IPXACT2022scalaxb.fromXML[IPXACT2022ScalaCases.UnsignedIntExpressionable](_, IPXACT2022scalaxb.ElemName(node) :: stack) },
        p8.headOption map { IPXACT2022scalaxb.fromXML[IPXACT2022ScalaCases.SystemGroupNames](_, IPXACT2022scalaxb.ElemName(node) :: stack) },
        p9.headOption map { IPXACT2022scalaxb.fromXML[IPXACT2022ScalaCases.Choices](_, IPXACT2022scalaxb.ElemName(node) :: stack) },
        p10.headOption map { IPXACT2022scalaxb.fromXML[IPXACT2022ScalaCases.Parameters](_, IPXACT2022scalaxb.ElemName(node) :: stack) },
        p11.headOption map { IPXACT2022scalaxb.fromXML[IPXACT2022ScalaCases.Assertions](_, IPXACT2022scalaxb.ElemName(node) :: stack) },
        p12.headOption map { IPXACT2022scalaxb.fromXML[IPXACT2022ScalaCases.VendorExtensions](_, IPXACT2022scalaxb.ElemName(node) :: stack) },
        scala.collection.immutable.ListMap(List(
        (node \ "@{http://www.w3.org/XML/1998/namespace}id").headOption map { x => IPXACT2022scalaxb.DataRecord(x, node, IPXACT2022scalaxb.fromXML[String](x, IPXACT2022scalaxb.ElemName(node) :: stack)) } map { "@{http://www.w3.org/XML/1998/namespace}id" -> _ }
        ).flatten[(String, IPXACT2022scalaxb.DataRecord[Any])]: _*)) })
    
    override def writesAttribute(__obj: IPXACT2022ScalaCases.BusDefinition, __scope: scala.xml.NamespaceBinding): scala.xml.MetaData = {
      var attr: scala.xml.MetaData  = scala.xml.Null
      __obj.attributes.toList map {
        case ("@{http://www.w3.org/XML/1998/namespace}id", _) => __obj.xmlid foreach { x => attr = scala.xml.Attribute(__scope.getPrefix("http://www.w3.org/XML/1998/namespace"), "id", x.toString, attr) }
        case (key, x) => attr = scala.xml.Attribute((x.namespace map { __scope.getPrefix(_) }).orNull, x.key.orNull, x.value.toString, attr)
      }
      attr
    }

    def writesChildNodes(__obj: IPXACT2022ScalaCases.BusDefinition, __scope: scala.xml.NamespaceBinding): Seq[scala.xml.Node] =
      Seq.concat(IPXACT2022scalaxb.toXML[IPXACT2022ScalaCases.DocumentNameGroupSequence](__obj.documentNameGroupSequence1, None, Some("documentNameGroupSequence1"), __scope, false),
        IPXACT2022scalaxb.toXML[Boolean](__obj.directConnection, Some("http://www.accellera.org/XMLSchema/IPXACT/1685-2022"), Some("directConnection"), __scope, false),
        __obj.broadcast map { IPXACT2022scalaxb.toXML[Boolean](_, Some("http://www.accellera.org/XMLSchema/IPXACT/1685-2022"), Some("broadcast"), __scope, false) } getOrElse {Nil},
        IPXACT2022scalaxb.toXML[Boolean](__obj.isAddressable, Some("http://www.accellera.org/XMLSchema/IPXACT/1685-2022"), Some("isAddressable"), __scope, false),
        __obj.extendsValue map { IPXACT2022scalaxb.toXML[IPXACT2022ScalaCases.LibraryRefType](_, Some("http://www.accellera.org/XMLSchema/IPXACT/1685-2022"), Some("extends"), __scope, false) } getOrElse {Nil},
        __obj.maxInitiators map { IPXACT2022scalaxb.toXML[IPXACT2022ScalaCases.UnsignedIntExpressionable](_, Some("http://www.accellera.org/XMLSchema/IPXACT/1685-2022"), Some("maxInitiators"), __scope, false) } getOrElse {Nil},
        __obj.maxTargets map { IPXACT2022scalaxb.toXML[IPXACT2022ScalaCases.UnsignedIntExpressionable](_, Some("http://www.accellera.org/XMLSchema/IPXACT/1685-2022"), Some("maxTargets"), __scope, false) } getOrElse {Nil},
        __obj.systemGroupNames map { IPXACT2022scalaxb.toXML[IPXACT2022ScalaCases.SystemGroupNames](_, Some("http://www.accellera.org/XMLSchema/IPXACT/1685-2022"), Some("systemGroupNames"), __scope, false) } getOrElse {Nil},
        __obj.choices map { IPXACT2022scalaxb.toXML[IPXACT2022ScalaCases.Choices](_, Some("http://www.accellera.org/XMLSchema/IPXACT/1685-2022"), Some("choices"), __scope, false) } getOrElse {Nil},
        __obj.parameters map { IPXACT2022scalaxb.toXML[IPXACT2022ScalaCases.Parameters](_, Some("http://www.accellera.org/XMLSchema/IPXACT/1685-2022"), Some("parameters"), __scope, false) } getOrElse {Nil},
        __obj.assertions map { IPXACT2022scalaxb.toXML[IPXACT2022ScalaCases.Assertions](_, Some("http://www.accellera.org/XMLSchema/IPXACT/1685-2022"), Some("assertions"), __scope, false) } getOrElse {Nil},
        __obj.vendorExtensions map { IPXACT2022scalaxb.toXML[IPXACT2022ScalaCases.VendorExtensions](_, Some("http://www.accellera.org/XMLSchema/IPXACT/1685-2022"), Some("vendorExtensions"), __scope, false) } getOrElse {Nil})

  }


  trait IPXACT2022ScalaCases_PortPropertiesGroupFormat extends IPXACT2022scalaxb.AnyElemNameParser {
    def parsePortPropertiesGroup(node: scala.xml.Node, stack: List[IPXACT2022scalaxb.ElemName]): Parser[IPXACT2022scalaxb.DataRecord[Any]] =
      (((IPXACT2022scalaxb.ElemName(Some("http://www.accellera.org/XMLSchema/IPXACT/1685-2022"), "direction")) ^^
      (x => IPXACT2022scalaxb.DataRecord(x.namespace, Some(x.name), IPXACT2022scalaxb.fromXML[String](x, IPXACT2022scalaxb.ElemName(node) :: stack)))) |
      ((IPXACT2022scalaxb.ElemName(Some("http://www.accellera.org/XMLSchema/IPXACT/1685-2022"), "initiative")) ^^
      (x => IPXACT2022scalaxb.DataRecord(x.namespace, Some(x.name), IPXACT2022scalaxb.fromXML[String](x, IPXACT2022scalaxb.ElemName(node) :: stack)))))
  
    def parsePortPropertiesGroup(node: scala.xml.Node, stack: List[IPXACT2022scalaxb.ElemName], wrap: Boolean): Parser[IPXACT2022scalaxb.DataRecord[Any]] =
      (((IPXACT2022scalaxb.ElemName(Some("http://www.accellera.org/XMLSchema/IPXACT/1685-2022"), "direction")) ^^
      (x => IPXACT2022scalaxb.DataRecord(x.namespace, Some(x.name), IPXACT2022scalaxb.fromXML[String](x, IPXACT2022scalaxb.ElemName(node) :: stack)))) |
      ((IPXACT2022scalaxb.ElemName(Some("http://www.accellera.org/XMLSchema/IPXACT/1685-2022"), "initiative")) ^^
      (x => IPXACT2022scalaxb.DataRecord(x.namespace, Some(x.name), IPXACT2022scalaxb.fromXML[String](x, IPXACT2022scalaxb.ElemName(node) :: stack)))))
    
    def parsemixedPortPropertiesGroup(node: scala.xml.Node, stack: List[IPXACT2022scalaxb.ElemName]): Parser[Seq[IPXACT2022scalaxb.DataRecord[Any]]] =
      (((((IPXACT2022scalaxb.ElemName(Some("http://www.accellera.org/XMLSchema/IPXACT/1685-2022"), "direction")) ^^
      (x => IPXACT2022scalaxb.DataRecord(x.namespace, Some(x.name), IPXACT2022scalaxb.fromXML[String](x, IPXACT2022scalaxb.ElemName(node) :: stack)))) ~
      optTextRecord) ^^ 
        { case p1 ~ p2 => Seq.concat(Seq(p1),
        p2.toList) }) ||| 
      ((((IPXACT2022scalaxb.ElemName(Some("http://www.accellera.org/XMLSchema/IPXACT/1685-2022"), "initiative")) ^^
      (x => IPXACT2022scalaxb.DataRecord(x.namespace, Some(x.name), IPXACT2022scalaxb.fromXML[String](x, IPXACT2022scalaxb.ElemName(node) :: stack)))) ~
      optTextRecord) ^^ 
        { case p1 ~ p2 => Seq.concat(Seq(p1),
        p2.toList) }))
  }

  def buildIPXACT2022ScalaCases_EndianessTypeFormat = new DefaultIPXACT2022ScalaCases_EndianessTypeFormat {}
  trait DefaultIPXACT2022ScalaCases_EndianessTypeFormat extends IPXACT2022scalaxb.XMLFormat[IPXACT2022ScalaCases.EndianessType] {
    val targetNamespace: Option[String] = Some("http://www.accellera.org/XMLSchema/IPXACT/1685-2022")
    
    def fromString(value: String, scope: scala.xml.NamespaceBinding): IPXACT2022ScalaCases.EndianessType =
        (fromString0(value, scope)).apply(IPXACT2022scalaxb.fromXML[String](scala.xml.Text(value)))

    private def fromString0(value: String, scope: scala.xml.NamespaceBinding): PartialFunction[Any, IPXACT2022ScalaCases.EndianessType] = {
      case x: String if x == IPXACT2022scalaxb.fromXML[String](scala.xml.Text("big")) => IPXACT2022ScalaCases.Big
      case x: String if x == IPXACT2022scalaxb.fromXML[String](scala.xml.Text("little")) => IPXACT2022ScalaCases.Little

    }



    def reads(seq: scala.xml.NodeSeq, stack: List[IPXACT2022scalaxb.ElemName]): Either[String, IPXACT2022ScalaCases.EndianessType] = seq match {
      case elem: scala.xml.Elem => Right(fromString(elem.text, elem.scope))
      case _ => Right(fromString(seq.text, scala.xml.TopScope))
    }
    
    def writes(__obj: IPXACT2022ScalaCases.EndianessType, __namespace: Option[String], __elementLabel: Option[String],
        __scope: scala.xml.NamespaceBinding, __typeAttribute: Boolean): scala.xml.NodeSeq =
      scala.xml.Elem(IPXACT2022scalaxb.Helper.getPrefix(__namespace, __scope).orNull,
        __elementLabel getOrElse { sys.error("missing element label.") },
        scala.xml.Null, __scope, true, scala.xml.Text(__obj.toString))
  }
  trait DefaultIPXACT2022ScalaCases_ViewRef5Format extends IPXACT2022scalaxb.XMLFormat[IPXACT2022ScalaCases.ViewRef5] with IPXACT2022scalaxb.CanWriteChildNodes[IPXACT2022ScalaCases.ViewRef5] {
    val targetNamespace: Option[String] = Some("http://www.accellera.org/XMLSchema/IPXACT/1685-2022")
    def reads(seq: scala.xml.NodeSeq, stack: List[IPXACT2022scalaxb.ElemName]): Either[String, IPXACT2022ScalaCases.ViewRef5] = seq match {
      case node: scala.xml.Node => Right(IPXACT2022ScalaCases.ViewRef5(IPXACT2022scalaxb.fromXML[String](node, IPXACT2022scalaxb.ElemName(node) :: stack),
        scala.collection.immutable.ListMap(List(
        (node \ "@{http://www.w3.org/XML/1998/namespace}id").headOption map { x => IPXACT2022scalaxb.DataRecord(x, node, IPXACT2022scalaxb.fromXML[String](x, IPXACT2022scalaxb.ElemName(node) :: stack)) } map { "@{http://www.w3.org/XML/1998/namespace}id" -> _ }
        ).flatten[(String, IPXACT2022scalaxb.DataRecord[Any])]: _*)))
      case _ => Left("reads failed: seq must be scala.xml.Node")
    }
    
    override def writesAttribute(__obj: IPXACT2022ScalaCases.ViewRef5, __scope: scala.xml.NamespaceBinding): scala.xml.MetaData = {
      var attr: scala.xml.MetaData  = scala.xml.Null
      __obj.attributes.toList map {
        case ("@{http://www.w3.org/XML/1998/namespace}id", _) => __obj.xmlid foreach { x => attr = scala.xml.Attribute(__scope.getPrefix("http://www.w3.org/XML/1998/namespace"), "id", x.toString, attr) }
        case (key, x) => attr = scala.xml.Attribute((x.namespace map { __scope.getPrefix(_) }).orNull, x.key.orNull, x.value.toString, attr)
      }
      attr
    }

    def writesChildNodes(__obj: IPXACT2022ScalaCases.ViewRef5, __scope: scala.xml.NamespaceBinding): Seq[scala.xml.Node] =
      Seq(scala.xml.Text(__obj.value.toString))

  }

  trait DefaultIPXACT2022ScalaCases_BusInterfacesFormat extends IPXACT2022scalaxb.ElemNameParser[IPXACT2022ScalaCases.BusInterfaces] {
    val targetNamespace: Option[String] = Some("http://www.accellera.org/XMLSchema/IPXACT/1685-2022")
    
    def parser(node: scala.xml.Node, stack: List[IPXACT2022scalaxb.ElemName]): Parser[IPXACT2022ScalaCases.BusInterfaces] =
      phrase(safeRep(IPXACT2022scalaxb.ElemName(Some("http://www.accellera.org/XMLSchema/IPXACT/1685-2022"), "busInterface")) ^^
      { case p1 =>
      IPXACT2022ScalaCases.BusInterfaces(p1 map { IPXACT2022scalaxb.fromXML[IPXACT2022ScalaCases.BusInterfaceType](_, IPXACT2022scalaxb.ElemName(node) :: stack) }) })
    
    def writesChildNodes(__obj: IPXACT2022ScalaCases.BusInterfaces, __scope: scala.xml.NamespaceBinding): Seq[scala.xml.Node] =
      (__obj.busInterface flatMap { IPXACT2022scalaxb.toXML[IPXACT2022ScalaCases.BusInterfaceType](_, Some("http://www.accellera.org/XMLSchema/IPXACT/1685-2022"), Some("busInterface"), __scope, false) })
  }
  trait DefaultIPXACT2022ScalaCases_BusInterfaceTypeFormat extends IPXACT2022scalaxb.ElemNameParser[IPXACT2022ScalaCases.BusInterfaceType] with IPXACT2022ScalaCases_NameGroupGroupFormat with IPXACT2022ScalaCases_InterfaceModeGroupFormat {
    val targetNamespace: Option[String] = Some("http://www.accellera.org/XMLSchema/IPXACT/1685-2022")
    
    override def typeName: Option[String] = Some("busInterfaceType")

    def parser(node: scala.xml.Node, stack: List[IPXACT2022scalaxb.ElemName]): Parser[IPXACT2022ScalaCases.BusInterfaceType] =
      phrase((parseNameGroupGroup(node, IPXACT2022scalaxb.ElemName(node) :: stack)) ~
      (IPXACT2022scalaxb.ElemName(Some("http://www.accellera.org/XMLSchema/IPXACT/1685-2022"), "busType")) ~
      opt(IPXACT2022scalaxb.ElemName(Some("http://www.accellera.org/XMLSchema/IPXACT/1685-2022"), "abstractionTypes")) ~
      (parseInterfaceModeGroup(node, IPXACT2022scalaxb.ElemName(node) :: stack)) ~
      opt(IPXACT2022scalaxb.ElemName(Some("http://www.accellera.org/XMLSchema/IPXACT/1685-2022"), "connectionRequired")) ~
      opt(IPXACT2022scalaxb.ElemName(Some("http://www.accellera.org/XMLSchema/IPXACT/1685-2022"), "bitsInLau")) ~
      opt(IPXACT2022scalaxb.ElemName(Some("http://www.accellera.org/XMLSchema/IPXACT/1685-2022"), "bitSteering")) ~
      opt(IPXACT2022scalaxb.ElemName(Some("http://www.accellera.org/XMLSchema/IPXACT/1685-2022"), "endianness")) ~
      opt(IPXACT2022scalaxb.ElemName(Some("http://www.accellera.org/XMLSchema/IPXACT/1685-2022"), "parameters")) ~
      opt(IPXACT2022scalaxb.ElemName(Some("http://www.accellera.org/XMLSchema/IPXACT/1685-2022"), "vendorExtensions")) ^^
      { case p1 ~ p2 ~ p3 ~ p4 ~ p5 ~ p6 ~ p7 ~ p8 ~ p9 ~ p10 =>
      IPXACT2022ScalaCases.BusInterfaceType(p1,
        IPXACT2022scalaxb.fromXML[IPXACT2022ScalaCases.ConfigurableLibraryRefType](p2, IPXACT2022scalaxb.ElemName(node) :: stack),
        p3.headOption map { IPXACT2022scalaxb.fromXML[IPXACT2022ScalaCases.AbstractionTypes](_, IPXACT2022scalaxb.ElemName(node) :: stack) },
        p4,
        p5.headOption map { IPXACT2022scalaxb.fromXML[Boolean](_, IPXACT2022scalaxb.ElemName(node) :: stack) },
        p6.headOption map { IPXACT2022scalaxb.fromXML[IPXACT2022ScalaCases.UnsignedPositiveLongintExpressionable](_, IPXACT2022scalaxb.ElemName(node) :: stack) },
        p7.headOption map { IPXACT2022scalaxb.fromXML[IPXACT2022ScalaCases.UnsignedBitExpression](_, IPXACT2022scalaxb.ElemName(node) :: stack) },
        p8.headOption map { IPXACT2022scalaxb.fromXML[IPXACT2022ScalaCases.EndianessType](_, IPXACT2022scalaxb.ElemName(node) :: stack) },
        p9.headOption map { IPXACT2022scalaxb.fromXML[IPXACT2022ScalaCases.Parameters](_, IPXACT2022scalaxb.ElemName(node) :: stack) },
        p10.headOption map { IPXACT2022scalaxb.fromXML[IPXACT2022ScalaCases.VendorExtensions](_, IPXACT2022scalaxb.ElemName(node) :: stack) },
        scala.collection.immutable.ListMap(List(
        (node \ "@{http://www.w3.org/XML/1998/namespace}id").headOption map { x => IPXACT2022scalaxb.DataRecord(x, node, IPXACT2022scalaxb.fromXML[String](x, IPXACT2022scalaxb.ElemName(node) :: stack)) } map { "@{http://www.w3.org/XML/1998/namespace}id" -> _ }
        ).flatten[(String, IPXACT2022scalaxb.DataRecord[Any])] ::: (node match {
          case elem: scala.xml.Elem =>
            elem.attributes.toList flatMap {
              case scala.xml.PrefixedAttribute(pre, key, value, _) if pre == elem.scope.getPrefix("http://www.w3.org/XML/1998/namespace") &&
                key == "id" => Nil
              case scala.xml.UnprefixedAttribute(key, value, _) =>
                List(("@" + key, IPXACT2022scalaxb.DataRecord(None, Some(key), value.text)))
              case scala.xml.PrefixedAttribute(pre, key, value, _) =>
                val ns = elem.scope.getURI(pre)
                List(("@{" + ns + "}" + key, IPXACT2022scalaxb.DataRecord(Option[String](ns), Some(key), value.text)))
              case _ => Nil
            }
          case _ => Nil
        }): _*)) })
    
    override def writesAttribute(__obj: IPXACT2022ScalaCases.BusInterfaceType, __scope: scala.xml.NamespaceBinding): scala.xml.MetaData = {
      var attr: scala.xml.MetaData  = scala.xml.Null
      __obj.attributes.toList map {
        case ("@{http://www.w3.org/XML/1998/namespace}id", _) => __obj.xmlid foreach { x => attr = scala.xml.Attribute(__scope.getPrefix("http://www.w3.org/XML/1998/namespace"), "id", x.toString, attr) }
        case (key, x) => attr = scala.xml.Attribute((x.namespace map { __scope.getPrefix(_) }).orNull, x.key.orNull, x.value.toString, attr)
      }
      attr
    }

    def writesChildNodes(__obj: IPXACT2022ScalaCases.BusInterfaceType, __scope: scala.xml.NamespaceBinding): Seq[scala.xml.Node] =
      Seq.concat(IPXACT2022scalaxb.toXML[IPXACT2022ScalaCases.NameGroupSequence](__obj.nameGroupSequence1, None, Some("nameGroupSequence1"), __scope, false),
        IPXACT2022scalaxb.toXML[IPXACT2022ScalaCases.ConfigurableLibraryRefType](__obj.busType, Some("http://www.accellera.org/XMLSchema/IPXACT/1685-2022"), Some("busType"), __scope, false),
        __obj.abstractionTypes map { IPXACT2022scalaxb.toXML[IPXACT2022ScalaCases.AbstractionTypes](_, Some("http://www.accellera.org/XMLSchema/IPXACT/1685-2022"), Some("abstractionTypes"), __scope, false) } getOrElse {Nil},
        (Some(__obj.interfaceModeOption4) map {x => IPXACT2022scalaxb.toXML[IPXACT2022scalaxb.DataRecord[Any]](x, x.namespace, x.key, __scope, false)}).get,
        __obj.connectionRequired map { IPXACT2022scalaxb.toXML[Boolean](_, Some("http://www.accellera.org/XMLSchema/IPXACT/1685-2022"), Some("connectionRequired"), __scope, false) } getOrElse {Nil},
        __obj.bitsInLau map { IPXACT2022scalaxb.toXML[IPXACT2022ScalaCases.UnsignedPositiveLongintExpressionable](_, Some("http://www.accellera.org/XMLSchema/IPXACT/1685-2022"), Some("bitsInLau"), __scope, false) } getOrElse {Nil},
        __obj.bitSteering map { IPXACT2022scalaxb.toXML[IPXACT2022ScalaCases.UnsignedBitExpression](_, Some("http://www.accellera.org/XMLSchema/IPXACT/1685-2022"), Some("bitSteering"), __scope, false) } getOrElse {Nil},
        __obj.endianness map { IPXACT2022scalaxb.toXML[IPXACT2022ScalaCases.EndianessType](_, Some("http://www.accellera.org/XMLSchema/IPXACT/1685-2022"), Some("endianness"), __scope, false) } getOrElse {Nil},
        __obj.parameters map { IPXACT2022scalaxb.toXML[IPXACT2022ScalaCases.Parameters](_, Some("http://www.accellera.org/XMLSchema/IPXACT/1685-2022"), Some("parameters"), __scope, false) } getOrElse {Nil},
        __obj.vendorExtensions map { IPXACT2022scalaxb.toXML[IPXACT2022ScalaCases.VendorExtensions](_, Some("http://www.accellera.org/XMLSchema/IPXACT/1685-2022"), Some("vendorExtensions"), __scope, false) } getOrElse {Nil})

  }

  trait DefaultIPXACT2022ScalaCases_BusInterfaceRefFormat extends IPXACT2022scalaxb.ElemNameParser[IPXACT2022ScalaCases.BusInterfaceRef] {
    val targetNamespace: Option[String] = Some("http://www.accellera.org/XMLSchema/IPXACT/1685-2022")
    
    def parser(node: scala.xml.Node, stack: List[IPXACT2022scalaxb.ElemName]): Parser[IPXACT2022ScalaCases.BusInterfaceRef] =
      phrase((IPXACT2022scalaxb.ElemName(Some("http://www.accellera.org/XMLSchema/IPXACT/1685-2022"), "localName")) ~
      opt(IPXACT2022scalaxb.ElemName(Some("http://www.accellera.org/XMLSchema/IPXACT/1685-2022"), "vendorExtensions")) ^^
      { case p1 ~ p2 =>
      IPXACT2022ScalaCases.BusInterfaceRef(IPXACT2022scalaxb.fromXML[String](p1, IPXACT2022scalaxb.ElemName(node) :: stack),
        p2.headOption map { IPXACT2022scalaxb.fromXML[IPXACT2022ScalaCases.VendorExtensions](_, IPXACT2022scalaxb.ElemName(node) :: stack) },
        scala.collection.immutable.ListMap(List(
        (node \ "@{http://www.w3.org/XML/1998/namespace}id").headOption map { x => IPXACT2022scalaxb.DataRecord(x, node, IPXACT2022scalaxb.fromXML[String](x, IPXACT2022scalaxb.ElemName(node) :: stack)) } map { "@{http://www.w3.org/XML/1998/namespace}id" -> _ }
        ).flatten[(String, IPXACT2022scalaxb.DataRecord[Any])]: _*)) })
    
    override def writesAttribute(__obj: IPXACT2022ScalaCases.BusInterfaceRef, __scope: scala.xml.NamespaceBinding): scala.xml.MetaData = {
      var attr: scala.xml.MetaData  = scala.xml.Null
      __obj.attributes.toList map {
        case ("@{http://www.w3.org/XML/1998/namespace}id", _) => __obj.xmlid foreach { x => attr = scala.xml.Attribute(__scope.getPrefix("http://www.w3.org/XML/1998/namespace"), "id", x.toString, attr) }
        case (key, x) => attr = scala.xml.Attribute((x.namespace map { __scope.getPrefix(_) }).orNull, x.key.orNull, x.value.toString, attr)
      }
      attr
    }

    def writesChildNodes(__obj: IPXACT2022ScalaCases.BusInterfaceRef, __scope: scala.xml.NamespaceBinding): Seq[scala.xml.Node] =
      Seq.concat(IPXACT2022scalaxb.toXML[String](__obj.localName, Some("http://www.accellera.org/XMLSchema/IPXACT/1685-2022"), Some("localName"), __scope, false),
        __obj.vendorExtensions map { IPXACT2022scalaxb.toXML[IPXACT2022ScalaCases.VendorExtensions](_, Some("http://www.accellera.org/XMLSchema/IPXACT/1685-2022"), Some("vendorExtensions"), __scope, false) } getOrElse {Nil})

  }

  trait DefaultIPXACT2022ScalaCases_ChannelFormat extends IPXACT2022scalaxb.ElemNameParser[IPXACT2022ScalaCases.Channel] with IPXACT2022ScalaCases_NameGroupGroupFormat {
    val targetNamespace: Option[String] = Some("http://www.accellera.org/XMLSchema/IPXACT/1685-2022")
    
    def parser(node: scala.xml.Node, stack: List[IPXACT2022scalaxb.ElemName]): Parser[IPXACT2022ScalaCases.Channel] =
      phrase((parseNameGroupGroup(node, IPXACT2022scalaxb.ElemName(node) :: stack)) ~
      safeRep(IPXACT2022scalaxb.ElemName(Some("http://www.accellera.org/XMLSchema/IPXACT/1685-2022"), "busInterfaceRef")) ~
      opt(IPXACT2022scalaxb.ElemName(Some("http://www.accellera.org/XMLSchema/IPXACT/1685-2022"), "vendorExtensions")) ^^
      { case p1 ~ p2 ~ p3 =>
      IPXACT2022ScalaCases.Channel(p1,
        p2 map { IPXACT2022scalaxb.fromXML[IPXACT2022ScalaCases.BusInterfaceRef](_, IPXACT2022scalaxb.ElemName(node) :: stack) },
        p3.headOption map { IPXACT2022scalaxb.fromXML[IPXACT2022ScalaCases.VendorExtensions](_, IPXACT2022scalaxb.ElemName(node) :: stack) },
        scala.collection.immutable.ListMap(List(
        (node \ "@{http://www.w3.org/XML/1998/namespace}id").headOption map { x => IPXACT2022scalaxb.DataRecord(x, node, IPXACT2022scalaxb.fromXML[String](x, IPXACT2022scalaxb.ElemName(node) :: stack)) } map { "@{http://www.w3.org/XML/1998/namespace}id" -> _ }
        ).flatten[(String, IPXACT2022scalaxb.DataRecord[Any])]: _*)) })
    
    override def writesAttribute(__obj: IPXACT2022ScalaCases.Channel, __scope: scala.xml.NamespaceBinding): scala.xml.MetaData = {
      var attr: scala.xml.MetaData  = scala.xml.Null
      __obj.attributes.toList map {
        case ("@{http://www.w3.org/XML/1998/namespace}id", _) => __obj.xmlid foreach { x => attr = scala.xml.Attribute(__scope.getPrefix("http://www.w3.org/XML/1998/namespace"), "id", x.toString, attr) }
        case (key, x) => attr = scala.xml.Attribute((x.namespace map { __scope.getPrefix(_) }).orNull, x.key.orNull, x.value.toString, attr)
      }
      attr
    }

    def writesChildNodes(__obj: IPXACT2022ScalaCases.Channel, __scope: scala.xml.NamespaceBinding): Seq[scala.xml.Node] =
      Seq.concat(IPXACT2022scalaxb.toXML[IPXACT2022ScalaCases.NameGroupSequence](__obj.nameGroupSequence1, None, Some("nameGroupSequence1"), __scope, false),
        __obj.busInterfaceRef flatMap { IPXACT2022scalaxb.toXML[IPXACT2022ScalaCases.BusInterfaceRef](_, Some("http://www.accellera.org/XMLSchema/IPXACT/1685-2022"), Some("busInterfaceRef"), __scope, false) },
        __obj.vendorExtensions map { IPXACT2022scalaxb.toXML[IPXACT2022ScalaCases.VendorExtensions](_, Some("http://www.accellera.org/XMLSchema/IPXACT/1685-2022"), Some("vendorExtensions"), __scope, false) } getOrElse {Nil})

  }

  trait DefaultIPXACT2022ScalaCases_ChannelsFormat extends IPXACT2022scalaxb.ElemNameParser[IPXACT2022ScalaCases.Channels] {
    val targetNamespace: Option[String] = Some("http://www.accellera.org/XMLSchema/IPXACT/1685-2022")
    
    def parser(node: scala.xml.Node, stack: List[IPXACT2022scalaxb.ElemName]): Parser[IPXACT2022ScalaCases.Channels] =
      phrase(safeRep(IPXACT2022scalaxb.ElemName(Some("http://www.accellera.org/XMLSchema/IPXACT/1685-2022"), "channel")) ^^
      { case p1 =>
      IPXACT2022ScalaCases.Channels(p1 map { IPXACT2022scalaxb.fromXML[IPXACT2022ScalaCases.Channel](_, IPXACT2022scalaxb.ElemName(node) :: stack) }) })
    
    def writesChildNodes(__obj: IPXACT2022ScalaCases.Channels, __scope: scala.xml.NamespaceBinding): Seq[scala.xml.Node] =
      (__obj.channel flatMap { IPXACT2022scalaxb.toXML[IPXACT2022ScalaCases.Channel](_, Some("http://www.accellera.org/XMLSchema/IPXACT/1685-2022"), Some("channel"), __scope, false) })
  }
  trait DefaultIPXACT2022ScalaCases_ModeRefFormat extends IPXACT2022scalaxb.XMLFormat[IPXACT2022ScalaCases.ModeRef] with IPXACT2022scalaxb.CanWriteChildNodes[IPXACT2022ScalaCases.ModeRef] {
    val targetNamespace: Option[String] = Some("http://www.accellera.org/XMLSchema/IPXACT/1685-2022")
    def reads(seq: scala.xml.NodeSeq, stack: List[IPXACT2022scalaxb.ElemName]): Either[String, IPXACT2022ScalaCases.ModeRef] = seq match {
      case node: scala.xml.Node => Right(IPXACT2022ScalaCases.ModeRef(IPXACT2022scalaxb.fromXML[String](node, IPXACT2022scalaxb.ElemName(node) :: stack),
        scala.collection.immutable.ListMap(List(
        (node \ "@{http://www.w3.org/XML/1998/namespace}id").headOption map { x => IPXACT2022scalaxb.DataRecord(x, node, IPXACT2022scalaxb.fromXML[String](x, IPXACT2022scalaxb.ElemName(node) :: stack)) } map { "@{http://www.w3.org/XML/1998/namespace}id" -> _ }
        ).flatten[(String, IPXACT2022scalaxb.DataRecord[Any])]: _*)))
      case _ => Left("reads failed: seq must be scala.xml.Node")
    }
    
    override def writesAttribute(__obj: IPXACT2022ScalaCases.ModeRef, __scope: scala.xml.NamespaceBinding): scala.xml.MetaData = {
      var attr: scala.xml.MetaData  = scala.xml.Null
      __obj.attributes.toList map {
        case ("@{http://www.w3.org/XML/1998/namespace}id", _) => __obj.xmlid foreach { x => attr = scala.xml.Attribute(__scope.getPrefix("http://www.w3.org/XML/1998/namespace"), "id", x.toString, attr) }
        case (key, x) => attr = scala.xml.Attribute((x.namespace map { __scope.getPrefix(_) }).orNull, x.key.orNull, x.value.toString, attr)
      }
      attr
    }

    def writesChildNodes(__obj: IPXACT2022ScalaCases.ModeRef, __scope: scala.xml.NamespaceBinding): Seq[scala.xml.Node] =
      Seq(scala.xml.Text(__obj.value.toString))

  }

  trait DefaultIPXACT2022ScalaCases_AddressSpaceRef3Format extends IPXACT2022scalaxb.ElemNameParser[IPXACT2022ScalaCases.AddressSpaceRef3] {
    val targetNamespace: Option[String] = Some("http://www.accellera.org/XMLSchema/IPXACT/1685-2022")
    
    def parser(node: scala.xml.Node, stack: List[IPXACT2022scalaxb.ElemName]): Parser[IPXACT2022ScalaCases.AddressSpaceRef3] =
      phrase(opt(IPXACT2022scalaxb.ElemName(Some("http://www.accellera.org/XMLSchema/IPXACT/1685-2022"), "vendorExtensions")) ~
      opt(IPXACT2022scalaxb.ElemName(Some("http://www.accellera.org/XMLSchema/IPXACT/1685-2022"), "baseAddress")) ~
      safeRep(IPXACT2022scalaxb.ElemName(Some("http://www.accellera.org/XMLSchema/IPXACT/1685-2022"), "modeRef")) ^^
      { case p1 ~ p2 ~ p3 =>
      IPXACT2022ScalaCases.AddressSpaceRef3(p1.headOption map { IPXACT2022scalaxb.fromXML[IPXACT2022ScalaCases.VendorExtensions](_, IPXACT2022scalaxb.ElemName(node) :: stack) },
        p2.headOption map { IPXACT2022scalaxb.fromXML[IPXACT2022ScalaCases.SignedLongintExpression](_, IPXACT2022scalaxb.ElemName(node) :: stack) },
        p3 map { IPXACT2022scalaxb.fromXML[IPXACT2022ScalaCases.ModeRef](_, IPXACT2022scalaxb.ElemName(node) :: stack) },
        scala.collection.immutable.ListMap(List(
        (node \ "@addressSpaceRef").headOption map { x => IPXACT2022scalaxb.DataRecord(x, node, IPXACT2022scalaxb.fromXML[String](x, IPXACT2022scalaxb.ElemName(node) :: stack)) } map { "@addressSpaceRef" -> _ },
        (node \ "@{http://www.w3.org/XML/1998/namespace}id").headOption map { x => IPXACT2022scalaxb.DataRecord(x, node, IPXACT2022scalaxb.fromXML[String](x, IPXACT2022scalaxb.ElemName(node) :: stack)) } map { "@{http://www.w3.org/XML/1998/namespace}id" -> _ }
        ).flatten[(String, IPXACT2022scalaxb.DataRecord[Any])]: _*)) })
    
    override def writesAttribute(__obj: IPXACT2022ScalaCases.AddressSpaceRef3, __scope: scala.xml.NamespaceBinding): scala.xml.MetaData = {
      var attr: scala.xml.MetaData  = scala.xml.Null
      __obj.attributes.toList map {
        case ("@addressSpaceRef", _) => attr = scala.xml.Attribute(null, "addressSpaceRef", __obj.addressSpaceRef.toString, attr)
        case ("@{http://www.w3.org/XML/1998/namespace}id", _) => __obj.xmlid foreach { x => attr = scala.xml.Attribute(__scope.getPrefix("http://www.w3.org/XML/1998/namespace"), "id", x.toString, attr) }
        case (key, x) => attr = scala.xml.Attribute((x.namespace map { __scope.getPrefix(_) }).orNull, x.key.orNull, x.value.toString, attr)
      }
      attr
    }

    def writesChildNodes(__obj: IPXACT2022ScalaCases.AddressSpaceRef3, __scope: scala.xml.NamespaceBinding): Seq[scala.xml.Node] =
      Seq.concat(__obj.vendorExtensions map { IPXACT2022scalaxb.toXML[IPXACT2022ScalaCases.VendorExtensions](_, Some("http://www.accellera.org/XMLSchema/IPXACT/1685-2022"), Some("vendorExtensions"), __scope, false) } getOrElse {Nil},
        __obj.baseAddress map { IPXACT2022scalaxb.toXML[IPXACT2022ScalaCases.SignedLongintExpression](_, Some("http://www.accellera.org/XMLSchema/IPXACT/1685-2022"), Some("baseAddress"), __scope, false) } getOrElse {Nil},
        __obj.modeRef flatMap { IPXACT2022scalaxb.toXML[IPXACT2022ScalaCases.ModeRef](_, Some("http://www.accellera.org/XMLSchema/IPXACT/1685-2022"), Some("modeRef"), __scope, false) })

  }

  trait DefaultIPXACT2022ScalaCases_InitiatorFormat extends IPXACT2022scalaxb.ElemNameParser[IPXACT2022ScalaCases.Initiator] {
    val targetNamespace: Option[String] = Some("http://www.accellera.org/XMLSchema/IPXACT/1685-2022")
    
    def parser(node: scala.xml.Node, stack: List[IPXACT2022scalaxb.ElemName]): Parser[IPXACT2022ScalaCases.Initiator] =
      phrase(opt(IPXACT2022scalaxb.ElemName(Some("http://www.accellera.org/XMLSchema/IPXACT/1685-2022"), "addressSpaceRef")) ^^
      { case p1 =>
      IPXACT2022ScalaCases.Initiator(p1.headOption map { IPXACT2022scalaxb.fromXML[IPXACT2022ScalaCases.AddressSpaceRef3](_, IPXACT2022scalaxb.ElemName(node) :: stack) }) })
    
    def writesChildNodes(__obj: IPXACT2022ScalaCases.Initiator, __scope: scala.xml.NamespaceBinding): Seq[scala.xml.Node] =
      (__obj.addressSpaceRef map { IPXACT2022scalaxb.toXML[IPXACT2022ScalaCases.AddressSpaceRef3](_, Some("http://www.accellera.org/XMLSchema/IPXACT/1685-2022"), Some("addressSpaceRef"), __scope, false) } getOrElse {Nil})
  }
  trait DefaultIPXACT2022ScalaCases_FileSetRefGroup2Format extends IPXACT2022scalaxb.ElemNameParser[IPXACT2022ScalaCases.FileSetRefGroup2] {
    val targetNamespace: Option[String] = Some("http://www.accellera.org/XMLSchema/IPXACT/1685-2022")
    
    def parser(node: scala.xml.Node, stack: List[IPXACT2022scalaxb.ElemName]): Parser[IPXACT2022ScalaCases.FileSetRefGroup2] =
      phrase(opt(IPXACT2022scalaxb.ElemName(Some("http://www.accellera.org/XMLSchema/IPXACT/1685-2022"), "group")) ~
      safeRep(IPXACT2022scalaxb.ElemName(Some("http://www.accellera.org/XMLSchema/IPXACT/1685-2022"), "fileSetRef")) ^^
      { case p1 ~ p2 =>
      IPXACT2022ScalaCases.FileSetRefGroup2(p1.headOption map { IPXACT2022scalaxb.fromXML[String](_, IPXACT2022scalaxb.ElemName(node) :: stack) },
        p2 map { IPXACT2022scalaxb.fromXML[IPXACT2022ScalaCases.FileSetRef](_, IPXACT2022scalaxb.ElemName(node) :: stack) },
        scala.collection.immutable.ListMap(List(
        (node \ "@{http://www.w3.org/XML/1998/namespace}id").headOption map { x => IPXACT2022scalaxb.DataRecord(x, node, IPXACT2022scalaxb.fromXML[String](x, IPXACT2022scalaxb.ElemName(node) :: stack)) } map { "@{http://www.w3.org/XML/1998/namespace}id" -> _ }
        ).flatten[(String, IPXACT2022scalaxb.DataRecord[Any])]: _*)) })
    
    override def writesAttribute(__obj: IPXACT2022ScalaCases.FileSetRefGroup2, __scope: scala.xml.NamespaceBinding): scala.xml.MetaData = {
      var attr: scala.xml.MetaData  = scala.xml.Null
      __obj.attributes.toList map {
        case ("@{http://www.w3.org/XML/1998/namespace}id", _) => __obj.xmlid foreach { x => attr = scala.xml.Attribute(__scope.getPrefix("http://www.w3.org/XML/1998/namespace"), "id", x.toString, attr) }
        case (key, x) => attr = scala.xml.Attribute((x.namespace map { __scope.getPrefix(_) }).orNull, x.key.orNull, x.value.toString, attr)
      }
      attr
    }

    def writesChildNodes(__obj: IPXACT2022ScalaCases.FileSetRefGroup2, __scope: scala.xml.NamespaceBinding): Seq[scala.xml.Node] =
      Seq.concat(__obj.group map { IPXACT2022scalaxb.toXML[String](_, Some("http://www.accellera.org/XMLSchema/IPXACT/1685-2022"), Some("group"), __scope, false) } getOrElse {Nil},
        __obj.fileSetRef flatMap { IPXACT2022scalaxb.toXML[IPXACT2022ScalaCases.FileSetRef](_, Some("http://www.accellera.org/XMLSchema/IPXACT/1685-2022"), Some("fileSetRef"), __scope, false) })

  }

  trait DefaultIPXACT2022ScalaCases_TargetFormat extends IPXACT2022scalaxb.ElemNameParser[IPXACT2022ScalaCases.Target] {
    val targetNamespace: Option[String] = Some("http://www.accellera.org/XMLSchema/IPXACT/1685-2022")
    
    def parser(node: scala.xml.Node, stack: List[IPXACT2022scalaxb.ElemName]): Parser[IPXACT2022ScalaCases.Target] =
      phrase(safeRep(((IPXACT2022scalaxb.ElemName(Some("http://www.accellera.org/XMLSchema/IPXACT/1685-2022"), "memoryMapRef")) ^^
      (x => IPXACT2022scalaxb.DataRecord(x.namespace, Some(x.name), IPXACT2022scalaxb.fromXML[IPXACT2022ScalaCases.MemoryMapRefType](x, IPXACT2022scalaxb.ElemName(node) :: stack)))) |
      ((IPXACT2022scalaxb.ElemName(Some("http://www.accellera.org/XMLSchema/IPXACT/1685-2022"), "transparentBridge")) ^^
      (x => IPXACT2022scalaxb.DataRecord(x.namespace, Some(x.name), IPXACT2022scalaxb.fromXML[IPXACT2022ScalaCases.TransparentBridge](x, IPXACT2022scalaxb.ElemName(node) :: stack))))) ~
      safeRep(IPXACT2022scalaxb.ElemName(Some("http://www.accellera.org/XMLSchema/IPXACT/1685-2022"), "fileSetRefGroup")) ^^
      { case p1 ~ p2 =>
      IPXACT2022ScalaCases.Target(p1,
        p2 map { IPXACT2022scalaxb.fromXML[IPXACT2022ScalaCases.FileSetRefGroup2](_, IPXACT2022scalaxb.ElemName(node) :: stack) }) })
    
    def writesChildNodes(__obj: IPXACT2022ScalaCases.Target, __scope: scala.xml.NamespaceBinding): Seq[scala.xml.Node] =
      Seq.concat(__obj.targetoption flatMap { x => IPXACT2022scalaxb.toXML[IPXACT2022scalaxb.DataRecord[IPXACT2022ScalaCases.TargetOption]](x, x.namespace, x.key, __scope, false) },
        __obj.fileSetRefGroup flatMap { IPXACT2022scalaxb.toXML[IPXACT2022ScalaCases.FileSetRefGroup2](_, Some("http://www.accellera.org/XMLSchema/IPXACT/1685-2022"), Some("fileSetRefGroup"), __scope, false) })

  }

  trait DefaultIPXACT2022ScalaCases_SystemFormat extends IPXACT2022scalaxb.ElemNameParser[IPXACT2022ScalaCases.System] {
    val targetNamespace: Option[String] = Some("http://www.accellera.org/XMLSchema/IPXACT/1685-2022")
    
    def parser(node: scala.xml.Node, stack: List[IPXACT2022scalaxb.ElemName]): Parser[IPXACT2022ScalaCases.System] =
      phrase((IPXACT2022scalaxb.ElemName(Some("http://www.accellera.org/XMLSchema/IPXACT/1685-2022"), "group")) ^^
      { case p1 =>
      IPXACT2022ScalaCases.System(IPXACT2022scalaxb.fromXML[String](p1, IPXACT2022scalaxb.ElemName(node) :: stack)) })
    
    def writesChildNodes(__obj: IPXACT2022ScalaCases.System, __scope: scala.xml.NamespaceBinding): Seq[scala.xml.Node] =
      (IPXACT2022scalaxb.toXML[String](__obj.group, Some("http://www.accellera.org/XMLSchema/IPXACT/1685-2022"), Some("group"), __scope, false))
  }
  trait DefaultIPXACT2022ScalaCases_RemapAddressFormat extends IPXACT2022scalaxb.ElemNameParser[IPXACT2022ScalaCases.RemapAddress] {
    val targetNamespace: Option[String] = Some("http://www.accellera.org/XMLSchema/IPXACT/1685-2022")
    
    def parser(node: scala.xml.Node, stack: List[IPXACT2022scalaxb.ElemName]): Parser[IPXACT2022ScalaCases.RemapAddress] =
      phrase((IPXACT2022scalaxb.ElemName(None, "value")) ^^
      { case p1 =>
      IPXACT2022ScalaCases.RemapAddress(IPXACT2022scalaxb.fromXML[String](p1, IPXACT2022scalaxb.ElemName(node) :: stack),
        scala.collection.immutable.ListMap(List(
        (node \ "@minimum").headOption map { x => IPXACT2022scalaxb.DataRecord(x, node, IPXACT2022scalaxb.fromXML[Int](x, IPXACT2022scalaxb.ElemName(node) :: stack)) } map { "@minimum" -> _ },
        (node \ "@maximum").headOption map { x => IPXACT2022scalaxb.DataRecord(x, node, IPXACT2022scalaxb.fromXML[Int](x, IPXACT2022scalaxb.ElemName(node) :: stack)) } map { "@maximum" -> _ }
        ).flatten[(String, IPXACT2022scalaxb.DataRecord[Any])] ::: (node match {
          case elem: scala.xml.Elem =>
            elem.attributes.toList flatMap {
              case scala.xml.UnprefixedAttribute(key, value, _) if key == "minimum" => Nil
              case scala.xml.UnprefixedAttribute(key, value, _) if key == "maximum" => Nil
              case scala.xml.UnprefixedAttribute(key, value, _) =>
                List(("@" + key, IPXACT2022scalaxb.DataRecord(None, Some(key), value.text)))
              case scala.xml.PrefixedAttribute(pre, key, value, _) =>
                val ns = elem.scope.getURI(pre)
                List(("@{" + ns + "}" + key, IPXACT2022scalaxb.DataRecord(Option[String](ns), Some(key), value.text)))
              case _ => Nil
            }
          case _ => Nil
        }): _*)) })
    
    override def writesAttribute(__obj: IPXACT2022ScalaCases.RemapAddress, __scope: scala.xml.NamespaceBinding): scala.xml.MetaData = {
      var attr: scala.xml.MetaData  = scala.xml.Null
      __obj.attributes.toList map {
        case ("@minimum", _) => __obj.minimum foreach { x => attr = scala.xml.Attribute(null, "minimum", x.toString, attr) }
        case ("@maximum", _) => __obj.maximum foreach { x => attr = scala.xml.Attribute(null, "maximum", x.toString, attr) }
        case (key, x) => attr = scala.xml.Attribute((x.namespace map { __scope.getPrefix(_) }).orNull, x.key.orNull, x.value.toString, attr)
      }
      attr
    }

    def writesChildNodes(__obj: IPXACT2022ScalaCases.RemapAddress, __scope: scala.xml.NamespaceBinding): Seq[scala.xml.Node] =
      (IPXACT2022scalaxb.toXML[String](__obj.value, None, Some("value"), __scope, false))
  }

  trait DefaultIPXACT2022ScalaCases_RemapAddressesFormat extends IPXACT2022scalaxb.ElemNameParser[IPXACT2022ScalaCases.RemapAddresses] {
    val targetNamespace: Option[String] = Some("http://www.accellera.org/XMLSchema/IPXACT/1685-2022")
    
    def parser(node: scala.xml.Node, stack: List[IPXACT2022scalaxb.ElemName]): Parser[IPXACT2022ScalaCases.RemapAddresses] =
      phrase((IPXACT2022scalaxb.ElemName(Some("http://www.accellera.org/XMLSchema/IPXACT/1685-2022"), "remapAddress")) ~
      safeRep(IPXACT2022scalaxb.ElemName(Some("http://www.accellera.org/XMLSchema/IPXACT/1685-2022"), "modeRef")) ^^
      { case p1 ~ p2 =>
      IPXACT2022ScalaCases.RemapAddresses(IPXACT2022scalaxb.fromXML[IPXACT2022ScalaCases.RemapAddress](p1, IPXACT2022scalaxb.ElemName(node) :: stack),
        p2 map { IPXACT2022scalaxb.fromXML[IPXACT2022ScalaCases.ModeRef3](_, IPXACT2022scalaxb.ElemName(node) :: stack) },
        scala.collection.immutable.ListMap(List(
        (node \ "@{http://www.w3.org/XML/1998/namespace}id").headOption map { x => IPXACT2022scalaxb.DataRecord(x, node, IPXACT2022scalaxb.fromXML[String](x, IPXACT2022scalaxb.ElemName(node) :: stack)) } map { "@{http://www.w3.org/XML/1998/namespace}id" -> _ }
        ).flatten[(String, IPXACT2022scalaxb.DataRecord[Any])]: _*)) })
    
    override def writesAttribute(__obj: IPXACT2022ScalaCases.RemapAddresses, __scope: scala.xml.NamespaceBinding): scala.xml.MetaData = {
      var attr: scala.xml.MetaData  = scala.xml.Null
      __obj.attributes.toList map {
        case ("@{http://www.w3.org/XML/1998/namespace}id", _) => __obj.xmlid foreach { x => attr = scala.xml.Attribute(__scope.getPrefix("http://www.w3.org/XML/1998/namespace"), "id", x.toString, attr) }
        case (key, x) => attr = scala.xml.Attribute((x.namespace map { __scope.getPrefix(_) }).orNull, x.key.orNull, x.value.toString, attr)
      }
      attr
    }

    def writesChildNodes(__obj: IPXACT2022ScalaCases.RemapAddresses, __scope: scala.xml.NamespaceBinding): Seq[scala.xml.Node] =
      Seq.concat(IPXACT2022scalaxb.toXML[IPXACT2022ScalaCases.RemapAddress](__obj.remapAddress, Some("http://www.accellera.org/XMLSchema/IPXACT/1685-2022"), Some("remapAddress"), __scope, false),
        __obj.modeRef flatMap { IPXACT2022scalaxb.toXML[IPXACT2022ScalaCases.ModeRef3](_, Some("http://www.accellera.org/XMLSchema/IPXACT/1685-2022"), Some("modeRef"), __scope, false) })

  }

  trait DefaultIPXACT2022ScalaCases_BaseAddressesFormat extends IPXACT2022scalaxb.ElemNameParser[IPXACT2022ScalaCases.BaseAddresses] {
    val targetNamespace: Option[String] = Some("http://www.accellera.org/XMLSchema/IPXACT/1685-2022")
    
    def parser(node: scala.xml.Node, stack: List[IPXACT2022scalaxb.ElemName]): Parser[IPXACT2022ScalaCases.BaseAddresses] =
      phrase(safeRep(IPXACT2022scalaxb.ElemName(Some("http://www.accellera.org/XMLSchema/IPXACT/1685-2022"), "remapAddresses")) ~
      (IPXACT2022scalaxb.ElemName(Some("http://www.accellera.org/XMLSchema/IPXACT/1685-2022"), "range")) ^^
      { case p1 ~ p2 =>
      IPXACT2022ScalaCases.BaseAddresses(p1 map { IPXACT2022scalaxb.fromXML[IPXACT2022ScalaCases.RemapAddresses](_, IPXACT2022scalaxb.ElemName(node) :: stack) },
        IPXACT2022scalaxb.fromXML[IPXACT2022ScalaCases.UnsignedPositiveLongintExpressionable](p2, IPXACT2022scalaxb.ElemName(node) :: stack)) })
    
    def writesChildNodes(__obj: IPXACT2022ScalaCases.BaseAddresses, __scope: scala.xml.NamespaceBinding): Seq[scala.xml.Node] =
      Seq.concat(__obj.remapAddresses flatMap { IPXACT2022scalaxb.toXML[IPXACT2022ScalaCases.RemapAddresses](_, Some("http://www.accellera.org/XMLSchema/IPXACT/1685-2022"), Some("remapAddresses"), __scope, false) },
        IPXACT2022scalaxb.toXML[IPXACT2022ScalaCases.UnsignedPositiveLongintExpressionable](__obj.range, Some("http://www.accellera.org/XMLSchema/IPXACT/1685-2022"), Some("range"), __scope, false))

  }

  trait DefaultIPXACT2022ScalaCases_MirroredTargetFormat extends IPXACT2022scalaxb.ElemNameParser[IPXACT2022ScalaCases.MirroredTarget] {
    val targetNamespace: Option[String] = Some("http://www.accellera.org/XMLSchema/IPXACT/1685-2022")
    
    def parser(node: scala.xml.Node, stack: List[IPXACT2022scalaxb.ElemName]): Parser[IPXACT2022ScalaCases.MirroredTarget] =
      phrase(opt((opt(IPXACT2022scalaxb.ElemName(Some("http://www.accellera.org/XMLSchema/IPXACT/1685-2022"), "baseAddresses"))) ^^
        { case p1 => IPXACT2022ScalaCases.MirroredTargetSequence1(p1.headOption map { IPXACT2022scalaxb.fromXML[IPXACT2022ScalaCases.BaseAddresses](_, IPXACT2022scalaxb.ElemName(node) :: stack) }) }) ^^
      { case p1 =>
      IPXACT2022ScalaCases.MirroredTarget(p1) })
    
    def writesChildNodes(__obj: IPXACT2022ScalaCases.MirroredTarget, __scope: scala.xml.NamespaceBinding): Seq[scala.xml.Node] =
      (__obj.mirroredtargetsequence1 map { IPXACT2022scalaxb.toXML[IPXACT2022ScalaCases.MirroredTargetSequence1](_, None, Some("mirroredtargetsequence1"), __scope, false) } getOrElse {Nil})
  }

  trait DefaultIPXACT2022ScalaCases_MirroredTargetSequence1Format extends IPXACT2022scalaxb.XMLFormat[IPXACT2022ScalaCases.MirroredTargetSequence1] {
    def reads(seq: scala.xml.NodeSeq, stack: List[IPXACT2022scalaxb.ElemName]): Either[String, IPXACT2022ScalaCases.MirroredTargetSequence1] = Left("don't call me.")
    
    def writes(__obj: IPXACT2022ScalaCases.MirroredTargetSequence1, __namespace: Option[String], __elementLabel: Option[String],
        __scope: scala.xml.NamespaceBinding, __typeAttribute: Boolean): scala.xml.NodeSeq =
      __obj.baseAddresses map { IPXACT2022scalaxb.toXML[IPXACT2022ScalaCases.BaseAddresses](_, Some("http://www.accellera.org/XMLSchema/IPXACT/1685-2022"), Some("baseAddresses"), __scope, false) } getOrElse {Nil}

  }
  trait DefaultIPXACT2022ScalaCases_MirroredSystemFormat extends IPXACT2022scalaxb.ElemNameParser[IPXACT2022ScalaCases.MirroredSystem] {
    val targetNamespace: Option[String] = Some("http://www.accellera.org/XMLSchema/IPXACT/1685-2022")
    
    def parser(node: scala.xml.Node, stack: List[IPXACT2022scalaxb.ElemName]): Parser[IPXACT2022ScalaCases.MirroredSystem] =
      phrase((IPXACT2022scalaxb.ElemName(Some("http://www.accellera.org/XMLSchema/IPXACT/1685-2022"), "group")) ^^
      { case p1 =>
      IPXACT2022ScalaCases.MirroredSystem(IPXACT2022scalaxb.fromXML[String](p1, IPXACT2022scalaxb.ElemName(node) :: stack)) })
    
    def writesChildNodes(__obj: IPXACT2022ScalaCases.MirroredSystem, __scope: scala.xml.NamespaceBinding): Seq[scala.xml.Node] =
      (IPXACT2022scalaxb.toXML[String](__obj.group, Some("http://www.accellera.org/XMLSchema/IPXACT/1685-2022"), Some("group"), __scope, false))
  }
  def buildIPXACT2022ScalaCases_InterfaceModeFormat = new DefaultIPXACT2022ScalaCases_InterfaceModeFormat {}
  trait DefaultIPXACT2022ScalaCases_InterfaceModeFormat extends IPXACT2022scalaxb.XMLFormat[IPXACT2022ScalaCases.InterfaceMode] {
    val targetNamespace: Option[String] = Some("http://www.accellera.org/XMLSchema/IPXACT/1685-2022")
    
    def fromString(value: String, scope: scala.xml.NamespaceBinding): IPXACT2022ScalaCases.InterfaceMode =
        (fromString0(value, scope)).apply(IPXACT2022scalaxb.fromXML[String](scala.xml.Text(value)))

    private def fromString0(value: String, scope: scala.xml.NamespaceBinding): PartialFunction[Any, IPXACT2022ScalaCases.InterfaceMode] = {
      case x: String if x == IPXACT2022scalaxb.fromXML[String](scala.xml.Text("initiator")) => IPXACT2022ScalaCases.InitiatorValue2
      case x: String if x == IPXACT2022scalaxb.fromXML[String](scala.xml.Text("target")) => IPXACT2022ScalaCases.TargetValue2
      case x: String if x == IPXACT2022scalaxb.fromXML[String](scala.xml.Text("system")) => IPXACT2022ScalaCases.SystemValue2
      case x: String if x == IPXACT2022scalaxb.fromXML[String](scala.xml.Text("mirroredInitiator")) => IPXACT2022ScalaCases.MirroredInitiator
      case x: String if x == IPXACT2022scalaxb.fromXML[String](scala.xml.Text("mirroredTarget")) => IPXACT2022ScalaCases.MirroredTargetValue
      case x: String if x == IPXACT2022scalaxb.fromXML[String](scala.xml.Text("mirroredSystem")) => IPXACT2022ScalaCases.MirroredSystemValue

    }



    def reads(seq: scala.xml.NodeSeq, stack: List[IPXACT2022scalaxb.ElemName]): Either[String, IPXACT2022ScalaCases.InterfaceMode] = seq match {
      case elem: scala.xml.Elem => Right(fromString(elem.text, elem.scope))
      case _ => Right(fromString(seq.text, scala.xml.TopScope))
    }
    
    def writes(__obj: IPXACT2022ScalaCases.InterfaceMode, __namespace: Option[String], __elementLabel: Option[String],
        __scope: scala.xml.NamespaceBinding, __typeAttribute: Boolean): scala.xml.NodeSeq =
      scala.xml.Elem(IPXACT2022scalaxb.Helper.getPrefix(__namespace, __scope).orNull,
        __elementLabel getOrElse { sys.error("missing element label.") },
        scala.xml.Null, __scope, true, scala.xml.Text(__obj.toString))
  }
  trait DefaultIPXACT2022ScalaCases_MonitorFormat extends IPXACT2022scalaxb.ElemNameParser[IPXACT2022ScalaCases.Monitor] {
    val targetNamespace: Option[String] = Some("http://www.accellera.org/XMLSchema/IPXACT/1685-2022")
    
    def parser(node: scala.xml.Node, stack: List[IPXACT2022scalaxb.ElemName]): Parser[IPXACT2022ScalaCases.Monitor] =
      phrase(opt(IPXACT2022scalaxb.ElemName(Some("http://www.accellera.org/XMLSchema/IPXACT/1685-2022"), "group")) ^^
      { case p1 =>
      IPXACT2022ScalaCases.Monitor(p1.headOption map { IPXACT2022scalaxb.fromXML[String](_, IPXACT2022scalaxb.ElemName(node) :: stack) },
        scala.collection.immutable.ListMap(List(
        (node \ "@interfaceMode").headOption map { x => IPXACT2022scalaxb.DataRecord(x, node, IPXACT2022scalaxb.fromXML[IPXACT2022ScalaCases.InterfaceMode](x, IPXACT2022scalaxb.ElemName(node) :: stack)) } map { "@interfaceMode" -> _ }
        ).flatten[(String, IPXACT2022scalaxb.DataRecord[Any])]: _*)) })
    
    override def writesAttribute(__obj: IPXACT2022ScalaCases.Monitor, __scope: scala.xml.NamespaceBinding): scala.xml.MetaData = {
      var attr: scala.xml.MetaData  = scala.xml.Null
      __obj.attributes.toList map {
        case ("@interfaceMode", _) => attr = scala.xml.Attribute(null, "interfaceMode", __obj.interfaceMode.toString, attr)
        case (key, x) => attr = scala.xml.Attribute((x.namespace map { __scope.getPrefix(_) }).orNull, x.key.orNull, x.value.toString, attr)
      }
      attr
    }

    def writesChildNodes(__obj: IPXACT2022ScalaCases.Monitor, __scope: scala.xml.NamespaceBinding): Seq[scala.xml.Node] =
      (__obj.group map { IPXACT2022scalaxb.toXML[String](_, Some("http://www.accellera.org/XMLSchema/IPXACT/1685-2022"), Some("group"), __scope, false) } getOrElse {Nil})
  }

  trait DefaultIPXACT2022ScalaCases_TransparentBridgeFormat extends IPXACT2022scalaxb.ElemNameParser[IPXACT2022ScalaCases.TransparentBridge] {
    val targetNamespace: Option[String] = Some("http://www.accellera.org/XMLSchema/IPXACT/1685-2022")
    
    def parser(node: scala.xml.Node, stack: List[IPXACT2022scalaxb.ElemName]): Parser[IPXACT2022ScalaCases.TransparentBridge] =
      phrase(opt(IPXACT2022scalaxb.ElemName(Some("http://www.accellera.org/XMLSchema/IPXACT/1685-2022"), "vendorExtensions")) ^^
      { case p1 =>
      IPXACT2022ScalaCases.TransparentBridge(p1.headOption map { IPXACT2022scalaxb.fromXML[IPXACT2022ScalaCases.VendorExtensions](_, IPXACT2022scalaxb.ElemName(node) :: stack) },
        scala.collection.immutable.ListMap(List(
        (node \ "@initiatorRef").headOption map { x => IPXACT2022scalaxb.DataRecord(x, node, IPXACT2022scalaxb.fromXML[String](x, IPXACT2022scalaxb.ElemName(node) :: stack)) } map { "@initiatorRef" -> _ },
        (node \ "@{http://www.w3.org/XML/1998/namespace}id").headOption map { x => IPXACT2022scalaxb.DataRecord(x, node, IPXACT2022scalaxb.fromXML[String](x, IPXACT2022scalaxb.ElemName(node) :: stack)) } map { "@{http://www.w3.org/XML/1998/namespace}id" -> _ }
        ).flatten[(String, IPXACT2022scalaxb.DataRecord[Any])]: _*)) })
    
    override def writesAttribute(__obj: IPXACT2022ScalaCases.TransparentBridge, __scope: scala.xml.NamespaceBinding): scala.xml.MetaData = {
      var attr: scala.xml.MetaData  = scala.xml.Null
      __obj.attributes.toList map {
        case ("@initiatorRef", _) => attr = scala.xml.Attribute(null, "initiatorRef", __obj.initiatorRef.toString, attr)
        case ("@{http://www.w3.org/XML/1998/namespace}id", _) => __obj.xmlid foreach { x => attr = scala.xml.Attribute(__scope.getPrefix("http://www.w3.org/XML/1998/namespace"), "id", x.toString, attr) }
        case (key, x) => attr = scala.xml.Attribute((x.namespace map { __scope.getPrefix(_) }).orNull, x.key.orNull, x.value.toString, attr)
      }
      attr
    }

    def writesChildNodes(__obj: IPXACT2022ScalaCases.TransparentBridge, __scope: scala.xml.NamespaceBinding): Seq[scala.xml.Node] =
      (__obj.vendorExtensions map { IPXACT2022scalaxb.toXML[IPXACT2022ScalaCases.VendorExtensions](_, Some("http://www.accellera.org/XMLSchema/IPXACT/1685-2022"), Some("vendorExtensions"), __scope, false) } getOrElse {Nil})
  }

  trait DefaultIPXACT2022ScalaCases_System2Format extends IPXACT2022scalaxb.ElemNameParser[IPXACT2022ScalaCases.System2] {
    val targetNamespace: Option[String] = Some("http://www.accellera.org/XMLSchema/IPXACT/1685-2022")
    
    def parser(node: scala.xml.Node, stack: List[IPXACT2022scalaxb.ElemName]): Parser[IPXACT2022ScalaCases.System2] =
      phrase((IPXACT2022scalaxb.ElemName(Some("http://www.accellera.org/XMLSchema/IPXACT/1685-2022"), "group")) ^^
      { case p1 =>
      IPXACT2022ScalaCases.System2(IPXACT2022scalaxb.fromXML[String](p1, IPXACT2022scalaxb.ElemName(node) :: stack)) })
    
    def writesChildNodes(__obj: IPXACT2022ScalaCases.System2, __scope: scala.xml.NamespaceBinding): Seq[scala.xml.Node] =
      (IPXACT2022scalaxb.toXML[String](__obj.group, Some("http://www.accellera.org/XMLSchema/IPXACT/1685-2022"), Some("group"), __scope, false))
  }
  trait DefaultIPXACT2022ScalaCases_MirroredSystem2Format extends IPXACT2022scalaxb.ElemNameParser[IPXACT2022ScalaCases.MirroredSystem2] {
    val targetNamespace: Option[String] = Some("http://www.accellera.org/XMLSchema/IPXACT/1685-2022")
    
    def parser(node: scala.xml.Node, stack: List[IPXACT2022scalaxb.ElemName]): Parser[IPXACT2022ScalaCases.MirroredSystem2] =
      phrase((IPXACT2022scalaxb.ElemName(Some("http://www.accellera.org/XMLSchema/IPXACT/1685-2022"), "group")) ^^
      { case p1 =>
      IPXACT2022ScalaCases.MirroredSystem2(IPXACT2022scalaxb.fromXML[String](p1, IPXACT2022scalaxb.ElemName(node) :: stack)) })
    
    def writesChildNodes(__obj: IPXACT2022ScalaCases.MirroredSystem2, __scope: scala.xml.NamespaceBinding): Seq[scala.xml.Node] =
      (IPXACT2022scalaxb.toXML[String](__obj.group, Some("http://www.accellera.org/XMLSchema/IPXACT/1685-2022"), Some("group"), __scope, false))
  }
  trait DefaultIPXACT2022ScalaCases_AbstractorBusInterfaceTypeFormat extends IPXACT2022scalaxb.ElemNameParser[IPXACT2022ScalaCases.AbstractorBusInterfaceType] with IPXACT2022ScalaCases_NameGroupGroupFormat {
    val targetNamespace: Option[String] = Some("http://www.accellera.org/XMLSchema/IPXACT/1685-2022")
    
    override def typeName: Option[String] = Some("abstractorBusInterfaceType")

    def parser(node: scala.xml.Node, stack: List[IPXACT2022scalaxb.ElemName]): Parser[IPXACT2022ScalaCases.AbstractorBusInterfaceType] =
      phrase((parseNameGroupGroup(node, IPXACT2022scalaxb.ElemName(node) :: stack)) ~
      opt(IPXACT2022scalaxb.ElemName(Some("http://www.accellera.org/XMLSchema/IPXACT/1685-2022"), "abstractionTypes")) ~
      opt(IPXACT2022scalaxb.ElemName(Some("http://www.accellera.org/XMLSchema/IPXACT/1685-2022"), "parameters")) ~
      opt(IPXACT2022scalaxb.ElemName(Some("http://www.accellera.org/XMLSchema/IPXACT/1685-2022"), "vendorExtensions")) ^^
      { case p1 ~ p2 ~ p3 ~ p4 =>
      IPXACT2022ScalaCases.AbstractorBusInterfaceType(p1,
        p2.headOption map { IPXACT2022scalaxb.fromXML[IPXACT2022ScalaCases.AbstractionTypes](_, IPXACT2022scalaxb.ElemName(node) :: stack) },
        p3.headOption map { IPXACT2022scalaxb.fromXML[IPXACT2022ScalaCases.Parameters](_, IPXACT2022scalaxb.ElemName(node) :: stack) },
        p4.headOption map { IPXACT2022scalaxb.fromXML[IPXACT2022ScalaCases.VendorExtensions](_, IPXACT2022scalaxb.ElemName(node) :: stack) },
        scala.collection.immutable.ListMap(List(
        (node \ "@{http://www.w3.org/XML/1998/namespace}id").headOption map { x => IPXACT2022scalaxb.DataRecord(x, node, IPXACT2022scalaxb.fromXML[String](x, IPXACT2022scalaxb.ElemName(node) :: stack)) } map { "@{http://www.w3.org/XML/1998/namespace}id" -> _ }
        ).flatten[(String, IPXACT2022scalaxb.DataRecord[Any])] ::: (node match {
          case elem: scala.xml.Elem =>
            elem.attributes.toList flatMap {
              case scala.xml.PrefixedAttribute(pre, key, value, _) if pre == elem.scope.getPrefix("http://www.w3.org/XML/1998/namespace") &&
                key == "id" => Nil
              case scala.xml.UnprefixedAttribute(key, value, _) =>
                List(("@" + key, IPXACT2022scalaxb.DataRecord(None, Some(key), value.text)))
              case scala.xml.PrefixedAttribute(pre, key, value, _) =>
                val ns = elem.scope.getURI(pre)
                List(("@{" + ns + "}" + key, IPXACT2022scalaxb.DataRecord(Option[String](ns), Some(key), value.text)))
              case _ => Nil
            }
          case _ => Nil
        }): _*)) })
    
    override def writesAttribute(__obj: IPXACT2022ScalaCases.AbstractorBusInterfaceType, __scope: scala.xml.NamespaceBinding): scala.xml.MetaData = {
      var attr: scala.xml.MetaData  = scala.xml.Null
      __obj.attributes.toList map {
        case ("@{http://www.w3.org/XML/1998/namespace}id", _) => __obj.xmlid foreach { x => attr = scala.xml.Attribute(__scope.getPrefix("http://www.w3.org/XML/1998/namespace"), "id", x.toString, attr) }
        case (key, x) => attr = scala.xml.Attribute((x.namespace map { __scope.getPrefix(_) }).orNull, x.key.orNull, x.value.toString, attr)
      }
      attr
    }

    def writesChildNodes(__obj: IPXACT2022ScalaCases.AbstractorBusInterfaceType, __scope: scala.xml.NamespaceBinding): Seq[scala.xml.Node] =
      Seq.concat(IPXACT2022scalaxb.toXML[IPXACT2022ScalaCases.NameGroupSequence](__obj.nameGroupSequence1, None, Some("nameGroupSequence1"), __scope, false),
        __obj.abstractionTypes map { IPXACT2022scalaxb.toXML[IPXACT2022ScalaCases.AbstractionTypes](_, Some("http://www.accellera.org/XMLSchema/IPXACT/1685-2022"), Some("abstractionTypes"), __scope, false) } getOrElse {Nil},
        __obj.parameters map { IPXACT2022scalaxb.toXML[IPXACT2022ScalaCases.Parameters](_, Some("http://www.accellera.org/XMLSchema/IPXACT/1685-2022"), Some("parameters"), __scope, false) } getOrElse {Nil},
        __obj.vendorExtensions map { IPXACT2022scalaxb.toXML[IPXACT2022ScalaCases.VendorExtensions](_, Some("http://www.accellera.org/XMLSchema/IPXACT/1685-2022"), Some("vendorExtensions"), __scope, false) } getOrElse {Nil})

  }

  trait DefaultIPXACT2022ScalaCases_IndirectInterfacesFormat extends IPXACT2022scalaxb.ElemNameParser[IPXACT2022ScalaCases.IndirectInterfaces] {
    val targetNamespace: Option[String] = Some("http://www.accellera.org/XMLSchema/IPXACT/1685-2022")
    
    def parser(node: scala.xml.Node, stack: List[IPXACT2022scalaxb.ElemName]): Parser[IPXACT2022ScalaCases.IndirectInterfaces] =
      phrase(safeRep(IPXACT2022scalaxb.ElemName(Some("http://www.accellera.org/XMLSchema/IPXACT/1685-2022"), "indirectInterface")) ^^
      { case p1 =>
      IPXACT2022ScalaCases.IndirectInterfaces(p1 map { IPXACT2022scalaxb.fromXML[IPXACT2022ScalaCases.IndirectInterfaceType](_, IPXACT2022scalaxb.ElemName(node) :: stack) }) })
    
    def writesChildNodes(__obj: IPXACT2022ScalaCases.IndirectInterfaces, __scope: scala.xml.NamespaceBinding): Seq[scala.xml.Node] =
      (__obj.indirectInterface flatMap { IPXACT2022scalaxb.toXML[IPXACT2022ScalaCases.IndirectInterfaceType](_, Some("http://www.accellera.org/XMLSchema/IPXACT/1685-2022"), Some("indirectInterface"), __scope, false) })
  }
  trait DefaultIPXACT2022ScalaCases_IndirectInterfaceTypeFormat extends IPXACT2022scalaxb.ElemNameParser[IPXACT2022ScalaCases.IndirectInterfaceType] with IPXACT2022ScalaCases_NameGroupGroupFormat {
    val targetNamespace: Option[String] = Some("http://www.accellera.org/XMLSchema/IPXACT/1685-2022")
    
    override def typeName: Option[String] = Some("indirectInterfaceType")

    def parser(node: scala.xml.Node, stack: List[IPXACT2022scalaxb.ElemName]): Parser[IPXACT2022ScalaCases.IndirectInterfaceType] =
      phrase((parseNameGroupGroup(node, IPXACT2022scalaxb.ElemName(node) :: stack)) ~
      (IPXACT2022scalaxb.ElemName(Some("http://www.accellera.org/XMLSchema/IPXACT/1685-2022"), "indirectAddressRef")) ~
      (IPXACT2022scalaxb.ElemName(Some("http://www.accellera.org/XMLSchema/IPXACT/1685-2022"), "indirectDataRef")) ~
      safeRep(((IPXACT2022scalaxb.ElemName(Some("http://www.accellera.org/XMLSchema/IPXACT/1685-2022"), "memoryMapRef")) ^^
      (x => IPXACT2022scalaxb.DataRecord(x.namespace, Some(x.name), IPXACT2022scalaxb.fromXML[String](x, IPXACT2022scalaxb.ElemName(node) :: stack)))) |
      ((IPXACT2022scalaxb.ElemName(Some("http://www.accellera.org/XMLSchema/IPXACT/1685-2022"), "transparentBridge")) ^^
      (x => IPXACT2022scalaxb.DataRecord(x.namespace, Some(x.name), IPXACT2022scalaxb.fromXML[IPXACT2022ScalaCases.TransparentBridge](x, IPXACT2022scalaxb.ElemName(node) :: stack))))) ~
      opt(IPXACT2022scalaxb.ElemName(Some("http://www.accellera.org/XMLSchema/IPXACT/1685-2022"), "bitsInLau")) ~
      opt(IPXACT2022scalaxb.ElemName(Some("http://www.accellera.org/XMLSchema/IPXACT/1685-2022"), "endianness")) ~
      opt(IPXACT2022scalaxb.ElemName(Some("http://www.accellera.org/XMLSchema/IPXACT/1685-2022"), "parameters")) ~
      opt(IPXACT2022scalaxb.ElemName(Some("http://www.accellera.org/XMLSchema/IPXACT/1685-2022"), "vendorExtensions")) ^^
      { case p1 ~ p2 ~ p3 ~ p4 ~ p5 ~ p6 ~ p7 ~ p8 =>
      IPXACT2022ScalaCases.IndirectInterfaceType(p1,
        IPXACT2022scalaxb.fromXML[IPXACT2022ScalaCases.IndirectAddressRef](p2, IPXACT2022scalaxb.ElemName(node) :: stack),
        IPXACT2022scalaxb.fromXML[IPXACT2022ScalaCases.IndirectDataRef](p3, IPXACT2022scalaxb.ElemName(node) :: stack),
        p4,
        p5.headOption map { IPXACT2022scalaxb.fromXML[IPXACT2022ScalaCases.UnsignedPositiveLongintExpressionable](_, IPXACT2022scalaxb.ElemName(node) :: stack) },
        p6.headOption map { IPXACT2022scalaxb.fromXML[IPXACT2022ScalaCases.EndianessType](_, IPXACT2022scalaxb.ElemName(node) :: stack) },
        p7.headOption map { IPXACT2022scalaxb.fromXML[IPXACT2022ScalaCases.Parameters](_, IPXACT2022scalaxb.ElemName(node) :: stack) },
        p8.headOption map { IPXACT2022scalaxb.fromXML[IPXACT2022ScalaCases.VendorExtensions](_, IPXACT2022scalaxb.ElemName(node) :: stack) },
        scala.collection.immutable.ListMap(List(
        (node \ "@{http://www.w3.org/XML/1998/namespace}id").headOption map { x => IPXACT2022scalaxb.DataRecord(x, node, IPXACT2022scalaxb.fromXML[String](x, IPXACT2022scalaxb.ElemName(node) :: stack)) } map { "@{http://www.w3.org/XML/1998/namespace}id" -> _ }
        ).flatten[(String, IPXACT2022scalaxb.DataRecord[Any])] ::: (node match {
          case elem: scala.xml.Elem =>
            elem.attributes.toList flatMap {
              case scala.xml.PrefixedAttribute(pre, key, value, _) if pre == elem.scope.getPrefix("http://www.w3.org/XML/1998/namespace") &&
                key == "id" => Nil
              case scala.xml.UnprefixedAttribute(key, value, _) =>
                List(("@" + key, IPXACT2022scalaxb.DataRecord(None, Some(key), value.text)))
              case scala.xml.PrefixedAttribute(pre, key, value, _) =>
                val ns = elem.scope.getURI(pre)
                List(("@{" + ns + "}" + key, IPXACT2022scalaxb.DataRecord(Option[String](ns), Some(key), value.text)))
              case _ => Nil
            }
          case _ => Nil
        }): _*)) })
    
    override def writesAttribute(__obj: IPXACT2022ScalaCases.IndirectInterfaceType, __scope: scala.xml.NamespaceBinding): scala.xml.MetaData = {
      var attr: scala.xml.MetaData  = scala.xml.Null
      __obj.attributes.toList map {
        case ("@{http://www.w3.org/XML/1998/namespace}id", _) => __obj.xmlid foreach { x => attr = scala.xml.Attribute(__scope.getPrefix("http://www.w3.org/XML/1998/namespace"), "id", x.toString, attr) }
        case (key, x) => attr = scala.xml.Attribute((x.namespace map { __scope.getPrefix(_) }).orNull, x.key.orNull, x.value.toString, attr)
      }
      attr
    }

    def writesChildNodes(__obj: IPXACT2022ScalaCases.IndirectInterfaceType, __scope: scala.xml.NamespaceBinding): Seq[scala.xml.Node] =
      Seq.concat(IPXACT2022scalaxb.toXML[IPXACT2022ScalaCases.NameGroupSequence](__obj.nameGroupSequence1, None, Some("nameGroupSequence1"), __scope, false),
        IPXACT2022scalaxb.toXML[IPXACT2022ScalaCases.IndirectAddressRef](__obj.indirectAddressRef, Some("http://www.accellera.org/XMLSchema/IPXACT/1685-2022"), Some("indirectAddressRef"), __scope, false),
        IPXACT2022scalaxb.toXML[IPXACT2022ScalaCases.IndirectDataRef](__obj.indirectDataRef, Some("http://www.accellera.org/XMLSchema/IPXACT/1685-2022"), Some("indirectDataRef"), __scope, false),
        __obj.indirectinterfacetypeoption flatMap { x => IPXACT2022scalaxb.toXML[IPXACT2022scalaxb.DataRecord[Any]](x, x.namespace, x.key, __scope, false) },
        __obj.bitsInLau map { IPXACT2022scalaxb.toXML[IPXACT2022ScalaCases.UnsignedPositiveLongintExpressionable](_, Some("http://www.accellera.org/XMLSchema/IPXACT/1685-2022"), Some("bitsInLau"), __scope, false) } getOrElse {Nil},
        __obj.endianness map { IPXACT2022scalaxb.toXML[IPXACT2022ScalaCases.EndianessType](_, Some("http://www.accellera.org/XMLSchema/IPXACT/1685-2022"), Some("endianness"), __scope, false) } getOrElse {Nil},
        __obj.parameters map { IPXACT2022scalaxb.toXML[IPXACT2022ScalaCases.Parameters](_, Some("http://www.accellera.org/XMLSchema/IPXACT/1685-2022"), Some("parameters"), __scope, false) } getOrElse {Nil},
        __obj.vendorExtensions map { IPXACT2022scalaxb.toXML[IPXACT2022ScalaCases.VendorExtensions](_, Some("http://www.accellera.org/XMLSchema/IPXACT/1685-2022"), Some("vendorExtensions"), __scope, false) } getOrElse {Nil})

  }

  trait DefaultIPXACT2022ScalaCases_IndirectAddressRefFormat extends IPXACT2022scalaxb.ElemNameParser[IPXACT2022ScalaCases.IndirectAddressRef] with IPXACT2022ScalaCases_FieldReferenceGroupGroupFormat {
    val targetNamespace: Option[String] = Some("http://www.accellera.org/XMLSchema/IPXACT/1685-2022")
    
    def parser(node: scala.xml.Node, stack: List[IPXACT2022scalaxb.ElemName]): Parser[IPXACT2022ScalaCases.IndirectAddressRef] =
      phrase((parseFieldReferenceGroupGroup(node, IPXACT2022scalaxb.ElemName(node) :: stack)) ^^
      { case p1 =>
      IPXACT2022ScalaCases.IndirectAddressRef(p1) })
    
    def writesChildNodes(__obj: IPXACT2022ScalaCases.IndirectAddressRef, __scope: scala.xml.NamespaceBinding): Seq[scala.xml.Node] =
      (IPXACT2022scalaxb.toXML[IPXACT2022ScalaCases.FieldReferenceGroupSequence](__obj.fieldReferenceGroupSequence1, None, Some("fieldReferenceGroupSequence1"), __scope, false))
  }
  trait DefaultIPXACT2022ScalaCases_IndirectDataRefFormat extends IPXACT2022scalaxb.ElemNameParser[IPXACT2022ScalaCases.IndirectDataRef] with IPXACT2022ScalaCases_FieldReferenceGroupGroupFormat {
    val targetNamespace: Option[String] = Some("http://www.accellera.org/XMLSchema/IPXACT/1685-2022")
    
    def parser(node: scala.xml.Node, stack: List[IPXACT2022scalaxb.ElemName]): Parser[IPXACT2022ScalaCases.IndirectDataRef] =
      phrase((parseFieldReferenceGroupGroup(node, IPXACT2022scalaxb.ElemName(node) :: stack)) ^^
      { case p1 =>
      IPXACT2022ScalaCases.IndirectDataRef(p1) })
    
    def writesChildNodes(__obj: IPXACT2022ScalaCases.IndirectDataRef, __scope: scala.xml.NamespaceBinding): Seq[scala.xml.Node] =
      (IPXACT2022scalaxb.toXML[IPXACT2022ScalaCases.FieldReferenceGroupSequence](__obj.fieldReferenceGroupSequence1, None, Some("fieldReferenceGroupSequence1"), __scope, false))
  }
  trait DefaultIPXACT2022ScalaCases_LogicalPortFormat extends IPXACT2022scalaxb.ElemNameParser[IPXACT2022ScalaCases.LogicalPort] {
    val targetNamespace: Option[String] = Some("http://www.accellera.org/XMLSchema/IPXACT/1685-2022")
    
    def parser(node: scala.xml.Node, stack: List[IPXACT2022scalaxb.ElemName]): Parser[IPXACT2022ScalaCases.LogicalPort] =
      phrase((IPXACT2022scalaxb.ElemName(Some("http://www.accellera.org/XMLSchema/IPXACT/1685-2022"), "name")) ~
      opt(IPXACT2022scalaxb.ElemName(Some("http://www.accellera.org/XMLSchema/IPXACT/1685-2022"), "range")) ^^
      { case p1 ~ p2 =>
      IPXACT2022ScalaCases.LogicalPort(IPXACT2022scalaxb.fromXML[String](p1, IPXACT2022scalaxb.ElemName(node) :: stack),
        p2.headOption map { IPXACT2022scalaxb.fromXML[IPXACT2022ScalaCases.RangeType](_, IPXACT2022scalaxb.ElemName(node) :: stack) },
        scala.collection.immutable.ListMap(List(
        (node \ "@{http://www.w3.org/XML/1998/namespace}id").headOption map { x => IPXACT2022scalaxb.DataRecord(x, node, IPXACT2022scalaxb.fromXML[String](x, IPXACT2022scalaxb.ElemName(node) :: stack)) } map { "@{http://www.w3.org/XML/1998/namespace}id" -> _ }
        ).flatten[(String, IPXACT2022scalaxb.DataRecord[Any])]: _*)) })
    
    override def writesAttribute(__obj: IPXACT2022ScalaCases.LogicalPort, __scope: scala.xml.NamespaceBinding): scala.xml.MetaData = {
      var attr: scala.xml.MetaData  = scala.xml.Null
      __obj.attributes.toList map {
        case ("@{http://www.w3.org/XML/1998/namespace}id", _) => __obj.xmlid foreach { x => attr = scala.xml.Attribute(__scope.getPrefix("http://www.w3.org/XML/1998/namespace"), "id", x.toString, attr) }
        case (key, x) => attr = scala.xml.Attribute((x.namespace map { __scope.getPrefix(_) }).orNull, x.key.orNull, x.value.toString, attr)
      }
      attr
    }

    def writesChildNodes(__obj: IPXACT2022ScalaCases.LogicalPort, __scope: scala.xml.NamespaceBinding): Seq[scala.xml.Node] =
      Seq.concat(IPXACT2022scalaxb.toXML[String](__obj.name, Some("http://www.accellera.org/XMLSchema/IPXACT/1685-2022"), Some("name"), __scope, false),
        __obj.range map { IPXACT2022scalaxb.toXML[IPXACT2022ScalaCases.RangeType](_, Some("http://www.accellera.org/XMLSchema/IPXACT/1685-2022"), Some("range"), __scope, false) } getOrElse {Nil})

  }

  trait DefaultIPXACT2022ScalaCases_SubPortFormat extends IPXACT2022scalaxb.ElemNameParser[IPXACT2022ScalaCases.SubPort] {
    val targetNamespace: Option[String] = Some("http://www.accellera.org/XMLSchema/IPXACT/1685-2022")
    
    def parser(node: scala.xml.Node, stack: List[IPXACT2022scalaxb.ElemName]): Parser[IPXACT2022ScalaCases.SubPort] =
      phrase((IPXACT2022scalaxb.ElemName(Some("http://www.accellera.org/XMLSchema/IPXACT/1685-2022"), "name")) ~
      opt(IPXACT2022scalaxb.ElemName(Some("http://www.accellera.org/XMLSchema/IPXACT/1685-2022"), "partSelect")) ^^
      { case p1 ~ p2 =>
      IPXACT2022ScalaCases.SubPort(IPXACT2022scalaxb.fromXML[String](p1, IPXACT2022scalaxb.ElemName(node) :: stack),
        p2.headOption map { IPXACT2022scalaxb.fromXML[IPXACT2022ScalaCases.PartSelect](_, IPXACT2022scalaxb.ElemName(node) :: stack) },
        scala.collection.immutable.ListMap(List(
        (node \ "@{http://www.w3.org/XML/1998/namespace}id").headOption map { x => IPXACT2022scalaxb.DataRecord(x, node, IPXACT2022scalaxb.fromXML[String](x, IPXACT2022scalaxb.ElemName(node) :: stack)) } map { "@{http://www.w3.org/XML/1998/namespace}id" -> _ }
        ).flatten[(String, IPXACT2022scalaxb.DataRecord[Any])]: _*)) })
    
    override def writesAttribute(__obj: IPXACT2022ScalaCases.SubPort, __scope: scala.xml.NamespaceBinding): scala.xml.MetaData = {
      var attr: scala.xml.MetaData  = scala.xml.Null
      __obj.attributes.toList map {
        case ("@{http://www.w3.org/XML/1998/namespace}id", _) => __obj.xmlid foreach { x => attr = scala.xml.Attribute(__scope.getPrefix("http://www.w3.org/XML/1998/namespace"), "id", x.toString, attr) }
        case (key, x) => attr = scala.xml.Attribute((x.namespace map { __scope.getPrefix(_) }).orNull, x.key.orNull, x.value.toString, attr)
      }
      attr
    }

    def writesChildNodes(__obj: IPXACT2022ScalaCases.SubPort, __scope: scala.xml.NamespaceBinding): Seq[scala.xml.Node] =
      Seq.concat(IPXACT2022scalaxb.toXML[String](__obj.name, Some("http://www.accellera.org/XMLSchema/IPXACT/1685-2022"), Some("name"), __scope, false),
        __obj.partSelect map { IPXACT2022scalaxb.toXML[IPXACT2022ScalaCases.PartSelect](_, Some("http://www.accellera.org/XMLSchema/IPXACT/1685-2022"), Some("partSelect"), __scope, false) } getOrElse {Nil})

  }

  trait DefaultIPXACT2022ScalaCases_PhysicalPortFormat extends IPXACT2022scalaxb.ElemNameParser[IPXACT2022ScalaCases.PhysicalPort] {
    val targetNamespace: Option[String] = Some("http://www.accellera.org/XMLSchema/IPXACT/1685-2022")
    
    def parser(node: scala.xml.Node, stack: List[IPXACT2022scalaxb.ElemName]): Parser[IPXACT2022ScalaCases.PhysicalPort] =
      phrase((IPXACT2022scalaxb.ElemName(Some("http://www.accellera.org/XMLSchema/IPXACT/1685-2022"), "name")) ~
      opt(IPXACT2022scalaxb.ElemName(Some("http://www.accellera.org/XMLSchema/IPXACT/1685-2022"), "partSelect")) ~
      safeRep(IPXACT2022scalaxb.ElemName(Some("http://www.accellera.org/XMLSchema/IPXACT/1685-2022"), "subPort")) ^^
      { case p1 ~ p2 ~ p3 =>
      IPXACT2022ScalaCases.PhysicalPort(IPXACT2022scalaxb.fromXML[String](p1, IPXACT2022scalaxb.ElemName(node) :: stack),
        p2.headOption map { IPXACT2022scalaxb.fromXML[IPXACT2022ScalaCases.PartSelect](_, IPXACT2022scalaxb.ElemName(node) :: stack) },
        p3 map { IPXACT2022scalaxb.fromXML[IPXACT2022ScalaCases.SubPort](_, IPXACT2022scalaxb.ElemName(node) :: stack) },
        scala.collection.immutable.ListMap(List(
        (node \ "@{http://www.w3.org/XML/1998/namespace}id").headOption map { x => IPXACT2022scalaxb.DataRecord(x, node, IPXACT2022scalaxb.fromXML[String](x, IPXACT2022scalaxb.ElemName(node) :: stack)) } map { "@{http://www.w3.org/XML/1998/namespace}id" -> _ }
        ).flatten[(String, IPXACT2022scalaxb.DataRecord[Any])]: _*)) })
    
    override def writesAttribute(__obj: IPXACT2022ScalaCases.PhysicalPort, __scope: scala.xml.NamespaceBinding): scala.xml.MetaData = {
      var attr: scala.xml.MetaData  = scala.xml.Null
      __obj.attributes.toList map {
        case ("@{http://www.w3.org/XML/1998/namespace}id", _) => __obj.xmlid foreach { x => attr = scala.xml.Attribute(__scope.getPrefix("http://www.w3.org/XML/1998/namespace"), "id", x.toString, attr) }
        case (key, x) => attr = scala.xml.Attribute((x.namespace map { __scope.getPrefix(_) }).orNull, x.key.orNull, x.value.toString, attr)
      }
      attr
    }

    def writesChildNodes(__obj: IPXACT2022ScalaCases.PhysicalPort, __scope: scala.xml.NamespaceBinding): Seq[scala.xml.Node] =
      Seq.concat(IPXACT2022scalaxb.toXML[String](__obj.name, Some("http://www.accellera.org/XMLSchema/IPXACT/1685-2022"), Some("name"), __scope, false),
        __obj.partSelect map { IPXACT2022scalaxb.toXML[IPXACT2022ScalaCases.PartSelect](_, Some("http://www.accellera.org/XMLSchema/IPXACT/1685-2022"), Some("partSelect"), __scope, false) } getOrElse {Nil},
        __obj.subPort flatMap { IPXACT2022scalaxb.toXML[IPXACT2022ScalaCases.SubPort](_, Some("http://www.accellera.org/XMLSchema/IPXACT/1685-2022"), Some("subPort"), __scope, false) })

  }

  trait DefaultIPXACT2022ScalaCases_PortMapFormat extends IPXACT2022scalaxb.ElemNameParser[IPXACT2022ScalaCases.PortMap] {
    val targetNamespace: Option[String] = Some("http://www.accellera.org/XMLSchema/IPXACT/1685-2022")
    
    def parser(node: scala.xml.Node, stack: List[IPXACT2022scalaxb.ElemName]): Parser[IPXACT2022ScalaCases.PortMap] =
      phrase((IPXACT2022scalaxb.ElemName(Some("http://www.accellera.org/XMLSchema/IPXACT/1685-2022"), "logicalPort")) ~
      (((IPXACT2022scalaxb.ElemName(Some("http://www.accellera.org/XMLSchema/IPXACT/1685-2022"), "physicalPort")) ^^
      (x => IPXACT2022scalaxb.DataRecord(x.namespace, Some(x.name), IPXACT2022scalaxb.fromXML[IPXACT2022ScalaCases.PhysicalPort](x, IPXACT2022scalaxb.ElemName(node) :: stack)))) |
      ((IPXACT2022scalaxb.ElemName(Some("http://www.accellera.org/XMLSchema/IPXACT/1685-2022"), "logicalTieOff")) ^^
      (x => IPXACT2022scalaxb.DataRecord(x.namespace, Some(x.name), IPXACT2022scalaxb.fromXML[IPXACT2022ScalaCases.UnsignedBitVectorExpressionable](x, IPXACT2022scalaxb.ElemName(node) :: stack))))) ~
      opt(IPXACT2022scalaxb.ElemName(Some("http://www.accellera.org/XMLSchema/IPXACT/1685-2022"), "isInformative")) ~
      opt(IPXACT2022scalaxb.ElemName(Some("http://www.accellera.org/XMLSchema/IPXACT/1685-2022"), "vendorExtensions")) ^^
      { case p1 ~ p2 ~ p3 ~ p4 =>
      IPXACT2022ScalaCases.PortMap(IPXACT2022scalaxb.fromXML[IPXACT2022ScalaCases.LogicalPort](p1, IPXACT2022scalaxb.ElemName(node) :: stack),
        p2,
        p3.headOption map { IPXACT2022scalaxb.fromXML[Boolean](_, IPXACT2022scalaxb.ElemName(node) :: stack) },
        p4.headOption map { IPXACT2022scalaxb.fromXML[IPXACT2022ScalaCases.VendorExtensions](_, IPXACT2022scalaxb.ElemName(node) :: stack) },
        scala.collection.immutable.ListMap(List(
        (node \ "@{http://www.w3.org/XML/1998/namespace}id").headOption map { x => IPXACT2022scalaxb.DataRecord(x, node, IPXACT2022scalaxb.fromXML[String](x, IPXACT2022scalaxb.ElemName(node) :: stack)) } map { "@{http://www.w3.org/XML/1998/namespace}id" -> _ },
        (node \ "@invert").headOption map { x => IPXACT2022scalaxb.DataRecord(x, node, IPXACT2022scalaxb.fromXML[String](x, IPXACT2022scalaxb.ElemName(node) :: stack)) } orElse Some(IPXACT2022scalaxb.DataRecord(None, None, IPXACT2022scalaxb.fromXML[String](scala.xml.Text("false"), IPXACT2022scalaxb.ElemName(node) :: stack))) map { "@invert" -> _ }
        ).flatten[(String, IPXACT2022scalaxb.DataRecord[Any])]: _*)) })
    
    override def writesAttribute(__obj: IPXACT2022ScalaCases.PortMap, __scope: scala.xml.NamespaceBinding): scala.xml.MetaData = {
      var attr: scala.xml.MetaData  = scala.xml.Null
      __obj.attributes.toList map {
        case ("@{http://www.w3.org/XML/1998/namespace}id", _) => __obj.xmlid foreach { x => attr = scala.xml.Attribute(__scope.getPrefix("http://www.w3.org/XML/1998/namespace"), "id", x.toString, attr) }
        case ("@invert", _) => if (__obj.invert.toString != "false") attr = scala.xml.Attribute(null, "invert", __obj.invert.toString, attr)
        case (key, x) => attr = scala.xml.Attribute((x.namespace map { __scope.getPrefix(_) }).orNull, x.key.orNull, x.value.toString, attr)
      }
      attr
    }

    def writesChildNodes(__obj: IPXACT2022ScalaCases.PortMap, __scope: scala.xml.NamespaceBinding): Seq[scala.xml.Node] =
      Seq.concat(IPXACT2022scalaxb.toXML[IPXACT2022ScalaCases.LogicalPort](__obj.logicalPort, Some("http://www.accellera.org/XMLSchema/IPXACT/1685-2022"), Some("logicalPort"), __scope, false),
        (Some(__obj.portmapoption) map {x => IPXACT2022scalaxb.toXML[IPXACT2022scalaxb.DataRecord[IPXACT2022ScalaCases.PortMapOption]](x, x.namespace, x.key, __scope, false)}).get,
        __obj.isInformative map { IPXACT2022scalaxb.toXML[Boolean](_, Some("http://www.accellera.org/XMLSchema/IPXACT/1685-2022"), Some("isInformative"), __scope, false) } getOrElse {Nil},
        __obj.vendorExtensions map { IPXACT2022scalaxb.toXML[IPXACT2022ScalaCases.VendorExtensions](_, Some("http://www.accellera.org/XMLSchema/IPXACT/1685-2022"), Some("vendorExtensions"), __scope, false) } getOrElse {Nil})

  }

  trait DefaultIPXACT2022ScalaCases_PortMapsFormat extends IPXACT2022scalaxb.ElemNameParser[IPXACT2022ScalaCases.PortMaps] {
    val targetNamespace: Option[String] = Some("http://www.accellera.org/XMLSchema/IPXACT/1685-2022")
    
    def parser(node: scala.xml.Node, stack: List[IPXACT2022scalaxb.ElemName]): Parser[IPXACT2022ScalaCases.PortMaps] =
      phrase(safeRep(IPXACT2022scalaxb.ElemName(Some("http://www.accellera.org/XMLSchema/IPXACT/1685-2022"), "portMap")) ^^
      { case p1 =>
      IPXACT2022ScalaCases.PortMaps(p1 map { IPXACT2022scalaxb.fromXML[IPXACT2022ScalaCases.PortMap](_, IPXACT2022scalaxb.ElemName(node) :: stack) }) })
    
    def writesChildNodes(__obj: IPXACT2022ScalaCases.PortMaps, __scope: scala.xml.NamespaceBinding): Seq[scala.xml.Node] =
      (__obj.portMap flatMap { IPXACT2022scalaxb.toXML[IPXACT2022ScalaCases.PortMap](_, Some("http://www.accellera.org/XMLSchema/IPXACT/1685-2022"), Some("portMap"), __scope, false) })
  }
  trait DefaultIPXACT2022ScalaCases_AbstractionTypeFormat extends IPXACT2022scalaxb.ElemNameParser[IPXACT2022ScalaCases.AbstractionType] {
    val targetNamespace: Option[String] = Some("http://www.accellera.org/XMLSchema/IPXACT/1685-2022")
    
    def parser(node: scala.xml.Node, stack: List[IPXACT2022scalaxb.ElemName]): Parser[IPXACT2022ScalaCases.AbstractionType] =
      phrase(safeRep(IPXACT2022scalaxb.ElemName(Some("http://www.accellera.org/XMLSchema/IPXACT/1685-2022"), "viewRef")) ~
      (IPXACT2022scalaxb.ElemName(Some("http://www.accellera.org/XMLSchema/IPXACT/1685-2022"), "abstractionRef")) ~
      opt(IPXACT2022scalaxb.ElemName(Some("http://www.accellera.org/XMLSchema/IPXACT/1685-2022"), "portMaps")) ^^
      { case p1 ~ p2 ~ p3 =>
      IPXACT2022ScalaCases.AbstractionType(p1 map { IPXACT2022scalaxb.fromXML[IPXACT2022ScalaCases.ViewRef5](_, IPXACT2022scalaxb.ElemName(node) :: stack) },
        IPXACT2022scalaxb.fromXML[IPXACT2022ScalaCases.ConfigurableLibraryRefType](p2, IPXACT2022scalaxb.ElemName(node) :: stack),
        p3.headOption map { IPXACT2022scalaxb.fromXML[IPXACT2022ScalaCases.PortMaps](_, IPXACT2022scalaxb.ElemName(node) :: stack) },
        scala.collection.immutable.ListMap(List(
        (node \ "@{http://www.w3.org/XML/1998/namespace}id").headOption map { x => IPXACT2022scalaxb.DataRecord(x, node, IPXACT2022scalaxb.fromXML[String](x, IPXACT2022scalaxb.ElemName(node) :: stack)) } map { "@{http://www.w3.org/XML/1998/namespace}id" -> _ }
        ).flatten[(String, IPXACT2022scalaxb.DataRecord[Any])]: _*)) })
    
    override def writesAttribute(__obj: IPXACT2022ScalaCases.AbstractionType, __scope: scala.xml.NamespaceBinding): scala.xml.MetaData = {
      var attr: scala.xml.MetaData  = scala.xml.Null
      __obj.attributes.toList map {
        case ("@{http://www.w3.org/XML/1998/namespace}id", _) => __obj.xmlid foreach { x => attr = scala.xml.Attribute(__scope.getPrefix("http://www.w3.org/XML/1998/namespace"), "id", x.toString, attr) }
        case (key, x) => attr = scala.xml.Attribute((x.namespace map { __scope.getPrefix(_) }).orNull, x.key.orNull, x.value.toString, attr)
      }
      attr
    }

    def writesChildNodes(__obj: IPXACT2022ScalaCases.AbstractionType, __scope: scala.xml.NamespaceBinding): Seq[scala.xml.Node] =
      Seq.concat(__obj.viewRef flatMap { IPXACT2022scalaxb.toXML[IPXACT2022ScalaCases.ViewRef5](_, Some("http://www.accellera.org/XMLSchema/IPXACT/1685-2022"), Some("viewRef"), __scope, false) },
        IPXACT2022scalaxb.toXML[IPXACT2022ScalaCases.ConfigurableLibraryRefType](__obj.abstractionRef, Some("http://www.accellera.org/XMLSchema/IPXACT/1685-2022"), Some("abstractionRef"), __scope, false),
        __obj.portMaps map { IPXACT2022scalaxb.toXML[IPXACT2022ScalaCases.PortMaps](_, Some("http://www.accellera.org/XMLSchema/IPXACT/1685-2022"), Some("portMaps"), __scope, false) } getOrElse {Nil})

  }

  trait DefaultIPXACT2022ScalaCases_AbstractionTypesFormat extends IPXACT2022scalaxb.ElemNameParser[IPXACT2022ScalaCases.AbstractionTypes] {
    val targetNamespace: Option[String] = Some("http://www.accellera.org/XMLSchema/IPXACT/1685-2022")
    
    def parser(node: scala.xml.Node, stack: List[IPXACT2022scalaxb.ElemName]): Parser[IPXACT2022ScalaCases.AbstractionTypes] =
      phrase(safeRep(IPXACT2022scalaxb.ElemName(Some("http://www.accellera.org/XMLSchema/IPXACT/1685-2022"), "abstractionType")) ^^
      { case p1 =>
      IPXACT2022ScalaCases.AbstractionTypes(p1 map { IPXACT2022scalaxb.fromXML[IPXACT2022ScalaCases.AbstractionType](_, IPXACT2022scalaxb.ElemName(node) :: stack) }) })
    
    def writesChildNodes(__obj: IPXACT2022ScalaCases.AbstractionTypes, __scope: scala.xml.NamespaceBinding): Seq[scala.xml.Node] =
      (__obj.abstractionType flatMap { IPXACT2022scalaxb.toXML[IPXACT2022ScalaCases.AbstractionType](_, Some("http://www.accellera.org/XMLSchema/IPXACT/1685-2022"), Some("abstractionType"), __scope, false) })
  }

/** Group of the different modes a busInterface can take on in an abstractor
*/
  trait IPXACT2022ScalaCases_AbstractorInterfaceModeGroupFormat extends IPXACT2022scalaxb.AnyElemNameParser {
    def parseAbstractorInterfaceModeGroup(node: scala.xml.Node, stack: List[IPXACT2022scalaxb.ElemName]): Parser[IPXACT2022scalaxb.DataRecord[Any]] =
      (((any(_ => true) ^^ (IPXACT2022scalaxb.fromXML[IPXACT2022scalaxb.DataRecord[Any]](_, IPXACT2022scalaxb.ElemName(node) :: stack)))) |
      ((any(_ => true) ^^ (IPXACT2022scalaxb.fromXML[IPXACT2022scalaxb.DataRecord[Any]](_, IPXACT2022scalaxb.ElemName(node) :: stack)))) |
      ((IPXACT2022scalaxb.ElemName(Some("http://www.accellera.org/XMLSchema/IPXACT/1685-2022"), "system")) ^^
      (x => IPXACT2022scalaxb.DataRecord(x.namespace, Some(x.name), IPXACT2022scalaxb.fromXML[IPXACT2022ScalaCases.System2](x, IPXACT2022scalaxb.ElemName(node) :: stack)))) |
      ((any(_ => true) ^^ (IPXACT2022scalaxb.fromXML[IPXACT2022scalaxb.DataRecord[Any]](_, IPXACT2022scalaxb.ElemName(node) :: stack)))) |
      ((any(_ => true) ^^ (IPXACT2022scalaxb.fromXML[IPXACT2022scalaxb.DataRecord[Any]](_, IPXACT2022scalaxb.ElemName(node) :: stack)))) |
      ((IPXACT2022scalaxb.ElemName(Some("http://www.accellera.org/XMLSchema/IPXACT/1685-2022"), "mirroredSystem")) ^^
      (x => IPXACT2022scalaxb.DataRecord(x.namespace, Some(x.name), IPXACT2022scalaxb.fromXML[IPXACT2022ScalaCases.MirroredSystem2](x, IPXACT2022scalaxb.ElemName(node) :: stack)))))
  
    def parseAbstractorInterfaceModeGroup(node: scala.xml.Node, stack: List[IPXACT2022scalaxb.ElemName], wrap: Boolean): Parser[IPXACT2022scalaxb.DataRecord[Any]] =
      (((any(_ => true) ^^ (IPXACT2022scalaxb.fromXML[IPXACT2022scalaxb.DataRecord[Any]](_, IPXACT2022scalaxb.ElemName(node) :: stack)))) |
      ((any(_ => true) ^^ (IPXACT2022scalaxb.fromXML[IPXACT2022scalaxb.DataRecord[Any]](_, IPXACT2022scalaxb.ElemName(node) :: stack)))) |
      ((IPXACT2022scalaxb.ElemName(Some("http://www.accellera.org/XMLSchema/IPXACT/1685-2022"), "system")) ^^
      (x => IPXACT2022scalaxb.DataRecord(x.namespace, Some(x.name), IPXACT2022scalaxb.fromXML[IPXACT2022ScalaCases.System2](x, IPXACT2022scalaxb.ElemName(node) :: stack)))) |
      ((any(_ => true) ^^ (IPXACT2022scalaxb.fromXML[IPXACT2022scalaxb.DataRecord[Any]](_, IPXACT2022scalaxb.ElemName(node) :: stack)))) |
      ((any(_ => true) ^^ (IPXACT2022scalaxb.fromXML[IPXACT2022scalaxb.DataRecord[Any]](_, IPXACT2022scalaxb.ElemName(node) :: stack)))) |
      ((IPXACT2022scalaxb.ElemName(Some("http://www.accellera.org/XMLSchema/IPXACT/1685-2022"), "mirroredSystem")) ^^
      (x => IPXACT2022scalaxb.DataRecord(x.namespace, Some(x.name), IPXACT2022scalaxb.fromXML[IPXACT2022ScalaCases.MirroredSystem2](x, IPXACT2022scalaxb.ElemName(node) :: stack)))))
    
    def parsemixedAbstractorInterfaceModeGroup(node: scala.xml.Node, stack: List[IPXACT2022scalaxb.ElemName]): Parser[Seq[IPXACT2022scalaxb.DataRecord[Any]]] =
      ((((((any(_ => true) ^^ (IPXACT2022scalaxb.fromXML[IPXACT2022scalaxb.DataRecord[Any]](_, IPXACT2022scalaxb.ElemName(node) :: stack))) ~
      optTextRecord) ^^ 
      { case p1 ~ p2 => Seq.concat(Seq(p1), p2.toList) }) ~ 
      optTextRecord) ^^ 
        { case p1 ~ p2 => Seq.concat(p1,
        p2.toList) }) ||| 
      (((((any(_ => true) ^^ (IPXACT2022scalaxb.fromXML[IPXACT2022scalaxb.DataRecord[Any]](_, IPXACT2022scalaxb.ElemName(node) :: stack))) ~
      optTextRecord) ^^ 
      { case p1 ~ p2 => Seq.concat(Seq(p1), p2.toList) }) ~ 
      optTextRecord) ^^ 
        { case p1 ~ p2 => Seq.concat(p1,
        p2.toList) }) ||| 
      ((((IPXACT2022scalaxb.ElemName(Some("http://www.accellera.org/XMLSchema/IPXACT/1685-2022"), "system")) ^^
      (x => IPXACT2022scalaxb.DataRecord(x.namespace, Some(x.name), IPXACT2022scalaxb.fromXML[IPXACT2022ScalaCases.System2](x, IPXACT2022scalaxb.ElemName(node) :: stack)))) ~
      optTextRecord) ^^ 
        { case p1 ~ p2 => Seq.concat(Seq(p1),
        p2.toList) }) ||| 
      (((((any(_ => true) ^^ (IPXACT2022scalaxb.fromXML[IPXACT2022scalaxb.DataRecord[Any]](_, IPXACT2022scalaxb.ElemName(node) :: stack))) ~
      optTextRecord) ^^ 
      { case p1 ~ p2 => Seq.concat(Seq(p1), p2.toList) }) ~ 
      optTextRecord) ^^ 
        { case p1 ~ p2 => Seq.concat(p1,
        p2.toList) }) ||| 
      (((((any(_ => true) ^^ (IPXACT2022scalaxb.fromXML[IPXACT2022scalaxb.DataRecord[Any]](_, IPXACT2022scalaxb.ElemName(node) :: stack))) ~
      optTextRecord) ^^ 
      { case p1 ~ p2 => Seq.concat(Seq(p1), p2.toList) }) ~ 
      optTextRecord) ^^ 
        { case p1 ~ p2 => Seq.concat(p1,
        p2.toList) }) ||| 
      ((((IPXACT2022scalaxb.ElemName(Some("http://www.accellera.org/XMLSchema/IPXACT/1685-2022"), "mirroredSystem")) ^^
      (x => IPXACT2022scalaxb.DataRecord(x.namespace, Some(x.name), IPXACT2022scalaxb.fromXML[IPXACT2022ScalaCases.MirroredSystem2](x, IPXACT2022scalaxb.ElemName(node) :: stack)))) ~
      optTextRecord) ^^ 
        { case p1 ~ p2 => Seq.concat(Seq(p1),
        p2.toList) }))
  }


/** Group of the different modes a busInterface can take on in a component
*/
  trait IPXACT2022ScalaCases_InterfaceModeGroupFormat extends IPXACT2022scalaxb.AnyElemNameParser {
    def parseInterfaceModeGroup(node: scala.xml.Node, stack: List[IPXACT2022scalaxb.ElemName]): Parser[IPXACT2022scalaxb.DataRecord[Any]] =
      (((IPXACT2022scalaxb.ElemName(Some("http://www.accellera.org/XMLSchema/IPXACT/1685-2022"), "initiator")) ^^
      (x => IPXACT2022scalaxb.DataRecord(x.namespace, Some(x.name), IPXACT2022scalaxb.fromXML[IPXACT2022ScalaCases.Initiator](x, IPXACT2022scalaxb.ElemName(node) :: stack)))) |
      ((IPXACT2022scalaxb.ElemName(Some("http://www.accellera.org/XMLSchema/IPXACT/1685-2022"), "target")) ^^
      (x => IPXACT2022scalaxb.DataRecord(x.namespace, Some(x.name), IPXACT2022scalaxb.fromXML[IPXACT2022ScalaCases.Target](x, IPXACT2022scalaxb.ElemName(node) :: stack)))) |
      ((IPXACT2022scalaxb.ElemName(Some("http://www.accellera.org/XMLSchema/IPXACT/1685-2022"), "system")) ^^
      (x => IPXACT2022scalaxb.DataRecord(x.namespace, Some(x.name), IPXACT2022scalaxb.fromXML[IPXACT2022ScalaCases.System](x, IPXACT2022scalaxb.ElemName(node) :: stack)))) |
      ((IPXACT2022scalaxb.ElemName(Some("http://www.accellera.org/XMLSchema/IPXACT/1685-2022"), "mirroredTarget")) ^^
      (x => IPXACT2022scalaxb.DataRecord(x.namespace, Some(x.name), IPXACT2022scalaxb.fromXML[IPXACT2022ScalaCases.MirroredTarget](x, IPXACT2022scalaxb.ElemName(node) :: stack)))) |
      ((any(_ => true) ^^ (IPXACT2022scalaxb.fromXML[IPXACT2022scalaxb.DataRecord[Any]](_, IPXACT2022scalaxb.ElemName(node) :: stack)))) |
      ((IPXACT2022scalaxb.ElemName(Some("http://www.accellera.org/XMLSchema/IPXACT/1685-2022"), "mirroredSystem")) ^^
      (x => IPXACT2022scalaxb.DataRecord(x.namespace, Some(x.name), IPXACT2022scalaxb.fromXML[IPXACT2022ScalaCases.MirroredSystem](x, IPXACT2022scalaxb.ElemName(node) :: stack)))) |
      ((IPXACT2022scalaxb.ElemName(Some("http://www.accellera.org/XMLSchema/IPXACT/1685-2022"), "monitor")) ^^
      (x => IPXACT2022scalaxb.DataRecord(x.namespace, Some(x.name), IPXACT2022scalaxb.fromXML[IPXACT2022ScalaCases.Monitor](x, IPXACT2022scalaxb.ElemName(node) :: stack)))))
  
    def parseInterfaceModeGroup(node: scala.xml.Node, stack: List[IPXACT2022scalaxb.ElemName], wrap: Boolean): Parser[IPXACT2022scalaxb.DataRecord[Any]] =
      (((IPXACT2022scalaxb.ElemName(Some("http://www.accellera.org/XMLSchema/IPXACT/1685-2022"), "initiator")) ^^
      (x => IPXACT2022scalaxb.DataRecord(x.namespace, Some(x.name), IPXACT2022scalaxb.fromXML[IPXACT2022ScalaCases.Initiator](x, IPXACT2022scalaxb.ElemName(node) :: stack)))) |
      ((IPXACT2022scalaxb.ElemName(Some("http://www.accellera.org/XMLSchema/IPXACT/1685-2022"), "target")) ^^
      (x => IPXACT2022scalaxb.DataRecord(x.namespace, Some(x.name), IPXACT2022scalaxb.fromXML[IPXACT2022ScalaCases.Target](x, IPXACT2022scalaxb.ElemName(node) :: stack)))) |
      ((IPXACT2022scalaxb.ElemName(Some("http://www.accellera.org/XMLSchema/IPXACT/1685-2022"), "system")) ^^
      (x => IPXACT2022scalaxb.DataRecord(x.namespace, Some(x.name), IPXACT2022scalaxb.fromXML[IPXACT2022ScalaCases.System](x, IPXACT2022scalaxb.ElemName(node) :: stack)))) |
      ((IPXACT2022scalaxb.ElemName(Some("http://www.accellera.org/XMLSchema/IPXACT/1685-2022"), "mirroredTarget")) ^^
      (x => IPXACT2022scalaxb.DataRecord(x.namespace, Some(x.name), IPXACT2022scalaxb.fromXML[IPXACT2022ScalaCases.MirroredTarget](x, IPXACT2022scalaxb.ElemName(node) :: stack)))) |
      ((any(_ => true) ^^ (IPXACT2022scalaxb.fromXML[IPXACT2022scalaxb.DataRecord[Any]](_, IPXACT2022scalaxb.ElemName(node) :: stack)))) |
      ((IPXACT2022scalaxb.ElemName(Some("http://www.accellera.org/XMLSchema/IPXACT/1685-2022"), "mirroredSystem")) ^^
      (x => IPXACT2022scalaxb.DataRecord(x.namespace, Some(x.name), IPXACT2022scalaxb.fromXML[IPXACT2022ScalaCases.MirroredSystem](x, IPXACT2022scalaxb.ElemName(node) :: stack)))) |
      ((IPXACT2022scalaxb.ElemName(Some("http://www.accellera.org/XMLSchema/IPXACT/1685-2022"), "monitor")) ^^
      (x => IPXACT2022scalaxb.DataRecord(x.namespace, Some(x.name), IPXACT2022scalaxb.fromXML[IPXACT2022ScalaCases.Monitor](x, IPXACT2022scalaxb.ElemName(node) :: stack)))))
    
    def parsemixedInterfaceModeGroup(node: scala.xml.Node, stack: List[IPXACT2022scalaxb.ElemName]): Parser[Seq[IPXACT2022scalaxb.DataRecord[Any]]] =
      (((((IPXACT2022scalaxb.ElemName(Some("http://www.accellera.org/XMLSchema/IPXACT/1685-2022"), "initiator")) ^^
      (x => IPXACT2022scalaxb.DataRecord(x.namespace, Some(x.name), IPXACT2022scalaxb.fromXML[IPXACT2022ScalaCases.Initiator](x, IPXACT2022scalaxb.ElemName(node) :: stack)))) ~
      optTextRecord) ^^ 
        { case p1 ~ p2 => Seq.concat(Seq(p1),
        p2.toList) }) ||| 
      ((((IPXACT2022scalaxb.ElemName(Some("http://www.accellera.org/XMLSchema/IPXACT/1685-2022"), "target")) ^^
      (x => IPXACT2022scalaxb.DataRecord(x.namespace, Some(x.name), IPXACT2022scalaxb.fromXML[IPXACT2022ScalaCases.Target](x, IPXACT2022scalaxb.ElemName(node) :: stack)))) ~
      optTextRecord) ^^ 
        { case p1 ~ p2 => Seq.concat(Seq(p1),
        p2.toList) }) ||| 
      ((((IPXACT2022scalaxb.ElemName(Some("http://www.accellera.org/XMLSchema/IPXACT/1685-2022"), "system")) ^^
      (x => IPXACT2022scalaxb.DataRecord(x.namespace, Some(x.name), IPXACT2022scalaxb.fromXML[IPXACT2022ScalaCases.System](x, IPXACT2022scalaxb.ElemName(node) :: stack)))) ~
      optTextRecord) ^^ 
        { case p1 ~ p2 => Seq.concat(Seq(p1),
        p2.toList) }) ||| 
      ((((IPXACT2022scalaxb.ElemName(Some("http://www.accellera.org/XMLSchema/IPXACT/1685-2022"), "mirroredTarget")) ^^
      (x => IPXACT2022scalaxb.DataRecord(x.namespace, Some(x.name), IPXACT2022scalaxb.fromXML[IPXACT2022ScalaCases.MirroredTarget](x, IPXACT2022scalaxb.ElemName(node) :: stack)))) ~
      optTextRecord) ^^ 
        { case p1 ~ p2 => Seq.concat(Seq(p1),
        p2.toList) }) ||| 
      (((((any(_ => true) ^^ (IPXACT2022scalaxb.fromXML[IPXACT2022scalaxb.DataRecord[Any]](_, IPXACT2022scalaxb.ElemName(node) :: stack))) ~
      optTextRecord) ^^ 
      { case p1 ~ p2 => Seq.concat(Seq(p1), p2.toList) }) ~ 
      optTextRecord) ^^ 
        { case p1 ~ p2 => Seq.concat(p1,
        p2.toList) }) ||| 
      ((((IPXACT2022scalaxb.ElemName(Some("http://www.accellera.org/XMLSchema/IPXACT/1685-2022"), "mirroredSystem")) ^^
      (x => IPXACT2022scalaxb.DataRecord(x.namespace, Some(x.name), IPXACT2022scalaxb.fromXML[IPXACT2022ScalaCases.MirroredSystem](x, IPXACT2022scalaxb.ElemName(node) :: stack)))) ~
      optTextRecord) ^^ 
        { case p1 ~ p2 => Seq.concat(Seq(p1),
        p2.toList) }) ||| 
      ((((IPXACT2022scalaxb.ElemName(Some("http://www.accellera.org/XMLSchema/IPXACT/1685-2022"), "monitor")) ^^
      (x => IPXACT2022scalaxb.DataRecord(x.namespace, Some(x.name), IPXACT2022scalaxb.fromXML[IPXACT2022ScalaCases.Monitor](x, IPXACT2022scalaxb.ElemName(node) :: stack)))) ~
      optTextRecord) ^^ 
        { case p1 ~ p2 => Seq.concat(Seq(p1),
        p2.toList) }))
  }

  trait DefaultIPXACT2022ScalaCases_IpxactFilesTypeFormat extends IPXACT2022scalaxb.ElemNameParser[IPXACT2022ScalaCases.IpxactFilesType] {
    val targetNamespace: Option[String] = Some("http://www.accellera.org/XMLSchema/IPXACT/1685-2022")
    
    override def typeName: Option[String] = Some("ipxactFilesType")

    def parser(node: scala.xml.Node, stack: List[IPXACT2022scalaxb.ElemName]): Parser[IPXACT2022ScalaCases.IpxactFilesType] =
      phrase(safeRep(IPXACT2022scalaxb.ElemName(Some("http://www.accellera.org/XMLSchema/IPXACT/1685-2022"), "ipxactFile")) ^^
      { case p1 =>
      IPXACT2022ScalaCases.IpxactFilesType(p1 map { IPXACT2022scalaxb.fromXML[IPXACT2022ScalaCases.IpxactFileType](_, IPXACT2022scalaxb.ElemName(node) :: stack) }) })
    
    def writesChildNodes(__obj: IPXACT2022ScalaCases.IpxactFilesType, __scope: scala.xml.NamespaceBinding): Seq[scala.xml.Node] =
      (__obj.ipxactFile flatMap { IPXACT2022scalaxb.toXML[IPXACT2022ScalaCases.IpxactFileType](_, Some("http://www.accellera.org/XMLSchema/IPXACT/1685-2022"), Some("ipxactFile"), __scope, false) })
  }

  trait DefaultIPXACT2022ScalaCases_CatalogFormat extends IPXACT2022scalaxb.ElemNameParser[IPXACT2022ScalaCases.Catalog] with IPXACT2022ScalaCases_DocumentNameGroupGroupFormat {
    val targetNamespace: Option[String] = Some("http://www.accellera.org/XMLSchema/IPXACT/1685-2022")
    
    def parser(node: scala.xml.Node, stack: List[IPXACT2022scalaxb.ElemName]): Parser[IPXACT2022ScalaCases.Catalog] =
      phrase((parseDocumentNameGroupGroup(node, IPXACT2022scalaxb.ElemName(node) :: stack)) ~
      opt(IPXACT2022scalaxb.ElemName(Some("http://www.accellera.org/XMLSchema/IPXACT/1685-2022"), "catalogs")) ~
      opt(IPXACT2022scalaxb.ElemName(Some("http://www.accellera.org/XMLSchema/IPXACT/1685-2022"), "busDefinitions")) ~
      opt(IPXACT2022scalaxb.ElemName(Some("http://www.accellera.org/XMLSchema/IPXACT/1685-2022"), "abstractionDefinitions")) ~
      opt(IPXACT2022scalaxb.ElemName(Some("http://www.accellera.org/XMLSchema/IPXACT/1685-2022"), "components")) ~
      opt(IPXACT2022scalaxb.ElemName(Some("http://www.accellera.org/XMLSchema/IPXACT/1685-2022"), "abstractors")) ~
      opt(IPXACT2022scalaxb.ElemName(Some("http://www.accellera.org/XMLSchema/IPXACT/1685-2022"), "designs")) ~
      opt(IPXACT2022scalaxb.ElemName(Some("http://www.accellera.org/XMLSchema/IPXACT/1685-2022"), "designConfigurations")) ~
      opt(IPXACT2022scalaxb.ElemName(Some("http://www.accellera.org/XMLSchema/IPXACT/1685-2022"), "generatorChains")) ~
      opt(IPXACT2022scalaxb.ElemName(Some("http://www.accellera.org/XMLSchema/IPXACT/1685-2022"), "typeDefinitions")) ~
      opt(IPXACT2022scalaxb.ElemName(Some("http://www.accellera.org/XMLSchema/IPXACT/1685-2022"), "vendorExtensions")) ^^
      { case p1 ~ p2 ~ p3 ~ p4 ~ p5 ~ p6 ~ p7 ~ p8 ~ p9 ~ p10 ~ p11 =>
      IPXACT2022ScalaCases.Catalog(p1,
        p2.headOption map { IPXACT2022scalaxb.fromXML[IPXACT2022ScalaCases.IpxactFilesType](_, IPXACT2022scalaxb.ElemName(node) :: stack) },
        p3.headOption map { IPXACT2022scalaxb.fromXML[IPXACT2022ScalaCases.IpxactFilesType](_, IPXACT2022scalaxb.ElemName(node) :: stack) },
        p4.headOption map { IPXACT2022scalaxb.fromXML[IPXACT2022ScalaCases.IpxactFilesType](_, IPXACT2022scalaxb.ElemName(node) :: stack) },
        p5.headOption map { IPXACT2022scalaxb.fromXML[IPXACT2022ScalaCases.IpxactFilesType](_, IPXACT2022scalaxb.ElemName(node) :: stack) },
        p6.headOption map { IPXACT2022scalaxb.fromXML[IPXACT2022ScalaCases.IpxactFilesType](_, IPXACT2022scalaxb.ElemName(node) :: stack) },
        p7.headOption map { IPXACT2022scalaxb.fromXML[IPXACT2022ScalaCases.IpxactFilesType](_, IPXACT2022scalaxb.ElemName(node) :: stack) },
        p8.headOption map { IPXACT2022scalaxb.fromXML[IPXACT2022ScalaCases.IpxactFilesType](_, IPXACT2022scalaxb.ElemName(node) :: stack) },
        p9.headOption map { IPXACT2022scalaxb.fromXML[IPXACT2022ScalaCases.IpxactFilesType](_, IPXACT2022scalaxb.ElemName(node) :: stack) },
        p10.headOption map { IPXACT2022scalaxb.fromXML[IPXACT2022ScalaCases.IpxactFilesType](_, IPXACT2022scalaxb.ElemName(node) :: stack) },
        p11.headOption map { IPXACT2022scalaxb.fromXML[IPXACT2022ScalaCases.VendorExtensions](_, IPXACT2022scalaxb.ElemName(node) :: stack) },
        scala.collection.immutable.ListMap(List(
        (node \ "@{http://www.w3.org/XML/1998/namespace}id").headOption map { x => IPXACT2022scalaxb.DataRecord(x, node, IPXACT2022scalaxb.fromXML[String](x, IPXACT2022scalaxb.ElemName(node) :: stack)) } map { "@{http://www.w3.org/XML/1998/namespace}id" -> _ }
        ).flatten[(String, IPXACT2022scalaxb.DataRecord[Any])]: _*)) })
    
    override def writesAttribute(__obj: IPXACT2022ScalaCases.Catalog, __scope: scala.xml.NamespaceBinding): scala.xml.MetaData = {
      var attr: scala.xml.MetaData  = scala.xml.Null
      __obj.attributes.toList map {
        case ("@{http://www.w3.org/XML/1998/namespace}id", _) => __obj.xmlid foreach { x => attr = scala.xml.Attribute(__scope.getPrefix("http://www.w3.org/XML/1998/namespace"), "id", x.toString, attr) }
        case (key, x) => attr = scala.xml.Attribute((x.namespace map { __scope.getPrefix(_) }).orNull, x.key.orNull, x.value.toString, attr)
      }
      attr
    }

    def writesChildNodes(__obj: IPXACT2022ScalaCases.Catalog, __scope: scala.xml.NamespaceBinding): Seq[scala.xml.Node] =
      Seq.concat(IPXACT2022scalaxb.toXML[IPXACT2022ScalaCases.DocumentNameGroupSequence](__obj.documentNameGroupSequence1, None, Some("documentNameGroupSequence1"), __scope, false),
        __obj.catalogs map { IPXACT2022scalaxb.toXML[IPXACT2022ScalaCases.IpxactFilesType](_, Some("http://www.accellera.org/XMLSchema/IPXACT/1685-2022"), Some("catalogs"), __scope, false) } getOrElse {Nil},
        __obj.busDefinitions map { IPXACT2022scalaxb.toXML[IPXACT2022ScalaCases.IpxactFilesType](_, Some("http://www.accellera.org/XMLSchema/IPXACT/1685-2022"), Some("busDefinitions"), __scope, false) } getOrElse {Nil},
        __obj.abstractionDefinitions map { IPXACT2022scalaxb.toXML[IPXACT2022ScalaCases.IpxactFilesType](_, Some("http://www.accellera.org/XMLSchema/IPXACT/1685-2022"), Some("abstractionDefinitions"), __scope, false) } getOrElse {Nil},
        __obj.components map { IPXACT2022scalaxb.toXML[IPXACT2022ScalaCases.IpxactFilesType](_, Some("http://www.accellera.org/XMLSchema/IPXACT/1685-2022"), Some("components"), __scope, false) } getOrElse {Nil},
        __obj.abstractors map { IPXACT2022scalaxb.toXML[IPXACT2022ScalaCases.IpxactFilesType](_, Some("http://www.accellera.org/XMLSchema/IPXACT/1685-2022"), Some("abstractors"), __scope, false) } getOrElse {Nil},
        __obj.designs map { IPXACT2022scalaxb.toXML[IPXACT2022ScalaCases.IpxactFilesType](_, Some("http://www.accellera.org/XMLSchema/IPXACT/1685-2022"), Some("designs"), __scope, false) } getOrElse {Nil},
        __obj.designConfigurations map { IPXACT2022scalaxb.toXML[IPXACT2022ScalaCases.IpxactFilesType](_, Some("http://www.accellera.org/XMLSchema/IPXACT/1685-2022"), Some("designConfigurations"), __scope, false) } getOrElse {Nil},
        __obj.generatorChains map { IPXACT2022scalaxb.toXML[IPXACT2022ScalaCases.IpxactFilesType](_, Some("http://www.accellera.org/XMLSchema/IPXACT/1685-2022"), Some("generatorChains"), __scope, false) } getOrElse {Nil},
        __obj.typeDefinitions map { IPXACT2022scalaxb.toXML[IPXACT2022ScalaCases.IpxactFilesType](_, Some("http://www.accellera.org/XMLSchema/IPXACT/1685-2022"), Some("typeDefinitions"), __scope, false) } getOrElse {Nil},
        __obj.vendorExtensions map { IPXACT2022scalaxb.toXML[IPXACT2022ScalaCases.VendorExtensions](_, Some("http://www.accellera.org/XMLSchema/IPXACT/1685-2022"), Some("vendorExtensions"), __scope, false) } getOrElse {Nil})

  }

  trait DefaultIPXACT2022ScalaCases_IpxactFileTypeFormat extends IPXACT2022scalaxb.ElemNameParser[IPXACT2022ScalaCases.IpxactFileType] {
    val targetNamespace: Option[String] = Some("http://www.accellera.org/XMLSchema/IPXACT/1685-2022")
    
    override def typeName: Option[String] = Some("ipxactFileType")

    def parser(node: scala.xml.Node, stack: List[IPXACT2022scalaxb.ElemName]): Parser[IPXACT2022ScalaCases.IpxactFileType] =
      phrase((IPXACT2022scalaxb.ElemName(Some("http://www.accellera.org/XMLSchema/IPXACT/1685-2022"), "vlnv")) ~
      (IPXACT2022scalaxb.ElemName(Some("http://www.accellera.org/XMLSchema/IPXACT/1685-2022"), "name")) ~
      opt(IPXACT2022scalaxb.ElemName(Some("http://www.accellera.org/XMLSchema/IPXACT/1685-2022"), "description")) ~
      opt(IPXACT2022scalaxb.ElemName(Some("http://www.accellera.org/XMLSchema/IPXACT/1685-2022"), "vendorExtensions")) ^^
      { case p1 ~ p2 ~ p3 ~ p4 =>
      IPXACT2022ScalaCases.IpxactFileType(IPXACT2022scalaxb.fromXML[IPXACT2022ScalaCases.LibraryRefType](p1, IPXACT2022scalaxb.ElemName(node) :: stack),
        IPXACT2022scalaxb.fromXML[IPXACT2022ScalaCases.IpxactURIable](p2, IPXACT2022scalaxb.ElemName(node) :: stack),
        p3.headOption map { IPXACT2022scalaxb.fromXML[String](_, IPXACT2022scalaxb.ElemName(node) :: stack) },
        p4.headOption map { IPXACT2022scalaxb.fromXML[IPXACT2022ScalaCases.VendorExtensions](_, IPXACT2022scalaxb.ElemName(node) :: stack) },
        scala.collection.immutable.ListMap(List(
        (node \ "@{http://www.w3.org/XML/1998/namespace}id").headOption map { x => IPXACT2022scalaxb.DataRecord(x, node, IPXACT2022scalaxb.fromXML[String](x, IPXACT2022scalaxb.ElemName(node) :: stack)) } map { "@{http://www.w3.org/XML/1998/namespace}id" -> _ }
        ).flatten[(String, IPXACT2022scalaxb.DataRecord[Any])]: _*)) })
    
    override def writesAttribute(__obj: IPXACT2022ScalaCases.IpxactFileType, __scope: scala.xml.NamespaceBinding): scala.xml.MetaData = {
      var attr: scala.xml.MetaData  = scala.xml.Null
      __obj.attributes.toList map {
        case ("@{http://www.w3.org/XML/1998/namespace}id", _) => __obj.xmlid foreach { x => attr = scala.xml.Attribute(__scope.getPrefix("http://www.w3.org/XML/1998/namespace"), "id", x.toString, attr) }
        case (key, x) => attr = scala.xml.Attribute((x.namespace map { __scope.getPrefix(_) }).orNull, x.key.orNull, x.value.toString, attr)
      }
      attr
    }

    def writesChildNodes(__obj: IPXACT2022ScalaCases.IpxactFileType, __scope: scala.xml.NamespaceBinding): Seq[scala.xml.Node] =
      Seq.concat(IPXACT2022scalaxb.toXML[IPXACT2022ScalaCases.LibraryRefType](__obj.vlnv, Some("http://www.accellera.org/XMLSchema/IPXACT/1685-2022"), Some("vlnv"), __scope, false),
        IPXACT2022scalaxb.toXML[IPXACT2022ScalaCases.IpxactURIable](__obj.name, Some("http://www.accellera.org/XMLSchema/IPXACT/1685-2022"), Some("name"), __scope, false),
        __obj.description map { IPXACT2022scalaxb.toXML[String](_, Some("http://www.accellera.org/XMLSchema/IPXACT/1685-2022"), Some("description"), __scope, false) } getOrElse {Nil},
        __obj.vendorExtensions map { IPXACT2022scalaxb.toXML[IPXACT2022ScalaCases.VendorExtensions](_, Some("http://www.accellera.org/XMLSchema/IPXACT/1685-2022"), Some("vendorExtensions"), __scope, false) } getOrElse {Nil})

  }

  trait DefaultIPXACT2022ScalaCases_AssertionFormat extends IPXACT2022scalaxb.ElemNameParser[IPXACT2022ScalaCases.Assertion] with IPXACT2022ScalaCases_NameGroupGroupFormat {
    val targetNamespace: Option[String] = Some("http://www.accellera.org/XMLSchema/IPXACT/1685-2022")
    
    def parser(node: scala.xml.Node, stack: List[IPXACT2022scalaxb.ElemName]): Parser[IPXACT2022ScalaCases.Assertion] =
      phrase((parseNameGroupGroup(node, IPXACT2022scalaxb.ElemName(node) :: stack)) ~
      (IPXACT2022scalaxb.ElemName(Some("http://www.accellera.org/XMLSchema/IPXACT/1685-2022"), "assert")) ^^
      { case p1 ~ p2 =>
      IPXACT2022ScalaCases.Assertion(p1,
        IPXACT2022scalaxb.fromXML[IPXACT2022ScalaCases.UnsignedBitExpression](p2, IPXACT2022scalaxb.ElemName(node) :: stack),
        scala.collection.immutable.ListMap(List(
        (node \ "@{http://www.w3.org/XML/1998/namespace}id").headOption map { x => IPXACT2022scalaxb.DataRecord(x, node, IPXACT2022scalaxb.fromXML[String](x, IPXACT2022scalaxb.ElemName(node) :: stack)) } map { "@{http://www.w3.org/XML/1998/namespace}id" -> _ }
        ).flatten[(String, IPXACT2022scalaxb.DataRecord[Any])]: _*)) })
    
    override def writesAttribute(__obj: IPXACT2022ScalaCases.Assertion, __scope: scala.xml.NamespaceBinding): scala.xml.MetaData = {
      var attr: scala.xml.MetaData  = scala.xml.Null
      __obj.attributes.toList map {
        case ("@{http://www.w3.org/XML/1998/namespace}id", _) => __obj.xmlid foreach { x => attr = scala.xml.Attribute(__scope.getPrefix("http://www.w3.org/XML/1998/namespace"), "id", x.toString, attr) }
        case (key, x) => attr = scala.xml.Attribute((x.namespace map { __scope.getPrefix(_) }).orNull, x.key.orNull, x.value.toString, attr)
      }
      attr
    }

    def writesChildNodes(__obj: IPXACT2022ScalaCases.Assertion, __scope: scala.xml.NamespaceBinding): Seq[scala.xml.Node] =
      Seq.concat(IPXACT2022scalaxb.toXML[IPXACT2022ScalaCases.NameGroupSequence](__obj.nameGroupSequence1, None, Some("nameGroupSequence1"), __scope, false),
        IPXACT2022scalaxb.toXML[IPXACT2022ScalaCases.UnsignedBitExpression](__obj.assert, Some("http://www.accellera.org/XMLSchema/IPXACT/1685-2022"), Some("assert"), __scope, false))

  }

  trait DefaultIPXACT2022ScalaCases_AssertionsFormat extends IPXACT2022scalaxb.ElemNameParser[IPXACT2022ScalaCases.Assertions] {
    val targetNamespace: Option[String] = Some("http://www.accellera.org/XMLSchema/IPXACT/1685-2022")
    
    def parser(node: scala.xml.Node, stack: List[IPXACT2022scalaxb.ElemName]): Parser[IPXACT2022ScalaCases.Assertions] =
      phrase(safeRep(IPXACT2022scalaxb.ElemName(Some("http://www.accellera.org/XMLSchema/IPXACT/1685-2022"), "assertion")) ^^
      { case p1 =>
      IPXACT2022ScalaCases.Assertions(p1 map { IPXACT2022scalaxb.fromXML[IPXACT2022ScalaCases.Assertion](_, IPXACT2022scalaxb.ElemName(node) :: stack) }) })
    
    def writesChildNodes(__obj: IPXACT2022ScalaCases.Assertions, __scope: scala.xml.NamespaceBinding): Seq[scala.xml.Node] =
      (__obj.assertion flatMap { IPXACT2022scalaxb.toXML[IPXACT2022ScalaCases.Assertion](_, Some("http://www.accellera.org/XMLSchema/IPXACT/1685-2022"), Some("assertion"), __scope, false) })
  }
  def buildIPXACT2022ScalaCases_LevelFormat = new DefaultIPXACT2022ScalaCases_LevelFormat {}
  trait DefaultIPXACT2022ScalaCases_LevelFormat extends IPXACT2022scalaxb.XMLFormat[IPXACT2022ScalaCases.Level] {
    val targetNamespace: Option[String] = Some("http://www.accellera.org/XMLSchema/IPXACT/1685-2022")
    
    def fromString(value: String, scope: scala.xml.NamespaceBinding): IPXACT2022ScalaCases.Level =
        (fromString0(value, scope)).apply(IPXACT2022scalaxb.fromXML[String](scala.xml.Text(value)))

    private def fromString0(value: String, scope: scala.xml.NamespaceBinding): PartialFunction[Any, IPXACT2022ScalaCases.Level] = {
      case x: String if x == IPXACT2022scalaxb.fromXML[String](scala.xml.Text("low")) => IPXACT2022ScalaCases.LowValue
      case x: String if x == IPXACT2022scalaxb.fromXML[String](scala.xml.Text("high")) => IPXACT2022ScalaCases.HighValue

    }



    def reads(seq: scala.xml.NodeSeq, stack: List[IPXACT2022scalaxb.ElemName]): Either[String, IPXACT2022ScalaCases.Level] = seq match {
      case elem: scala.xml.Elem => Right(fromString(elem.text, elem.scope))
      case _ => Right(fromString(seq.text, scala.xml.TopScope))
    }
    
    def writes(__obj: IPXACT2022ScalaCases.Level, __namespace: Option[String], __elementLabel: Option[String],
        __scope: scala.xml.NamespaceBinding, __typeAttribute: Boolean): scala.xml.NodeSeq =
      scala.xml.Elem(IPXACT2022scalaxb.Helper.getPrefix(__namespace, __scope).orNull,
        __elementLabel getOrElse { sys.error("missing element label.") },
        scala.xml.Null, __scope, true, scala.xml.Text(__obj.toString))
  }
  trait DefaultIPXACT2022ScalaCases_IsResetFormat extends IPXACT2022scalaxb.XMLFormat[IPXACT2022ScalaCases.IsReset] with IPXACT2022scalaxb.CanWriteChildNodes[IPXACT2022ScalaCases.IsReset] {
    val targetNamespace: Option[String] = Some("http://www.accellera.org/XMLSchema/IPXACT/1685-2022")
    def reads(seq: scala.xml.NodeSeq, stack: List[IPXACT2022scalaxb.ElemName]): Either[String, IPXACT2022ScalaCases.IsReset] = seq match {
      case node: scala.xml.Node => Right(IPXACT2022ScalaCases.IsReset(IPXACT2022scalaxb.fromXML[Boolean](node, IPXACT2022scalaxb.ElemName(node) :: stack),
        scala.collection.immutable.ListMap(List(
        (node \ "@level").headOption map { x => IPXACT2022scalaxb.DataRecord(x, node, IPXACT2022scalaxb.fromXML[IPXACT2022ScalaCases.Level](x, IPXACT2022scalaxb.ElemName(node) :: stack)) } map { "@level" -> _ }
        ).flatten[(String, IPXACT2022scalaxb.DataRecord[Any])]: _*)))
      case _ => Left("reads failed: seq must be scala.xml.Node")
    }
    
    override def writesAttribute(__obj: IPXACT2022ScalaCases.IsReset, __scope: scala.xml.NamespaceBinding): scala.xml.MetaData = {
      var attr: scala.xml.MetaData  = scala.xml.Null
      __obj.attributes.toList map {
        case ("@level", _) => __obj.level foreach { x => attr = scala.xml.Attribute(null, "level", x.toString, attr) }
        case (key, x) => attr = scala.xml.Attribute((x.namespace map { __scope.getPrefix(_) }).orNull, x.key.orNull, x.value.toString, attr)
      }
      attr
    }

    def writesChildNodes(__obj: IPXACT2022ScalaCases.IsReset, __scope: scala.xml.NamespaceBinding): Seq[scala.xml.Node] =
      Seq(scala.xml.Text(__obj.value.toString))

  }

  def buildIPXACT2022ScalaCases_LevelTypeFormat = new DefaultIPXACT2022ScalaCases_LevelTypeFormat {}
  trait DefaultIPXACT2022ScalaCases_LevelTypeFormat extends IPXACT2022scalaxb.XMLFormat[IPXACT2022ScalaCases.LevelType] {
    val targetNamespace: Option[String] = Some("http://www.accellera.org/XMLSchema/IPXACT/1685-2022")
    
    def fromString(value: String, scope: scala.xml.NamespaceBinding): IPXACT2022ScalaCases.LevelType =
        (fromString0(value, scope)).apply(IPXACT2022scalaxb.fromXML[String](scala.xml.Text(value)))

    private def fromString0(value: String, scope: scala.xml.NamespaceBinding): PartialFunction[Any, IPXACT2022ScalaCases.LevelType] = {
      case x: String if x == IPXACT2022scalaxb.fromXML[String](scala.xml.Text("low")) => IPXACT2022ScalaCases.LowValue2
      case x: String if x == IPXACT2022scalaxb.fromXML[String](scala.xml.Text("high")) => IPXACT2022ScalaCases.HighValue2

    }



    def reads(seq: scala.xml.NodeSeq, stack: List[IPXACT2022scalaxb.ElemName]): Either[String, IPXACT2022ScalaCases.LevelType] = seq match {
      case elem: scala.xml.Elem => Right(fromString(elem.text, elem.scope))
      case _ => Right(fromString(seq.text, scala.xml.TopScope))
    }
    
    def writes(__obj: IPXACT2022ScalaCases.LevelType, __namespace: Option[String], __elementLabel: Option[String],
        __scope: scala.xml.NamespaceBinding, __typeAttribute: Boolean): scala.xml.NodeSeq =
      scala.xml.Elem(IPXACT2022scalaxb.Helper.getPrefix(__namespace, __scope).orNull,
        __elementLabel getOrElse { sys.error("missing element label.") },
        scala.xml.Null, __scope, true, scala.xml.Text(__obj.toString))
  }
  trait DefaultIPXACT2022ScalaCases_IsClockEnFormat extends IPXACT2022scalaxb.XMLFormat[IPXACT2022ScalaCases.IsClockEn] with IPXACT2022scalaxb.CanWriteChildNodes[IPXACT2022ScalaCases.IsClockEn] {
    val targetNamespace: Option[String] = Some("http://www.accellera.org/XMLSchema/IPXACT/1685-2022")
    def reads(seq: scala.xml.NodeSeq, stack: List[IPXACT2022scalaxb.ElemName]): Either[String, IPXACT2022ScalaCases.IsClockEn] = seq match {
      case node: scala.xml.Node => Right(IPXACT2022ScalaCases.IsClockEn(IPXACT2022scalaxb.fromXML[Boolean](node, IPXACT2022scalaxb.ElemName(node) :: stack),
        scala.collection.immutable.ListMap(List(
        (node \ "@level").headOption map { x => IPXACT2022scalaxb.DataRecord(x, node, IPXACT2022scalaxb.fromXML[IPXACT2022ScalaCases.LevelType](x, IPXACT2022scalaxb.ElemName(node) :: stack)) } map { "@level" -> _ }
        ).flatten[(String, IPXACT2022scalaxb.DataRecord[Any])]: _*)))
      case _ => Left("reads failed: seq must be scala.xml.Node")
    }
    
    override def writesAttribute(__obj: IPXACT2022ScalaCases.IsClockEn, __scope: scala.xml.NamespaceBinding): scala.xml.MetaData = {
      var attr: scala.xml.MetaData  = scala.xml.Null
      __obj.attributes.toList map {
        case ("@level", _) => __obj.level foreach { x => attr = scala.xml.Attribute(null, "level", x.toString, attr) }
        case (key, x) => attr = scala.xml.Attribute((x.namespace map { __scope.getPrefix(_) }).orNull, x.key.orNull, x.value.toString, attr)
      }
      attr
    }

    def writesChildNodes(__obj: IPXACT2022ScalaCases.IsClockEn, __scope: scala.xml.NamespaceBinding): Seq[scala.xml.Node] =
      Seq(scala.xml.Text(__obj.value.toString))

  }

  def buildIPXACT2022ScalaCases_LevelType2Format = new DefaultIPXACT2022ScalaCases_LevelType2Format {}
  trait DefaultIPXACT2022ScalaCases_LevelType2Format extends IPXACT2022scalaxb.XMLFormat[IPXACT2022ScalaCases.LevelType2] {
    val targetNamespace: Option[String] = Some("http://www.accellera.org/XMLSchema/IPXACT/1685-2022")
    
    def fromString(value: String, scope: scala.xml.NamespaceBinding): IPXACT2022ScalaCases.LevelType2 =
        (fromString0(value, scope)).apply(IPXACT2022scalaxb.fromXML[String](scala.xml.Text(value)))

    private def fromString0(value: String, scope: scala.xml.NamespaceBinding): PartialFunction[Any, IPXACT2022ScalaCases.LevelType2] = {
      case x: String if x == IPXACT2022scalaxb.fromXML[String](scala.xml.Text("low")) => IPXACT2022ScalaCases.LowValue3
      case x: String if x == IPXACT2022scalaxb.fromXML[String](scala.xml.Text("high")) => IPXACT2022ScalaCases.HighValue3

    }



    def reads(seq: scala.xml.NodeSeq, stack: List[IPXACT2022scalaxb.ElemName]): Either[String, IPXACT2022ScalaCases.LevelType2] = seq match {
      case elem: scala.xml.Elem => Right(fromString(elem.text, elem.scope))
      case _ => Right(fromString(seq.text, scala.xml.TopScope))
    }
    
    def writes(__obj: IPXACT2022ScalaCases.LevelType2, __namespace: Option[String], __elementLabel: Option[String],
        __scope: scala.xml.NamespaceBinding, __typeAttribute: Boolean): scala.xml.NodeSeq =
      scala.xml.Elem(IPXACT2022scalaxb.Helper.getPrefix(__namespace, __scope).orNull,
        __elementLabel getOrElse { sys.error("missing element label.") },
        scala.xml.Null, __scope, true, scala.xml.Text(__obj.toString))
  }
  trait DefaultIPXACT2022ScalaCases_IsPowerEnFormat extends IPXACT2022scalaxb.XMLFormat[IPXACT2022ScalaCases.IsPowerEn] with IPXACT2022scalaxb.CanWriteChildNodes[IPXACT2022ScalaCases.IsPowerEn] {
    val targetNamespace: Option[String] = Some("http://www.accellera.org/XMLSchema/IPXACT/1685-2022")
    def reads(seq: scala.xml.NodeSeq, stack: List[IPXACT2022scalaxb.ElemName]): Either[String, IPXACT2022ScalaCases.IsPowerEn] = seq match {
      case node: scala.xml.Node => Right(IPXACT2022ScalaCases.IsPowerEn(IPXACT2022scalaxb.fromXML[Boolean](node, IPXACT2022scalaxb.ElemName(node) :: stack),
        scala.collection.immutable.ListMap(List(
        (node \ "@level").headOption map { x => IPXACT2022scalaxb.DataRecord(x, node, IPXACT2022scalaxb.fromXML[IPXACT2022ScalaCases.LevelType2](x, IPXACT2022scalaxb.ElemName(node) :: stack)) } map { "@level" -> _ },
        (node \ "@powerDomainRef").headOption map { x => IPXACT2022scalaxb.DataRecord(x, node, IPXACT2022scalaxb.fromXML[String](x, IPXACT2022scalaxb.ElemName(node) :: stack)) } map { "@powerDomainRef" -> _ }
        ).flatten[(String, IPXACT2022scalaxb.DataRecord[Any])]: _*)))
      case _ => Left("reads failed: seq must be scala.xml.Node")
    }
    
    override def writesAttribute(__obj: IPXACT2022ScalaCases.IsPowerEn, __scope: scala.xml.NamespaceBinding): scala.xml.MetaData = {
      var attr: scala.xml.MetaData  = scala.xml.Null
      __obj.attributes.toList map {
        case ("@level", _) => __obj.level foreach { x => attr = scala.xml.Attribute(null, "level", x.toString, attr) }
        case ("@powerDomainRef", _) => __obj.powerDomainRef foreach { x => attr = scala.xml.Attribute(null, "powerDomainRef", x.toString, attr) }
        case (key, x) => attr = scala.xml.Attribute((x.namespace map { __scope.getPrefix(_) }).orNull, x.key.orNull, x.value.toString, attr)
      }
      attr
    }

    def writesChildNodes(__obj: IPXACT2022ScalaCases.IsPowerEn, __scope: scala.xml.NamespaceBinding): Seq[scala.xml.Node] =
      Seq(scala.xml.Text(__obj.value.toString))

  }

  def buildIPXACT2022ScalaCases_FlowTypeFormat = new DefaultIPXACT2022ScalaCases_FlowTypeFormat {}
  trait DefaultIPXACT2022ScalaCases_FlowTypeFormat extends IPXACT2022scalaxb.XMLFormat[IPXACT2022ScalaCases.FlowType] {
    val targetNamespace: Option[String] = Some("http://www.accellera.org/XMLSchema/IPXACT/1685-2022")
    
    def fromString(value: String, scope: scala.xml.NamespaceBinding): IPXACT2022ScalaCases.FlowType =
        (fromString0(value, scope)).apply(IPXACT2022scalaxb.fromXML[String](scala.xml.Text(value)))

    private def fromString0(value: String, scope: scala.xml.NamespaceBinding): PartialFunction[Any, IPXACT2022ScalaCases.FlowType] = {
      case x: String if x == IPXACT2022scalaxb.fromXML[String](scala.xml.Text("credit-return")) => IPXACT2022ScalaCases.Creditu45return
      case x: String if x == IPXACT2022scalaxb.fromXML[String](scala.xml.Text("ready")) => IPXACT2022ScalaCases.Ready
      case x: String if x == IPXACT2022scalaxb.fromXML[String](scala.xml.Text("busy")) => IPXACT2022ScalaCases.Busy
      case x: String if x == IPXACT2022scalaxb.fromXML[String](scala.xml.Text("user")) => IPXACT2022ScalaCases.UserValue

    }



    def reads(seq: scala.xml.NodeSeq, stack: List[IPXACT2022scalaxb.ElemName]): Either[String, IPXACT2022ScalaCases.FlowType] = seq match {
      case elem: scala.xml.Elem => Right(fromString(elem.text, elem.scope))
      case _ => Right(fromString(seq.text, scala.xml.TopScope))
    }
    
    def writes(__obj: IPXACT2022ScalaCases.FlowType, __namespace: Option[String], __elementLabel: Option[String],
        __scope: scala.xml.NamespaceBinding, __typeAttribute: Boolean): scala.xml.NodeSeq =
      scala.xml.Elem(IPXACT2022scalaxb.Helper.getPrefix(__namespace, __scope).orNull,
        __elementLabel getOrElse { sys.error("missing element label.") },
        scala.xml.Null, __scope, true, scala.xml.Text(__obj.toString))
  }
  trait DefaultIPXACT2022ScalaCases_IsFlowControlFormat extends IPXACT2022scalaxb.XMLFormat[IPXACT2022ScalaCases.IsFlowControl] with IPXACT2022scalaxb.CanWriteChildNodes[IPXACT2022ScalaCases.IsFlowControl] {
    val targetNamespace: Option[String] = Some("http://www.accellera.org/XMLSchema/IPXACT/1685-2022")
    def reads(seq: scala.xml.NodeSeq, stack: List[IPXACT2022scalaxb.ElemName]): Either[String, IPXACT2022ScalaCases.IsFlowControl] = seq match {
      case node: scala.xml.Node => Right(IPXACT2022ScalaCases.IsFlowControl(IPXACT2022scalaxb.fromXML[Boolean](node, IPXACT2022scalaxb.ElemName(node) :: stack),
        scala.collection.immutable.ListMap(List(
        (node \ "@flowType").headOption map { x => IPXACT2022scalaxb.DataRecord(x, node, IPXACT2022scalaxb.fromXML[IPXACT2022ScalaCases.FlowType](x, IPXACT2022scalaxb.ElemName(node) :: stack)) } map { "@flowType" -> _ },
        (node \ "@user").headOption map { x => IPXACT2022scalaxb.DataRecord(x, node, IPXACT2022scalaxb.fromXML[String](x, IPXACT2022scalaxb.ElemName(node) :: stack)) } map { "@user" -> _ }
        ).flatten[(String, IPXACT2022scalaxb.DataRecord[Any])]: _*)))
      case _ => Left("reads failed: seq must be scala.xml.Node")
    }
    
    override def writesAttribute(__obj: IPXACT2022ScalaCases.IsFlowControl, __scope: scala.xml.NamespaceBinding): scala.xml.MetaData = {
      var attr: scala.xml.MetaData  = scala.xml.Null
      __obj.attributes.toList map {
        case ("@flowType", _) => __obj.flowType foreach { x => attr = scala.xml.Attribute(null, "flowType", x.toString, attr) }
        case ("@user", _) => __obj.user foreach { x => attr = scala.xml.Attribute(null, "user", x.toString, attr) }
        case (key, x) => attr = scala.xml.Attribute((x.namespace map { __scope.getPrefix(_) }).orNull, x.key.orNull, x.value.toString, attr)
      }
      attr
    }

    def writesChildNodes(__obj: IPXACT2022ScalaCases.IsFlowControl, __scope: scala.xml.NamespaceBinding): Seq[scala.xml.Node] =
      Seq(scala.xml.Text(__obj.value.toString))

  }

  trait DefaultIPXACT2022ScalaCases_IsUserFormat extends IPXACT2022scalaxb.XMLFormat[IPXACT2022ScalaCases.IsUser] with IPXACT2022scalaxb.CanWriteChildNodes[IPXACT2022ScalaCases.IsUser] {
    val targetNamespace: Option[String] = Some("http://www.accellera.org/XMLSchema/IPXACT/1685-2022")
    def reads(seq: scala.xml.NodeSeq, stack: List[IPXACT2022scalaxb.ElemName]): Either[String, IPXACT2022ScalaCases.IsUser] = seq match {
      case node: scala.xml.Node => Right(IPXACT2022ScalaCases.IsUser(IPXACT2022scalaxb.fromXML[Boolean](node, IPXACT2022scalaxb.ElemName(node) :: stack),
        scala.collection.immutable.ListMap(List(
        (node \ "@user").headOption map { x => IPXACT2022scalaxb.DataRecord(x, node, IPXACT2022scalaxb.fromXML[String](x, IPXACT2022scalaxb.ElemName(node) :: stack)) } map { "@user" -> _ }
        ).flatten[(String, IPXACT2022scalaxb.DataRecord[Any])]: _*)))
      case _ => Left("reads failed: seq must be scala.xml.Node")
    }
    
    override def writesAttribute(__obj: IPXACT2022ScalaCases.IsUser, __scope: scala.xml.NamespaceBinding): scala.xml.MetaData = {
      var attr: scala.xml.MetaData  = scala.xml.Null
      __obj.attributes.toList map {
        case ("@user", _) => __obj.user foreach { x => attr = scala.xml.Attribute(null, "user", x.toString, attr) }
        case (key, x) => attr = scala.xml.Attribute((x.namespace map { __scope.getPrefix(_) }).orNull, x.key.orNull, x.value.toString, attr)
      }
      attr
    }

    def writesChildNodes(__obj: IPXACT2022ScalaCases.IsUser, __scope: scala.xml.NamespaceBinding): Seq[scala.xml.Node] =
      Seq(scala.xml.Text(__obj.value.toString))

  }

  trait DefaultIPXACT2022ScalaCases_QualifierTypeFormat extends IPXACT2022scalaxb.ElemNameParser[IPXACT2022ScalaCases.QualifierType] {
    val targetNamespace: Option[String] = Some("http://www.accellera.org/XMLSchema/IPXACT/1685-2022")
    
    override def typeName: Option[String] = Some("qualifierType")

    def parser(node: scala.xml.Node, stack: List[IPXACT2022scalaxb.ElemName]): Parser[IPXACT2022ScalaCases.QualifierType] =
      phrase(opt(IPXACT2022scalaxb.ElemName(Some("http://www.accellera.org/XMLSchema/IPXACT/1685-2022"), "isAddress")) ~
      opt(IPXACT2022scalaxb.ElemName(Some("http://www.accellera.org/XMLSchema/IPXACT/1685-2022"), "isData")) ~
      opt(IPXACT2022scalaxb.ElemName(Some("http://www.accellera.org/XMLSchema/IPXACT/1685-2022"), "isClock")) ~
      opt(IPXACT2022scalaxb.ElemName(Some("http://www.accellera.org/XMLSchema/IPXACT/1685-2022"), "isReset")) ~
      opt(IPXACT2022scalaxb.ElemName(Some("http://www.accellera.org/XMLSchema/IPXACT/1685-2022"), "isValid")) ~
      opt(IPXACT2022scalaxb.ElemName(Some("http://www.accellera.org/XMLSchema/IPXACT/1685-2022"), "isInterrupt")) ~
      opt(IPXACT2022scalaxb.ElemName(Some("http://www.accellera.org/XMLSchema/IPXACT/1685-2022"), "isClockEn")) ~
      opt(IPXACT2022scalaxb.ElemName(Some("http://www.accellera.org/XMLSchema/IPXACT/1685-2022"), "isPowerEn")) ~
      opt(IPXACT2022scalaxb.ElemName(Some("http://www.accellera.org/XMLSchema/IPXACT/1685-2022"), "isOpcode")) ~
      opt(IPXACT2022scalaxb.ElemName(Some("http://www.accellera.org/XMLSchema/IPXACT/1685-2022"), "isProtection")) ~
      opt(IPXACT2022scalaxb.ElemName(Some("http://www.accellera.org/XMLSchema/IPXACT/1685-2022"), "isFlowControl")) ~
      opt(IPXACT2022scalaxb.ElemName(Some("http://www.accellera.org/XMLSchema/IPXACT/1685-2022"), "isUser")) ~
      opt(IPXACT2022scalaxb.ElemName(Some("http://www.accellera.org/XMLSchema/IPXACT/1685-2022"), "isRequest")) ~
      opt(IPXACT2022scalaxb.ElemName(Some("http://www.accellera.org/XMLSchema/IPXACT/1685-2022"), "isResponse")) ^^
      { case p1 ~ p2 ~ p3 ~ p4 ~ p5 ~ p6 ~ p7 ~ p8 ~ p9 ~ p10 ~ p11 ~ p12 ~ p13 ~ p14 =>
      IPXACT2022ScalaCases.QualifierType(p1.headOption map { IPXACT2022scalaxb.fromXML[Boolean](_, IPXACT2022scalaxb.ElemName(node) :: stack) },
        p2.headOption map { IPXACT2022scalaxb.fromXML[Boolean](_, IPXACT2022scalaxb.ElemName(node) :: stack) },
        p3.headOption map { IPXACT2022scalaxb.fromXML[Boolean](_, IPXACT2022scalaxb.ElemName(node) :: stack) },
        p4.headOption map { IPXACT2022scalaxb.fromXML[IPXACT2022ScalaCases.IsReset](_, IPXACT2022scalaxb.ElemName(node) :: stack) },
        p5.headOption map { IPXACT2022scalaxb.fromXML[Boolean](_, IPXACT2022scalaxb.ElemName(node) :: stack) },
        p6.headOption map { IPXACT2022scalaxb.fromXML[Boolean](_, IPXACT2022scalaxb.ElemName(node) :: stack) },
        p7.headOption map { IPXACT2022scalaxb.fromXML[IPXACT2022ScalaCases.IsClockEn](_, IPXACT2022scalaxb.ElemName(node) :: stack) },
        p8.headOption map { IPXACT2022scalaxb.fromXML[IPXACT2022ScalaCases.IsPowerEn](_, IPXACT2022scalaxb.ElemName(node) :: stack) },
        p9.headOption map { IPXACT2022scalaxb.fromXML[Boolean](_, IPXACT2022scalaxb.ElemName(node) :: stack) },
        p10.headOption map { IPXACT2022scalaxb.fromXML[Boolean](_, IPXACT2022scalaxb.ElemName(node) :: stack) },
        p11.headOption map { IPXACT2022scalaxb.fromXML[IPXACT2022ScalaCases.IsFlowControl](_, IPXACT2022scalaxb.ElemName(node) :: stack) },
        p12.headOption map { IPXACT2022scalaxb.fromXML[IPXACT2022ScalaCases.IsUser](_, IPXACT2022scalaxb.ElemName(node) :: stack) },
        p13.headOption map { IPXACT2022scalaxb.fromXML[Boolean](_, IPXACT2022scalaxb.ElemName(node) :: stack) },
        p14.headOption map { IPXACT2022scalaxb.fromXML[Boolean](_, IPXACT2022scalaxb.ElemName(node) :: stack) },
        scala.collection.immutable.ListMap(List(
        (node \ "@{http://www.w3.org/XML/1998/namespace}id").headOption map { x => IPXACT2022scalaxb.DataRecord(x, node, IPXACT2022scalaxb.fromXML[String](x, IPXACT2022scalaxb.ElemName(node) :: stack)) } map { "@{http://www.w3.org/XML/1998/namespace}id" -> _ }
        ).flatten[(String, IPXACT2022scalaxb.DataRecord[Any])]: _*)) })
    
    override def writesAttribute(__obj: IPXACT2022ScalaCases.QualifierType, __scope: scala.xml.NamespaceBinding): scala.xml.MetaData = {
      var attr: scala.xml.MetaData  = scala.xml.Null
      __obj.attributes.toList map {
        case ("@{http://www.w3.org/XML/1998/namespace}id", _) => __obj.xmlid foreach { x => attr = scala.xml.Attribute(__scope.getPrefix("http://www.w3.org/XML/1998/namespace"), "id", x.toString, attr) }
        case (key, x) => attr = scala.xml.Attribute((x.namespace map { __scope.getPrefix(_) }).orNull, x.key.orNull, x.value.toString, attr)
      }
      attr
    }

    def writesChildNodes(__obj: IPXACT2022ScalaCases.QualifierType, __scope: scala.xml.NamespaceBinding): Seq[scala.xml.Node] =
      Seq.concat(__obj.isAddress map { IPXACT2022scalaxb.toXML[Boolean](_, Some("http://www.accellera.org/XMLSchema/IPXACT/1685-2022"), Some("isAddress"), __scope, false) } getOrElse {Nil},
        __obj.isData map { IPXACT2022scalaxb.toXML[Boolean](_, Some("http://www.accellera.org/XMLSchema/IPXACT/1685-2022"), Some("isData"), __scope, false) } getOrElse {Nil},
        __obj.isClock map { IPXACT2022scalaxb.toXML[Boolean](_, Some("http://www.accellera.org/XMLSchema/IPXACT/1685-2022"), Some("isClock"), __scope, false) } getOrElse {Nil},
        __obj.isReset map { IPXACT2022scalaxb.toXML[IPXACT2022ScalaCases.IsReset](_, Some("http://www.accellera.org/XMLSchema/IPXACT/1685-2022"), Some("isReset"), __scope, false) } getOrElse {Nil},
        __obj.isValid map { IPXACT2022scalaxb.toXML[Boolean](_, Some("http://www.accellera.org/XMLSchema/IPXACT/1685-2022"), Some("isValid"), __scope, false) } getOrElse {Nil},
        __obj.isInterrupt map { IPXACT2022scalaxb.toXML[Boolean](_, Some("http://www.accellera.org/XMLSchema/IPXACT/1685-2022"), Some("isInterrupt"), __scope, false) } getOrElse {Nil},
        __obj.isClockEn map { IPXACT2022scalaxb.toXML[IPXACT2022ScalaCases.IsClockEn](_, Some("http://www.accellera.org/XMLSchema/IPXACT/1685-2022"), Some("isClockEn"), __scope, false) } getOrElse {Nil},
        __obj.isPowerEn map { IPXACT2022scalaxb.toXML[IPXACT2022ScalaCases.IsPowerEn](_, Some("http://www.accellera.org/XMLSchema/IPXACT/1685-2022"), Some("isPowerEn"), __scope, false) } getOrElse {Nil},
        __obj.isOpcode map { IPXACT2022scalaxb.toXML[Boolean](_, Some("http://www.accellera.org/XMLSchema/IPXACT/1685-2022"), Some("isOpcode"), __scope, false) } getOrElse {Nil},
        __obj.isProtection map { IPXACT2022scalaxb.toXML[Boolean](_, Some("http://www.accellera.org/XMLSchema/IPXACT/1685-2022"), Some("isProtection"), __scope, false) } getOrElse {Nil},
        __obj.isFlowControl map { IPXACT2022scalaxb.toXML[IPXACT2022ScalaCases.IsFlowControl](_, Some("http://www.accellera.org/XMLSchema/IPXACT/1685-2022"), Some("isFlowControl"), __scope, false) } getOrElse {Nil},
        __obj.isUser map { IPXACT2022scalaxb.toXML[IPXACT2022ScalaCases.IsUser](_, Some("http://www.accellera.org/XMLSchema/IPXACT/1685-2022"), Some("isUser"), __scope, false) } getOrElse {Nil},
        __obj.isRequest map { IPXACT2022scalaxb.toXML[Boolean](_, Some("http://www.accellera.org/XMLSchema/IPXACT/1685-2022"), Some("isRequest"), __scope, false) } getOrElse {Nil},
        __obj.isResponse map { IPXACT2022scalaxb.toXML[Boolean](_, Some("http://www.accellera.org/XMLSchema/IPXACT/1685-2022"), Some("isResponse"), __scope, false) } getOrElse {Nil})

  }

  trait DefaultIPXACT2022ScalaCases_ParametersFormat extends IPXACT2022scalaxb.ElemNameParser[IPXACT2022ScalaCases.Parameters] {
    val targetNamespace: Option[String] = Some("http://www.accellera.org/XMLSchema/IPXACT/1685-2022")
    
    def parser(node: scala.xml.Node, stack: List[IPXACT2022scalaxb.ElemName]): Parser[IPXACT2022ScalaCases.Parameters] =
      phrase(safeRep(IPXACT2022scalaxb.ElemName(Some("http://www.accellera.org/XMLSchema/IPXACT/1685-2022"), "parameter")) ^^
      { case p1 =>
      IPXACT2022ScalaCases.Parameters(p1 map { IPXACT2022scalaxb.fromXML[IPXACT2022ScalaCases.ParameterType](_, IPXACT2022scalaxb.ElemName(node) :: stack) }) })
    
    def writesChildNodes(__obj: IPXACT2022ScalaCases.Parameters, __scope: scala.xml.NamespaceBinding): Seq[scala.xml.Node] =
      (__obj.parameter flatMap { IPXACT2022scalaxb.toXML[IPXACT2022ScalaCases.ParameterType](_, Some("http://www.accellera.org/XMLSchema/IPXACT/1685-2022"), Some("parameter"), __scope, false) })
  }
  trait DefaultIPXACT2022ScalaCases_VendorExtensionsFormat extends IPXACT2022scalaxb.ElemNameParser[IPXACT2022ScalaCases.VendorExtensions] {
    val targetNamespace: Option[String] = Some("http://www.accellera.org/XMLSchema/IPXACT/1685-2022")
    
    def parser(node: scala.xml.Node, stack: List[IPXACT2022scalaxb.ElemName]): Parser[IPXACT2022ScalaCases.VendorExtensions] =
      phrase(safeRep(any(_ => true)) ^^
      { case p1 =>
      IPXACT2022ScalaCases.VendorExtensions(p1 map { IPXACT2022scalaxb.fromXML[IPXACT2022scalaxb.DataRecord[Any]](_, IPXACT2022scalaxb.ElemName(node) :: stack) }) })
    
    def writesChildNodes(__obj: IPXACT2022ScalaCases.VendorExtensions, __scope: scala.xml.NamespaceBinding): Seq[scala.xml.Node] =
      (__obj.any flatMap { x => IPXACT2022scalaxb.toXML[IPXACT2022scalaxb.DataRecord[Any]](x, x.namespace, x.key, __scope, true) })
  }
  trait DefaultIPXACT2022ScalaCases_ViewRef2Format extends IPXACT2022scalaxb.XMLFormat[IPXACT2022ScalaCases.ViewRef2] with IPXACT2022scalaxb.CanWriteChildNodes[IPXACT2022ScalaCases.ViewRef2] {
    val targetNamespace: Option[String] = Some("http://www.accellera.org/XMLSchema/IPXACT/1685-2022")
    def reads(seq: scala.xml.NodeSeq, stack: List[IPXACT2022scalaxb.ElemName]): Either[String, IPXACT2022ScalaCases.ViewRef2] = seq match {
      case node: scala.xml.Node => Right(IPXACT2022ScalaCases.ViewRef2(IPXACT2022scalaxb.fromXML[String](node, IPXACT2022scalaxb.ElemName(node) :: stack),
        scala.collection.immutable.ListMap(List(
        (node \ "@{http://www.w3.org/XML/1998/namespace}id").headOption map { x => IPXACT2022scalaxb.DataRecord(x, node, IPXACT2022scalaxb.fromXML[String](x, IPXACT2022scalaxb.ElemName(node) :: stack)) } map { "@{http://www.w3.org/XML/1998/namespace}id" -> _ }
        ).flatten[(String, IPXACT2022scalaxb.DataRecord[Any])]: _*)))
      case _ => Left("reads failed: seq must be scala.xml.Node")
    }
    
    override def writesAttribute(__obj: IPXACT2022ScalaCases.ViewRef2, __scope: scala.xml.NamespaceBinding): scala.xml.MetaData = {
      var attr: scala.xml.MetaData  = scala.xml.Null
      __obj.attributes.toList map {
        case ("@{http://www.w3.org/XML/1998/namespace}id", _) => __obj.xmlid foreach { x => attr = scala.xml.Attribute(__scope.getPrefix("http://www.w3.org/XML/1998/namespace"), "id", x.toString, attr) }
        case (key, x) => attr = scala.xml.Attribute((x.namespace map { __scope.getPrefix(_) }).orNull, x.key.orNull, x.value.toString, attr)
      }
      attr
    }

    def writesChildNodes(__obj: IPXACT2022ScalaCases.ViewRef2, __scope: scala.xml.NamespaceBinding): Seq[scala.xml.Node] =
      Seq(scala.xml.Text(__obj.value.toString))

  }

  trait DefaultIPXACT2022ScalaCases_IndexFormat extends IPXACT2022scalaxb.XMLFormat[IPXACT2022ScalaCases.Index] with IPXACT2022scalaxb.CanWriteChildNodes[IPXACT2022ScalaCases.Index] {
    val targetNamespace: Option[String] = Some("http://www.accellera.org/XMLSchema/IPXACT/1685-2022")
    def reads(seq: scala.xml.NodeSeq, stack: List[IPXACT2022scalaxb.ElemName]): Either[String, IPXACT2022ScalaCases.Index] = seq match {
      case node: scala.xml.Node => Right(IPXACT2022ScalaCases.Index(IPXACT2022scalaxb.fromXML[String](node, IPXACT2022scalaxb.ElemName(node) :: stack),
        scala.collection.immutable.ListMap(List(
        (node \ "@minimum").headOption map { x => IPXACT2022scalaxb.DataRecord(x, node, IPXACT2022scalaxb.fromXML[Int](x, IPXACT2022scalaxb.ElemName(node) :: stack)) } map { "@minimum" -> _ },
        (node \ "@maximum").headOption map { x => IPXACT2022scalaxb.DataRecord(x, node, IPXACT2022scalaxb.fromXML[Int](x, IPXACT2022scalaxb.ElemName(node) :: stack)) } map { "@maximum" -> _ },
        (node \ "@{http://www.w3.org/XML/1998/namespace}id").headOption map { x => IPXACT2022scalaxb.DataRecord(x, node, IPXACT2022scalaxb.fromXML[String](x, IPXACT2022scalaxb.ElemName(node) :: stack)) } map { "@{http://www.w3.org/XML/1998/namespace}id" -> _ }
        ).flatten[(String, IPXACT2022scalaxb.DataRecord[Any])] ::: (node match {
          case elem: scala.xml.Elem =>
            elem.attributes.toList flatMap {
              case scala.xml.UnprefixedAttribute(key, value, _) if key == "minimum" => Nil
              case scala.xml.UnprefixedAttribute(key, value, _) if key == "maximum" => Nil
              case scala.xml.PrefixedAttribute(pre, key, value, _) if pre == elem.scope.getPrefix("http://www.w3.org/XML/1998/namespace") &&
                key == "id" => Nil
              case scala.xml.UnprefixedAttribute(key, value, _) =>
                List(("@" + key, IPXACT2022scalaxb.DataRecord(None, Some(key), value.text)))
              case scala.xml.PrefixedAttribute(pre, key, value, _) =>
                val ns = elem.scope.getURI(pre)
                List(("@{" + ns + "}" + key, IPXACT2022scalaxb.DataRecord(Option[String](ns), Some(key), value.text)))
              case _ => Nil
            }
          case _ => Nil
        }): _*)))
      case _ => Left("reads failed: seq must be scala.xml.Node")
    }
    
    override def writesAttribute(__obj: IPXACT2022ScalaCases.Index, __scope: scala.xml.NamespaceBinding): scala.xml.MetaData = {
      var attr: scala.xml.MetaData  = scala.xml.Null
      __obj.attributes.toList map {
        case ("@minimum", _) => __obj.minimum foreach { x => attr = scala.xml.Attribute(null, "minimum", x.toString, attr) }
        case ("@maximum", _) => __obj.maximum foreach { x => attr = scala.xml.Attribute(null, "maximum", x.toString, attr) }
        case ("@{http://www.w3.org/XML/1998/namespace}id", _) => __obj.xmlid foreach { x => attr = scala.xml.Attribute(__scope.getPrefix("http://www.w3.org/XML/1998/namespace"), "id", x.toString, attr) }
        case (key, x) => attr = scala.xml.Attribute((x.namespace map { __scope.getPrefix(_) }).orNull, x.key.orNull, x.value.toString, attr)
      }
      attr
    }

    def writesChildNodes(__obj: IPXACT2022ScalaCases.Index, __scope: scala.xml.NamespaceBinding): Seq[scala.xml.Node] =
      Seq(scala.xml.Text(__obj.value.toString))

  }

  trait DefaultIPXACT2022ScalaCases_IndicesFormat extends IPXACT2022scalaxb.ElemNameParser[IPXACT2022ScalaCases.Indices] {
    val targetNamespace: Option[String] = Some("http://www.accellera.org/XMLSchema/IPXACT/1685-2022")
    
    def parser(node: scala.xml.Node, stack: List[IPXACT2022scalaxb.ElemName]): Parser[IPXACT2022ScalaCases.Indices] =
      phrase(safeRep(IPXACT2022scalaxb.ElemName(Some("http://www.accellera.org/XMLSchema/IPXACT/1685-2022"), "index")) ^^
      { case p1 =>
      IPXACT2022ScalaCases.Indices(p1 map { IPXACT2022scalaxb.fromXML[IPXACT2022ScalaCases.Index](_, IPXACT2022scalaxb.ElemName(node) :: stack) }) })
    
    def writesChildNodes(__obj: IPXACT2022ScalaCases.Indices, __scope: scala.xml.NamespaceBinding): Seq[scala.xml.Node] =
      (__obj.index flatMap { IPXACT2022scalaxb.toXML[IPXACT2022ScalaCases.Index](_, Some("http://www.accellera.org/XMLSchema/IPXACT/1685-2022"), Some("index"), __scope, false) })
  }
  trait DefaultIPXACT2022ScalaCases_PortAccessHandleFormat extends IPXACT2022scalaxb.ElemNameParser[IPXACT2022ScalaCases.PortAccessHandle] {
    val targetNamespace: Option[String] = Some("http://www.accellera.org/XMLSchema/IPXACT/1685-2022")
    
    override def typeName: Option[String] = Some("portAccessHandle")

    def parser(node: scala.xml.Node, stack: List[IPXACT2022scalaxb.ElemName]): Parser[IPXACT2022ScalaCases.PortAccessHandle] =
      phrase(safeRep(IPXACT2022scalaxb.ElemName(Some("http://www.accellera.org/XMLSchema/IPXACT/1685-2022"), "viewRef")) ~
      opt(IPXACT2022scalaxb.ElemName(Some("http://www.accellera.org/XMLSchema/IPXACT/1685-2022"), "indices")) ~
      (IPXACT2022scalaxb.ElemName(Some("http://www.accellera.org/XMLSchema/IPXACT/1685-2022"), "slices")) ~
      opt(IPXACT2022scalaxb.ElemName(Some("http://www.accellera.org/XMLSchema/IPXACT/1685-2022"), "vendorExtensions")) ^^
      { case p1 ~ p2 ~ p3 ~ p4 =>
      IPXACT2022ScalaCases.PortAccessHandle(p1 map { IPXACT2022scalaxb.fromXML[IPXACT2022ScalaCases.ViewRef2](_, IPXACT2022scalaxb.ElemName(node) :: stack) },
        p2.headOption map { IPXACT2022scalaxb.fromXML[IPXACT2022ScalaCases.Indices](_, IPXACT2022scalaxb.ElemName(node) :: stack) },
        IPXACT2022scalaxb.fromXML[IPXACT2022ScalaCases.PortSlicesType](p3, IPXACT2022scalaxb.ElemName(node) :: stack),
        p4.headOption map { IPXACT2022scalaxb.fromXML[IPXACT2022ScalaCases.VendorExtensions](_, IPXACT2022scalaxb.ElemName(node) :: stack) },
        scala.collection.immutable.ListMap(List(
        (node \ "@force").headOption map { x => IPXACT2022scalaxb.DataRecord(x, node, IPXACT2022scalaxb.fromXML[Boolean](x, IPXACT2022scalaxb.ElemName(node) :: stack)) } orElse Some(IPXACT2022scalaxb.DataRecord(None, None, IPXACT2022scalaxb.fromXML[Boolean](scala.xml.Text("true"), IPXACT2022scalaxb.ElemName(node) :: stack))) map { "@force" -> _ },
        (node \ "@{http://www.w3.org/XML/1998/namespace}id").headOption map { x => IPXACT2022scalaxb.DataRecord(x, node, IPXACT2022scalaxb.fromXML[String](x, IPXACT2022scalaxb.ElemName(node) :: stack)) } map { "@{http://www.w3.org/XML/1998/namespace}id" -> _ }
        ).flatten[(String, IPXACT2022scalaxb.DataRecord[Any])]: _*)) })
    
    override def writesAttribute(__obj: IPXACT2022ScalaCases.PortAccessHandle, __scope: scala.xml.NamespaceBinding): scala.xml.MetaData = {
      var attr: scala.xml.MetaData  = scala.xml.Null
      __obj.attributes.toList map {
        case ("@force", _) => if (__obj.force.toString != "true") attr = scala.xml.Attribute(null, "force", __obj.force.toString, attr)
        case ("@{http://www.w3.org/XML/1998/namespace}id", _) => __obj.xmlid foreach { x => attr = scala.xml.Attribute(__scope.getPrefix("http://www.w3.org/XML/1998/namespace"), "id", x.toString, attr) }
        case (key, x) => attr = scala.xml.Attribute((x.namespace map { __scope.getPrefix(_) }).orNull, x.key.orNull, x.value.toString, attr)
      }
      attr
    }

    def writesChildNodes(__obj: IPXACT2022ScalaCases.PortAccessHandle, __scope: scala.xml.NamespaceBinding): Seq[scala.xml.Node] =
      Seq.concat(__obj.viewRef flatMap { IPXACT2022scalaxb.toXML[IPXACT2022ScalaCases.ViewRef2](_, Some("http://www.accellera.org/XMLSchema/IPXACT/1685-2022"), Some("viewRef"), __scope, false) },
        __obj.indices map { IPXACT2022scalaxb.toXML[IPXACT2022ScalaCases.Indices](_, Some("http://www.accellera.org/XMLSchema/IPXACT/1685-2022"), Some("indices"), __scope, false) } getOrElse {Nil},
        IPXACT2022scalaxb.toXML[IPXACT2022ScalaCases.PortSlicesType](__obj.slices, Some("http://www.accellera.org/XMLSchema/IPXACT/1685-2022"), Some("slices"), __scope, false),
        __obj.vendorExtensions map { IPXACT2022scalaxb.toXML[IPXACT2022ScalaCases.VendorExtensions](_, Some("http://www.accellera.org/XMLSchema/IPXACT/1685-2022"), Some("vendorExtensions"), __scope, false) } getOrElse {Nil})

  }

  trait DefaultIPXACT2022ScalaCases_ViewRef3Format extends IPXACT2022scalaxb.XMLFormat[IPXACT2022ScalaCases.ViewRef3] with IPXACT2022scalaxb.CanWriteChildNodes[IPXACT2022ScalaCases.ViewRef3] {
    val targetNamespace: Option[String] = Some("http://www.accellera.org/XMLSchema/IPXACT/1685-2022")
    def reads(seq: scala.xml.NodeSeq, stack: List[IPXACT2022scalaxb.ElemName]): Either[String, IPXACT2022ScalaCases.ViewRef3] = seq match {
      case node: scala.xml.Node => Right(IPXACT2022ScalaCases.ViewRef3(IPXACT2022scalaxb.fromXML[String](node, IPXACT2022scalaxb.ElemName(node) :: stack),
        scala.collection.immutable.ListMap(List(
        (node \ "@{http://www.w3.org/XML/1998/namespace}id").headOption map { x => IPXACT2022scalaxb.DataRecord(x, node, IPXACT2022scalaxb.fromXML[String](x, IPXACT2022scalaxb.ElemName(node) :: stack)) } map { "@{http://www.w3.org/XML/1998/namespace}id" -> _ }
        ).flatten[(String, IPXACT2022scalaxb.DataRecord[Any])]: _*)))
      case _ => Left("reads failed: seq must be scala.xml.Node")
    }
    
    override def writesAttribute(__obj: IPXACT2022ScalaCases.ViewRef3, __scope: scala.xml.NamespaceBinding): scala.xml.MetaData = {
      var attr: scala.xml.MetaData  = scala.xml.Null
      __obj.attributes.toList map {
        case ("@{http://www.w3.org/XML/1998/namespace}id", _) => __obj.xmlid foreach { x => attr = scala.xml.Attribute(__scope.getPrefix("http://www.w3.org/XML/1998/namespace"), "id", x.toString, attr) }
        case (key, x) => attr = scala.xml.Attribute((x.namespace map { __scope.getPrefix(_) }).orNull, x.key.orNull, x.value.toString, attr)
      }
      attr
    }

    def writesChildNodes(__obj: IPXACT2022ScalaCases.ViewRef3, __scope: scala.xml.NamespaceBinding): Seq[scala.xml.Node] =
      Seq(scala.xml.Text(__obj.value.toString))

  }

  trait DefaultIPXACT2022ScalaCases_SlicedAccessHandleFormat extends IPXACT2022scalaxb.ElemNameParser[IPXACT2022ScalaCases.SlicedAccessHandle] {
    val targetNamespace: Option[String] = Some("http://www.accellera.org/XMLSchema/IPXACT/1685-2022")
    
    override def typeName: Option[String] = Some("slicedAccessHandle")

    def parser(node: scala.xml.Node, stack: List[IPXACT2022scalaxb.ElemName]): Parser[IPXACT2022ScalaCases.SlicedAccessHandle] =
      phrase(safeRep(IPXACT2022scalaxb.ElemName(Some("http://www.accellera.org/XMLSchema/IPXACT/1685-2022"), "viewRef")) ~
      (IPXACT2022scalaxb.ElemName(Some("http://www.accellera.org/XMLSchema/IPXACT/1685-2022"), "slices")) ~
      opt(IPXACT2022scalaxb.ElemName(Some("http://www.accellera.org/XMLSchema/IPXACT/1685-2022"), "vendorExtensions")) ^^
      { case p1 ~ p2 ~ p3 =>
      IPXACT2022ScalaCases.SlicedAccessHandle(p1 map { IPXACT2022scalaxb.fromXML[IPXACT2022ScalaCases.ViewRef3](_, IPXACT2022scalaxb.ElemName(node) :: stack) },
        IPXACT2022scalaxb.fromXML[IPXACT2022ScalaCases.SlicesType](p2, IPXACT2022scalaxb.ElemName(node) :: stack),
        p3.headOption map { IPXACT2022scalaxb.fromXML[IPXACT2022ScalaCases.VendorExtensions](_, IPXACT2022scalaxb.ElemName(node) :: stack) },
        scala.collection.immutable.ListMap(List(
        (node \ "@force").headOption map { x => IPXACT2022scalaxb.DataRecord(x, node, IPXACT2022scalaxb.fromXML[Boolean](x, IPXACT2022scalaxb.ElemName(node) :: stack)) } orElse Some(IPXACT2022scalaxb.DataRecord(None, None, IPXACT2022scalaxb.fromXML[Boolean](scala.xml.Text("true"), IPXACT2022scalaxb.ElemName(node) :: stack))) map { "@force" -> _ },
        (node \ "@{http://www.w3.org/XML/1998/namespace}id").headOption map { x => IPXACT2022scalaxb.DataRecord(x, node, IPXACT2022scalaxb.fromXML[String](x, IPXACT2022scalaxb.ElemName(node) :: stack)) } map { "@{http://www.w3.org/XML/1998/namespace}id" -> _ }
        ).flatten[(String, IPXACT2022scalaxb.DataRecord[Any])]: _*)) })
    
    override def writesAttribute(__obj: IPXACT2022ScalaCases.SlicedAccessHandle, __scope: scala.xml.NamespaceBinding): scala.xml.MetaData = {
      var attr: scala.xml.MetaData  = scala.xml.Null
      __obj.attributes.toList map {
        case ("@force", _) => if (__obj.force.toString != "true") attr = scala.xml.Attribute(null, "force", __obj.force.toString, attr)
        case ("@{http://www.w3.org/XML/1998/namespace}id", _) => __obj.xmlid foreach { x => attr = scala.xml.Attribute(__scope.getPrefix("http://www.w3.org/XML/1998/namespace"), "id", x.toString, attr) }
        case (key, x) => attr = scala.xml.Attribute((x.namespace map { __scope.getPrefix(_) }).orNull, x.key.orNull, x.value.toString, attr)
      }
      attr
    }

    def writesChildNodes(__obj: IPXACT2022ScalaCases.SlicedAccessHandle, __scope: scala.xml.NamespaceBinding): Seq[scala.xml.Node] =
      Seq.concat(__obj.viewRef flatMap { IPXACT2022scalaxb.toXML[IPXACT2022ScalaCases.ViewRef3](_, Some("http://www.accellera.org/XMLSchema/IPXACT/1685-2022"), Some("viewRef"), __scope, false) },
        IPXACT2022scalaxb.toXML[IPXACT2022ScalaCases.SlicesType](__obj.slices, Some("http://www.accellera.org/XMLSchema/IPXACT/1685-2022"), Some("slices"), __scope, false),
        __obj.vendorExtensions map { IPXACT2022scalaxb.toXML[IPXACT2022ScalaCases.VendorExtensions](_, Some("http://www.accellera.org/XMLSchema/IPXACT/1685-2022"), Some("vendorExtensions"), __scope, false) } getOrElse {Nil})

  }

  trait DefaultIPXACT2022ScalaCases_ViewRef4Format extends IPXACT2022scalaxb.XMLFormat[IPXACT2022ScalaCases.ViewRef4] with IPXACT2022scalaxb.CanWriteChildNodes[IPXACT2022ScalaCases.ViewRef4] {
    val targetNamespace: Option[String] = Some("http://www.accellera.org/XMLSchema/IPXACT/1685-2022")
    def reads(seq: scala.xml.NodeSeq, stack: List[IPXACT2022scalaxb.ElemName]): Either[String, IPXACT2022ScalaCases.ViewRef4] = seq match {
      case node: scala.xml.Node => Right(IPXACT2022ScalaCases.ViewRef4(IPXACT2022scalaxb.fromXML[String](node, IPXACT2022scalaxb.ElemName(node) :: stack),
        scala.collection.immutable.ListMap(List(
        (node \ "@{http://www.w3.org/XML/1998/namespace}id").headOption map { x => IPXACT2022scalaxb.DataRecord(x, node, IPXACT2022scalaxb.fromXML[String](x, IPXACT2022scalaxb.ElemName(node) :: stack)) } map { "@{http://www.w3.org/XML/1998/namespace}id" -> _ }
        ).flatten[(String, IPXACT2022scalaxb.DataRecord[Any])]: _*)))
      case _ => Left("reads failed: seq must be scala.xml.Node")
    }
    
    override def writesAttribute(__obj: IPXACT2022ScalaCases.ViewRef4, __scope: scala.xml.NamespaceBinding): scala.xml.MetaData = {
      var attr: scala.xml.MetaData  = scala.xml.Null
      __obj.attributes.toList map {
        case ("@{http://www.w3.org/XML/1998/namespace}id", _) => __obj.xmlid foreach { x => attr = scala.xml.Attribute(__scope.getPrefix("http://www.w3.org/XML/1998/namespace"), "id", x.toString, attr) }
        case (key, x) => attr = scala.xml.Attribute((x.namespace map { __scope.getPrefix(_) }).orNull, x.key.orNull, x.value.toString, attr)
      }
      attr
    }

    def writesChildNodes(__obj: IPXACT2022ScalaCases.ViewRef4, __scope: scala.xml.NamespaceBinding): Seq[scala.xml.Node] =
      Seq(scala.xml.Text(__obj.value.toString))

  }

  trait DefaultIPXACT2022ScalaCases_PathSegmentsFormat extends IPXACT2022scalaxb.ElemNameParser[IPXACT2022ScalaCases.PathSegments] {
    val targetNamespace: Option[String] = Some("http://www.accellera.org/XMLSchema/IPXACT/1685-2022")
    
    def parser(node: scala.xml.Node, stack: List[IPXACT2022scalaxb.ElemName]): Parser[IPXACT2022ScalaCases.PathSegments] =
      phrase(safeRep(IPXACT2022scalaxb.ElemName(Some("http://www.accellera.org/XMLSchema/IPXACT/1685-2022"), "pathSegment")) ^^
      { case p1 =>
      IPXACT2022ScalaCases.PathSegments(p1 map { IPXACT2022scalaxb.fromXML[IPXACT2022ScalaCases.PathSegmentType](_, IPXACT2022scalaxb.ElemName(node) :: stack) }) })
    
    def writesChildNodes(__obj: IPXACT2022ScalaCases.PathSegments, __scope: scala.xml.NamespaceBinding): Seq[scala.xml.Node] =
      (__obj.pathSegment flatMap { IPXACT2022scalaxb.toXML[IPXACT2022ScalaCases.PathSegmentType](_, Some("http://www.accellera.org/XMLSchema/IPXACT/1685-2022"), Some("pathSegment"), __scope, false) })
  }
  trait DefaultIPXACT2022ScalaCases_SimpleAccessHandleFormat extends IPXACT2022scalaxb.ElemNameParser[IPXACT2022ScalaCases.SimpleAccessHandle] {
    val targetNamespace: Option[String] = Some("http://www.accellera.org/XMLSchema/IPXACT/1685-2022")
    
    override def typeName: Option[String] = Some("simpleAccessHandle")

    def parser(node: scala.xml.Node, stack: List[IPXACT2022scalaxb.ElemName]): Parser[IPXACT2022ScalaCases.SimpleAccessHandle] =
      phrase(safeRep(IPXACT2022scalaxb.ElemName(Some("http://www.accellera.org/XMLSchema/IPXACT/1685-2022"), "viewRef")) ~
      (IPXACT2022scalaxb.ElemName(Some("http://www.accellera.org/XMLSchema/IPXACT/1685-2022"), "pathSegments")) ~
      opt(IPXACT2022scalaxb.ElemName(Some("http://www.accellera.org/XMLSchema/IPXACT/1685-2022"), "vendorExtensions")) ^^
      { case p1 ~ p2 ~ p3 =>
      IPXACT2022ScalaCases.SimpleAccessHandle(p1 map { IPXACT2022scalaxb.fromXML[IPXACT2022ScalaCases.ViewRef4](_, IPXACT2022scalaxb.ElemName(node) :: stack) },
        IPXACT2022scalaxb.fromXML[IPXACT2022ScalaCases.PathSegments](p2, IPXACT2022scalaxb.ElemName(node) :: stack),
        p3.headOption map { IPXACT2022scalaxb.fromXML[IPXACT2022ScalaCases.VendorExtensions](_, IPXACT2022scalaxb.ElemName(node) :: stack) },
        scala.collection.immutable.ListMap(List(
        (node \ "@{http://www.w3.org/XML/1998/namespace}id").headOption map { x => IPXACT2022scalaxb.DataRecord(x, node, IPXACT2022scalaxb.fromXML[String](x, IPXACT2022scalaxb.ElemName(node) :: stack)) } map { "@{http://www.w3.org/XML/1998/namespace}id" -> _ }
        ).flatten[(String, IPXACT2022scalaxb.DataRecord[Any])]: _*)) })
    
    override def writesAttribute(__obj: IPXACT2022ScalaCases.SimpleAccessHandle, __scope: scala.xml.NamespaceBinding): scala.xml.MetaData = {
      var attr: scala.xml.MetaData  = scala.xml.Null
      __obj.attributes.toList map {
        case ("@{http://www.w3.org/XML/1998/namespace}id", _) => __obj.xmlid foreach { x => attr = scala.xml.Attribute(__scope.getPrefix("http://www.w3.org/XML/1998/namespace"), "id", x.toString, attr) }
        case (key, x) => attr = scala.xml.Attribute((x.namespace map { __scope.getPrefix(_) }).orNull, x.key.orNull, x.value.toString, attr)
      }
      attr
    }

    def writesChildNodes(__obj: IPXACT2022ScalaCases.SimpleAccessHandle, __scope: scala.xml.NamespaceBinding): Seq[scala.xml.Node] =
      Seq.concat(__obj.viewRef flatMap { IPXACT2022scalaxb.toXML[IPXACT2022ScalaCases.ViewRef4](_, Some("http://www.accellera.org/XMLSchema/IPXACT/1685-2022"), Some("viewRef"), __scope, false) },
        IPXACT2022scalaxb.toXML[IPXACT2022ScalaCases.PathSegments](__obj.pathSegments, Some("http://www.accellera.org/XMLSchema/IPXACT/1685-2022"), Some("pathSegments"), __scope, false),
        __obj.vendorExtensions map { IPXACT2022scalaxb.toXML[IPXACT2022ScalaCases.VendorExtensions](_, Some("http://www.accellera.org/XMLSchema/IPXACT/1685-2022"), Some("vendorExtensions"), __scope, false) } getOrElse {Nil})

  }

  trait DefaultIPXACT2022ScalaCases_SlicesTypeFormat extends IPXACT2022scalaxb.ElemNameParser[IPXACT2022ScalaCases.SlicesType] {
    val targetNamespace: Option[String] = Some("http://www.accellera.org/XMLSchema/IPXACT/1685-2022")
    
    override def typeName: Option[String] = Some("slicesType")

    def parser(node: scala.xml.Node, stack: List[IPXACT2022scalaxb.ElemName]): Parser[IPXACT2022ScalaCases.SlicesType] =
      phrase(safeRep(IPXACT2022scalaxb.ElemName(Some("http://www.accellera.org/XMLSchema/IPXACT/1685-2022"), "slice")) ^^
      { case p1 =>
      IPXACT2022ScalaCases.SlicesType(p1 map { IPXACT2022scalaxb.fromXML[IPXACT2022ScalaCases.SliceType](_, IPXACT2022scalaxb.ElemName(node) :: stack) },
        scala.collection.immutable.ListMap(List(
        (node \ "@{http://www.w3.org/XML/1998/namespace}id").headOption map { x => IPXACT2022scalaxb.DataRecord(x, node, IPXACT2022scalaxb.fromXML[String](x, IPXACT2022scalaxb.ElemName(node) :: stack)) } map { "@{http://www.w3.org/XML/1998/namespace}id" -> _ }
        ).flatten[(String, IPXACT2022scalaxb.DataRecord[Any])]: _*)) })
    
    override def writesAttribute(__obj: IPXACT2022ScalaCases.SlicesType, __scope: scala.xml.NamespaceBinding): scala.xml.MetaData = {
      var attr: scala.xml.MetaData  = scala.xml.Null
      __obj.attributes.toList map {
        case ("@{http://www.w3.org/XML/1998/namespace}id", _) => __obj.xmlid foreach { x => attr = scala.xml.Attribute(__scope.getPrefix("http://www.w3.org/XML/1998/namespace"), "id", x.toString, attr) }
        case (key, x) => attr = scala.xml.Attribute((x.namespace map { __scope.getPrefix(_) }).orNull, x.key.orNull, x.value.toString, attr)
      }
      attr
    }

    def writesChildNodes(__obj: IPXACT2022ScalaCases.SlicesType, __scope: scala.xml.NamespaceBinding): Seq[scala.xml.Node] =
      (__obj.slice flatMap { IPXACT2022scalaxb.toXML[IPXACT2022ScalaCases.SliceType](_, Some("http://www.accellera.org/XMLSchema/IPXACT/1685-2022"), Some("slice"), __scope, false) })
  }

  trait DefaultIPXACT2022ScalaCases_PathSegments2Format extends IPXACT2022scalaxb.ElemNameParser[IPXACT2022ScalaCases.PathSegments2] {
    val targetNamespace: Option[String] = Some("http://www.accellera.org/XMLSchema/IPXACT/1685-2022")
    
    def parser(node: scala.xml.Node, stack: List[IPXACT2022scalaxb.ElemName]): Parser[IPXACT2022ScalaCases.PathSegments2] =
      phrase(safeRep(IPXACT2022scalaxb.ElemName(Some("http://www.accellera.org/XMLSchema/IPXACT/1685-2022"), "pathSegment")) ^^
      { case p1 =>
      IPXACT2022ScalaCases.PathSegments2(p1 map { IPXACT2022scalaxb.fromXML[IPXACT2022ScalaCases.PathSegmentType](_, IPXACT2022scalaxb.ElemName(node) :: stack) }) })
    
    def writesChildNodes(__obj: IPXACT2022ScalaCases.PathSegments2, __scope: scala.xml.NamespaceBinding): Seq[scala.xml.Node] =
      (__obj.pathSegment flatMap { IPXACT2022scalaxb.toXML[IPXACT2022ScalaCases.PathSegmentType](_, Some("http://www.accellera.org/XMLSchema/IPXACT/1685-2022"), Some("pathSegment"), __scope, false) })
  }
  trait DefaultIPXACT2022ScalaCases_SliceTypeFormat extends IPXACT2022scalaxb.ElemNameParser[IPXACT2022ScalaCases.SliceType] {
    val targetNamespace: Option[String] = Some("http://www.accellera.org/XMLSchema/IPXACT/1685-2022")
    
    override def typeName: Option[String] = Some("sliceType")

    def parser(node: scala.xml.Node, stack: List[IPXACT2022scalaxb.ElemName]): Parser[IPXACT2022ScalaCases.SliceType] =
      phrase((IPXACT2022scalaxb.ElemName(Some("http://www.accellera.org/XMLSchema/IPXACT/1685-2022"), "pathSegments")) ~
      opt(IPXACT2022scalaxb.ElemName(Some("http://www.accellera.org/XMLSchema/IPXACT/1685-2022"), "range")) ^^
      { case p1 ~ p2 =>
      IPXACT2022ScalaCases.SliceType(IPXACT2022scalaxb.fromXML[IPXACT2022ScalaCases.PathSegments2](p1, IPXACT2022scalaxb.ElemName(node) :: stack),
        p2.headOption map { IPXACT2022scalaxb.fromXML[IPXACT2022ScalaCases.RangeType](_, IPXACT2022scalaxb.ElemName(node) :: stack) },
        scala.collection.immutable.ListMap(List(
        (node \ "@{http://www.w3.org/XML/1998/namespace}id").headOption map { x => IPXACT2022scalaxb.DataRecord(x, node, IPXACT2022scalaxb.fromXML[String](x, IPXACT2022scalaxb.ElemName(node) :: stack)) } map { "@{http://www.w3.org/XML/1998/namespace}id" -> _ }
        ).flatten[(String, IPXACT2022scalaxb.DataRecord[Any])]: _*)) })
    
    override def writesAttribute(__obj: IPXACT2022ScalaCases.SliceType, __scope: scala.xml.NamespaceBinding): scala.xml.MetaData = {
      var attr: scala.xml.MetaData  = scala.xml.Null
      __obj.attributes.toList map {
        case ("@{http://www.w3.org/XML/1998/namespace}id", _) => __obj.xmlid foreach { x => attr = scala.xml.Attribute(__scope.getPrefix("http://www.w3.org/XML/1998/namespace"), "id", x.toString, attr) }
        case (key, x) => attr = scala.xml.Attribute((x.namespace map { __scope.getPrefix(_) }).orNull, x.key.orNull, x.value.toString, attr)
      }
      attr
    }

    def writesChildNodes(__obj: IPXACT2022ScalaCases.SliceType, __scope: scala.xml.NamespaceBinding): Seq[scala.xml.Node] =
      Seq.concat(IPXACT2022scalaxb.toXML[IPXACT2022ScalaCases.PathSegments2](__obj.pathSegments, Some("http://www.accellera.org/XMLSchema/IPXACT/1685-2022"), Some("pathSegments"), __scope, false),
        __obj.range map { IPXACT2022scalaxb.toXML[IPXACT2022ScalaCases.RangeType](_, Some("http://www.accellera.org/XMLSchema/IPXACT/1685-2022"), Some("range"), __scope, false) } getOrElse {Nil})

  }

  trait DefaultIPXACT2022ScalaCases_PathSegmentTypeFormat extends IPXACT2022scalaxb.XMLFormat[IPXACT2022ScalaCases.PathSegmentType] with IPXACT2022scalaxb.CanWriteChildNodes[IPXACT2022ScalaCases.PathSegmentType] {
    val targetNamespace: Option[String] = Some("http://www.accellera.org/XMLSchema/IPXACT/1685-2022")
    def reads(seq: scala.xml.NodeSeq, stack: List[IPXACT2022scalaxb.ElemName]): Either[String, IPXACT2022ScalaCases.PathSegmentType] = seq match {
      case node: scala.xml.Node => Right(IPXACT2022ScalaCases.PathSegmentType(IPXACT2022scalaxb.fromXML[String](node, IPXACT2022scalaxb.ElemName(node) :: stack),
        scala.collection.immutable.ListMap(List(
        (node \ "@{http://www.w3.org/XML/1998/namespace}id").headOption map { x => IPXACT2022scalaxb.DataRecord(x, node, IPXACT2022scalaxb.fromXML[String](x, IPXACT2022scalaxb.ElemName(node) :: stack)) } map { "@{http://www.w3.org/XML/1998/namespace}id" -> _ }
        ).flatten[(String, IPXACT2022scalaxb.DataRecord[Any])] ::: (node match {
          case elem: scala.xml.Elem =>
            elem.attributes.toList flatMap {
              case scala.xml.PrefixedAttribute(pre, key, value, _) if pre == elem.scope.getPrefix("http://www.w3.org/XML/1998/namespace") &&
                key == "id" => Nil
              case scala.xml.UnprefixedAttribute(key, value, _) =>
                List(("@" + key, IPXACT2022scalaxb.DataRecord(None, Some(key), value.text)))
              case scala.xml.PrefixedAttribute(pre, key, value, _) =>
                val ns = elem.scope.getURI(pre)
                List(("@{" + ns + "}" + key, IPXACT2022scalaxb.DataRecord(Option[String](ns), Some(key), value.text)))
              case _ => Nil
            }
          case _ => Nil
        }): _*)))
      case _ => Left("reads failed: seq must be scala.xml.Node")
    }
    
    override def writesAttribute(__obj: IPXACT2022ScalaCases.PathSegmentType, __scope: scala.xml.NamespaceBinding): scala.xml.MetaData = {
      var attr: scala.xml.MetaData  = scala.xml.Null
      __obj.attributes.toList map {
        case ("@{http://www.w3.org/XML/1998/namespace}id", _) => __obj.xmlid foreach { x => attr = scala.xml.Attribute(__scope.getPrefix("http://www.w3.org/XML/1998/namespace"), "id", x.toString, attr) }
        case (key, x) => attr = scala.xml.Attribute((x.namespace map { __scope.getPrefix(_) }).orNull, x.key.orNull, x.value.toString, attr)
      }
      attr
    }

    def writesChildNodes(__obj: IPXACT2022ScalaCases.PathSegmentType, __scope: scala.xml.NamespaceBinding): Seq[scala.xml.Node] =
      Seq(scala.xml.Text(__obj.value.toString))

  }

  trait DefaultIPXACT2022ScalaCases_PortSlicesTypeFormat extends IPXACT2022scalaxb.ElemNameParser[IPXACT2022ScalaCases.PortSlicesType] {
    val targetNamespace: Option[String] = Some("http://www.accellera.org/XMLSchema/IPXACT/1685-2022")
    
    override def typeName: Option[String] = Some("portSlicesType")

    def parser(node: scala.xml.Node, stack: List[IPXACT2022scalaxb.ElemName]): Parser[IPXACT2022ScalaCases.PortSlicesType] =
      phrase(safeRep(IPXACT2022scalaxb.ElemName(Some("http://www.accellera.org/XMLSchema/IPXACT/1685-2022"), "slice")) ^^
      { case p1 =>
      IPXACT2022ScalaCases.PortSlicesType(p1 map { IPXACT2022scalaxb.fromXML[IPXACT2022ScalaCases.PortSliceType](_, IPXACT2022scalaxb.ElemName(node) :: stack) }) })
    
    def writesChildNodes(__obj: IPXACT2022ScalaCases.PortSlicesType, __scope: scala.xml.NamespaceBinding): Seq[scala.xml.Node] =
      (__obj.slice flatMap { IPXACT2022scalaxb.toXML[IPXACT2022ScalaCases.PortSliceType](_, Some("http://www.accellera.org/XMLSchema/IPXACT/1685-2022"), Some("slice"), __scope, false) })
  }

  trait DefaultIPXACT2022ScalaCases_PathSegments3Format extends IPXACT2022scalaxb.ElemNameParser[IPXACT2022ScalaCases.PathSegments3] {
    val targetNamespace: Option[String] = Some("http://www.accellera.org/XMLSchema/IPXACT/1685-2022")
    
    def parser(node: scala.xml.Node, stack: List[IPXACT2022scalaxb.ElemName]): Parser[IPXACT2022ScalaCases.PathSegments3] =
      phrase(safeRep(IPXACT2022scalaxb.ElemName(Some("http://www.accellera.org/XMLSchema/IPXACT/1685-2022"), "pathSegment")) ^^
      { case p1 =>
      IPXACT2022ScalaCases.PathSegments3(p1 map { IPXACT2022scalaxb.fromXML[IPXACT2022ScalaCases.PortPathSegmentType](_, IPXACT2022scalaxb.ElemName(node) :: stack) }) })
    
    def writesChildNodes(__obj: IPXACT2022ScalaCases.PathSegments3, __scope: scala.xml.NamespaceBinding): Seq[scala.xml.Node] =
      (__obj.pathSegment flatMap { IPXACT2022scalaxb.toXML[IPXACT2022ScalaCases.PortPathSegmentType](_, Some("http://www.accellera.org/XMLSchema/IPXACT/1685-2022"), Some("pathSegment"), __scope, false) })
  }
  trait DefaultIPXACT2022ScalaCases_PortSliceTypeFormat extends IPXACT2022scalaxb.ElemNameParser[IPXACT2022ScalaCases.PortSliceType] {
    val targetNamespace: Option[String] = Some("http://www.accellera.org/XMLSchema/IPXACT/1685-2022")
    
    override def typeName: Option[String] = Some("portSliceType")

    def parser(node: scala.xml.Node, stack: List[IPXACT2022scalaxb.ElemName]): Parser[IPXACT2022ScalaCases.PortSliceType] =
      phrase((IPXACT2022scalaxb.ElemName(Some("http://www.accellera.org/XMLSchema/IPXACT/1685-2022"), "pathSegments")) ~
      opt(IPXACT2022scalaxb.ElemName(Some("http://www.accellera.org/XMLSchema/IPXACT/1685-2022"), "range")) ^^
      { case p1 ~ p2 =>
      IPXACT2022ScalaCases.PortSliceType(IPXACT2022scalaxb.fromXML[IPXACT2022ScalaCases.PathSegments3](p1, IPXACT2022scalaxb.ElemName(node) :: stack),
        p2.headOption map { IPXACT2022scalaxb.fromXML[IPXACT2022ScalaCases.RangeType](_, IPXACT2022scalaxb.ElemName(node) :: stack) },
        scala.collection.immutable.ListMap(List(
        (node \ "@{http://www.w3.org/XML/1998/namespace}id").headOption map { x => IPXACT2022scalaxb.DataRecord(x, node, IPXACT2022scalaxb.fromXML[String](x, IPXACT2022scalaxb.ElemName(node) :: stack)) } map { "@{http://www.w3.org/XML/1998/namespace}id" -> _ }
        ).flatten[(String, IPXACT2022scalaxb.DataRecord[Any])]: _*)) })
    
    override def writesAttribute(__obj: IPXACT2022ScalaCases.PortSliceType, __scope: scala.xml.NamespaceBinding): scala.xml.MetaData = {
      var attr: scala.xml.MetaData  = scala.xml.Null
      __obj.attributes.toList map {
        case ("@{http://www.w3.org/XML/1998/namespace}id", _) => __obj.xmlid foreach { x => attr = scala.xml.Attribute(__scope.getPrefix("http://www.w3.org/XML/1998/namespace"), "id", x.toString, attr) }
        case (key, x) => attr = scala.xml.Attribute((x.namespace map { __scope.getPrefix(_) }).orNull, x.key.orNull, x.value.toString, attr)
      }
      attr
    }

    def writesChildNodes(__obj: IPXACT2022ScalaCases.PortSliceType, __scope: scala.xml.NamespaceBinding): Seq[scala.xml.Node] =
      Seq.concat(IPXACT2022scalaxb.toXML[IPXACT2022ScalaCases.PathSegments3](__obj.pathSegments, Some("http://www.accellera.org/XMLSchema/IPXACT/1685-2022"), Some("pathSegments"), __scope, false),
        __obj.range map { IPXACT2022scalaxb.toXML[IPXACT2022ScalaCases.RangeType](_, Some("http://www.accellera.org/XMLSchema/IPXACT/1685-2022"), Some("range"), __scope, false) } getOrElse {Nil})

  }

  trait DefaultIPXACT2022ScalaCases_PortPathSegmentTypeFormat extends IPXACT2022scalaxb.XMLFormat[IPXACT2022ScalaCases.PortPathSegmentType] with IPXACT2022scalaxb.CanWriteChildNodes[IPXACT2022ScalaCases.PortPathSegmentType] {
    val targetNamespace: Option[String] = Some("http://www.accellera.org/XMLSchema/IPXACT/1685-2022")
    def reads(seq: scala.xml.NodeSeq, stack: List[IPXACT2022scalaxb.ElemName]): Either[String, IPXACT2022ScalaCases.PortPathSegmentType] = seq match {
      case node: scala.xml.Node => Right(IPXACT2022ScalaCases.PortPathSegmentType(IPXACT2022scalaxb.fromXML[String](node, IPXACT2022scalaxb.ElemName(node) :: stack),
        scala.collection.immutable.ListMap(List(
        (node \ "@{http://www.w3.org/XML/1998/namespace}id").headOption map { x => IPXACT2022scalaxb.DataRecord(x, node, IPXACT2022scalaxb.fromXML[String](x, IPXACT2022scalaxb.ElemName(node) :: stack)) } map { "@{http://www.w3.org/XML/1998/namespace}id" -> _ }
        ).flatten[(String, IPXACT2022scalaxb.DataRecord[Any])] ::: (node match {
          case elem: scala.xml.Elem =>
            elem.attributes.toList flatMap {
              case scala.xml.PrefixedAttribute(pre, key, value, _) if pre == elem.scope.getPrefix("http://www.w3.org/XML/1998/namespace") &&
                key == "id" => Nil
              case scala.xml.UnprefixedAttribute(key, value, _) =>
                List(("@" + key, IPXACT2022scalaxb.DataRecord(None, Some(key), value.text)))
              case scala.xml.PrefixedAttribute(pre, key, value, _) =>
                val ns = elem.scope.getURI(pre)
                List(("@{" + ns + "}" + key, IPXACT2022scalaxb.DataRecord(Option[String](ns), Some(key), value.text)))
              case _ => Nil
            }
          case _ => Nil
        }): _*)))
      case _ => Left("reads failed: seq must be scala.xml.Node")
    }
    
    override def writesAttribute(__obj: IPXACT2022ScalaCases.PortPathSegmentType, __scope: scala.xml.NamespaceBinding): scala.xml.MetaData = {
      var attr: scala.xml.MetaData  = scala.xml.Null
      __obj.attributes.toList map {
        case ("@{http://www.w3.org/XML/1998/namespace}id", _) => __obj.xmlid foreach { x => attr = scala.xml.Attribute(__scope.getPrefix("http://www.w3.org/XML/1998/namespace"), "id", x.toString, attr) }
        case (key, x) => attr = scala.xml.Attribute((x.namespace map { __scope.getPrefix(_) }).orNull, x.key.orNull, x.value.toString, attr)
      }
      attr
    }

    def writesChildNodes(__obj: IPXACT2022ScalaCases.PortPathSegmentType, __scope: scala.xml.NamespaceBinding): Seq[scala.xml.Node] =
      Seq(scala.xml.Text(__obj.value.toString))

  }

  trait DefaultIPXACT2022ScalaCases_ParameterTypeFormat extends IPXACT2022scalaxb.ElemNameParser[IPXACT2022ScalaCases.ParameterType] with IPXACT2022ScalaCases_NameGroupStringGroupFormat {
    val targetNamespace: Option[String] = Some("http://www.accellera.org/XMLSchema/IPXACT/1685-2022")
    
    override def typeName: Option[String] = Some("parameterType")

    def parser(node: scala.xml.Node, stack: List[IPXACT2022scalaxb.ElemName]): Parser[IPXACT2022ScalaCases.ParameterType] =
      phrase((parseNameGroupStringGroup(node, IPXACT2022scalaxb.ElemName(node) :: stack)) ~
      opt(IPXACT2022scalaxb.ElemName(Some("http://www.accellera.org/XMLSchema/IPXACT/1685-2022"), "vectors")) ~
      opt(IPXACT2022scalaxb.ElemName(Some("http://www.accellera.org/XMLSchema/IPXACT/1685-2022"), "arrays")) ~
      (IPXACT2022scalaxb.ElemName(Some("http://www.accellera.org/XMLSchema/IPXACT/1685-2022"), "value")) ~
      opt(IPXACT2022scalaxb.ElemName(Some("http://www.accellera.org/XMLSchema/IPXACT/1685-2022"), "vendorExtensions")) ^^
      { case p1 ~ p2 ~ p3 ~ p4 ~ p5 =>
      IPXACT2022ScalaCases.ParameterType(p1,
        p2.headOption map { IPXACT2022scalaxb.fromXML[IPXACT2022ScalaCases.Vectors2](_, IPXACT2022scalaxb.ElemName(node) :: stack) },
        p3.headOption map { IPXACT2022scalaxb.fromXML[IPXACT2022ScalaCases.ConfigurableArrays](_, IPXACT2022scalaxb.ElemName(node) :: stack) },
        IPXACT2022scalaxb.fromXML[IPXACT2022ScalaCases.StringExpressionable](p4, IPXACT2022scalaxb.ElemName(node) :: stack),
        p5.headOption map { IPXACT2022scalaxb.fromXML[IPXACT2022ScalaCases.VendorExtensions](_, IPXACT2022scalaxb.ElemName(node) :: stack) },
        scala.collection.immutable.ListMap(List(
        (node \ "@{http://www.w3.org/XML/1998/namespace}id").headOption map { x => IPXACT2022scalaxb.DataRecord(x, node, IPXACT2022scalaxb.fromXML[String](x, IPXACT2022scalaxb.ElemName(node) :: stack)) } map { "@{http://www.w3.org/XML/1998/namespace}id" -> _ },
        (node \ "@parameterId").headOption map { x => IPXACT2022scalaxb.DataRecord(x, node, IPXACT2022scalaxb.fromXML[String](x, IPXACT2022scalaxb.ElemName(node) :: stack)) } map { "@parameterId" -> _ },
        (node \ "@prompt").headOption map { x => IPXACT2022scalaxb.DataRecord(x, node, IPXACT2022scalaxb.fromXML[String](x, IPXACT2022scalaxb.ElemName(node) :: stack)) } map { "@prompt" -> _ },
        (node \ "@choiceRef").headOption map { x => IPXACT2022scalaxb.DataRecord(x, node, IPXACT2022scalaxb.fromXML[String](x, IPXACT2022scalaxb.ElemName(node) :: stack)) } map { "@choiceRef" -> _ },
        (node \ "@order").headOption map { x => IPXACT2022scalaxb.DataRecord(x, node, IPXACT2022scalaxb.fromXML[Float](x, IPXACT2022scalaxb.ElemName(node) :: stack)) } map { "@order" -> _ },
        (node \ "@configGroups").headOption map { x => IPXACT2022scalaxb.DataRecord(x, node, IPXACT2022scalaxb.fromXML[Seq[String]](x, IPXACT2022scalaxb.ElemName(node) :: stack)) } map { "@configGroups" -> _ },
        (node \ "@minimum").headOption map { x => IPXACT2022scalaxb.DataRecord(x, node, IPXACT2022scalaxb.fromXML[String](x, IPXACT2022scalaxb.ElemName(node) :: stack)) } map { "@minimum" -> _ },
        (node \ "@maximum").headOption map { x => IPXACT2022scalaxb.DataRecord(x, node, IPXACT2022scalaxb.fromXML[String](x, IPXACT2022scalaxb.ElemName(node) :: stack)) } map { "@maximum" -> _ },
        (node \ "@type").headOption map { x => IPXACT2022scalaxb.DataRecord(x, node, IPXACT2022scalaxb.fromXML[IPXACT2022ScalaCases.FormatType](x, IPXACT2022scalaxb.ElemName(node) :: stack)) } orElse Some(IPXACT2022scalaxb.DataRecord(None, None, IPXACT2022scalaxb.fromXML[IPXACT2022ScalaCases.FormatType](scala.xml.Text("string"), IPXACT2022scalaxb.ElemName(node) :: stack))) map { "@type" -> _ },
        (node \ "@sign").headOption map { x => IPXACT2022scalaxb.DataRecord(x, node, IPXACT2022scalaxb.fromXML[IPXACT2022ScalaCases.SignType](x, IPXACT2022scalaxb.ElemName(node) :: stack)) } map { "@sign" -> _ },
        (node \ "@prefix").headOption map { x => IPXACT2022scalaxb.DataRecord(x, node, IPXACT2022scalaxb.fromXML[IPXACT2022ScalaCases.Prefix](x, IPXACT2022scalaxb.ElemName(node) :: stack)) } map { "@prefix" -> _ },
        (node \ "@unit").headOption map { x => IPXACT2022scalaxb.DataRecord(x, node, IPXACT2022scalaxb.fromXML[IPXACT2022ScalaCases.UnitType](x, IPXACT2022scalaxb.ElemName(node) :: stack)) } map { "@unit" -> _ },
        (node \ "@resolve").headOption map { x => IPXACT2022scalaxb.DataRecord(x, node, IPXACT2022scalaxb.fromXML[IPXACT2022ScalaCases.Resolve](x, IPXACT2022scalaxb.ElemName(node) :: stack)) } orElse Some(IPXACT2022scalaxb.DataRecord(None, None, IPXACT2022scalaxb.fromXML[IPXACT2022ScalaCases.Resolve](scala.xml.Text("immediate"), IPXACT2022scalaxb.ElemName(node) :: stack))) map { "@resolve" -> _ }
        ).flatten[(String, IPXACT2022scalaxb.DataRecord[Any])] ::: (node match {
          case elem: scala.xml.Elem =>
            elem.attributes.toList flatMap {
              case scala.xml.PrefixedAttribute(pre, key, value, _) if pre == elem.scope.getPrefix("http://www.w3.org/XML/1998/namespace") &&
                key == "id" => Nil
              case scala.xml.UnprefixedAttribute(key, value, _) if key == "parameterId" => Nil
              case scala.xml.UnprefixedAttribute(key, value, _) if key == "prompt" => Nil
              case scala.xml.UnprefixedAttribute(key, value, _) if key == "choiceRef" => Nil
              case scala.xml.UnprefixedAttribute(key, value, _) if key == "order" => Nil
              case scala.xml.UnprefixedAttribute(key, value, _) if key == "configGroups" => Nil
              case scala.xml.UnprefixedAttribute(key, value, _) if key == "minimum" => Nil
              case scala.xml.UnprefixedAttribute(key, value, _) if key == "maximum" => Nil
              case scala.xml.UnprefixedAttribute(key, value, _) if key == "type" => Nil
              case scala.xml.UnprefixedAttribute(key, value, _) if key == "sign" => Nil
              case scala.xml.UnprefixedAttribute(key, value, _) if key == "prefix" => Nil
              case scala.xml.UnprefixedAttribute(key, value, _) if key == "unit" => Nil
              case scala.xml.UnprefixedAttribute(key, value, _) if key == "resolve" => Nil
              case scala.xml.UnprefixedAttribute(key, value, _) =>
                List(("@" + key, IPXACT2022scalaxb.DataRecord(None, Some(key), value.text)))
              case scala.xml.PrefixedAttribute(pre, key, value, _) =>
                val ns = elem.scope.getURI(pre)
                List(("@{" + ns + "}" + key, IPXACT2022scalaxb.DataRecord(Option[String](ns), Some(key), value.text)))
              case _ => Nil
            }
          case _ => Nil
        }): _*)) })
    
    override def writesAttribute(__obj: IPXACT2022ScalaCases.ParameterType, __scope: scala.xml.NamespaceBinding): scala.xml.MetaData = {
      var attr: scala.xml.MetaData  = scala.xml.Null
      __obj.attributes.toList map {
        case ("@{http://www.w3.org/XML/1998/namespace}id", _) => __obj.xmlid foreach { x => attr = scala.xml.Attribute(__scope.getPrefix("http://www.w3.org/XML/1998/namespace"), "id", x.toString, attr) }
        case ("@parameterId", _) => __obj.parameterId foreach { x => attr = scala.xml.Attribute(null, "parameterId", x.toString, attr) }
        case ("@prompt", _) => __obj.prompt foreach { x => attr = scala.xml.Attribute(null, "prompt", x.toString, attr) }
        case ("@choiceRef", _) => __obj.choiceRef foreach { x => attr = scala.xml.Attribute(null, "choiceRef", x.toString, attr) }
        case ("@order", _) => __obj.order foreach { x => attr = scala.xml.Attribute(null, "order", x.toString, attr) }
        case ("@configGroups", _) => __obj.configGroups foreach { x => attr = scala.xml.Attribute(null, "configGroups", x.toString, attr) }
        case ("@minimum", _) => __obj.minimum foreach { x => attr = scala.xml.Attribute(null, "minimum", x.toString, attr) }
        case ("@maximum", _) => __obj.maximum foreach { x => attr = scala.xml.Attribute(null, "maximum", x.toString, attr) }
        case ("@type", _) => if (__obj.typeValue.toString != "string") attr = scala.xml.Attribute(null, "type", __obj.typeValue.toString, attr)
        case ("@sign", _) => __obj.sign foreach { x => attr = scala.xml.Attribute(null, "sign", x.toString, attr) }
        case ("@prefix", _) => __obj.prefix foreach { x => attr = scala.xml.Attribute(null, "prefix", x.toString, attr) }
        case ("@unit", _) => __obj.unit foreach { x => attr = scala.xml.Attribute(null, "unit", x.toString, attr) }
        case ("@resolve", _) => if (__obj.resolve.toString != "immediate") attr = scala.xml.Attribute(null, "resolve", __obj.resolve.toString, attr)
        case (key, x) => attr = scala.xml.Attribute((x.namespace map { __scope.getPrefix(_) }).orNull, x.key.orNull, x.value.toString, attr)
      }
      attr
    }

    def writesChildNodes(__obj: IPXACT2022ScalaCases.ParameterType, __scope: scala.xml.NamespaceBinding): Seq[scala.xml.Node] =
      Seq.concat(IPXACT2022scalaxb.toXML[IPXACT2022ScalaCases.NameGroupStringSequence](__obj.nameGroupStringSequence1, None, Some("nameGroupStringSequence1"), __scope, false),
        __obj.vectors map { IPXACT2022scalaxb.toXML[IPXACT2022ScalaCases.Vectors2](_, Some("http://www.accellera.org/XMLSchema/IPXACT/1685-2022"), Some("vectors"), __scope, false) } getOrElse {Nil},
        __obj.arrays map { IPXACT2022scalaxb.toXML[IPXACT2022ScalaCases.ConfigurableArrays](_, Some("http://www.accellera.org/XMLSchema/IPXACT/1685-2022"), Some("arrays"), __scope, false) } getOrElse {Nil},
        IPXACT2022scalaxb.toXML[IPXACT2022ScalaCases.StringExpressionable](__obj.value, Some("http://www.accellera.org/XMLSchema/IPXACT/1685-2022"), Some("value"), __scope, false),
        __obj.vendorExtensions map { IPXACT2022scalaxb.toXML[IPXACT2022ScalaCases.VendorExtensions](_, Some("http://www.accellera.org/XMLSchema/IPXACT/1685-2022"), Some("vendorExtensions"), __scope, false) } getOrElse {Nil})

  }

  def buildIPXACT2022ScalaCases_UsageTypeTypeFormat = new DefaultIPXACT2022ScalaCases_UsageTypeTypeFormat {}
  trait DefaultIPXACT2022ScalaCases_UsageTypeTypeFormat extends IPXACT2022scalaxb.XMLFormat[IPXACT2022ScalaCases.UsageTypeType] {
    val targetNamespace: Option[String] = Some("http://www.accellera.org/XMLSchema/IPXACT/1685-2022")
    
    def fromString(value: String, scope: scala.xml.NamespaceBinding): IPXACT2022ScalaCases.UsageTypeType =
        (fromString0(value, scope)).apply(IPXACT2022scalaxb.fromXML[String](scala.xml.Text(value)))

    private def fromString0(value: String, scope: scala.xml.NamespaceBinding): PartialFunction[Any, IPXACT2022ScalaCases.UsageTypeType] = {
      case x: String if x == IPXACT2022scalaxb.fromXML[String](scala.xml.Text("nontyped")) => IPXACT2022ScalaCases.Nontyped
      case x: String if x == IPXACT2022scalaxb.fromXML[String](scala.xml.Text("typed")) => IPXACT2022ScalaCases.Typed
      case x: String if x == IPXACT2022scalaxb.fromXML[String](scala.xml.Text("runtime")) => IPXACT2022ScalaCases.Runtime

    }



    def reads(seq: scala.xml.NodeSeq, stack: List[IPXACT2022scalaxb.ElemName]): Either[String, IPXACT2022ScalaCases.UsageTypeType] = seq match {
      case elem: scala.xml.Elem => Right(fromString(elem.text, elem.scope))
      case _ => Right(fromString(seq.text, scala.xml.TopScope))
    }
    
    def writes(__obj: IPXACT2022ScalaCases.UsageTypeType, __namespace: Option[String], __elementLabel: Option[String],
        __scope: scala.xml.NamespaceBinding, __typeAttribute: Boolean): scala.xml.NodeSeq =
      scala.xml.Elem(IPXACT2022scalaxb.Helper.getPrefix(__namespace, __scope).orNull,
        __elementLabel getOrElse { sys.error("missing element label.") },
        scala.xml.Null, __scope, true, scala.xml.Text(__obj.toString))
  }
  trait DefaultIPXACT2022ScalaCases_VectorFormat extends IPXACT2022scalaxb.ElemNameParser[IPXACT2022ScalaCases.Vector] {
    val targetNamespace: Option[String] = Some("http://www.accellera.org/XMLSchema/IPXACT/1685-2022")
    
    def parser(node: scala.xml.Node, stack: List[IPXACT2022scalaxb.ElemName]): Parser[IPXACT2022ScalaCases.Vector] =
      phrase((IPXACT2022scalaxb.ElemName(Some("http://www.accellera.org/XMLSchema/IPXACT/1685-2022"), "left")) ~
      (IPXACT2022scalaxb.ElemName(Some("http://www.accellera.org/XMLSchema/IPXACT/1685-2022"), "right")) ^^
      { case p1 ~ p2 =>
      IPXACT2022ScalaCases.Vector(IPXACT2022scalaxb.fromXML[IPXACT2022ScalaCases.UnsignedIntExpressionable](p1, IPXACT2022scalaxb.ElemName(node) :: stack),
        IPXACT2022scalaxb.fromXML[IPXACT2022ScalaCases.UnsignedIntExpressionable](p2, IPXACT2022scalaxb.ElemName(node) :: stack),
        scala.collection.immutable.ListMap(List(
        (node \ "@vectorId").headOption map { x => IPXACT2022scalaxb.DataRecord(x, node, IPXACT2022scalaxb.fromXML[String](x, IPXACT2022scalaxb.ElemName(node) :: stack)) } map { "@vectorId" -> _ },
        (node \ "@{http://www.w3.org/XML/1998/namespace}id").headOption map { x => IPXACT2022scalaxb.DataRecord(x, node, IPXACT2022scalaxb.fromXML[String](x, IPXACT2022scalaxb.ElemName(node) :: stack)) } map { "@{http://www.w3.org/XML/1998/namespace}id" -> _ }
        ).flatten[(String, IPXACT2022scalaxb.DataRecord[Any])]: _*)) })
    
    override def writesAttribute(__obj: IPXACT2022ScalaCases.Vector, __scope: scala.xml.NamespaceBinding): scala.xml.MetaData = {
      var attr: scala.xml.MetaData  = scala.xml.Null
      __obj.attributes.toList map {
        case ("@vectorId", _) => __obj.vectorId foreach { x => attr = scala.xml.Attribute(null, "vectorId", x.toString, attr) }
        case ("@{http://www.w3.org/XML/1998/namespace}id", _) => __obj.xmlid foreach { x => attr = scala.xml.Attribute(__scope.getPrefix("http://www.w3.org/XML/1998/namespace"), "id", x.toString, attr) }
        case (key, x) => attr = scala.xml.Attribute((x.namespace map { __scope.getPrefix(_) }).orNull, x.key.orNull, x.value.toString, attr)
      }
      attr
    }

    def writesChildNodes(__obj: IPXACT2022ScalaCases.Vector, __scope: scala.xml.NamespaceBinding): Seq[scala.xml.Node] =
      Seq.concat(IPXACT2022scalaxb.toXML[IPXACT2022ScalaCases.UnsignedIntExpressionable](__obj.left, Some("http://www.accellera.org/XMLSchema/IPXACT/1685-2022"), Some("left"), __scope, false),
        IPXACT2022scalaxb.toXML[IPXACT2022ScalaCases.UnsignedIntExpressionable](__obj.right, Some("http://www.accellera.org/XMLSchema/IPXACT/1685-2022"), Some("right"), __scope, false))

  }

  trait DefaultIPXACT2022ScalaCases_VectorsFormat extends IPXACT2022scalaxb.ElemNameParser[IPXACT2022ScalaCases.Vectors] {
    val targetNamespace: Option[String] = Some("http://www.accellera.org/XMLSchema/IPXACT/1685-2022")
    
    def parser(node: scala.xml.Node, stack: List[IPXACT2022scalaxb.ElemName]): Parser[IPXACT2022ScalaCases.Vectors] =
      phrase(safeRep(IPXACT2022scalaxb.ElemName(Some("http://www.accellera.org/XMLSchema/IPXACT/1685-2022"), "vector")) ^^
      { case p1 =>
      IPXACT2022ScalaCases.Vectors(p1 map { IPXACT2022scalaxb.fromXML[IPXACT2022ScalaCases.Vector](_, IPXACT2022scalaxb.ElemName(node) :: stack) }) })
    
    def writesChildNodes(__obj: IPXACT2022ScalaCases.Vectors, __scope: scala.xml.NamespaceBinding): Seq[scala.xml.Node] =
      (__obj.vector flatMap { IPXACT2022scalaxb.toXML[IPXACT2022ScalaCases.Vector](_, Some("http://www.accellera.org/XMLSchema/IPXACT/1685-2022"), Some("vector"), __scope, false) })
  }
  trait DefaultIPXACT2022ScalaCases_ModuleParameterTypeFormat extends IPXACT2022scalaxb.ElemNameParser[IPXACT2022ScalaCases.ModuleParameterType] with IPXACT2022ScalaCases_NameGroupStringGroupFormat {
    val targetNamespace: Option[String] = Some("http://www.accellera.org/XMLSchema/IPXACT/1685-2022")
    
    override def typeName: Option[String] = Some("moduleParameterType")

    def parser(node: scala.xml.Node, stack: List[IPXACT2022scalaxb.ElemName]): Parser[IPXACT2022ScalaCases.ModuleParameterType] =
      phrase((parseNameGroupStringGroup(node, IPXACT2022scalaxb.ElemName(node) :: stack)) ~
      opt(IPXACT2022scalaxb.ElemName(Some("http://www.accellera.org/XMLSchema/IPXACT/1685-2022"), "vectors")) ~
      opt(IPXACT2022scalaxb.ElemName(Some("http://www.accellera.org/XMLSchema/IPXACT/1685-2022"), "arrays")) ~
      (IPXACT2022scalaxb.ElemName(Some("http://www.accellera.org/XMLSchema/IPXACT/1685-2022"), "value")) ~
      opt(IPXACT2022scalaxb.ElemName(Some("http://www.accellera.org/XMLSchema/IPXACT/1685-2022"), "vendorExtensions")) ^^
      { case p1 ~ p2 ~ p3 ~ p4 ~ p5 =>
      IPXACT2022ScalaCases.ModuleParameterType(p1,
        p2.headOption map { IPXACT2022scalaxb.fromXML[IPXACT2022ScalaCases.Vectors](_, IPXACT2022scalaxb.ElemName(node) :: stack) },
        p3.headOption map { IPXACT2022scalaxb.fromXML[IPXACT2022ScalaCases.ModuleParameterArrays](_, IPXACT2022scalaxb.ElemName(node) :: stack) },
        IPXACT2022scalaxb.fromXML[IPXACT2022ScalaCases.StringExpressionable](p4, IPXACT2022scalaxb.ElemName(node) :: stack),
        p5.headOption map { IPXACT2022scalaxb.fromXML[IPXACT2022ScalaCases.VendorExtensions](_, IPXACT2022scalaxb.ElemName(node) :: stack) },
        scala.collection.immutable.ListMap(List(
        (node \ "@{http://www.w3.org/XML/1998/namespace}id").headOption map { x => IPXACT2022scalaxb.DataRecord(x, node, IPXACT2022scalaxb.fromXML[String](x, IPXACT2022scalaxb.ElemName(node) :: stack)) } map { "@{http://www.w3.org/XML/1998/namespace}id" -> _ },
        (node \ "@parameterId").headOption map { x => IPXACT2022scalaxb.DataRecord(x, node, IPXACT2022scalaxb.fromXML[String](x, IPXACT2022scalaxb.ElemName(node) :: stack)) } map { "@parameterId" -> _ },
        (node \ "@prompt").headOption map { x => IPXACT2022scalaxb.DataRecord(x, node, IPXACT2022scalaxb.fromXML[String](x, IPXACT2022scalaxb.ElemName(node) :: stack)) } map { "@prompt" -> _ },
        (node \ "@choiceRef").headOption map { x => IPXACT2022scalaxb.DataRecord(x, node, IPXACT2022scalaxb.fromXML[String](x, IPXACT2022scalaxb.ElemName(node) :: stack)) } map { "@choiceRef" -> _ },
        (node \ "@order").headOption map { x => IPXACT2022scalaxb.DataRecord(x, node, IPXACT2022scalaxb.fromXML[Float](x, IPXACT2022scalaxb.ElemName(node) :: stack)) } map { "@order" -> _ },
        (node \ "@configGroups").headOption map { x => IPXACT2022scalaxb.DataRecord(x, node, IPXACT2022scalaxb.fromXML[Seq[String]](x, IPXACT2022scalaxb.ElemName(node) :: stack)) } map { "@configGroups" -> _ },
        (node \ "@minimum").headOption map { x => IPXACT2022scalaxb.DataRecord(x, node, IPXACT2022scalaxb.fromXML[String](x, IPXACT2022scalaxb.ElemName(node) :: stack)) } map { "@minimum" -> _ },
        (node \ "@maximum").headOption map { x => IPXACT2022scalaxb.DataRecord(x, node, IPXACT2022scalaxb.fromXML[String](x, IPXACT2022scalaxb.ElemName(node) :: stack)) } map { "@maximum" -> _ },
        (node \ "@type").headOption map { x => IPXACT2022scalaxb.DataRecord(x, node, IPXACT2022scalaxb.fromXML[IPXACT2022ScalaCases.FormatType](x, IPXACT2022scalaxb.ElemName(node) :: stack)) } orElse Some(IPXACT2022scalaxb.DataRecord(None, None, IPXACT2022scalaxb.fromXML[IPXACT2022ScalaCases.FormatType](scala.xml.Text("string"), IPXACT2022scalaxb.ElemName(node) :: stack))) map { "@type" -> _ },
        (node \ "@sign").headOption map { x => IPXACT2022scalaxb.DataRecord(x, node, IPXACT2022scalaxb.fromXML[IPXACT2022ScalaCases.SignType](x, IPXACT2022scalaxb.ElemName(node) :: stack)) } map { "@sign" -> _ },
        (node \ "@prefix").headOption map { x => IPXACT2022scalaxb.DataRecord(x, node, IPXACT2022scalaxb.fromXML[IPXACT2022ScalaCases.Prefix](x, IPXACT2022scalaxb.ElemName(node) :: stack)) } map { "@prefix" -> _ },
        (node \ "@unit").headOption map { x => IPXACT2022scalaxb.DataRecord(x, node, IPXACT2022scalaxb.fromXML[IPXACT2022ScalaCases.UnitType](x, IPXACT2022scalaxb.ElemName(node) :: stack)) } map { "@unit" -> _ },
        (node \ "@resolve").headOption map { x => IPXACT2022scalaxb.DataRecord(x, node, IPXACT2022scalaxb.fromXML[IPXACT2022ScalaCases.Resolve](x, IPXACT2022scalaxb.ElemName(node) :: stack)) } orElse Some(IPXACT2022scalaxb.DataRecord(None, None, IPXACT2022scalaxb.fromXML[IPXACT2022ScalaCases.Resolve](scala.xml.Text("immediate"), IPXACT2022scalaxb.ElemName(node) :: stack))) map { "@resolve" -> _ },
        (node \ "@dataType").headOption map { x => IPXACT2022scalaxb.DataRecord(x, node, IPXACT2022scalaxb.fromXML[String](x, IPXACT2022scalaxb.ElemName(node) :: stack)) } map { "@dataType" -> _ },
        (node \ "@usageType").headOption map { x => IPXACT2022scalaxb.DataRecord(x, node, IPXACT2022scalaxb.fromXML[IPXACT2022ScalaCases.UsageTypeType](x, IPXACT2022scalaxb.ElemName(node) :: stack)) } orElse Some(IPXACT2022scalaxb.DataRecord(None, None, IPXACT2022scalaxb.fromXML[IPXACT2022ScalaCases.UsageTypeType](scala.xml.Text("typed"), IPXACT2022scalaxb.ElemName(node) :: stack))) map { "@usageType" -> _ },
        (node \ "@dataTypeDefinition").headOption map { x => IPXACT2022scalaxb.DataRecord(x, node, IPXACT2022scalaxb.fromXML[String](x, IPXACT2022scalaxb.ElemName(node) :: stack)) } map { "@dataTypeDefinition" -> _ },
        (node \ "@constrained").headOption map { x => IPXACT2022scalaxb.DataRecord(x, node, IPXACT2022scalaxb.fromXML[Seq[String]](x, IPXACT2022scalaxb.ElemName(node) :: stack)) } map { "@constrained" -> _ }
        ).flatten[(String, IPXACT2022scalaxb.DataRecord[Any])] ::: (node match {
          case elem: scala.xml.Elem =>
            elem.attributes.toList flatMap {
              case scala.xml.PrefixedAttribute(pre, key, value, _) if pre == elem.scope.getPrefix("http://www.w3.org/XML/1998/namespace") &&
                key == "id" => Nil
              case scala.xml.UnprefixedAttribute(key, value, _) if key == "parameterId" => Nil
              case scala.xml.UnprefixedAttribute(key, value, _) if key == "prompt" => Nil
              case scala.xml.UnprefixedAttribute(key, value, _) if key == "choiceRef" => Nil
              case scala.xml.UnprefixedAttribute(key, value, _) if key == "order" => Nil
              case scala.xml.UnprefixedAttribute(key, value, _) if key == "configGroups" => Nil
              case scala.xml.UnprefixedAttribute(key, value, _) if key == "minimum" => Nil
              case scala.xml.UnprefixedAttribute(key, value, _) if key == "maximum" => Nil
              case scala.xml.UnprefixedAttribute(key, value, _) if key == "type" => Nil
              case scala.xml.UnprefixedAttribute(key, value, _) if key == "sign" => Nil
              case scala.xml.UnprefixedAttribute(key, value, _) if key == "prefix" => Nil
              case scala.xml.UnprefixedAttribute(key, value, _) if key == "unit" => Nil
              case scala.xml.UnprefixedAttribute(key, value, _) if key == "resolve" => Nil
              case scala.xml.UnprefixedAttribute(key, value, _) if key == "dataType" => Nil
              case scala.xml.UnprefixedAttribute(key, value, _) if key == "usageType" => Nil
              case scala.xml.UnprefixedAttribute(key, value, _) if key == "dataTypeDefinition" => Nil
              case scala.xml.UnprefixedAttribute(key, value, _) if key == "constrained" => Nil
              case scala.xml.UnprefixedAttribute(key, value, _) =>
                List(("@" + key, IPXACT2022scalaxb.DataRecord(None, Some(key), value.text)))
              case scala.xml.PrefixedAttribute(pre, key, value, _) =>
                val ns = elem.scope.getURI(pre)
                List(("@{" + ns + "}" + key, IPXACT2022scalaxb.DataRecord(Option[String](ns), Some(key), value.text)))
              case _ => Nil
            }
          case _ => Nil
        }): _*)) })
    
    override def writesAttribute(__obj: IPXACT2022ScalaCases.ModuleParameterType, __scope: scala.xml.NamespaceBinding): scala.xml.MetaData = {
      var attr: scala.xml.MetaData  = scala.xml.Null
      __obj.attributes.toList map {
        case ("@{http://www.w3.org/XML/1998/namespace}id", _) => __obj.xmlid foreach { x => attr = scala.xml.Attribute(__scope.getPrefix("http://www.w3.org/XML/1998/namespace"), "id", x.toString, attr) }
        case ("@parameterId", _) => __obj.parameterId foreach { x => attr = scala.xml.Attribute(null, "parameterId", x.toString, attr) }
        case ("@prompt", _) => __obj.prompt foreach { x => attr = scala.xml.Attribute(null, "prompt", x.toString, attr) }
        case ("@choiceRef", _) => __obj.choiceRef foreach { x => attr = scala.xml.Attribute(null, "choiceRef", x.toString, attr) }
        case ("@order", _) => __obj.order foreach { x => attr = scala.xml.Attribute(null, "order", x.toString, attr) }
        case ("@configGroups", _) => __obj.configGroups foreach { x => attr = scala.xml.Attribute(null, "configGroups", x.toString, attr) }
        case ("@minimum", _) => __obj.minimum foreach { x => attr = scala.xml.Attribute(null, "minimum", x.toString, attr) }
        case ("@maximum", _) => __obj.maximum foreach { x => attr = scala.xml.Attribute(null, "maximum", x.toString, attr) }
        case ("@type", _) => if (__obj.typeValue.toString != "string") attr = scala.xml.Attribute(null, "type", __obj.typeValue.toString, attr)
        case ("@sign", _) => __obj.sign foreach { x => attr = scala.xml.Attribute(null, "sign", x.toString, attr) }
        case ("@prefix", _) => __obj.prefix foreach { x => attr = scala.xml.Attribute(null, "prefix", x.toString, attr) }
        case ("@unit", _) => __obj.unit foreach { x => attr = scala.xml.Attribute(null, "unit", x.toString, attr) }
        case ("@resolve", _) => if (__obj.resolve.toString != "immediate") attr = scala.xml.Attribute(null, "resolve", __obj.resolve.toString, attr)
        case ("@dataType", _) => __obj.dataType foreach { x => attr = scala.xml.Attribute(null, "dataType", x.toString, attr) }
        case ("@usageType", _) => if (__obj.usageType.toString != "typed") attr = scala.xml.Attribute(null, "usageType", __obj.usageType.toString, attr)
        case ("@dataTypeDefinition", _) => __obj.dataTypeDefinition foreach { x => attr = scala.xml.Attribute(null, "dataTypeDefinition", x.toString, attr) }
        case ("@constrained", _) => __obj.constrained foreach { x => attr = scala.xml.Attribute(null, "constrained", x.map(x => x.toString).mkString(" "), attr) }
        case (key, x) => attr = scala.xml.Attribute((x.namespace map { __scope.getPrefix(_) }).orNull, x.key.orNull, x.value.toString, attr)
      }
      attr
    }

    def writesChildNodes(__obj: IPXACT2022ScalaCases.ModuleParameterType, __scope: scala.xml.NamespaceBinding): Seq[scala.xml.Node] =
      Seq.concat(IPXACT2022scalaxb.toXML[IPXACT2022ScalaCases.NameGroupStringSequence](__obj.nameGroupStringSequence1, None, Some("nameGroupStringSequence1"), __scope, false),
        __obj.vectors map { IPXACT2022scalaxb.toXML[IPXACT2022ScalaCases.Vectors](_, Some("http://www.accellera.org/XMLSchema/IPXACT/1685-2022"), Some("vectors"), __scope, false) } getOrElse {Nil},
        __obj.arrays map { IPXACT2022scalaxb.toXML[IPXACT2022ScalaCases.ModuleParameterArrays](_, Some("http://www.accellera.org/XMLSchema/IPXACT/1685-2022"), Some("arrays"), __scope, false) } getOrElse {Nil},
        IPXACT2022scalaxb.toXML[IPXACT2022ScalaCases.StringExpressionable](__obj.value, Some("http://www.accellera.org/XMLSchema/IPXACT/1685-2022"), Some("value"), __scope, false),
        __obj.vendorExtensions map { IPXACT2022scalaxb.toXML[IPXACT2022ScalaCases.VendorExtensions](_, Some("http://www.accellera.org/XMLSchema/IPXACT/1685-2022"), Some("vendorExtensions"), __scope, false) } getOrElse {Nil})

  }

  trait DefaultIPXACT2022ScalaCases_NameValuePairTypableFormat extends IPXACT2022scalaxb.XMLFormat[IPXACT2022ScalaCases.NameValuePairTypable] {
    def reads(seq: scala.xml.NodeSeq, stack: List[IPXACT2022scalaxb.ElemName]): Either[String, IPXACT2022ScalaCases.NameValuePairTypable] = seq match {
      case node: scala.xml.Node =>     
        IPXACT2022scalaxb.Helper.instanceType(node) match {
          
          case _ => Right(IPXACT2022scalaxb.fromXML[IPXACT2022ScalaCases.NameValuePairType](node, stack))
        }
      case _ => Left("reads failed: seq must be scala.xml.Node")  
    }
    
    def writes(__obj: IPXACT2022ScalaCases.NameValuePairTypable, __namespace: Option[String], __elementLabel: Option[String],
        __scope: scala.xml.NamespaceBinding, __typeAttribute: Boolean): scala.xml.NodeSeq = __obj match {
      case x: IPXACT2022ScalaCases.Argument => IPXACT2022scalaxb.toXML[IPXACT2022ScalaCases.Argument](x, __namespace, __elementLabel, __scope, true)
      case x: IPXACT2022ScalaCases.NameValuePairType => IPXACT2022scalaxb.toXML[IPXACT2022ScalaCases.NameValuePairType](x, __namespace, __elementLabel, __scope, __typeAttribute)
    }
  }
  trait DefaultIPXACT2022ScalaCases_NameValuePairTypeFormat extends IPXACT2022scalaxb.ElemNameParser[IPXACT2022ScalaCases.NameValuePairType] with IPXACT2022ScalaCases_NameGroupStringGroupFormat {
    val targetNamespace: Option[String] = Some("http://www.accellera.org/XMLSchema/IPXACT/1685-2022")
    
    override def typeName: Option[String] = Some("nameValuePairType")

    def parser(node: scala.xml.Node, stack: List[IPXACT2022scalaxb.ElemName]): Parser[IPXACT2022ScalaCases.NameValuePairType] =
      phrase((parseNameGroupStringGroup(node, IPXACT2022scalaxb.ElemName(node) :: stack)) ~
      (IPXACT2022scalaxb.ElemName(Some("http://www.accellera.org/XMLSchema/IPXACT/1685-2022"), "value")) ~
      opt(IPXACT2022scalaxb.ElemName(Some("http://www.accellera.org/XMLSchema/IPXACT/1685-2022"), "vendorExtensions")) ^^
      { case p1 ~ p2 ~ p3 =>
      IPXACT2022ScalaCases.NameValuePairType(p1,
        IPXACT2022scalaxb.fromXML[IPXACT2022ScalaCases.StringExpressionable](p2, IPXACT2022scalaxb.ElemName(node) :: stack),
        p3.headOption map { IPXACT2022scalaxb.fromXML[IPXACT2022ScalaCases.VendorExtensions](_, IPXACT2022scalaxb.ElemName(node) :: stack) },
        scala.collection.immutable.ListMap(List(
        (node \ "@{http://www.w3.org/XML/1998/namespace}id").headOption map { x => IPXACT2022scalaxb.DataRecord(x, node, IPXACT2022scalaxb.fromXML[String](x, IPXACT2022scalaxb.ElemName(node) :: stack)) } map { "@{http://www.w3.org/XML/1998/namespace}id" -> _ }
        ).flatten[(String, IPXACT2022scalaxb.DataRecord[Any])]: _*)) })
    
    override def writesAttribute(__obj: IPXACT2022ScalaCases.NameValuePairType, __scope: scala.xml.NamespaceBinding): scala.xml.MetaData = {
      var attr: scala.xml.MetaData  = scala.xml.Null
      __obj.attributes.toList map {
        case ("@{http://www.w3.org/XML/1998/namespace}id", _) => __obj.xmlid foreach { x => attr = scala.xml.Attribute(__scope.getPrefix("http://www.w3.org/XML/1998/namespace"), "id", x.toString, attr) }
        case (key, x) => attr = scala.xml.Attribute((x.namespace map { __scope.getPrefix(_) }).orNull, x.key.orNull, x.value.toString, attr)
      }
      attr
    }

    def writesChildNodes(__obj: IPXACT2022ScalaCases.NameValuePairType, __scope: scala.xml.NamespaceBinding): Seq[scala.xml.Node] =
      Seq.concat(IPXACT2022scalaxb.toXML[IPXACT2022ScalaCases.NameGroupStringSequence](__obj.nameGroupStringSequence1, None, Some("nameGroupStringSequence1"), __scope, false),
        IPXACT2022scalaxb.toXML[IPXACT2022ScalaCases.StringExpressionable](__obj.value, Some("http://www.accellera.org/XMLSchema/IPXACT/1685-2022"), Some("value"), __scope, false),
        __obj.vendorExtensions map { IPXACT2022scalaxb.toXML[IPXACT2022ScalaCases.VendorExtensions](_, Some("http://www.accellera.org/XMLSchema/IPXACT/1685-2022"), Some("vendorExtensions"), __scope, false) } getOrElse {Nil})

  }

  trait DefaultIPXACT2022ScalaCases_Vector2Format extends IPXACT2022scalaxb.ElemNameParser[IPXACT2022ScalaCases.Vector2] {
    val targetNamespace: Option[String] = Some("http://www.accellera.org/XMLSchema/IPXACT/1685-2022")
    
    def parser(node: scala.xml.Node, stack: List[IPXACT2022scalaxb.ElemName]): Parser[IPXACT2022ScalaCases.Vector2] =
      phrase((IPXACT2022scalaxb.ElemName(Some("http://www.accellera.org/XMLSchema/IPXACT/1685-2022"), "left")) ~
      (IPXACT2022scalaxb.ElemName(Some("http://www.accellera.org/XMLSchema/IPXACT/1685-2022"), "right")) ^^
      { case p1 ~ p2 =>
      IPXACT2022ScalaCases.Vector2(IPXACT2022scalaxb.fromXML[IPXACT2022ScalaCases.UnsignedIntExpressionable](p1, IPXACT2022scalaxb.ElemName(node) :: stack),
        IPXACT2022scalaxb.fromXML[IPXACT2022ScalaCases.UnsignedIntExpressionable](p2, IPXACT2022scalaxb.ElemName(node) :: stack),
        scala.collection.immutable.ListMap(List(
        (node \ "@{http://www.w3.org/XML/1998/namespace}id").headOption map { x => IPXACT2022scalaxb.DataRecord(x, node, IPXACT2022scalaxb.fromXML[String](x, IPXACT2022scalaxb.ElemName(node) :: stack)) } map { "@{http://www.w3.org/XML/1998/namespace}id" -> _ }
        ).flatten[(String, IPXACT2022scalaxb.DataRecord[Any])]: _*)) })
    
    override def writesAttribute(__obj: IPXACT2022ScalaCases.Vector2, __scope: scala.xml.NamespaceBinding): scala.xml.MetaData = {
      var attr: scala.xml.MetaData  = scala.xml.Null
      __obj.attributes.toList map {
        case ("@{http://www.w3.org/XML/1998/namespace}id", _) => __obj.xmlid foreach { x => attr = scala.xml.Attribute(__scope.getPrefix("http://www.w3.org/XML/1998/namespace"), "id", x.toString, attr) }
        case (key, x) => attr = scala.xml.Attribute((x.namespace map { __scope.getPrefix(_) }).orNull, x.key.orNull, x.value.toString, attr)
      }
      attr
    }

    def writesChildNodes(__obj: IPXACT2022ScalaCases.Vector2, __scope: scala.xml.NamespaceBinding): Seq[scala.xml.Node] =
      Seq.concat(IPXACT2022scalaxb.toXML[IPXACT2022ScalaCases.UnsignedIntExpressionable](__obj.left, Some("http://www.accellera.org/XMLSchema/IPXACT/1685-2022"), Some("left"), __scope, false),
        IPXACT2022scalaxb.toXML[IPXACT2022ScalaCases.UnsignedIntExpressionable](__obj.right, Some("http://www.accellera.org/XMLSchema/IPXACT/1685-2022"), Some("right"), __scope, false))

  }

  trait DefaultIPXACT2022ScalaCases_Vectors2Format extends IPXACT2022scalaxb.ElemNameParser[IPXACT2022ScalaCases.Vectors2] {
    val targetNamespace: Option[String] = Some("http://www.accellera.org/XMLSchema/IPXACT/1685-2022")
    
    def parser(node: scala.xml.Node, stack: List[IPXACT2022scalaxb.ElemName]): Parser[IPXACT2022ScalaCases.Vectors2] =
      phrase(safeRep(IPXACT2022scalaxb.ElemName(Some("http://www.accellera.org/XMLSchema/IPXACT/1685-2022"), "vector")) ^^
      { case p1 =>
      IPXACT2022ScalaCases.Vectors2(p1 map { IPXACT2022scalaxb.fromXML[IPXACT2022ScalaCases.Vector2](_, IPXACT2022scalaxb.ElemName(node) :: stack) }) })
    
    def writesChildNodes(__obj: IPXACT2022ScalaCases.Vectors2, __scope: scala.xml.NamespaceBinding): Seq[scala.xml.Node] =
      (__obj.vector flatMap { IPXACT2022scalaxb.toXML[IPXACT2022ScalaCases.Vector2](_, Some("http://www.accellera.org/XMLSchema/IPXACT/1685-2022"), Some("vector"), __scope, false) })
  }
  trait DefaultIPXACT2022ScalaCases_RangeTypeFormat extends IPXACT2022scalaxb.ElemNameParser[IPXACT2022ScalaCases.RangeType] {
    val targetNamespace: Option[String] = Some("http://www.accellera.org/XMLSchema/IPXACT/1685-2022")
    
    def parser(node: scala.xml.Node, stack: List[IPXACT2022scalaxb.ElemName]): Parser[IPXACT2022ScalaCases.RangeType] =
      phrase((IPXACT2022scalaxb.ElemName(Some("http://www.accellera.org/XMLSchema/IPXACT/1685-2022"), "left")) ~
      (IPXACT2022scalaxb.ElemName(Some("http://www.accellera.org/XMLSchema/IPXACT/1685-2022"), "right")) ^^
      { case p1 ~ p2 =>
      IPXACT2022ScalaCases.RangeType(IPXACT2022scalaxb.fromXML[IPXACT2022ScalaCases.UnsignedIntExpressionable](p1, IPXACT2022scalaxb.ElemName(node) :: stack),
        IPXACT2022scalaxb.fromXML[IPXACT2022ScalaCases.UnsignedIntExpressionable](p2, IPXACT2022scalaxb.ElemName(node) :: stack)) })
    
    def writesChildNodes(__obj: IPXACT2022ScalaCases.RangeType, __scope: scala.xml.NamespaceBinding): Seq[scala.xml.Node] =
      Seq.concat(IPXACT2022scalaxb.toXML[IPXACT2022ScalaCases.UnsignedIntExpressionable](__obj.left, Some("http://www.accellera.org/XMLSchema/IPXACT/1685-2022"), Some("left"), __scope, false),
        IPXACT2022scalaxb.toXML[IPXACT2022ScalaCases.UnsignedIntExpressionable](__obj.right, Some("http://www.accellera.org/XMLSchema/IPXACT/1685-2022"), Some("right"), __scope, false))

  }

  trait DefaultIPXACT2022ScalaCases_PartSelectFormat extends IPXACT2022scalaxb.ElemNameParser[IPXACT2022ScalaCases.PartSelect] {
    val targetNamespace: Option[String] = Some("http://www.accellera.org/XMLSchema/IPXACT/1685-2022")
    
    def parser(node: scala.xml.Node, stack: List[IPXACT2022scalaxb.ElemName]): Parser[IPXACT2022ScalaCases.PartSelect] =
      phrase((((IPXACT2022scalaxb.ElemName(Some("http://www.accellera.org/XMLSchema/IPXACT/1685-2022"), "range")) ^^
      (x => IPXACT2022scalaxb.DataRecord(x.namespace, Some(x.name), IPXACT2022scalaxb.fromXML[IPXACT2022ScalaCases.RangeType](x, IPXACT2022scalaxb.ElemName(node) :: stack)))) |||
      (((IPXACT2022scalaxb.ElemName(Some("http://www.accellera.org/XMLSchema/IPXACT/1685-2022"), "indices")) ~
      opt(IPXACT2022scalaxb.ElemName(Some("http://www.accellera.org/XMLSchema/IPXACT/1685-2022"), "range"))) ^^
        { case p1 ~ p2 => IPXACT2022scalaxb.DataRecord(IPXACT2022ScalaCases.PartSelectSequence1(IPXACT2022scalaxb.fromXML[IPXACT2022ScalaCases.IndicesType](p1, IPXACT2022scalaxb.ElemName(node) :: stack),
        p2.headOption map { IPXACT2022scalaxb.fromXML[IPXACT2022ScalaCases.RangeType](_, IPXACT2022scalaxb.ElemName(node) :: stack) })) })) ^^
      { case p1 =>
      IPXACT2022ScalaCases.PartSelect(p1,
        scala.collection.immutable.ListMap(List(
        (node \ "@{http://www.w3.org/XML/1998/namespace}id").headOption map { x => IPXACT2022scalaxb.DataRecord(x, node, IPXACT2022scalaxb.fromXML[String](x, IPXACT2022scalaxb.ElemName(node) :: stack)) } map { "@{http://www.w3.org/XML/1998/namespace}id" -> _ }
        ).flatten[(String, IPXACT2022scalaxb.DataRecord[Any])]: _*)) })
    
    override def writesAttribute(__obj: IPXACT2022ScalaCases.PartSelect, __scope: scala.xml.NamespaceBinding): scala.xml.MetaData = {
      var attr: scala.xml.MetaData  = scala.xml.Null
      __obj.attributes.toList map {
        case ("@{http://www.w3.org/XML/1998/namespace}id", _) => __obj.xmlid foreach { x => attr = scala.xml.Attribute(__scope.getPrefix("http://www.w3.org/XML/1998/namespace"), "id", x.toString, attr) }
        case (key, x) => attr = scala.xml.Attribute((x.namespace map { __scope.getPrefix(_) }).orNull, x.key.orNull, x.value.toString, attr)
      }
      attr
    }

    def writesChildNodes(__obj: IPXACT2022ScalaCases.PartSelect, __scope: scala.xml.NamespaceBinding): Seq[scala.xml.Node] =
      ((Some(__obj.partselectoption) map {x => IPXACT2022scalaxb.toXML[IPXACT2022scalaxb.DataRecord[IPXACT2022ScalaCases.PartSelectOption]](x, x.namespace, x.key, __scope, false)}).get)
  }

  trait DefaultIPXACT2022ScalaCases_PartSelectSequence1Format extends IPXACT2022scalaxb.XMLFormat[IPXACT2022ScalaCases.PartSelectSequence1] {
    def reads(seq: scala.xml.NodeSeq, stack: List[IPXACT2022scalaxb.ElemName]): Either[String, IPXACT2022ScalaCases.PartSelectSequence1] = Left("don't call me.")
    
    def writes(__obj: IPXACT2022ScalaCases.PartSelectSequence1, __namespace: Option[String], __elementLabel: Option[String],
        __scope: scala.xml.NamespaceBinding, __typeAttribute: Boolean): scala.xml.NodeSeq =
      Seq.concat(IPXACT2022scalaxb.toXML[IPXACT2022ScalaCases.IndicesType](__obj.indices, Some("http://www.accellera.org/XMLSchema/IPXACT/1685-2022"), Some("indices"), __scope, false),
        __obj.range map { IPXACT2022scalaxb.toXML[IPXACT2022ScalaCases.RangeType](_, Some("http://www.accellera.org/XMLSchema/IPXACT/1685-2022"), Some("range"), __scope, false) } getOrElse {Nil})


  }

  trait DefaultIPXACT2022ScalaCases_SubPortReferenceFormat extends IPXACT2022scalaxb.ElemNameParser[IPXACT2022ScalaCases.SubPortReference] {
    val targetNamespace: Option[String] = Some("http://www.accellera.org/XMLSchema/IPXACT/1685-2022")
    
    def parser(node: scala.xml.Node, stack: List[IPXACT2022scalaxb.ElemName]): Parser[IPXACT2022ScalaCases.SubPortReference] =
      phrase(opt(IPXACT2022scalaxb.ElemName(Some("http://www.accellera.org/XMLSchema/IPXACT/1685-2022"), "partSelect")) ^^
      { case p1 =>
      IPXACT2022ScalaCases.SubPortReference(p1.headOption map { IPXACT2022scalaxb.fromXML[IPXACT2022ScalaCases.PartSelect](_, IPXACT2022scalaxb.ElemName(node) :: stack) },
        scala.collection.immutable.ListMap(List(
        (node \ "@subPortRef").headOption map { x => IPXACT2022scalaxb.DataRecord(x, node, IPXACT2022scalaxb.fromXML[String](x, IPXACT2022scalaxb.ElemName(node) :: stack)) } map { "@subPortRef" -> _ },
        (node \ "@{http://www.w3.org/XML/1998/namespace}id").headOption map { x => IPXACT2022scalaxb.DataRecord(x, node, IPXACT2022scalaxb.fromXML[String](x, IPXACT2022scalaxb.ElemName(node) :: stack)) } map { "@{http://www.w3.org/XML/1998/namespace}id" -> _ }
        ).flatten[(String, IPXACT2022scalaxb.DataRecord[Any])]: _*)) })
    
    override def writesAttribute(__obj: IPXACT2022ScalaCases.SubPortReference, __scope: scala.xml.NamespaceBinding): scala.xml.MetaData = {
      var attr: scala.xml.MetaData  = scala.xml.Null
      __obj.attributes.toList map {
        case ("@subPortRef", _) => attr = scala.xml.Attribute(null, "subPortRef", __obj.subPortRef.toString, attr)
        case ("@{http://www.w3.org/XML/1998/namespace}id", _) => __obj.xmlid foreach { x => attr = scala.xml.Attribute(__scope.getPrefix("http://www.w3.org/XML/1998/namespace"), "id", x.toString, attr) }
        case (key, x) => attr = scala.xml.Attribute((x.namespace map { __scope.getPrefix(_) }).orNull, x.key.orNull, x.value.toString, attr)
      }
      attr
    }

    def writesChildNodes(__obj: IPXACT2022ScalaCases.SubPortReference, __scope: scala.xml.NamespaceBinding): Seq[scala.xml.Node] =
      (__obj.partSelect map { IPXACT2022scalaxb.toXML[IPXACT2022ScalaCases.PartSelect](_, Some("http://www.accellera.org/XMLSchema/IPXACT/1685-2022"), Some("partSelect"), __scope, false) } getOrElse {Nil})
  }

  trait DefaultIPXACT2022ScalaCases_AddressBlockRefFormat extends IPXACT2022scalaxb.ElemNameParser[IPXACT2022ScalaCases.AddressBlockRef] {
    val targetNamespace: Option[String] = Some("http://www.accellera.org/XMLSchema/IPXACT/1685-2022")
    
    def parser(node: scala.xml.Node, stack: List[IPXACT2022scalaxb.ElemName]): Parser[IPXACT2022ScalaCases.AddressBlockRef] =
      phrase(opt(IPXACT2022scalaxb.ElemName(Some("http://www.accellera.org/XMLSchema/IPXACT/1685-2022"), "indices")) ^^
      { case p1 =>
      IPXACT2022ScalaCases.AddressBlockRef(p1.headOption map { IPXACT2022scalaxb.fromXML[IPXACT2022ScalaCases.IndicesType](_, IPXACT2022scalaxb.ElemName(node) :: stack) },
        scala.collection.immutable.ListMap(List(
        (node \ "@addressBlockRef").headOption map { x => IPXACT2022scalaxb.DataRecord(x, node, IPXACT2022scalaxb.fromXML[String](x, IPXACT2022scalaxb.ElemName(node) :: stack)) } map { "@addressBlockRef" -> _ }
        ).flatten[(String, IPXACT2022scalaxb.DataRecord[Any])]: _*)) })
    
    override def writesAttribute(__obj: IPXACT2022ScalaCases.AddressBlockRef, __scope: scala.xml.NamespaceBinding): scala.xml.MetaData = {
      var attr: scala.xml.MetaData  = scala.xml.Null
      __obj.attributes.toList map {
        case ("@addressBlockRef", _) => attr = scala.xml.Attribute(null, "addressBlockRef", __obj.addressBlockRef.toString, attr)
        case (key, x) => attr = scala.xml.Attribute((x.namespace map { __scope.getPrefix(_) }).orNull, x.key.orNull, x.value.toString, attr)
      }
      attr
    }

    def writesChildNodes(__obj: IPXACT2022ScalaCases.AddressBlockRef, __scope: scala.xml.NamespaceBinding): Seq[scala.xml.Node] =
      (__obj.indices map { IPXACT2022scalaxb.toXML[IPXACT2022ScalaCases.IndicesType](_, Some("http://www.accellera.org/XMLSchema/IPXACT/1685-2022"), Some("indices"), __scope, false) } getOrElse {Nil})
  }

  trait DefaultIPXACT2022ScalaCases_RegisterFileRefFormat extends IPXACT2022scalaxb.ElemNameParser[IPXACT2022ScalaCases.RegisterFileRef] {
    val targetNamespace: Option[String] = Some("http://www.accellera.org/XMLSchema/IPXACT/1685-2022")
    
    def parser(node: scala.xml.Node, stack: List[IPXACT2022scalaxb.ElemName]): Parser[IPXACT2022ScalaCases.RegisterFileRef] =
      phrase(opt(IPXACT2022scalaxb.ElemName(Some("http://www.accellera.org/XMLSchema/IPXACT/1685-2022"), "indices")) ^^
      { case p1 =>
      IPXACT2022ScalaCases.RegisterFileRef(p1.headOption map { IPXACT2022scalaxb.fromXML[IPXACT2022ScalaCases.IndicesType](_, IPXACT2022scalaxb.ElemName(node) :: stack) },
        scala.collection.immutable.ListMap(List(
        (node \ "@registerFileRef").headOption map { x => IPXACT2022scalaxb.DataRecord(x, node, IPXACT2022scalaxb.fromXML[String](x, IPXACT2022scalaxb.ElemName(node) :: stack)) } map { "@registerFileRef" -> _ },
        (node \ "@{http://www.w3.org/XML/1998/namespace}id").headOption map { x => IPXACT2022scalaxb.DataRecord(x, node, IPXACT2022scalaxb.fromXML[String](x, IPXACT2022scalaxb.ElemName(node) :: stack)) } map { "@{http://www.w3.org/XML/1998/namespace}id" -> _ }
        ).flatten[(String, IPXACT2022scalaxb.DataRecord[Any])]: _*)) })
    
    override def writesAttribute(__obj: IPXACT2022ScalaCases.RegisterFileRef, __scope: scala.xml.NamespaceBinding): scala.xml.MetaData = {
      var attr: scala.xml.MetaData  = scala.xml.Null
      __obj.attributes.toList map {
        case ("@registerFileRef", _) => attr = scala.xml.Attribute(null, "registerFileRef", __obj.registerFileRef.toString, attr)
        case ("@{http://www.w3.org/XML/1998/namespace}id", _) => __obj.xmlid foreach { x => attr = scala.xml.Attribute(__scope.getPrefix("http://www.w3.org/XML/1998/namespace"), "id", x.toString, attr) }
        case (key, x) => attr = scala.xml.Attribute((x.namespace map { __scope.getPrefix(_) }).orNull, x.key.orNull, x.value.toString, attr)
      }
      attr
    }

    def writesChildNodes(__obj: IPXACT2022ScalaCases.RegisterFileRef, __scope: scala.xml.NamespaceBinding): Seq[scala.xml.Node] =
      (__obj.indices map { IPXACT2022scalaxb.toXML[IPXACT2022ScalaCases.IndicesType](_, Some("http://www.accellera.org/XMLSchema/IPXACT/1685-2022"), Some("indices"), __scope, false) } getOrElse {Nil})
  }

  trait DefaultIPXACT2022ScalaCases_RegisterRefFormat extends IPXACT2022scalaxb.ElemNameParser[IPXACT2022ScalaCases.RegisterRef] {
    val targetNamespace: Option[String] = Some("http://www.accellera.org/XMLSchema/IPXACT/1685-2022")
    
    def parser(node: scala.xml.Node, stack: List[IPXACT2022scalaxb.ElemName]): Parser[IPXACT2022ScalaCases.RegisterRef] =
      phrase(opt(IPXACT2022scalaxb.ElemName(Some("http://www.accellera.org/XMLSchema/IPXACT/1685-2022"), "indices")) ^^
      { case p1 =>
      IPXACT2022ScalaCases.RegisterRef(p1.headOption map { IPXACT2022scalaxb.fromXML[IPXACT2022ScalaCases.IndicesType](_, IPXACT2022scalaxb.ElemName(node) :: stack) },
        scala.collection.immutable.ListMap(List(
        (node \ "@registerRef").headOption map { x => IPXACT2022scalaxb.DataRecord(x, node, IPXACT2022scalaxb.fromXML[String](x, IPXACT2022scalaxb.ElemName(node) :: stack)) } map { "@registerRef" -> _ }
        ).flatten[(String, IPXACT2022scalaxb.DataRecord[Any])]: _*)) })
    
    override def writesAttribute(__obj: IPXACT2022ScalaCases.RegisterRef, __scope: scala.xml.NamespaceBinding): scala.xml.MetaData = {
      var attr: scala.xml.MetaData  = scala.xml.Null
      __obj.attributes.toList map {
        case ("@registerRef", _) => attr = scala.xml.Attribute(null, "registerRef", __obj.registerRef.toString, attr)
        case (key, x) => attr = scala.xml.Attribute((x.namespace map { __scope.getPrefix(_) }).orNull, x.key.orNull, x.value.toString, attr)
      }
      attr
    }

    def writesChildNodes(__obj: IPXACT2022ScalaCases.RegisterRef, __scope: scala.xml.NamespaceBinding): Seq[scala.xml.Node] =
      (__obj.indices map { IPXACT2022scalaxb.toXML[IPXACT2022ScalaCases.IndicesType](_, Some("http://www.accellera.org/XMLSchema/IPXACT/1685-2022"), Some("indices"), __scope, false) } getOrElse {Nil})
  }

  trait DefaultIPXACT2022ScalaCases_AlternateRegisterRefFormat extends IPXACT2022scalaxb.XMLFormat[IPXACT2022ScalaCases.AlternateRegisterRef] with IPXACT2022scalaxb.CanWriteChildNodes[IPXACT2022ScalaCases.AlternateRegisterRef] {
    val targetNamespace: Option[String] = Some("http://www.accellera.org/XMLSchema/IPXACT/1685-2022")
    def reads(seq: scala.xml.NodeSeq, stack: List[IPXACT2022scalaxb.ElemName]): Either[String, IPXACT2022ScalaCases.AlternateRegisterRef] = seq match {
      case node: scala.xml.Node => Right(IPXACT2022ScalaCases.AlternateRegisterRef(scala.collection.immutable.ListMap(List(
        (node \ "@alternateRegisterRef").headOption map { x => IPXACT2022scalaxb.DataRecord(x, node, IPXACT2022scalaxb.fromXML[String](x, IPXACT2022scalaxb.ElemName(node) :: stack)) } map { "@alternateRegisterRef" -> _ }
        ).flatten[(String, IPXACT2022scalaxb.DataRecord[Any])]: _*)))
      case _ => Left("reads failed: seq must be scala.xml.Node")
    }
    
    override def writesAttribute(__obj: IPXACT2022ScalaCases.AlternateRegisterRef, __scope: scala.xml.NamespaceBinding): scala.xml.MetaData = {
      var attr: scala.xml.MetaData  = scala.xml.Null
      __obj.attributes.toList map {
        case ("@alternateRegisterRef", _) => attr = scala.xml.Attribute(null, "alternateRegisterRef", __obj.alternateRegisterRef.toString, attr)
        case (key, x) => attr = scala.xml.Attribute((x.namespace map { __scope.getPrefix(_) }).orNull, x.key.orNull, x.value.toString, attr)
      }
      attr
    }

    def writesChildNodes(__obj: IPXACT2022ScalaCases.AlternateRegisterRef, __scope: scala.xml.NamespaceBinding): Seq[scala.xml.Node] =
      Nil

  }

  trait DefaultIPXACT2022ScalaCases_FieldRefFormat extends IPXACT2022scalaxb.ElemNameParser[IPXACT2022ScalaCases.FieldRef] {
    val targetNamespace: Option[String] = Some("http://www.accellera.org/XMLSchema/IPXACT/1685-2022")
    
    def parser(node: scala.xml.Node, stack: List[IPXACT2022scalaxb.ElemName]): Parser[IPXACT2022ScalaCases.FieldRef] =
      phrase(opt(IPXACT2022scalaxb.ElemName(Some("http://www.accellera.org/XMLSchema/IPXACT/1685-2022"), "indices")) ^^
      { case p1 =>
      IPXACT2022ScalaCases.FieldRef(p1.headOption map { IPXACT2022scalaxb.fromXML[IPXACT2022ScalaCases.IndicesType](_, IPXACT2022scalaxb.ElemName(node) :: stack) },
        scala.collection.immutable.ListMap(List(
        (node \ "@fieldRef").headOption map { x => IPXACT2022scalaxb.DataRecord(x, node, IPXACT2022scalaxb.fromXML[String](x, IPXACT2022scalaxb.ElemName(node) :: stack)) } map { "@fieldRef" -> _ }
        ).flatten[(String, IPXACT2022scalaxb.DataRecord[Any])]: _*)) })
    
    override def writesAttribute(__obj: IPXACT2022ScalaCases.FieldRef, __scope: scala.xml.NamespaceBinding): scala.xml.MetaData = {
      var attr: scala.xml.MetaData  = scala.xml.Null
      __obj.attributes.toList map {
        case ("@fieldRef", _) => attr = scala.xml.Attribute(null, "fieldRef", __obj.fieldRef.toString, attr)
        case (key, x) => attr = scala.xml.Attribute((x.namespace map { __scope.getPrefix(_) }).orNull, x.key.orNull, x.value.toString, attr)
      }
      attr
    }

    def writesChildNodes(__obj: IPXACT2022ScalaCases.FieldRef, __scope: scala.xml.NamespaceBinding): Seq[scala.xml.Node] =
      (__obj.indices map { IPXACT2022scalaxb.toXML[IPXACT2022ScalaCases.IndicesType](_, Some("http://www.accellera.org/XMLSchema/IPXACT/1685-2022"), Some("indices"), __scope, false) } getOrElse {Nil})
  }

  trait DefaultIPXACT2022ScalaCases_BankRefFormat extends IPXACT2022scalaxb.XMLFormat[IPXACT2022ScalaCases.BankRef] with IPXACT2022scalaxb.CanWriteChildNodes[IPXACT2022ScalaCases.BankRef] {
    val targetNamespace: Option[String] = Some("http://www.accellera.org/XMLSchema/IPXACT/1685-2022")
    def reads(seq: scala.xml.NodeSeq, stack: List[IPXACT2022scalaxb.ElemName]): Either[String, IPXACT2022ScalaCases.BankRef] = seq match {
      case node: scala.xml.Node => Right(IPXACT2022ScalaCases.BankRef(scala.collection.immutable.ListMap(List(
        (node \ "@bankRef").headOption map { x => IPXACT2022scalaxb.DataRecord(x, node, IPXACT2022scalaxb.fromXML[String](x, IPXACT2022scalaxb.ElemName(node) :: stack)) } map { "@bankRef" -> _ },
        (node \ "@{http://www.w3.org/XML/1998/namespace}id").headOption map { x => IPXACT2022scalaxb.DataRecord(x, node, IPXACT2022scalaxb.fromXML[String](x, IPXACT2022scalaxb.ElemName(node) :: stack)) } map { "@{http://www.w3.org/XML/1998/namespace}id" -> _ }
        ).flatten[(String, IPXACT2022scalaxb.DataRecord[Any])]: _*)))
      case _ => Left("reads failed: seq must be scala.xml.Node")
    }
    
    override def writesAttribute(__obj: IPXACT2022ScalaCases.BankRef, __scope: scala.xml.NamespaceBinding): scala.xml.MetaData = {
      var attr: scala.xml.MetaData  = scala.xml.Null
      __obj.attributes.toList map {
        case ("@bankRef", _) => attr = scala.xml.Attribute(null, "bankRef", __obj.bankRef.toString, attr)
        case ("@{http://www.w3.org/XML/1998/namespace}id", _) => __obj.xmlid foreach { x => attr = scala.xml.Attribute(__scope.getPrefix("http://www.w3.org/XML/1998/namespace"), "id", x.toString, attr) }
        case (key, x) => attr = scala.xml.Attribute((x.namespace map { __scope.getPrefix(_) }).orNull, x.key.orNull, x.value.toString, attr)
      }
      attr
    }

    def writesChildNodes(__obj: IPXACT2022ScalaCases.BankRef, __scope: scala.xml.NamespaceBinding): Seq[scala.xml.Node] =
      Nil

  }

  trait DefaultIPXACT2022ScalaCases_MemoryRemapRefFormat extends IPXACT2022scalaxb.XMLFormat[IPXACT2022ScalaCases.MemoryRemapRef] with IPXACT2022scalaxb.CanWriteChildNodes[IPXACT2022ScalaCases.MemoryRemapRef] {
    val targetNamespace: Option[String] = Some("http://www.accellera.org/XMLSchema/IPXACT/1685-2022")
    def reads(seq: scala.xml.NodeSeq, stack: List[IPXACT2022scalaxb.ElemName]): Either[String, IPXACT2022ScalaCases.MemoryRemapRef] = seq match {
      case node: scala.xml.Node => Right(IPXACT2022ScalaCases.MemoryRemapRef(scala.collection.immutable.ListMap(List(
        (node \ "@memoryRemapRef").headOption map { x => IPXACT2022scalaxb.DataRecord(x, node, IPXACT2022scalaxb.fromXML[String](x, IPXACT2022scalaxb.ElemName(node) :: stack)) } map { "@memoryRemapRef" -> _ }
        ).flatten[(String, IPXACT2022scalaxb.DataRecord[Any])]: _*)))
      case _ => Left("reads failed: seq must be scala.xml.Node")
    }
    
    override def writesAttribute(__obj: IPXACT2022ScalaCases.MemoryRemapRef, __scope: scala.xml.NamespaceBinding): scala.xml.MetaData = {
      var attr: scala.xml.MetaData  = scala.xml.Null
      __obj.attributes.toList map {
        case ("@memoryRemapRef", _) => attr = scala.xml.Attribute(null, "memoryRemapRef", __obj.memoryRemapRef.toString, attr)
        case (key, x) => attr = scala.xml.Attribute((x.namespace map { __scope.getPrefix(_) }).orNull, x.key.orNull, x.value.toString, attr)
      }
      attr
    }

    def writesChildNodes(__obj: IPXACT2022ScalaCases.MemoryRemapRef, __scope: scala.xml.NamespaceBinding): Seq[scala.xml.Node] =
      Nil

  }

  trait DefaultIPXACT2022ScalaCases_AddressSpaceRefFormat extends IPXACT2022scalaxb.XMLFormat[IPXACT2022ScalaCases.AddressSpaceRef] with IPXACT2022scalaxb.CanWriteChildNodes[IPXACT2022ScalaCases.AddressSpaceRef] {
    val targetNamespace: Option[String] = Some("http://www.accellera.org/XMLSchema/IPXACT/1685-2022")
    def reads(seq: scala.xml.NodeSeq, stack: List[IPXACT2022scalaxb.ElemName]): Either[String, IPXACT2022ScalaCases.AddressSpaceRef] = seq match {
      case node: scala.xml.Node => Right(IPXACT2022ScalaCases.AddressSpaceRef(scala.collection.immutable.ListMap(List(
        (node \ "@addressSpaceRef").headOption map { x => IPXACT2022scalaxb.DataRecord(x, node, IPXACT2022scalaxb.fromXML[String](x, IPXACT2022scalaxb.ElemName(node) :: stack)) } map { "@addressSpaceRef" -> _ }
        ).flatten[(String, IPXACT2022scalaxb.DataRecord[Any])]: _*)))
      case _ => Left("reads failed: seq must be scala.xml.Node")
    }
    
    override def writesAttribute(__obj: IPXACT2022ScalaCases.AddressSpaceRef, __scope: scala.xml.NamespaceBinding): scala.xml.MetaData = {
      var attr: scala.xml.MetaData  = scala.xml.Null
      __obj.attributes.toList map {
        case ("@addressSpaceRef", _) => attr = scala.xml.Attribute(null, "addressSpaceRef", __obj.addressSpaceRef.toString, attr)
        case (key, x) => attr = scala.xml.Attribute((x.namespace map { __scope.getPrefix(_) }).orNull, x.key.orNull, x.value.toString, attr)
      }
      attr
    }

    def writesChildNodes(__obj: IPXACT2022ScalaCases.AddressSpaceRef, __scope: scala.xml.NamespaceBinding): Seq[scala.xml.Node] =
      Nil

  }

  trait DefaultIPXACT2022ScalaCases_MemoryMapRefFormat extends IPXACT2022scalaxb.XMLFormat[IPXACT2022ScalaCases.MemoryMapRef] with IPXACT2022scalaxb.CanWriteChildNodes[IPXACT2022ScalaCases.MemoryMapRef] {
    val targetNamespace: Option[String] = Some("http://www.accellera.org/XMLSchema/IPXACT/1685-2022")
    def reads(seq: scala.xml.NodeSeq, stack: List[IPXACT2022scalaxb.ElemName]): Either[String, IPXACT2022ScalaCases.MemoryMapRef] = seq match {
      case node: scala.xml.Node => Right(IPXACT2022ScalaCases.MemoryMapRef(scala.collection.immutable.ListMap(List(
        (node \ "@memoryMapRef").headOption map { x => IPXACT2022scalaxb.DataRecord(x, node, IPXACT2022scalaxb.fromXML[String](x, IPXACT2022scalaxb.ElemName(node) :: stack)) } map { "@memoryMapRef" -> _ }
        ).flatten[(String, IPXACT2022scalaxb.DataRecord[Any])]: _*)))
      case _ => Left("reads failed: seq must be scala.xml.Node")
    }
    
    override def writesAttribute(__obj: IPXACT2022ScalaCases.MemoryMapRef, __scope: scala.xml.NamespaceBinding): scala.xml.MetaData = {
      var attr: scala.xml.MetaData  = scala.xml.Null
      __obj.attributes.toList map {
        case ("@memoryMapRef", _) => attr = scala.xml.Attribute(null, "memoryMapRef", __obj.memoryMapRef.toString, attr)
        case (key, x) => attr = scala.xml.Attribute((x.namespace map { __scope.getPrefix(_) }).orNull, x.key.orNull, x.value.toString, attr)
      }
      attr
    }

    def writesChildNodes(__obj: IPXACT2022ScalaCases.MemoryMapRef, __scope: scala.xml.NamespaceBinding): Seq[scala.xml.Node] =
      Nil

  }

  trait DefaultIPXACT2022ScalaCases_AddressSpaceRef2Format extends IPXACT2022scalaxb.XMLFormat[IPXACT2022ScalaCases.AddressSpaceRef2] with IPXACT2022scalaxb.CanWriteChildNodes[IPXACT2022ScalaCases.AddressSpaceRef2] {
    val targetNamespace: Option[String] = Some("http://www.accellera.org/XMLSchema/IPXACT/1685-2022")
    def reads(seq: scala.xml.NodeSeq, stack: List[IPXACT2022scalaxb.ElemName]): Either[String, IPXACT2022ScalaCases.AddressSpaceRef2] = seq match {
      case node: scala.xml.Node => Right(IPXACT2022ScalaCases.AddressSpaceRef2(scala.collection.immutable.ListMap(List(
        (node \ "@addressSpaceRef").headOption map { x => IPXACT2022scalaxb.DataRecord(x, node, IPXACT2022scalaxb.fromXML[String](x, IPXACT2022scalaxb.ElemName(node) :: stack)) } map { "@addressSpaceRef" -> _ }
        ).flatten[(String, IPXACT2022scalaxb.DataRecord[Any])]: _*)))
      case _ => Left("reads failed: seq must be scala.xml.Node")
    }
    
    override def writesAttribute(__obj: IPXACT2022ScalaCases.AddressSpaceRef2, __scope: scala.xml.NamespaceBinding): scala.xml.MetaData = {
      var attr: scala.xml.MetaData  = scala.xml.Null
      __obj.attributes.toList map {
        case ("@addressSpaceRef", _) => attr = scala.xml.Attribute(null, "addressSpaceRef", __obj.addressSpaceRef.toString, attr)
        case (key, x) => attr = scala.xml.Attribute((x.namespace map { __scope.getPrefix(_) }).orNull, x.key.orNull, x.value.toString, attr)
      }
      attr
    }

    def writesChildNodes(__obj: IPXACT2022ScalaCases.AddressSpaceRef2, __scope: scala.xml.NamespaceBinding): Seq[scala.xml.Node] =
      Nil

  }

  trait DefaultIPXACT2022ScalaCases_MemoryMapRef2Format extends IPXACT2022scalaxb.XMLFormat[IPXACT2022ScalaCases.MemoryMapRef2] with IPXACT2022scalaxb.CanWriteChildNodes[IPXACT2022ScalaCases.MemoryMapRef2] {
    val targetNamespace: Option[String] = Some("http://www.accellera.org/XMLSchema/IPXACT/1685-2022")
    def reads(seq: scala.xml.NodeSeq, stack: List[IPXACT2022scalaxb.ElemName]): Either[String, IPXACT2022ScalaCases.MemoryMapRef2] = seq match {
      case node: scala.xml.Node => Right(IPXACT2022ScalaCases.MemoryMapRef2(scala.collection.immutable.ListMap(List(
        (node \ "@memoryMapRef").headOption map { x => IPXACT2022scalaxb.DataRecord(x, node, IPXACT2022scalaxb.fromXML[String](x, IPXACT2022scalaxb.ElemName(node) :: stack)) } map { "@memoryMapRef" -> _ }
        ).flatten[(String, IPXACT2022scalaxb.DataRecord[Any])]: _*)))
      case _ => Left("reads failed: seq must be scala.xml.Node")
    }
    
    override def writesAttribute(__obj: IPXACT2022ScalaCases.MemoryMapRef2, __scope: scala.xml.NamespaceBinding): scala.xml.MetaData = {
      var attr: scala.xml.MetaData  = scala.xml.Null
      __obj.attributes.toList map {
        case ("@memoryMapRef", _) => attr = scala.xml.Attribute(null, "memoryMapRef", __obj.memoryMapRef.toString, attr)
        case (key, x) => attr = scala.xml.Attribute((x.namespace map { __scope.getPrefix(_) }).orNull, x.key.orNull, x.value.toString, attr)
      }
      attr
    }

    def writesChildNodes(__obj: IPXACT2022ScalaCases.MemoryMapRef2, __scope: scala.xml.NamespaceBinding): Seq[scala.xml.Node] =
      Nil

  }

  trait DefaultIPXACT2022ScalaCases_ArrayTypeFormat extends IPXACT2022scalaxb.ElemNameParser[IPXACT2022ScalaCases.ArrayType] {
    val targetNamespace: Option[String] = Some("http://www.accellera.org/XMLSchema/IPXACT/1685-2022")
    
    def parser(node: scala.xml.Node, stack: List[IPXACT2022scalaxb.ElemName]): Parser[IPXACT2022ScalaCases.ArrayType] =
      phrase((IPXACT2022scalaxb.ElemName(Some("http://www.accellera.org/XMLSchema/IPXACT/1685-2022"), "left")) ~
      (IPXACT2022scalaxb.ElemName(Some("http://www.accellera.org/XMLSchema/IPXACT/1685-2022"), "right")) ^^
      { case p1 ~ p2 =>
      IPXACT2022ScalaCases.ArrayType(IPXACT2022scalaxb.fromXML[IPXACT2022ScalaCases.UnsignedIntExpressionable](p1, IPXACT2022scalaxb.ElemName(node) :: stack),
        IPXACT2022scalaxb.fromXML[IPXACT2022ScalaCases.UnsignedIntExpressionable](p2, IPXACT2022scalaxb.ElemName(node) :: stack),
        scala.collection.immutable.ListMap(List(
        (node \ "@{http://www.w3.org/XML/1998/namespace}id").headOption map { x => IPXACT2022scalaxb.DataRecord(x, node, IPXACT2022scalaxb.fromXML[String](x, IPXACT2022scalaxb.ElemName(node) :: stack)) } map { "@{http://www.w3.org/XML/1998/namespace}id" -> _ }
        ).flatten[(String, IPXACT2022scalaxb.DataRecord[Any])]: _*)) })
    
    override def writesAttribute(__obj: IPXACT2022ScalaCases.ArrayType, __scope: scala.xml.NamespaceBinding): scala.xml.MetaData = {
      var attr: scala.xml.MetaData  = scala.xml.Null
      __obj.attributes.toList map {
        case ("@{http://www.w3.org/XML/1998/namespace}id", _) => __obj.xmlid foreach { x => attr = scala.xml.Attribute(__scope.getPrefix("http://www.w3.org/XML/1998/namespace"), "id", x.toString, attr) }
        case (key, x) => attr = scala.xml.Attribute((x.namespace map { __scope.getPrefix(_) }).orNull, x.key.orNull, x.value.toString, attr)
      }
      attr
    }

    def writesChildNodes(__obj: IPXACT2022ScalaCases.ArrayType, __scope: scala.xml.NamespaceBinding): Seq[scala.xml.Node] =
      Seq.concat(IPXACT2022scalaxb.toXML[IPXACT2022ScalaCases.UnsignedIntExpressionable](__obj.left, Some("http://www.accellera.org/XMLSchema/IPXACT/1685-2022"), Some("left"), __scope, false),
        IPXACT2022scalaxb.toXML[IPXACT2022ScalaCases.UnsignedIntExpressionable](__obj.right, Some("http://www.accellera.org/XMLSchema/IPXACT/1685-2022"), Some("right"), __scope, false))

  }

  trait DefaultIPXACT2022ScalaCases_ConfigurableArraysFormat extends IPXACT2022scalaxb.ElemNameParser[IPXACT2022ScalaCases.ConfigurableArrays] {
    val targetNamespace: Option[String] = Some("http://www.accellera.org/XMLSchema/IPXACT/1685-2022")
    
    override def typeName: Option[String] = Some("configurableArrays")

    def parser(node: scala.xml.Node, stack: List[IPXACT2022scalaxb.ElemName]): Parser[IPXACT2022ScalaCases.ConfigurableArrays] =
      phrase(safeRep(IPXACT2022scalaxb.ElemName(Some("http://www.accellera.org/XMLSchema/IPXACT/1685-2022"), "array")) ^^
      { case p1 =>
      IPXACT2022ScalaCases.ConfigurableArrays(p1 map { IPXACT2022scalaxb.fromXML[IPXACT2022ScalaCases.ArrayType](_, IPXACT2022scalaxb.ElemName(node) :: stack) }) })
    
    def writesChildNodes(__obj: IPXACT2022ScalaCases.ConfigurableArrays, __scope: scala.xml.NamespaceBinding): Seq[scala.xml.Node] =
      (__obj.array flatMap { IPXACT2022scalaxb.toXML[IPXACT2022ScalaCases.ArrayType](_, Some("http://www.accellera.org/XMLSchema/IPXACT/1685-2022"), Some("array"), __scope, false) })
  }

  trait DefaultIPXACT2022ScalaCases_ArrayType2Format extends IPXACT2022scalaxb.ElemNameParser[IPXACT2022ScalaCases.ArrayType2] {
    val targetNamespace: Option[String] = Some("http://www.accellera.org/XMLSchema/IPXACT/1685-2022")
    
    def parser(node: scala.xml.Node, stack: List[IPXACT2022scalaxb.ElemName]): Parser[IPXACT2022ScalaCases.ArrayType2] =
      phrase((IPXACT2022scalaxb.ElemName(Some("http://www.accellera.org/XMLSchema/IPXACT/1685-2022"), "left")) ~
      (IPXACT2022scalaxb.ElemName(Some("http://www.accellera.org/XMLSchema/IPXACT/1685-2022"), "right")) ^^
      { case p1 ~ p2 =>
      IPXACT2022ScalaCases.ArrayType2(IPXACT2022scalaxb.fromXML[IPXACT2022ScalaCases.UnsignedIntExpressionable](p1, IPXACT2022scalaxb.ElemName(node) :: stack),
        IPXACT2022scalaxb.fromXML[IPXACT2022ScalaCases.UnsignedIntExpressionable](p2, IPXACT2022scalaxb.ElemName(node) :: stack),
        scala.collection.immutable.ListMap(List(
        (node \ "@arrayId").headOption map { x => IPXACT2022scalaxb.DataRecord(x, node, IPXACT2022scalaxb.fromXML[String](x, IPXACT2022scalaxb.ElemName(node) :: stack)) } map { "@arrayId" -> _ },
        (node \ "@{http://www.w3.org/XML/1998/namespace}id").headOption map { x => IPXACT2022scalaxb.DataRecord(x, node, IPXACT2022scalaxb.fromXML[String](x, IPXACT2022scalaxb.ElemName(node) :: stack)) } map { "@{http://www.w3.org/XML/1998/namespace}id" -> _ }
        ).flatten[(String, IPXACT2022scalaxb.DataRecord[Any])]: _*)) })
    
    override def writesAttribute(__obj: IPXACT2022ScalaCases.ArrayType2, __scope: scala.xml.NamespaceBinding): scala.xml.MetaData = {
      var attr: scala.xml.MetaData  = scala.xml.Null
      __obj.attributes.toList map {
        case ("@arrayId", _) => __obj.arrayId foreach { x => attr = scala.xml.Attribute(null, "arrayId", x.toString, attr) }
        case ("@{http://www.w3.org/XML/1998/namespace}id", _) => __obj.xmlid foreach { x => attr = scala.xml.Attribute(__scope.getPrefix("http://www.w3.org/XML/1998/namespace"), "id", x.toString, attr) }
        case (key, x) => attr = scala.xml.Attribute((x.namespace map { __scope.getPrefix(_) }).orNull, x.key.orNull, x.value.toString, attr)
      }
      attr
    }

    def writesChildNodes(__obj: IPXACT2022ScalaCases.ArrayType2, __scope: scala.xml.NamespaceBinding): Seq[scala.xml.Node] =
      Seq.concat(IPXACT2022scalaxb.toXML[IPXACT2022ScalaCases.UnsignedIntExpressionable](__obj.left, Some("http://www.accellera.org/XMLSchema/IPXACT/1685-2022"), Some("left"), __scope, false),
        IPXACT2022scalaxb.toXML[IPXACT2022ScalaCases.UnsignedIntExpressionable](__obj.right, Some("http://www.accellera.org/XMLSchema/IPXACT/1685-2022"), Some("right"), __scope, false))

  }

  trait DefaultIPXACT2022ScalaCases_ModuleParameterArraysFormat extends IPXACT2022scalaxb.ElemNameParser[IPXACT2022ScalaCases.ModuleParameterArrays] {
    val targetNamespace: Option[String] = Some("http://www.accellera.org/XMLSchema/IPXACT/1685-2022")
    
    override def typeName: Option[String] = Some("moduleParameterArrays")

    def parser(node: scala.xml.Node, stack: List[IPXACT2022scalaxb.ElemName]): Parser[IPXACT2022ScalaCases.ModuleParameterArrays] =
      phrase(safeRep(IPXACT2022scalaxb.ElemName(Some("http://www.accellera.org/XMLSchema/IPXACT/1685-2022"), "array")) ^^
      { case p1 =>
      IPXACT2022ScalaCases.ModuleParameterArrays(p1 map { IPXACT2022scalaxb.fromXML[IPXACT2022ScalaCases.ArrayType2](_, IPXACT2022scalaxb.ElemName(node) :: stack) }) })
    
    def writesChildNodes(__obj: IPXACT2022ScalaCases.ModuleParameterArrays, __scope: scala.xml.NamespaceBinding): Seq[scala.xml.Node] =
      (__obj.array flatMap { IPXACT2022scalaxb.toXML[IPXACT2022ScalaCases.ArrayType2](_, Some("http://www.accellera.org/XMLSchema/IPXACT/1685-2022"), Some("array"), __scope, false) })
  }

  trait DefaultIPXACT2022ScalaCases_IndicesTypeFormat extends IPXACT2022scalaxb.ElemNameParser[IPXACT2022ScalaCases.IndicesType] {
    val targetNamespace: Option[String] = Some("http://www.accellera.org/XMLSchema/IPXACT/1685-2022")
    
    override def typeName: Option[String] = Some("indicesType")

    def parser(node: scala.xml.Node, stack: List[IPXACT2022scalaxb.ElemName]): Parser[IPXACT2022ScalaCases.IndicesType] =
      phrase(safeRep(IPXACT2022scalaxb.ElemName(Some("http://www.accellera.org/XMLSchema/IPXACT/1685-2022"), "index")) ^^
      { case p1 =>
      IPXACT2022ScalaCases.IndicesType(p1 map { IPXACT2022scalaxb.fromXML[IPXACT2022ScalaCases.Index2](_, IPXACT2022scalaxb.ElemName(node) :: stack) }) })
    
    def writesChildNodes(__obj: IPXACT2022ScalaCases.IndicesType, __scope: scala.xml.NamespaceBinding): Seq[scala.xml.Node] =
      (__obj.index flatMap { IPXACT2022scalaxb.toXML[IPXACT2022ScalaCases.Index2](_, Some("http://www.accellera.org/XMLSchema/IPXACT/1685-2022"), Some("index"), __scope, false) })
  }

  trait DefaultIPXACT2022ScalaCases_ExternalModeReferenceFormat extends IPXACT2022scalaxb.XMLFormat[IPXACT2022ScalaCases.ExternalModeReference] with IPXACT2022scalaxb.CanWriteChildNodes[IPXACT2022ScalaCases.ExternalModeReference] {
    val targetNamespace: Option[String] = Some("http://www.accellera.org/XMLSchema/IPXACT/1685-2022")
    def reads(seq: scala.xml.NodeSeq, stack: List[IPXACT2022scalaxb.ElemName]): Either[String, IPXACT2022ScalaCases.ExternalModeReference] = seq match {
      case node: scala.xml.Node => Right(IPXACT2022ScalaCases.ExternalModeReference(scala.collection.immutable.ListMap(List(
        (node \ "@modeRef").headOption map { x => IPXACT2022scalaxb.DataRecord(x, node, IPXACT2022scalaxb.fromXML[String](x, IPXACT2022scalaxb.ElemName(node) :: stack)) } map { "@modeRef" -> _ }
        ).flatten[(String, IPXACT2022scalaxb.DataRecord[Any])]: _*)))
      case _ => Left("reads failed: seq must be scala.xml.Node")
    }
    
    override def writesAttribute(__obj: IPXACT2022ScalaCases.ExternalModeReference, __scope: scala.xml.NamespaceBinding): scala.xml.MetaData = {
      var attr: scala.xml.MetaData  = scala.xml.Null
      __obj.attributes.toList map {
        case ("@modeRef", _) => attr = scala.xml.Attribute(null, "modeRef", __obj.modeRef.toString, attr)
        case (key, x) => attr = scala.xml.Attribute((x.namespace map { __scope.getPrefix(_) }).orNull, x.key.orNull, x.value.toString, attr)
      }
      attr
    }

    def writesChildNodes(__obj: IPXACT2022ScalaCases.ExternalModeReference, __scope: scala.xml.NamespaceBinding): Seq[scala.xml.Node] =
      Nil

  }

  trait DefaultIPXACT2022ScalaCases_ModeReferenceFormat extends IPXACT2022scalaxb.XMLFormat[IPXACT2022ScalaCases.ModeReference] with IPXACT2022scalaxb.CanWriteChildNodes[IPXACT2022ScalaCases.ModeReference] {
    val targetNamespace: Option[String] = Some("http://www.accellera.org/XMLSchema/IPXACT/1685-2022")
    def reads(seq: scala.xml.NodeSeq, stack: List[IPXACT2022scalaxb.ElemName]): Either[String, IPXACT2022ScalaCases.ModeReference] = seq match {
      case node: scala.xml.Node => Right(IPXACT2022ScalaCases.ModeReference(scala.collection.immutable.ListMap(List(
        (node \ "@modeRef").headOption map { x => IPXACT2022scalaxb.DataRecord(x, node, IPXACT2022scalaxb.fromXML[String](x, IPXACT2022scalaxb.ElemName(node) :: stack)) } map { "@modeRef" -> _ }
        ).flatten[(String, IPXACT2022scalaxb.DataRecord[Any])]: _*)))
      case _ => Left("reads failed: seq must be scala.xml.Node")
    }
    
    override def writesAttribute(__obj: IPXACT2022ScalaCases.ModeReference, __scope: scala.xml.NamespaceBinding): scala.xml.MetaData = {
      var attr: scala.xml.MetaData  = scala.xml.Null
      __obj.attributes.toList map {
        case ("@modeRef", _) => attr = scala.xml.Attribute(null, "modeRef", __obj.modeRef.toString, attr)
        case (key, x) => attr = scala.xml.Attribute((x.namespace map { __scope.getPrefix(_) }).orNull, x.key.orNull, x.value.toString, attr)
      }
      attr
    }

    def writesChildNodes(__obj: IPXACT2022ScalaCases.ModeReference, __scope: scala.xml.NamespaceBinding): Seq[scala.xml.Node] =
      Nil

  }

  trait DefaultIPXACT2022ScalaCases_ModeLinkFormat extends IPXACT2022scalaxb.ElemNameParser[IPXACT2022ScalaCases.ModeLink] {
    val targetNamespace: Option[String] = Some("http://www.accellera.org/XMLSchema/IPXACT/1685-2022")
    
    def parser(node: scala.xml.Node, stack: List[IPXACT2022scalaxb.ElemName]): Parser[IPXACT2022ScalaCases.ModeLink] =
      phrase((IPXACT2022scalaxb.ElemName(Some("http://www.accellera.org/XMLSchema/IPXACT/1685-2022"), "externalModeReference")) ~
      (IPXACT2022scalaxb.ElemName(Some("http://www.accellera.org/XMLSchema/IPXACT/1685-2022"), "modeReference")) ~
      opt(IPXACT2022scalaxb.ElemName(Some("http://www.accellera.org/XMLSchema/IPXACT/1685-2022"), "vendorExtensions")) ^^
      { case p1 ~ p2 ~ p3 =>
      IPXACT2022ScalaCases.ModeLink(IPXACT2022scalaxb.fromXML[IPXACT2022ScalaCases.ExternalModeReference](p1, IPXACT2022scalaxb.ElemName(node) :: stack),
        IPXACT2022scalaxb.fromXML[IPXACT2022ScalaCases.ModeReference](p2, IPXACT2022scalaxb.ElemName(node) :: stack),
        p3.headOption map { IPXACT2022scalaxb.fromXML[IPXACT2022ScalaCases.VendorExtensions](_, IPXACT2022scalaxb.ElemName(node) :: stack) },
        scala.collection.immutable.ListMap(List(
        (node \ "@{http://www.w3.org/XML/1998/namespace}id").headOption map { x => IPXACT2022scalaxb.DataRecord(x, node, IPXACT2022scalaxb.fromXML[String](x, IPXACT2022scalaxb.ElemName(node) :: stack)) } map { "@{http://www.w3.org/XML/1998/namespace}id" -> _ }
        ).flatten[(String, IPXACT2022scalaxb.DataRecord[Any])]: _*)) })
    
    override def writesAttribute(__obj: IPXACT2022ScalaCases.ModeLink, __scope: scala.xml.NamespaceBinding): scala.xml.MetaData = {
      var attr: scala.xml.MetaData  = scala.xml.Null
      __obj.attributes.toList map {
        case ("@{http://www.w3.org/XML/1998/namespace}id", _) => __obj.xmlid foreach { x => attr = scala.xml.Attribute(__scope.getPrefix("http://www.w3.org/XML/1998/namespace"), "id", x.toString, attr) }
        case (key, x) => attr = scala.xml.Attribute((x.namespace map { __scope.getPrefix(_) }).orNull, x.key.orNull, x.value.toString, attr)
      }
      attr
    }

    def writesChildNodes(__obj: IPXACT2022ScalaCases.ModeLink, __scope: scala.xml.NamespaceBinding): Seq[scala.xml.Node] =
      Seq.concat(IPXACT2022scalaxb.toXML[IPXACT2022ScalaCases.ExternalModeReference](__obj.externalModeReference, Some("http://www.accellera.org/XMLSchema/IPXACT/1685-2022"), Some("externalModeReference"), __scope, false),
        IPXACT2022scalaxb.toXML[IPXACT2022ScalaCases.ModeReference](__obj.modeReference, Some("http://www.accellera.org/XMLSchema/IPXACT/1685-2022"), Some("modeReference"), __scope, false),
        __obj.vendorExtensions map { IPXACT2022scalaxb.toXML[IPXACT2022ScalaCases.VendorExtensions](_, Some("http://www.accellera.org/XMLSchema/IPXACT/1685-2022"), Some("vendorExtensions"), __scope, false) } getOrElse {Nil})

  }

  trait DefaultIPXACT2022ScalaCases_ModeLinksFormat extends IPXACT2022scalaxb.ElemNameParser[IPXACT2022ScalaCases.ModeLinks] {
    val targetNamespace: Option[String] = Some("http://www.accellera.org/XMLSchema/IPXACT/1685-2022")
    
    def parser(node: scala.xml.Node, stack: List[IPXACT2022scalaxb.ElemName]): Parser[IPXACT2022ScalaCases.ModeLinks] =
      phrase(safeRep(IPXACT2022scalaxb.ElemName(Some("http://www.accellera.org/XMLSchema/IPXACT/1685-2022"), "modeLink")) ^^
      { case p1 =>
      IPXACT2022ScalaCases.ModeLinks(p1 map { IPXACT2022scalaxb.fromXML[IPXACT2022ScalaCases.ModeLink](_, IPXACT2022scalaxb.ElemName(node) :: stack) }) })
    
    def writesChildNodes(__obj: IPXACT2022ScalaCases.ModeLinks, __scope: scala.xml.NamespaceBinding): Seq[scala.xml.Node] =
      (__obj.modeLink flatMap { IPXACT2022scalaxb.toXML[IPXACT2022ScalaCases.ModeLink](_, Some("http://www.accellera.org/XMLSchema/IPXACT/1685-2022"), Some("modeLink"), __scope, false) })
  }
  trait DefaultIPXACT2022ScalaCases_ExternalViewReferenceFormat extends IPXACT2022scalaxb.XMLFormat[IPXACT2022ScalaCases.ExternalViewReference] with IPXACT2022scalaxb.CanWriteChildNodes[IPXACT2022ScalaCases.ExternalViewReference] {
    val targetNamespace: Option[String] = Some("http://www.accellera.org/XMLSchema/IPXACT/1685-2022")
    def reads(seq: scala.xml.NodeSeq, stack: List[IPXACT2022scalaxb.ElemName]): Either[String, IPXACT2022ScalaCases.ExternalViewReference] = seq match {
      case node: scala.xml.Node => Right(IPXACT2022ScalaCases.ExternalViewReference(scala.collection.immutable.ListMap(List(
        (node \ "@viewRef").headOption map { x => IPXACT2022scalaxb.DataRecord(x, node, IPXACT2022scalaxb.fromXML[String](x, IPXACT2022scalaxb.ElemName(node) :: stack)) } map { "@viewRef" -> _ }
        ).flatten[(String, IPXACT2022scalaxb.DataRecord[Any])]: _*)))
      case _ => Left("reads failed: seq must be scala.xml.Node")
    }
    
    override def writesAttribute(__obj: IPXACT2022ScalaCases.ExternalViewReference, __scope: scala.xml.NamespaceBinding): scala.xml.MetaData = {
      var attr: scala.xml.MetaData  = scala.xml.Null
      __obj.attributes.toList map {
        case ("@viewRef", _) => attr = scala.xml.Attribute(null, "viewRef", __obj.viewRef.toString, attr)
        case (key, x) => attr = scala.xml.Attribute((x.namespace map { __scope.getPrefix(_) }).orNull, x.key.orNull, x.value.toString, attr)
      }
      attr
    }

    def writesChildNodes(__obj: IPXACT2022ScalaCases.ExternalViewReference, __scope: scala.xml.NamespaceBinding): Seq[scala.xml.Node] =
      Nil

  }

  trait DefaultIPXACT2022ScalaCases_ViewReferenceFormat extends IPXACT2022scalaxb.XMLFormat[IPXACT2022ScalaCases.ViewReference] with IPXACT2022scalaxb.CanWriteChildNodes[IPXACT2022ScalaCases.ViewReference] {
    val targetNamespace: Option[String] = Some("http://www.accellera.org/XMLSchema/IPXACT/1685-2022")
    def reads(seq: scala.xml.NodeSeq, stack: List[IPXACT2022scalaxb.ElemName]): Either[String, IPXACT2022ScalaCases.ViewReference] = seq match {
      case node: scala.xml.Node => Right(IPXACT2022ScalaCases.ViewReference(scala.collection.immutable.ListMap(List(
        (node \ "@viewRef").headOption map { x => IPXACT2022scalaxb.DataRecord(x, node, IPXACT2022scalaxb.fromXML[String](x, IPXACT2022scalaxb.ElemName(node) :: stack)) } map { "@viewRef" -> _ }
        ).flatten[(String, IPXACT2022scalaxb.DataRecord[Any])]: _*)))
      case _ => Left("reads failed: seq must be scala.xml.Node")
    }
    
    override def writesAttribute(__obj: IPXACT2022ScalaCases.ViewReference, __scope: scala.xml.NamespaceBinding): scala.xml.MetaData = {
      var attr: scala.xml.MetaData  = scala.xml.Null
      __obj.attributes.toList map {
        case ("@viewRef", _) => attr = scala.xml.Attribute(null, "viewRef", __obj.viewRef.toString, attr)
        case (key, x) => attr = scala.xml.Attribute((x.namespace map { __scope.getPrefix(_) }).orNull, x.key.orNull, x.value.toString, attr)
      }
      attr
    }

    def writesChildNodes(__obj: IPXACT2022ScalaCases.ViewReference, __scope: scala.xml.NamespaceBinding): Seq[scala.xml.Node] =
      Nil

  }

  trait DefaultIPXACT2022ScalaCases_ViewLinkFormat extends IPXACT2022scalaxb.ElemNameParser[IPXACT2022ScalaCases.ViewLink] {
    val targetNamespace: Option[String] = Some("http://www.accellera.org/XMLSchema/IPXACT/1685-2022")
    
    def parser(node: scala.xml.Node, stack: List[IPXACT2022scalaxb.ElemName]): Parser[IPXACT2022ScalaCases.ViewLink] =
      phrase((IPXACT2022scalaxb.ElemName(Some("http://www.accellera.org/XMLSchema/IPXACT/1685-2022"), "externalViewReference")) ~
      (IPXACT2022scalaxb.ElemName(Some("http://www.accellera.org/XMLSchema/IPXACT/1685-2022"), "viewReference")) ~
      opt(IPXACT2022scalaxb.ElemName(Some("http://www.accellera.org/XMLSchema/IPXACT/1685-2022"), "vendorExtensions")) ^^
      { case p1 ~ p2 ~ p3 =>
      IPXACT2022ScalaCases.ViewLink(IPXACT2022scalaxb.fromXML[IPXACT2022ScalaCases.ExternalViewReference](p1, IPXACT2022scalaxb.ElemName(node) :: stack),
        IPXACT2022scalaxb.fromXML[IPXACT2022ScalaCases.ViewReference](p2, IPXACT2022scalaxb.ElemName(node) :: stack),
        p3.headOption map { IPXACT2022scalaxb.fromXML[IPXACT2022ScalaCases.VendorExtensions](_, IPXACT2022scalaxb.ElemName(node) :: stack) },
        scala.collection.immutable.ListMap(List(
        (node \ "@{http://www.w3.org/XML/1998/namespace}id").headOption map { x => IPXACT2022scalaxb.DataRecord(x, node, IPXACT2022scalaxb.fromXML[String](x, IPXACT2022scalaxb.ElemName(node) :: stack)) } map { "@{http://www.w3.org/XML/1998/namespace}id" -> _ }
        ).flatten[(String, IPXACT2022scalaxb.DataRecord[Any])]: _*)) })
    
    override def writesAttribute(__obj: IPXACT2022ScalaCases.ViewLink, __scope: scala.xml.NamespaceBinding): scala.xml.MetaData = {
      var attr: scala.xml.MetaData  = scala.xml.Null
      __obj.attributes.toList map {
        case ("@{http://www.w3.org/XML/1998/namespace}id", _) => __obj.xmlid foreach { x => attr = scala.xml.Attribute(__scope.getPrefix("http://www.w3.org/XML/1998/namespace"), "id", x.toString, attr) }
        case (key, x) => attr = scala.xml.Attribute((x.namespace map { __scope.getPrefix(_) }).orNull, x.key.orNull, x.value.toString, attr)
      }
      attr
    }

    def writesChildNodes(__obj: IPXACT2022ScalaCases.ViewLink, __scope: scala.xml.NamespaceBinding): Seq[scala.xml.Node] =
      Seq.concat(IPXACT2022scalaxb.toXML[IPXACT2022ScalaCases.ExternalViewReference](__obj.externalViewReference, Some("http://www.accellera.org/XMLSchema/IPXACT/1685-2022"), Some("externalViewReference"), __scope, false),
        IPXACT2022scalaxb.toXML[IPXACT2022ScalaCases.ViewReference](__obj.viewReference, Some("http://www.accellera.org/XMLSchema/IPXACT/1685-2022"), Some("viewReference"), __scope, false),
        __obj.vendorExtensions map { IPXACT2022scalaxb.toXML[IPXACT2022ScalaCases.VendorExtensions](_, Some("http://www.accellera.org/XMLSchema/IPXACT/1685-2022"), Some("vendorExtensions"), __scope, false) } getOrElse {Nil})

  }

  trait DefaultIPXACT2022ScalaCases_ViewLinksFormat extends IPXACT2022scalaxb.ElemNameParser[IPXACT2022ScalaCases.ViewLinks] {
    val targetNamespace: Option[String] = Some("http://www.accellera.org/XMLSchema/IPXACT/1685-2022")
    
    def parser(node: scala.xml.Node, stack: List[IPXACT2022scalaxb.ElemName]): Parser[IPXACT2022ScalaCases.ViewLinks] =
      phrase(safeRep(IPXACT2022scalaxb.ElemName(Some("http://www.accellera.org/XMLSchema/IPXACT/1685-2022"), "viewLink")) ^^
      { case p1 =>
      IPXACT2022ScalaCases.ViewLinks(p1 map { IPXACT2022scalaxb.fromXML[IPXACT2022ScalaCases.ViewLink](_, IPXACT2022scalaxb.ElemName(node) :: stack) }) })
    
    def writesChildNodes(__obj: IPXACT2022ScalaCases.ViewLinks, __scope: scala.xml.NamespaceBinding): Seq[scala.xml.Node] =
      (__obj.viewLink flatMap { IPXACT2022scalaxb.toXML[IPXACT2022ScalaCases.ViewLink](_, Some("http://www.accellera.org/XMLSchema/IPXACT/1685-2022"), Some("viewLink"), __scope, false) })
  }
  trait DefaultIPXACT2022ScalaCases_ExternalResetTypeReferenceFormat extends IPXACT2022scalaxb.XMLFormat[IPXACT2022ScalaCases.ExternalResetTypeReference] with IPXACT2022scalaxb.CanWriteChildNodes[IPXACT2022ScalaCases.ExternalResetTypeReference] {
    val targetNamespace: Option[String] = Some("http://www.accellera.org/XMLSchema/IPXACT/1685-2022")
    def reads(seq: scala.xml.NodeSeq, stack: List[IPXACT2022scalaxb.ElemName]): Either[String, IPXACT2022ScalaCases.ExternalResetTypeReference] = seq match {
      case node: scala.xml.Node => Right(IPXACT2022ScalaCases.ExternalResetTypeReference(scala.collection.immutable.ListMap(List(
        (node \ "@resetTypeRef").headOption map { x => IPXACT2022scalaxb.DataRecord(x, node, IPXACT2022scalaxb.fromXML[String](x, IPXACT2022scalaxb.ElemName(node) :: stack)) } map { "@resetTypeRef" -> _ }
        ).flatten[(String, IPXACT2022scalaxb.DataRecord[Any])]: _*)))
      case _ => Left("reads failed: seq must be scala.xml.Node")
    }
    
    override def writesAttribute(__obj: IPXACT2022ScalaCases.ExternalResetTypeReference, __scope: scala.xml.NamespaceBinding): scala.xml.MetaData = {
      var attr: scala.xml.MetaData  = scala.xml.Null
      __obj.attributes.toList map {
        case ("@resetTypeRef", _) => attr = scala.xml.Attribute(null, "resetTypeRef", __obj.resetTypeRef.toString, attr)
        case (key, x) => attr = scala.xml.Attribute((x.namespace map { __scope.getPrefix(_) }).orNull, x.key.orNull, x.value.toString, attr)
      }
      attr
    }

    def writesChildNodes(__obj: IPXACT2022ScalaCases.ExternalResetTypeReference, __scope: scala.xml.NamespaceBinding): Seq[scala.xml.Node] =
      Nil

  }

  trait DefaultIPXACT2022ScalaCases_ResetTypeReferenceFormat extends IPXACT2022scalaxb.XMLFormat[IPXACT2022ScalaCases.ResetTypeReference] with IPXACT2022scalaxb.CanWriteChildNodes[IPXACT2022ScalaCases.ResetTypeReference] {
    val targetNamespace: Option[String] = Some("http://www.accellera.org/XMLSchema/IPXACT/1685-2022")
    def reads(seq: scala.xml.NodeSeq, stack: List[IPXACT2022scalaxb.ElemName]): Either[String, IPXACT2022ScalaCases.ResetTypeReference] = seq match {
      case node: scala.xml.Node => Right(IPXACT2022ScalaCases.ResetTypeReference(scala.collection.immutable.ListMap(List(
        (node \ "@resetTypeRef").headOption map { x => IPXACT2022scalaxb.DataRecord(x, node, IPXACT2022scalaxb.fromXML[String](x, IPXACT2022scalaxb.ElemName(node) :: stack)) } map { "@resetTypeRef" -> _ }
        ).flatten[(String, IPXACT2022scalaxb.DataRecord[Any])]: _*)))
      case _ => Left("reads failed: seq must be scala.xml.Node")
    }
    
    override def writesAttribute(__obj: IPXACT2022ScalaCases.ResetTypeReference, __scope: scala.xml.NamespaceBinding): scala.xml.MetaData = {
      var attr: scala.xml.MetaData  = scala.xml.Null
      __obj.attributes.toList map {
        case ("@resetTypeRef", _) => attr = scala.xml.Attribute(null, "resetTypeRef", __obj.resetTypeRef.toString, attr)
        case (key, x) => attr = scala.xml.Attribute((x.namespace map { __scope.getPrefix(_) }).orNull, x.key.orNull, x.value.toString, attr)
      }
      attr
    }

    def writesChildNodes(__obj: IPXACT2022ScalaCases.ResetTypeReference, __scope: scala.xml.NamespaceBinding): Seq[scala.xml.Node] =
      Nil

  }

  trait DefaultIPXACT2022ScalaCases_ResetTypeLinkFormat extends IPXACT2022scalaxb.ElemNameParser[IPXACT2022ScalaCases.ResetTypeLink] {
    val targetNamespace: Option[String] = Some("http://www.accellera.org/XMLSchema/IPXACT/1685-2022")
    
    def parser(node: scala.xml.Node, stack: List[IPXACT2022scalaxb.ElemName]): Parser[IPXACT2022ScalaCases.ResetTypeLink] =
      phrase((IPXACT2022scalaxb.ElemName(Some("http://www.accellera.org/XMLSchema/IPXACT/1685-2022"), "externalResetTypeReference")) ~
      (IPXACT2022scalaxb.ElemName(Some("http://www.accellera.org/XMLSchema/IPXACT/1685-2022"), "resetTypeReference")) ~
      opt(IPXACT2022scalaxb.ElemName(Some("http://www.accellera.org/XMLSchema/IPXACT/1685-2022"), "vendorExtensions")) ^^
      { case p1 ~ p2 ~ p3 =>
      IPXACT2022ScalaCases.ResetTypeLink(IPXACT2022scalaxb.fromXML[IPXACT2022ScalaCases.ExternalResetTypeReference](p1, IPXACT2022scalaxb.ElemName(node) :: stack),
        IPXACT2022scalaxb.fromXML[IPXACT2022ScalaCases.ResetTypeReference](p2, IPXACT2022scalaxb.ElemName(node) :: stack),
        p3.headOption map { IPXACT2022scalaxb.fromXML[IPXACT2022ScalaCases.VendorExtensions](_, IPXACT2022scalaxb.ElemName(node) :: stack) },
        scala.collection.immutable.ListMap(List(
        (node \ "@{http://www.w3.org/XML/1998/namespace}id").headOption map { x => IPXACT2022scalaxb.DataRecord(x, node, IPXACT2022scalaxb.fromXML[String](x, IPXACT2022scalaxb.ElemName(node) :: stack)) } map { "@{http://www.w3.org/XML/1998/namespace}id" -> _ }
        ).flatten[(String, IPXACT2022scalaxb.DataRecord[Any])]: _*)) })
    
    override def writesAttribute(__obj: IPXACT2022ScalaCases.ResetTypeLink, __scope: scala.xml.NamespaceBinding): scala.xml.MetaData = {
      var attr: scala.xml.MetaData  = scala.xml.Null
      __obj.attributes.toList map {
        case ("@{http://www.w3.org/XML/1998/namespace}id", _) => __obj.xmlid foreach { x => attr = scala.xml.Attribute(__scope.getPrefix("http://www.w3.org/XML/1998/namespace"), "id", x.toString, attr) }
        case (key, x) => attr = scala.xml.Attribute((x.namespace map { __scope.getPrefix(_) }).orNull, x.key.orNull, x.value.toString, attr)
      }
      attr
    }

    def writesChildNodes(__obj: IPXACT2022ScalaCases.ResetTypeLink, __scope: scala.xml.NamespaceBinding): Seq[scala.xml.Node] =
      Seq.concat(IPXACT2022scalaxb.toXML[IPXACT2022ScalaCases.ExternalResetTypeReference](__obj.externalResetTypeReference, Some("http://www.accellera.org/XMLSchema/IPXACT/1685-2022"), Some("externalResetTypeReference"), __scope, false),
        IPXACT2022scalaxb.toXML[IPXACT2022ScalaCases.ResetTypeReference](__obj.resetTypeReference, Some("http://www.accellera.org/XMLSchema/IPXACT/1685-2022"), Some("resetTypeReference"), __scope, false),
        __obj.vendorExtensions map { IPXACT2022scalaxb.toXML[IPXACT2022ScalaCases.VendorExtensions](_, Some("http://www.accellera.org/XMLSchema/IPXACT/1685-2022"), Some("vendorExtensions"), __scope, false) } getOrElse {Nil})

  }

  trait DefaultIPXACT2022ScalaCases_ResetTypeLinksFormat extends IPXACT2022scalaxb.ElemNameParser[IPXACT2022ScalaCases.ResetTypeLinks] {
    val targetNamespace: Option[String] = Some("http://www.accellera.org/XMLSchema/IPXACT/1685-2022")
    
    def parser(node: scala.xml.Node, stack: List[IPXACT2022scalaxb.ElemName]): Parser[IPXACT2022ScalaCases.ResetTypeLinks] =
      phrase(safeRep(IPXACT2022scalaxb.ElemName(Some("http://www.accellera.org/XMLSchema/IPXACT/1685-2022"), "resetTypeLink")) ^^
      { case p1 =>
      IPXACT2022ScalaCases.ResetTypeLinks(p1 map { IPXACT2022scalaxb.fromXML[IPXACT2022ScalaCases.ResetTypeLink](_, IPXACT2022scalaxb.ElemName(node) :: stack) }) })
    
    def writesChildNodes(__obj: IPXACT2022ScalaCases.ResetTypeLinks, __scope: scala.xml.NamespaceBinding): Seq[scala.xml.Node] =
      (__obj.resetTypeLink flatMap { IPXACT2022scalaxb.toXML[IPXACT2022ScalaCases.ResetTypeLink](_, Some("http://www.accellera.org/XMLSchema/IPXACT/1685-2022"), Some("resetTypeLink"), __scope, false) })
  }
  trait DefaultIPXACT2022ScalaCases_Index2Format extends IPXACT2022scalaxb.XMLFormat[IPXACT2022ScalaCases.Index2] with IPXACT2022scalaxb.CanWriteChildNodes[IPXACT2022ScalaCases.Index2] {
    val targetNamespace: Option[String] = Some("http://www.accellera.org/XMLSchema/IPXACT/1685-2022")
    def reads(seq: scala.xml.NodeSeq, stack: List[IPXACT2022scalaxb.ElemName]): Either[String, IPXACT2022ScalaCases.Index2] = seq match {
      case node: scala.xml.Node => Right(IPXACT2022ScalaCases.Index2(IPXACT2022scalaxb.fromXML[String](node, IPXACT2022scalaxb.ElemName(node) :: stack),
        scala.collection.immutable.ListMap(List(
        (node \ "@minimum").headOption map { x => IPXACT2022scalaxb.DataRecord(x, node, IPXACT2022scalaxb.fromXML[Int](x, IPXACT2022scalaxb.ElemName(node) :: stack)) } map { "@minimum" -> _ },
        (node \ "@maximum").headOption map { x => IPXACT2022scalaxb.DataRecord(x, node, IPXACT2022scalaxb.fromXML[Int](x, IPXACT2022scalaxb.ElemName(node) :: stack)) } map { "@maximum" -> _ },
        (node \ "@{http://www.w3.org/XML/1998/namespace}id").headOption map { x => IPXACT2022scalaxb.DataRecord(x, node, IPXACT2022scalaxb.fromXML[String](x, IPXACT2022scalaxb.ElemName(node) :: stack)) } map { "@{http://www.w3.org/XML/1998/namespace}id" -> _ }
        ).flatten[(String, IPXACT2022scalaxb.DataRecord[Any])] ::: (node match {
          case elem: scala.xml.Elem =>
            elem.attributes.toList flatMap {
              case scala.xml.UnprefixedAttribute(key, value, _) if key == "minimum" => Nil
              case scala.xml.UnprefixedAttribute(key, value, _) if key == "maximum" => Nil
              case scala.xml.PrefixedAttribute(pre, key, value, _) if pre == elem.scope.getPrefix("http://www.w3.org/XML/1998/namespace") &&
                key == "id" => Nil
              case scala.xml.UnprefixedAttribute(key, value, _) =>
                List(("@" + key, IPXACT2022scalaxb.DataRecord(None, Some(key), value.text)))
              case scala.xml.PrefixedAttribute(pre, key, value, _) =>
                val ns = elem.scope.getURI(pre)
                List(("@{" + ns + "}" + key, IPXACT2022scalaxb.DataRecord(Option[String](ns), Some(key), value.text)))
              case _ => Nil
            }
          case _ => Nil
        }): _*)))
      case _ => Left("reads failed: seq must be scala.xml.Node")
    }
    
    override def writesAttribute(__obj: IPXACT2022ScalaCases.Index2, __scope: scala.xml.NamespaceBinding): scala.xml.MetaData = {
      var attr: scala.xml.MetaData  = scala.xml.Null
      __obj.attributes.toList map {
        case ("@minimum", _) => __obj.minimum foreach { x => attr = scala.xml.Attribute(null, "minimum", x.toString, attr) }
        case ("@maximum", _) => __obj.maximum foreach { x => attr = scala.xml.Attribute(null, "maximum", x.toString, attr) }
        case ("@{http://www.w3.org/XML/1998/namespace}id", _) => __obj.xmlid foreach { x => attr = scala.xml.Attribute(__scope.getPrefix("http://www.w3.org/XML/1998/namespace"), "id", x.toString, attr) }
        case (key, x) => attr = scala.xml.Attribute((x.namespace map { __scope.getPrefix(_) }).orNull, x.key.orNull, x.value.toString, attr)
      }
      attr
    }

    def writesChildNodes(__obj: IPXACT2022ScalaCases.Index2, __scope: scala.xml.NamespaceBinding): Seq[scala.xml.Node] =
      Seq(scala.xml.Text(__obj.value.toString))

  }

  def buildIPXACT2022ScalaCases_PrefixFormat = new DefaultIPXACT2022ScalaCases_PrefixFormat {}
  trait DefaultIPXACT2022ScalaCases_PrefixFormat extends IPXACT2022scalaxb.XMLFormat[IPXACT2022ScalaCases.Prefix] {
    val targetNamespace: Option[String] = Some("http://www.accellera.org/XMLSchema/IPXACT/1685-2022")
    
    def fromString(value: String, scope: scala.xml.NamespaceBinding): IPXACT2022ScalaCases.Prefix =
        (fromString0(value, scope)).apply(IPXACT2022scalaxb.fromXML[String](scala.xml.Text(value)))

    private def fromString0(value: String, scope: scala.xml.NamespaceBinding): PartialFunction[Any, IPXACT2022ScalaCases.Prefix] = {
      case x: String if x == IPXACT2022scalaxb.fromXML[String](scala.xml.Text("deca")) => IPXACT2022ScalaCases.Deca
      case x: String if x == IPXACT2022scalaxb.fromXML[String](scala.xml.Text("hecto")) => IPXACT2022ScalaCases.Hecto
      case x: String if x == IPXACT2022scalaxb.fromXML[String](scala.xml.Text("kilo")) => IPXACT2022ScalaCases.Kilo
      case x: String if x == IPXACT2022scalaxb.fromXML[String](scala.xml.Text("mega")) => IPXACT2022ScalaCases.Mega
      case x: String if x == IPXACT2022scalaxb.fromXML[String](scala.xml.Text("giga")) => IPXACT2022ScalaCases.Giga
      case x: String if x == IPXACT2022scalaxb.fromXML[String](scala.xml.Text("tera")) => IPXACT2022ScalaCases.Tera
      case x: String if x == IPXACT2022scalaxb.fromXML[String](scala.xml.Text("peta")) => IPXACT2022ScalaCases.Peta
      case x: String if x == IPXACT2022scalaxb.fromXML[String](scala.xml.Text("exa")) => IPXACT2022ScalaCases.Exa
      case x: String if x == IPXACT2022scalaxb.fromXML[String](scala.xml.Text("zetta")) => IPXACT2022ScalaCases.Zetta
      case x: String if x == IPXACT2022scalaxb.fromXML[String](scala.xml.Text("yotta")) => IPXACT2022ScalaCases.Yotta
      case x: String if x == IPXACT2022scalaxb.fromXML[String](scala.xml.Text("deci")) => IPXACT2022ScalaCases.Deci
      case x: String if x == IPXACT2022scalaxb.fromXML[String](scala.xml.Text("centi")) => IPXACT2022ScalaCases.Centi
      case x: String if x == IPXACT2022scalaxb.fromXML[String](scala.xml.Text("milli")) => IPXACT2022ScalaCases.Milli
      case x: String if x == IPXACT2022scalaxb.fromXML[String](scala.xml.Text("micro")) => IPXACT2022ScalaCases.Micro
      case x: String if x == IPXACT2022scalaxb.fromXML[String](scala.xml.Text("nano")) => IPXACT2022ScalaCases.Nano
      case x: String if x == IPXACT2022scalaxb.fromXML[String](scala.xml.Text("pico")) => IPXACT2022ScalaCases.Pico
      case x: String if x == IPXACT2022scalaxb.fromXML[String](scala.xml.Text("femto")) => IPXACT2022ScalaCases.Femto
      case x: String if x == IPXACT2022scalaxb.fromXML[String](scala.xml.Text("atto")) => IPXACT2022ScalaCases.Atto
      case x: String if x == IPXACT2022scalaxb.fromXML[String](scala.xml.Text("zepto")) => IPXACT2022ScalaCases.Zepto
      case x: String if x == IPXACT2022scalaxb.fromXML[String](scala.xml.Text("yocto")) => IPXACT2022ScalaCases.Yocto

    }



    def reads(seq: scala.xml.NodeSeq, stack: List[IPXACT2022scalaxb.ElemName]): Either[String, IPXACT2022ScalaCases.Prefix] = seq match {
      case elem: scala.xml.Elem => Right(fromString(elem.text, elem.scope))
      case _ => Right(fromString(seq.text, scala.xml.TopScope))
    }
    
    def writes(__obj: IPXACT2022ScalaCases.Prefix, __namespace: Option[String], __elementLabel: Option[String],
        __scope: scala.xml.NamespaceBinding, __typeAttribute: Boolean): scala.xml.NodeSeq =
      scala.xml.Elem(IPXACT2022scalaxb.Helper.getPrefix(__namespace, __scope).orNull,
        __elementLabel getOrElse { sys.error("missing element label.") },
        scala.xml.Null, __scope, true, scala.xml.Text(__obj.toString))
  }
  def buildIPXACT2022ScalaCases_UnitTypeFormat = new DefaultIPXACT2022ScalaCases_UnitTypeFormat {}
  trait DefaultIPXACT2022ScalaCases_UnitTypeFormat extends IPXACT2022scalaxb.XMLFormat[IPXACT2022ScalaCases.UnitType] {
    val targetNamespace: Option[String] = Some("http://www.accellera.org/XMLSchema/IPXACT/1685-2022")
    
    def fromString(value: String, scope: scala.xml.NamespaceBinding): IPXACT2022ScalaCases.UnitType =
        (fromString0(value, scope)).apply(IPXACT2022scalaxb.fromXML[String](scala.xml.Text(value)))

    private def fromString0(value: String, scope: scala.xml.NamespaceBinding): PartialFunction[Any, IPXACT2022ScalaCases.UnitType] = {
      case x: String if x == IPXACT2022scalaxb.fromXML[String](scala.xml.Text("second")) => IPXACT2022ScalaCases.Second
      case x: String if x == IPXACT2022scalaxb.fromXML[String](scala.xml.Text("ampere")) => IPXACT2022ScalaCases.Ampere
      case x: String if x == IPXACT2022scalaxb.fromXML[String](scala.xml.Text("kelvin")) => IPXACT2022ScalaCases.Kelvin
      case x: String if x == IPXACT2022scalaxb.fromXML[String](scala.xml.Text("hertz")) => IPXACT2022ScalaCases.Hertz
      case x: String if x == IPXACT2022scalaxb.fromXML[String](scala.xml.Text("joule")) => IPXACT2022ScalaCases.Joule
      case x: String if x == IPXACT2022scalaxb.fromXML[String](scala.xml.Text("watt")) => IPXACT2022ScalaCases.Watt
      case x: String if x == IPXACT2022scalaxb.fromXML[String](scala.xml.Text("coulomb")) => IPXACT2022ScalaCases.Coulomb
      case x: String if x == IPXACT2022scalaxb.fromXML[String](scala.xml.Text("volt")) => IPXACT2022ScalaCases.Volt
      case x: String if x == IPXACT2022scalaxb.fromXML[String](scala.xml.Text("farad")) => IPXACT2022ScalaCases.Farad
      case x: String if x == IPXACT2022scalaxb.fromXML[String](scala.xml.Text("ohm")) => IPXACT2022ScalaCases.Ohm
      case x: String if x == IPXACT2022scalaxb.fromXML[String](scala.xml.Text("siemens")) => IPXACT2022ScalaCases.Siemens
      case x: String if x == IPXACT2022scalaxb.fromXML[String](scala.xml.Text("henry")) => IPXACT2022ScalaCases.Henry
      case x: String if x == IPXACT2022scalaxb.fromXML[String](scala.xml.Text("Celsius")) => IPXACT2022ScalaCases.Celsius

    }



    def reads(seq: scala.xml.NodeSeq, stack: List[IPXACT2022scalaxb.ElemName]): Either[String, IPXACT2022ScalaCases.UnitType] = seq match {
      case elem: scala.xml.Elem => Right(fromString(elem.text, elem.scope))
      case _ => Right(fromString(seq.text, scala.xml.TopScope))
    }
    
    def writes(__obj: IPXACT2022ScalaCases.UnitType, __namespace: Option[String], __elementLabel: Option[String],
        __scope: scala.xml.NamespaceBinding, __typeAttribute: Boolean): scala.xml.NodeSeq =
      scala.xml.Elem(IPXACT2022scalaxb.Helper.getPrefix(__namespace, __scope).orNull,
        __elementLabel getOrElse { sys.error("missing element label.") },
        scala.xml.Null, __scope, true, scala.xml.Text(__obj.toString))
  }
  def buildIPXACT2022ScalaCases_UnitTypeTypeFormat = new DefaultIPXACT2022ScalaCases_UnitTypeTypeFormat {}
  trait DefaultIPXACT2022ScalaCases_UnitTypeTypeFormat extends IPXACT2022scalaxb.XMLFormat[IPXACT2022ScalaCases.UnitTypeType] {
    val targetNamespace: Option[String] = Some("http://www.accellera.org/XMLSchema/IPXACT/1685-2022")
    
    def fromString(value: String, scope: scala.xml.NamespaceBinding): IPXACT2022ScalaCases.UnitTypeType =
        (fromString0(value, scope)).apply(IPXACT2022scalaxb.fromXML[String](scala.xml.Text(value)))

    private def fromString0(value: String, scope: scala.xml.NamespaceBinding): PartialFunction[Any, IPXACT2022ScalaCases.UnitTypeType] = {
      case x: String if x == IPXACT2022scalaxb.fromXML[String](scala.xml.Text("second")) => IPXACT2022ScalaCases.SecondValue
      case x: String if x == IPXACT2022scalaxb.fromXML[String](scala.xml.Text("ampere")) => IPXACT2022ScalaCases.AmpereValue
      case x: String if x == IPXACT2022scalaxb.fromXML[String](scala.xml.Text("kelvin")) => IPXACT2022ScalaCases.KelvinValue
      case x: String if x == IPXACT2022scalaxb.fromXML[String](scala.xml.Text("hertz")) => IPXACT2022ScalaCases.HertzValue
      case x: String if x == IPXACT2022scalaxb.fromXML[String](scala.xml.Text("joule")) => IPXACT2022ScalaCases.JouleValue
      case x: String if x == IPXACT2022scalaxb.fromXML[String](scala.xml.Text("watt")) => IPXACT2022ScalaCases.WattValue
      case x: String if x == IPXACT2022scalaxb.fromXML[String](scala.xml.Text("coulomb")) => IPXACT2022ScalaCases.CoulombValue
      case x: String if x == IPXACT2022scalaxb.fromXML[String](scala.xml.Text("volt")) => IPXACT2022ScalaCases.VoltValue
      case x: String if x == IPXACT2022scalaxb.fromXML[String](scala.xml.Text("farad")) => IPXACT2022ScalaCases.FaradValue
      case x: String if x == IPXACT2022scalaxb.fromXML[String](scala.xml.Text("ohm")) => IPXACT2022ScalaCases.OhmValue
      case x: String if x == IPXACT2022scalaxb.fromXML[String](scala.xml.Text("siemens")) => IPXACT2022ScalaCases.SiemensValue
      case x: String if x == IPXACT2022scalaxb.fromXML[String](scala.xml.Text("henry")) => IPXACT2022ScalaCases.HenryValue
      case x: String if x == IPXACT2022scalaxb.fromXML[String](scala.xml.Text("Celsius")) => IPXACT2022ScalaCases.CelsiusValue

    }



    def reads(seq: scala.xml.NodeSeq, stack: List[IPXACT2022scalaxb.ElemName]): Either[String, IPXACT2022ScalaCases.UnitTypeType] = seq match {
      case elem: scala.xml.Elem => Right(fromString(elem.text, elem.scope))
      case _ => Right(fromString(seq.text, scala.xml.TopScope))
    }
    
    def writes(__obj: IPXACT2022ScalaCases.UnitTypeType, __namespace: Option[String], __elementLabel: Option[String],
        __scope: scala.xml.NamespaceBinding, __typeAttribute: Boolean): scala.xml.NodeSeq =
      scala.xml.Elem(IPXACT2022scalaxb.Helper.getPrefix(__namespace, __scope).orNull,
        __elementLabel getOrElse { sys.error("missing element label.") },
        scala.xml.Null, __scope, true, scala.xml.Text(__obj.toString))
  }
  def buildIPXACT2022ScalaCases_ResolveFormat = new DefaultIPXACT2022ScalaCases_ResolveFormat {}
  trait DefaultIPXACT2022ScalaCases_ResolveFormat extends IPXACT2022scalaxb.XMLFormat[IPXACT2022ScalaCases.Resolve] {
    val targetNamespace: Option[String] = Some("http://www.accellera.org/XMLSchema/IPXACT/1685-2022")
    
    def fromString(value: String, scope: scala.xml.NamespaceBinding): IPXACT2022ScalaCases.Resolve =
        (fromString0(value, scope)).apply(IPXACT2022scalaxb.fromXML[String](scala.xml.Text(value)))

    private def fromString0(value: String, scope: scala.xml.NamespaceBinding): PartialFunction[Any, IPXACT2022ScalaCases.Resolve] = {
      case x: String if x == IPXACT2022scalaxb.fromXML[String](scala.xml.Text("immediate")) => IPXACT2022ScalaCases.Immediate
      case x: String if x == IPXACT2022scalaxb.fromXML[String](scala.xml.Text("user")) => IPXACT2022ScalaCases.UserValue2
      case x: String if x == IPXACT2022scalaxb.fromXML[String](scala.xml.Text("generated")) => IPXACT2022ScalaCases.Generated

    }



    def reads(seq: scala.xml.NodeSeq, stack: List[IPXACT2022scalaxb.ElemName]): Either[String, IPXACT2022ScalaCases.Resolve] = seq match {
      case elem: scala.xml.Elem => Right(fromString(elem.text, elem.scope))
      case _ => Right(fromString(seq.text, scala.xml.TopScope))
    }
    
    def writes(__obj: IPXACT2022ScalaCases.Resolve, __namespace: Option[String], __elementLabel: Option[String],
        __scope: scala.xml.NamespaceBinding, __typeAttribute: Boolean): scala.xml.NodeSeq =
      scala.xml.Elem(IPXACT2022scalaxb.Helper.getPrefix(__namespace, __scope).orNull,
        __elementLabel getOrElse { sys.error("missing element label.") },
        scala.xml.Null, __scope, true, scala.xml.Text(__obj.toString))
  }

/** A group of elements for name(xs:string), displayName and description
*/
  trait IPXACT2022ScalaCases_NameGroupStringGroupFormat extends IPXACT2022scalaxb.AnyElemNameParser {
    def parseNameGroupStringGroup(node: scala.xml.Node, stack: List[IPXACT2022scalaxb.ElemName]): Parser[IPXACT2022ScalaCases.NameGroupStringSequence] =
      (((IPXACT2022scalaxb.ElemName(Some("http://www.accellera.org/XMLSchema/IPXACT/1685-2022"), "name")) ~
      opt(IPXACT2022scalaxb.ElemName(Some("http://www.accellera.org/XMLSchema/IPXACT/1685-2022"), "displayName")) ~
      opt(IPXACT2022scalaxb.ElemName(Some("http://www.accellera.org/XMLSchema/IPXACT/1685-2022"), "shortDescription")) ~
      opt(IPXACT2022scalaxb.ElemName(Some("http://www.accellera.org/XMLSchema/IPXACT/1685-2022"), "description"))) ^^
        { case p1 ~ p2 ~ p3 ~ p4 => IPXACT2022ScalaCases.NameGroupStringSequence(IPXACT2022scalaxb.fromXML[String](p1, IPXACT2022scalaxb.ElemName(node) :: stack),
        p2.headOption map { IPXACT2022scalaxb.fromXML[String](_, IPXACT2022scalaxb.ElemName(node) :: stack) },
        p3.headOption map { IPXACT2022scalaxb.fromXML[String](_, IPXACT2022scalaxb.ElemName(node) :: stack) },
        p4.headOption map { IPXACT2022scalaxb.fromXML[String](_, IPXACT2022scalaxb.ElemName(node) :: stack) }) })
  
    def parseNameGroupStringGroup(node: scala.xml.Node, stack: List[IPXACT2022scalaxb.ElemName], wrap: Boolean): Parser[IPXACT2022scalaxb.DataRecord[Any]] =
      (((IPXACT2022scalaxb.ElemName(Some("http://www.accellera.org/XMLSchema/IPXACT/1685-2022"), "name")) ~
      opt(IPXACT2022scalaxb.ElemName(Some("http://www.accellera.org/XMLSchema/IPXACT/1685-2022"), "displayName")) ~
      opt(IPXACT2022scalaxb.ElemName(Some("http://www.accellera.org/XMLSchema/IPXACT/1685-2022"), "shortDescription")) ~
      opt(IPXACT2022scalaxb.ElemName(Some("http://www.accellera.org/XMLSchema/IPXACT/1685-2022"), "description"))) ^^
        { case p1 ~ p2 ~ p3 ~ p4 => IPXACT2022scalaxb.DataRecord(IPXACT2022ScalaCases.NameGroupStringSequence(IPXACT2022scalaxb.fromXML[String](p1, IPXACT2022scalaxb.ElemName(node) :: stack),
        p2.headOption map { IPXACT2022scalaxb.fromXML[String](_, IPXACT2022scalaxb.ElemName(node) :: stack) },
        p3.headOption map { IPXACT2022scalaxb.fromXML[String](_, IPXACT2022scalaxb.ElemName(node) :: stack) },
        p4.headOption map { IPXACT2022scalaxb.fromXML[String](_, IPXACT2022scalaxb.ElemName(node) :: stack) })) })
    
    def parsemixedNameGroupStringGroup(node: scala.xml.Node, stack: List[IPXACT2022scalaxb.ElemName]): Parser[Seq[IPXACT2022scalaxb.DataRecord[Any]]] =
      ((((IPXACT2022scalaxb.ElemName(Some("http://www.accellera.org/XMLSchema/IPXACT/1685-2022"), "name")) ^^
      (x => IPXACT2022scalaxb.DataRecord(x.namespace, Some(x.name), IPXACT2022scalaxb.fromXML[String](x, IPXACT2022scalaxb.ElemName(node) :: stack)))) ~
      optTextRecord ~ 
      (opt(IPXACT2022scalaxb.ElemName(Some("http://www.accellera.org/XMLSchema/IPXACT/1685-2022"), "displayName")) ^^
      (_ map { x => IPXACT2022scalaxb.DataRecord(x.namespace, Some(x.name), IPXACT2022scalaxb.fromXML[String](x, IPXACT2022scalaxb.ElemName(node) :: stack)) })) ~
      optTextRecord ~ 
      (opt(IPXACT2022scalaxb.ElemName(Some("http://www.accellera.org/XMLSchema/IPXACT/1685-2022"), "shortDescription")) ^^
      (_ map { x => IPXACT2022scalaxb.DataRecord(x.namespace, Some(x.name), IPXACT2022scalaxb.fromXML[String](x, IPXACT2022scalaxb.ElemName(node) :: stack)) })) ~
      optTextRecord ~ 
      (opt(IPXACT2022scalaxb.ElemName(Some("http://www.accellera.org/XMLSchema/IPXACT/1685-2022"), "description")) ^^
      (_ map { x => IPXACT2022scalaxb.DataRecord(x.namespace, Some(x.name), IPXACT2022scalaxb.fromXML[String](x, IPXACT2022scalaxb.ElemName(node) :: stack)) })) ~
      optTextRecord) ^^ 
        { case p1 ~ p2 ~ p3 ~ p4 ~ p5 ~ p6 ~ p7 ~ p8 => Seq.concat(Seq(p1),
        p2.toList,
        p3.toList,
        p4.toList,
        p5.toList,
        p6.toList,
        p7.toList,
        p8.toList) })
  }

  trait DefaultIPXACT2022ScalaCases_NameGroupStringSequenceFormat extends IPXACT2022scalaxb.XMLFormat[IPXACT2022ScalaCases.NameGroupStringSequence] {
    def reads(seq: scala.xml.NodeSeq, stack: List[IPXACT2022scalaxb.ElemName]): Either[String, IPXACT2022ScalaCases.NameGroupStringSequence] = Left("don't call me.")
    
    def writes(__obj: IPXACT2022ScalaCases.NameGroupStringSequence, __namespace: Option[String], __elementLabel: Option[String],
        __scope: scala.xml.NamespaceBinding, __typeAttribute: Boolean): scala.xml.NodeSeq =
      Seq.concat(IPXACT2022scalaxb.toXML[String](__obj.name, Some("http://www.accellera.org/XMLSchema/IPXACT/1685-2022"), Some("name"), __scope, false),
        __obj.displayName map { IPXACT2022scalaxb.toXML[String](_, Some("http://www.accellera.org/XMLSchema/IPXACT/1685-2022"), Some("displayName"), __scope, false) } getOrElse {Nil},
        __obj.shortDescription map { IPXACT2022scalaxb.toXML[String](_, Some("http://www.accellera.org/XMLSchema/IPXACT/1685-2022"), Some("shortDescription"), __scope, false) } getOrElse {Nil},
        __obj.description map { IPXACT2022scalaxb.toXML[String](_, Some("http://www.accellera.org/XMLSchema/IPXACT/1685-2022"), Some("description"), __scope, false) } getOrElse {Nil})


  }


  trait IPXACT2022ScalaCases_FieldSliceReferenceGroupGroupFormat extends IPXACT2022scalaxb.AnyElemNameParser {
    def parseFieldSliceReferenceGroupGroup(node: scala.xml.Node, stack: List[IPXACT2022scalaxb.ElemName]): Parser[IPXACT2022ScalaCases.FieldSliceReferenceGroupSequence] =
      (((((IPXACT2022scalaxb.ElemName(Some("http://www.accellera.org/XMLSchema/IPXACT/1685-2022"), "addressSpaceRef")) ^^
      (x => IPXACT2022scalaxb.DataRecord(x.namespace, Some(x.name), IPXACT2022scalaxb.fromXML[IPXACT2022ScalaCases.AddressSpaceRef](x, IPXACT2022scalaxb.ElemName(node) :: stack)))) |||
      (((IPXACT2022scalaxb.ElemName(Some("http://www.accellera.org/XMLSchema/IPXACT/1685-2022"), "memoryMapRef")) ~
      opt(IPXACT2022scalaxb.ElemName(Some("http://www.accellera.org/XMLSchema/IPXACT/1685-2022"), "memoryRemapRef"))) ^^
        { case p1 ~ p2 => IPXACT2022scalaxb.DataRecord(IPXACT2022ScalaCases.FieldSliceReferenceGroupSequence2(IPXACT2022scalaxb.fromXML[IPXACT2022ScalaCases.MemoryMapRef](p1, IPXACT2022scalaxb.ElemName(node) :: stack),
        p2.headOption map { IPXACT2022scalaxb.fromXML[IPXACT2022ScalaCases.MemoryRemapRef](_, IPXACT2022scalaxb.ElemName(node) :: stack) })) })) ~
      safeRep(IPXACT2022scalaxb.ElemName(Some("http://www.accellera.org/XMLSchema/IPXACT/1685-2022"), "bankRef")) ~
      (IPXACT2022scalaxb.ElemName(Some("http://www.accellera.org/XMLSchema/IPXACT/1685-2022"), "addressBlockRef")) ~
      safeRep(IPXACT2022scalaxb.ElemName(Some("http://www.accellera.org/XMLSchema/IPXACT/1685-2022"), "registerFileRef")) ~
      (IPXACT2022scalaxb.ElemName(Some("http://www.accellera.org/XMLSchema/IPXACT/1685-2022"), "registerRef")) ~
      opt(IPXACT2022scalaxb.ElemName(Some("http://www.accellera.org/XMLSchema/IPXACT/1685-2022"), "alternateRegisterRef")) ~
      (IPXACT2022scalaxb.ElemName(Some("http://www.accellera.org/XMLSchema/IPXACT/1685-2022"), "fieldRef")) ~
      opt(IPXACT2022scalaxb.ElemName(Some("http://www.accellera.org/XMLSchema/IPXACT/1685-2022"), "range"))) ^^
        { case p1 ~ p2 ~ p3 ~ p4 ~ p5 ~ p6 ~ p7 ~ p8 => IPXACT2022ScalaCases.FieldSliceReferenceGroupSequence(p1,
        p2 map { IPXACT2022scalaxb.fromXML[IPXACT2022ScalaCases.BankRef](_, IPXACT2022scalaxb.ElemName(node) :: stack) },
        IPXACT2022scalaxb.fromXML[IPXACT2022ScalaCases.AddressBlockRef](p3, IPXACT2022scalaxb.ElemName(node) :: stack),
        p4 map { IPXACT2022scalaxb.fromXML[IPXACT2022ScalaCases.RegisterFileRef](_, IPXACT2022scalaxb.ElemName(node) :: stack) },
        IPXACT2022scalaxb.fromXML[IPXACT2022ScalaCases.RegisterRef](p5, IPXACT2022scalaxb.ElemName(node) :: stack),
        p6.headOption map { IPXACT2022scalaxb.fromXML[IPXACT2022ScalaCases.AlternateRegisterRef](_, IPXACT2022scalaxb.ElemName(node) :: stack) },
        IPXACT2022scalaxb.fromXML[IPXACT2022ScalaCases.FieldRef](p7, IPXACT2022scalaxb.ElemName(node) :: stack),
        p8.headOption map { IPXACT2022scalaxb.fromXML[IPXACT2022ScalaCases.RangeType](_, IPXACT2022scalaxb.ElemName(node) :: stack) }) })
  
    def parseFieldSliceReferenceGroupGroup(node: scala.xml.Node, stack: List[IPXACT2022scalaxb.ElemName], wrap: Boolean): Parser[IPXACT2022scalaxb.DataRecord[Any]] =
      (((((IPXACT2022scalaxb.ElemName(Some("http://www.accellera.org/XMLSchema/IPXACT/1685-2022"), "addressSpaceRef")) ^^
      (x => IPXACT2022scalaxb.DataRecord(x.namespace, Some(x.name), IPXACT2022scalaxb.fromXML[IPXACT2022ScalaCases.AddressSpaceRef](x, IPXACT2022scalaxb.ElemName(node) :: stack)))) |||
      (((IPXACT2022scalaxb.ElemName(Some("http://www.accellera.org/XMLSchema/IPXACT/1685-2022"), "memoryMapRef")) ~
      opt(IPXACT2022scalaxb.ElemName(Some("http://www.accellera.org/XMLSchema/IPXACT/1685-2022"), "memoryRemapRef"))) ^^
        { case p1 ~ p2 => IPXACT2022scalaxb.DataRecord(IPXACT2022ScalaCases.FieldSliceReferenceGroupSequence2(IPXACT2022scalaxb.fromXML[IPXACT2022ScalaCases.MemoryMapRef](p1, IPXACT2022scalaxb.ElemName(node) :: stack),
        p2.headOption map { IPXACT2022scalaxb.fromXML[IPXACT2022ScalaCases.MemoryRemapRef](_, IPXACT2022scalaxb.ElemName(node) :: stack) })) })) ~
      safeRep(IPXACT2022scalaxb.ElemName(Some("http://www.accellera.org/XMLSchema/IPXACT/1685-2022"), "bankRef")) ~
      (IPXACT2022scalaxb.ElemName(Some("http://www.accellera.org/XMLSchema/IPXACT/1685-2022"), "addressBlockRef")) ~
      safeRep(IPXACT2022scalaxb.ElemName(Some("http://www.accellera.org/XMLSchema/IPXACT/1685-2022"), "registerFileRef")) ~
      (IPXACT2022scalaxb.ElemName(Some("http://www.accellera.org/XMLSchema/IPXACT/1685-2022"), "registerRef")) ~
      opt(IPXACT2022scalaxb.ElemName(Some("http://www.accellera.org/XMLSchema/IPXACT/1685-2022"), "alternateRegisterRef")) ~
      (IPXACT2022scalaxb.ElemName(Some("http://www.accellera.org/XMLSchema/IPXACT/1685-2022"), "fieldRef")) ~
      opt(IPXACT2022scalaxb.ElemName(Some("http://www.accellera.org/XMLSchema/IPXACT/1685-2022"), "range"))) ^^
        { case p1 ~ p2 ~ p3 ~ p4 ~ p5 ~ p6 ~ p7 ~ p8 => IPXACT2022scalaxb.DataRecord(IPXACT2022ScalaCases.FieldSliceReferenceGroupSequence(p1,
        p2 map { IPXACT2022scalaxb.fromXML[IPXACT2022ScalaCases.BankRef](_, IPXACT2022scalaxb.ElemName(node) :: stack) },
        IPXACT2022scalaxb.fromXML[IPXACT2022ScalaCases.AddressBlockRef](p3, IPXACT2022scalaxb.ElemName(node) :: stack),
        p4 map { IPXACT2022scalaxb.fromXML[IPXACT2022ScalaCases.RegisterFileRef](_, IPXACT2022scalaxb.ElemName(node) :: stack) },
        IPXACT2022scalaxb.fromXML[IPXACT2022ScalaCases.RegisterRef](p5, IPXACT2022scalaxb.ElemName(node) :: stack),
        p6.headOption map { IPXACT2022scalaxb.fromXML[IPXACT2022ScalaCases.AlternateRegisterRef](_, IPXACT2022scalaxb.ElemName(node) :: stack) },
        IPXACT2022scalaxb.fromXML[IPXACT2022ScalaCases.FieldRef](p7, IPXACT2022scalaxb.ElemName(node) :: stack),
        p8.headOption map { IPXACT2022scalaxb.fromXML[IPXACT2022ScalaCases.RangeType](_, IPXACT2022scalaxb.ElemName(node) :: stack) })) })
    
    def parsemixedFieldSliceReferenceGroupGroup(node: scala.xml.Node, stack: List[IPXACT2022scalaxb.ElemName]): Parser[Seq[IPXACT2022scalaxb.DataRecord[Any]]] =
      (((((((IPXACT2022scalaxb.ElemName(Some("http://www.accellera.org/XMLSchema/IPXACT/1685-2022"), "addressSpaceRef")) ^^
      (x => IPXACT2022scalaxb.DataRecord(x.namespace, Some(x.name), IPXACT2022scalaxb.fromXML[IPXACT2022ScalaCases.AddressSpaceRef](x, IPXACT2022scalaxb.ElemName(node) :: stack)))) ~
      optTextRecord) ^^ 
        { case p1 ~ p2 => Seq.concat(Seq(p1),
        p2.toList) }) ||| 
      ((((IPXACT2022scalaxb.ElemName(Some("http://www.accellera.org/XMLSchema/IPXACT/1685-2022"), "memoryMapRef")) ^^
      (x => IPXACT2022scalaxb.DataRecord(x.namespace, Some(x.name), IPXACT2022scalaxb.fromXML[IPXACT2022ScalaCases.MemoryMapRef](x, IPXACT2022scalaxb.ElemName(node) :: stack)))) ~
      optTextRecord ~ 
      (opt(IPXACT2022scalaxb.ElemName(Some("http://www.accellera.org/XMLSchema/IPXACT/1685-2022"), "memoryRemapRef")) ^^
      (_ map { x => IPXACT2022scalaxb.DataRecord(x.namespace, Some(x.name), IPXACT2022scalaxb.fromXML[IPXACT2022ScalaCases.MemoryRemapRef](x, IPXACT2022scalaxb.ElemName(node) :: stack)) })) ~
      optTextRecord) ^^ 
        { case p1 ~ p2 ~ p3 ~ p4 => Seq.concat(Seq(p1),
        p2.toList,
        p3.toList,
        p4.toList) })) ~ 
      optTextRecord ~ 
      (safeRep(IPXACT2022scalaxb.ElemName(Some("http://www.accellera.org/XMLSchema/IPXACT/1685-2022"), "bankRef")) ^^
      (_.toSeq map { x => IPXACT2022scalaxb.DataRecord(x.namespace, Some(x.name), IPXACT2022scalaxb.fromXML[IPXACT2022ScalaCases.BankRef](x, IPXACT2022scalaxb.ElemName(node) :: stack)) })) ~
      optTextRecord ~ 
      ((IPXACT2022scalaxb.ElemName(Some("http://www.accellera.org/XMLSchema/IPXACT/1685-2022"), "addressBlockRef")) ^^
      (x => IPXACT2022scalaxb.DataRecord(x.namespace, Some(x.name), IPXACT2022scalaxb.fromXML[IPXACT2022ScalaCases.AddressBlockRef](x, IPXACT2022scalaxb.ElemName(node) :: stack)))) ~
      optTextRecord ~ 
      (safeRep(IPXACT2022scalaxb.ElemName(Some("http://www.accellera.org/XMLSchema/IPXACT/1685-2022"), "registerFileRef")) ^^
      (_.toSeq map { x => IPXACT2022scalaxb.DataRecord(x.namespace, Some(x.name), IPXACT2022scalaxb.fromXML[IPXACT2022ScalaCases.RegisterFileRef](x, IPXACT2022scalaxb.ElemName(node) :: stack)) })) ~
      optTextRecord ~ 
      ((IPXACT2022scalaxb.ElemName(Some("http://www.accellera.org/XMLSchema/IPXACT/1685-2022"), "registerRef")) ^^
      (x => IPXACT2022scalaxb.DataRecord(x.namespace, Some(x.name), IPXACT2022scalaxb.fromXML[IPXACT2022ScalaCases.RegisterRef](x, IPXACT2022scalaxb.ElemName(node) :: stack)))) ~
      optTextRecord ~ 
      (opt(IPXACT2022scalaxb.ElemName(Some("http://www.accellera.org/XMLSchema/IPXACT/1685-2022"), "alternateRegisterRef")) ^^
      (_ map { x => IPXACT2022scalaxb.DataRecord(x.namespace, Some(x.name), IPXACT2022scalaxb.fromXML[IPXACT2022ScalaCases.AlternateRegisterRef](x, IPXACT2022scalaxb.ElemName(node) :: stack)) })) ~
      optTextRecord ~ 
      ((IPXACT2022scalaxb.ElemName(Some("http://www.accellera.org/XMLSchema/IPXACT/1685-2022"), "fieldRef")) ^^
      (x => IPXACT2022scalaxb.DataRecord(x.namespace, Some(x.name), IPXACT2022scalaxb.fromXML[IPXACT2022ScalaCases.FieldRef](x, IPXACT2022scalaxb.ElemName(node) :: stack)))) ~
      optTextRecord ~ 
      (opt(IPXACT2022scalaxb.ElemName(Some("http://www.accellera.org/XMLSchema/IPXACT/1685-2022"), "range")) ^^
      (_ map { x => IPXACT2022scalaxb.DataRecord(x.namespace, Some(x.name), IPXACT2022scalaxb.fromXML[IPXACT2022ScalaCases.RangeType](x, IPXACT2022scalaxb.ElemName(node) :: stack)) })) ~
      optTextRecord) ^^ 
        { case p1 ~ p2 ~ p3 ~ p4 ~ p5 ~ p6 ~ p7 ~ p8 ~ p9 ~ p10 ~ p11 ~ p12 ~ p13 ~ p14 ~ p15 ~ p16 => Seq.concat(p1,
        p2.toList,
        p3,
        p4.toList,
        Seq(p5),
        p6.toList,
        p7,
        p8.toList,
        Seq(p9),
        p10.toList,
        p11.toList,
        p12.toList,
        Seq(p13),
        p14.toList,
        p15.toList,
        p16.toList) })
  }

  trait DefaultIPXACT2022ScalaCases_FieldSliceReferenceGroupSequence2Format extends IPXACT2022scalaxb.XMLFormat[IPXACT2022ScalaCases.FieldSliceReferenceGroupSequence2] {
    def reads(seq: scala.xml.NodeSeq, stack: List[IPXACT2022scalaxb.ElemName]): Either[String, IPXACT2022ScalaCases.FieldSliceReferenceGroupSequence2] = Left("don't call me.")
    
    def writes(__obj: IPXACT2022ScalaCases.FieldSliceReferenceGroupSequence2, __namespace: Option[String], __elementLabel: Option[String],
        __scope: scala.xml.NamespaceBinding, __typeAttribute: Boolean): scala.xml.NodeSeq =
      Seq.concat(IPXACT2022scalaxb.toXML[IPXACT2022ScalaCases.MemoryMapRef](__obj.memoryMapRef, Some("http://www.accellera.org/XMLSchema/IPXACT/1685-2022"), Some("memoryMapRef"), __scope, false),
        __obj.memoryRemapRef map { IPXACT2022scalaxb.toXML[IPXACT2022ScalaCases.MemoryRemapRef](_, Some("http://www.accellera.org/XMLSchema/IPXACT/1685-2022"), Some("memoryRemapRef"), __scope, false) } getOrElse {Nil})


  }

  trait DefaultIPXACT2022ScalaCases_FieldSliceReferenceGroupSequenceFormat extends IPXACT2022scalaxb.XMLFormat[IPXACT2022ScalaCases.FieldSliceReferenceGroupSequence] {
    def reads(seq: scala.xml.NodeSeq, stack: List[IPXACT2022scalaxb.ElemName]): Either[String, IPXACT2022ScalaCases.FieldSliceReferenceGroupSequence] = Left("don't call me.")
    
    def writes(__obj: IPXACT2022ScalaCases.FieldSliceReferenceGroupSequence, __namespace: Option[String], __elementLabel: Option[String],
        __scope: scala.xml.NamespaceBinding, __typeAttribute: Boolean): scala.xml.NodeSeq =
      Seq.concat((Some(__obj.fieldslicereferencegroupoption1) map {x => IPXACT2022scalaxb.toXML[IPXACT2022scalaxb.DataRecord[IPXACT2022ScalaCases.FieldSliceReferenceGroupOption1]](x, x.namespace, x.key, __scope, false)}).get,
        __obj.bankRef flatMap { IPXACT2022scalaxb.toXML[IPXACT2022ScalaCases.BankRef](_, Some("http://www.accellera.org/XMLSchema/IPXACT/1685-2022"), Some("bankRef"), __scope, false) },
        IPXACT2022scalaxb.toXML[IPXACT2022ScalaCases.AddressBlockRef](__obj.addressBlockRef, Some("http://www.accellera.org/XMLSchema/IPXACT/1685-2022"), Some("addressBlockRef"), __scope, false),
        __obj.registerFileRef flatMap { IPXACT2022scalaxb.toXML[IPXACT2022ScalaCases.RegisterFileRef](_, Some("http://www.accellera.org/XMLSchema/IPXACT/1685-2022"), Some("registerFileRef"), __scope, false) },
        IPXACT2022scalaxb.toXML[IPXACT2022ScalaCases.RegisterRef](__obj.registerRef, Some("http://www.accellera.org/XMLSchema/IPXACT/1685-2022"), Some("registerRef"), __scope, false),
        __obj.alternateRegisterRef map { IPXACT2022scalaxb.toXML[IPXACT2022ScalaCases.AlternateRegisterRef](_, Some("http://www.accellera.org/XMLSchema/IPXACT/1685-2022"), Some("alternateRegisterRef"), __scope, false) } getOrElse {Nil},
        IPXACT2022scalaxb.toXML[IPXACT2022ScalaCases.FieldRef](__obj.fieldRef, Some("http://www.accellera.org/XMLSchema/IPXACT/1685-2022"), Some("fieldRef"), __scope, false),
        __obj.range map { IPXACT2022scalaxb.toXML[IPXACT2022ScalaCases.RangeType](_, Some("http://www.accellera.org/XMLSchema/IPXACT/1685-2022"), Some("range"), __scope, false) } getOrElse {Nil})


  }


/** A group of elements for name(xs:NMTOKEN), displayName and description
*/
  trait IPXACT2022ScalaCases_NameGroupNMTOKENGroupFormat extends IPXACT2022scalaxb.AnyElemNameParser {
    def parseNameGroupNMTOKENGroup(node: scala.xml.Node, stack: List[IPXACT2022scalaxb.ElemName]): Parser[IPXACT2022ScalaCases.NameGroupNMTOKENSequence] =
      (((IPXACT2022scalaxb.ElemName(Some("http://www.accellera.org/XMLSchema/IPXACT/1685-2022"), "name")) ~
      opt(IPXACT2022scalaxb.ElemName(Some("http://www.accellera.org/XMLSchema/IPXACT/1685-2022"), "displayName")) ~
      opt(IPXACT2022scalaxb.ElemName(Some("http://www.accellera.org/XMLSchema/IPXACT/1685-2022"), "shortDescription")) ~
      opt(IPXACT2022scalaxb.ElemName(Some("http://www.accellera.org/XMLSchema/IPXACT/1685-2022"), "description"))) ^^
        { case p1 ~ p2 ~ p3 ~ p4 => IPXACT2022ScalaCases.NameGroupNMTOKENSequence(IPXACT2022scalaxb.fromXML[String](p1, IPXACT2022scalaxb.ElemName(node) :: stack),
        p2.headOption map { IPXACT2022scalaxb.fromXML[String](_, IPXACT2022scalaxb.ElemName(node) :: stack) },
        p3.headOption map { IPXACT2022scalaxb.fromXML[String](_, IPXACT2022scalaxb.ElemName(node) :: stack) },
        p4.headOption map { IPXACT2022scalaxb.fromXML[String](_, IPXACT2022scalaxb.ElemName(node) :: stack) }) })
  
    def parseNameGroupNMTOKENGroup(node: scala.xml.Node, stack: List[IPXACT2022scalaxb.ElemName], wrap: Boolean): Parser[IPXACT2022scalaxb.DataRecord[Any]] =
      (((IPXACT2022scalaxb.ElemName(Some("http://www.accellera.org/XMLSchema/IPXACT/1685-2022"), "name")) ~
      opt(IPXACT2022scalaxb.ElemName(Some("http://www.accellera.org/XMLSchema/IPXACT/1685-2022"), "displayName")) ~
      opt(IPXACT2022scalaxb.ElemName(Some("http://www.accellera.org/XMLSchema/IPXACT/1685-2022"), "shortDescription")) ~
      opt(IPXACT2022scalaxb.ElemName(Some("http://www.accellera.org/XMLSchema/IPXACT/1685-2022"), "description"))) ^^
        { case p1 ~ p2 ~ p3 ~ p4 => IPXACT2022scalaxb.DataRecord(IPXACT2022ScalaCases.NameGroupNMTOKENSequence(IPXACT2022scalaxb.fromXML[String](p1, IPXACT2022scalaxb.ElemName(node) :: stack),
        p2.headOption map { IPXACT2022scalaxb.fromXML[String](_, IPXACT2022scalaxb.ElemName(node) :: stack) },
        p3.headOption map { IPXACT2022scalaxb.fromXML[String](_, IPXACT2022scalaxb.ElemName(node) :: stack) },
        p4.headOption map { IPXACT2022scalaxb.fromXML[String](_, IPXACT2022scalaxb.ElemName(node) :: stack) })) })
    
    def parsemixedNameGroupNMTOKENGroup(node: scala.xml.Node, stack: List[IPXACT2022scalaxb.ElemName]): Parser[Seq[IPXACT2022scalaxb.DataRecord[Any]]] =
      ((((IPXACT2022scalaxb.ElemName(Some("http://www.accellera.org/XMLSchema/IPXACT/1685-2022"), "name")) ^^
      (x => IPXACT2022scalaxb.DataRecord(x.namespace, Some(x.name), IPXACT2022scalaxb.fromXML[String](x, IPXACT2022scalaxb.ElemName(node) :: stack)))) ~
      optTextRecord ~ 
      (opt(IPXACT2022scalaxb.ElemName(Some("http://www.accellera.org/XMLSchema/IPXACT/1685-2022"), "displayName")) ^^
      (_ map { x => IPXACT2022scalaxb.DataRecord(x.namespace, Some(x.name), IPXACT2022scalaxb.fromXML[String](x, IPXACT2022scalaxb.ElemName(node) :: stack)) })) ~
      optTextRecord ~ 
      (opt(IPXACT2022scalaxb.ElemName(Some("http://www.accellera.org/XMLSchema/IPXACT/1685-2022"), "shortDescription")) ^^
      (_ map { x => IPXACT2022scalaxb.DataRecord(x.namespace, Some(x.name), IPXACT2022scalaxb.fromXML[String](x, IPXACT2022scalaxb.ElemName(node) :: stack)) })) ~
      optTextRecord ~ 
      (opt(IPXACT2022scalaxb.ElemName(Some("http://www.accellera.org/XMLSchema/IPXACT/1685-2022"), "description")) ^^
      (_ map { x => IPXACT2022scalaxb.DataRecord(x.namespace, Some(x.name), IPXACT2022scalaxb.fromXML[String](x, IPXACT2022scalaxb.ElemName(node) :: stack)) })) ~
      optTextRecord) ^^ 
        { case p1 ~ p2 ~ p3 ~ p4 ~ p5 ~ p6 ~ p7 ~ p8 => Seq.concat(Seq(p1),
        p2.toList,
        p3.toList,
        p4.toList,
        p5.toList,
        p6.toList,
        p7.toList,
        p8.toList) })
  }

  trait DefaultIPXACT2022ScalaCases_NameGroupNMTOKENSequenceFormat extends IPXACT2022scalaxb.XMLFormat[IPXACT2022ScalaCases.NameGroupNMTOKENSequence] {
    def reads(seq: scala.xml.NodeSeq, stack: List[IPXACT2022scalaxb.ElemName]): Either[String, IPXACT2022ScalaCases.NameGroupNMTOKENSequence] = Left("don't call me.")
    
    def writes(__obj: IPXACT2022ScalaCases.NameGroupNMTOKENSequence, __namespace: Option[String], __elementLabel: Option[String],
        __scope: scala.xml.NamespaceBinding, __typeAttribute: Boolean): scala.xml.NodeSeq =
      Seq.concat(IPXACT2022scalaxb.toXML[String](__obj.name, Some("http://www.accellera.org/XMLSchema/IPXACT/1685-2022"), Some("name"), __scope, false),
        __obj.displayName map { IPXACT2022scalaxb.toXML[String](_, Some("http://www.accellera.org/XMLSchema/IPXACT/1685-2022"), Some("displayName"), __scope, false) } getOrElse {Nil},
        __obj.shortDescription map { IPXACT2022scalaxb.toXML[String](_, Some("http://www.accellera.org/XMLSchema/IPXACT/1685-2022"), Some("shortDescription"), __scope, false) } getOrElse {Nil},
        __obj.description map { IPXACT2022scalaxb.toXML[String](_, Some("http://www.accellera.org/XMLSchema/IPXACT/1685-2022"), Some("description"), __scope, false) } getOrElse {Nil})


  }


/** A group of elements for name (xs:name), displayName and description
*/
  trait IPXACT2022ScalaCases_NameGroupGroupFormat extends IPXACT2022scalaxb.AnyElemNameParser {
    def parseNameGroupGroup(node: scala.xml.Node, stack: List[IPXACT2022scalaxb.ElemName]): Parser[IPXACT2022ScalaCases.NameGroupSequence] =
      (((IPXACT2022scalaxb.ElemName(Some("http://www.accellera.org/XMLSchema/IPXACT/1685-2022"), "name")) ~
      opt(IPXACT2022scalaxb.ElemName(Some("http://www.accellera.org/XMLSchema/IPXACT/1685-2022"), "displayName")) ~
      opt(IPXACT2022scalaxb.ElemName(Some("http://www.accellera.org/XMLSchema/IPXACT/1685-2022"), "shortDescription")) ~
      opt(IPXACT2022scalaxb.ElemName(Some("http://www.accellera.org/XMLSchema/IPXACT/1685-2022"), "description"))) ^^
        { case p1 ~ p2 ~ p3 ~ p4 => IPXACT2022ScalaCases.NameGroupSequence(IPXACT2022scalaxb.fromXML[String](p1, IPXACT2022scalaxb.ElemName(node) :: stack),
        p2.headOption map { IPXACT2022scalaxb.fromXML[String](_, IPXACT2022scalaxb.ElemName(node) :: stack) },
        p3.headOption map { IPXACT2022scalaxb.fromXML[String](_, IPXACT2022scalaxb.ElemName(node) :: stack) },
        p4.headOption map { IPXACT2022scalaxb.fromXML[String](_, IPXACT2022scalaxb.ElemName(node) :: stack) }) })
  
    def parseNameGroupGroup(node: scala.xml.Node, stack: List[IPXACT2022scalaxb.ElemName], wrap: Boolean): Parser[IPXACT2022scalaxb.DataRecord[Any]] =
      (((IPXACT2022scalaxb.ElemName(Some("http://www.accellera.org/XMLSchema/IPXACT/1685-2022"), "name")) ~
      opt(IPXACT2022scalaxb.ElemName(Some("http://www.accellera.org/XMLSchema/IPXACT/1685-2022"), "displayName")) ~
      opt(IPXACT2022scalaxb.ElemName(Some("http://www.accellera.org/XMLSchema/IPXACT/1685-2022"), "shortDescription")) ~
      opt(IPXACT2022scalaxb.ElemName(Some("http://www.accellera.org/XMLSchema/IPXACT/1685-2022"), "description"))) ^^
        { case p1 ~ p2 ~ p3 ~ p4 => IPXACT2022scalaxb.DataRecord(IPXACT2022ScalaCases.NameGroupSequence(IPXACT2022scalaxb.fromXML[String](p1, IPXACT2022scalaxb.ElemName(node) :: stack),
        p2.headOption map { IPXACT2022scalaxb.fromXML[String](_, IPXACT2022scalaxb.ElemName(node) :: stack) },
        p3.headOption map { IPXACT2022scalaxb.fromXML[String](_, IPXACT2022scalaxb.ElemName(node) :: stack) },
        p4.headOption map { IPXACT2022scalaxb.fromXML[String](_, IPXACT2022scalaxb.ElemName(node) :: stack) })) })
    
    def parsemixedNameGroupGroup(node: scala.xml.Node, stack: List[IPXACT2022scalaxb.ElemName]): Parser[Seq[IPXACT2022scalaxb.DataRecord[Any]]] =
      ((((IPXACT2022scalaxb.ElemName(Some("http://www.accellera.org/XMLSchema/IPXACT/1685-2022"), "name")) ^^
      (x => IPXACT2022scalaxb.DataRecord(x.namespace, Some(x.name), IPXACT2022scalaxb.fromXML[String](x, IPXACT2022scalaxb.ElemName(node) :: stack)))) ~
      optTextRecord ~ 
      (opt(IPXACT2022scalaxb.ElemName(Some("http://www.accellera.org/XMLSchema/IPXACT/1685-2022"), "displayName")) ^^
      (_ map { x => IPXACT2022scalaxb.DataRecord(x.namespace, Some(x.name), IPXACT2022scalaxb.fromXML[String](x, IPXACT2022scalaxb.ElemName(node) :: stack)) })) ~
      optTextRecord ~ 
      (opt(IPXACT2022scalaxb.ElemName(Some("http://www.accellera.org/XMLSchema/IPXACT/1685-2022"), "shortDescription")) ^^
      (_ map { x => IPXACT2022scalaxb.DataRecord(x.namespace, Some(x.name), IPXACT2022scalaxb.fromXML[String](x, IPXACT2022scalaxb.ElemName(node) :: stack)) })) ~
      optTextRecord ~ 
      (opt(IPXACT2022scalaxb.ElemName(Some("http://www.accellera.org/XMLSchema/IPXACT/1685-2022"), "description")) ^^
      (_ map { x => IPXACT2022scalaxb.DataRecord(x.namespace, Some(x.name), IPXACT2022scalaxb.fromXML[String](x, IPXACT2022scalaxb.ElemName(node) :: stack)) })) ~
      optTextRecord) ^^ 
        { case p1 ~ p2 ~ p3 ~ p4 ~ p5 ~ p6 ~ p7 ~ p8 => Seq.concat(Seq(p1),
        p2.toList,
        p3.toList,
        p4.toList,
        p5.toList,
        p6.toList,
        p7.toList,
        p8.toList) })
  }

  trait DefaultIPXACT2022ScalaCases_NameGroupSequenceFormat extends IPXACT2022scalaxb.XMLFormat[IPXACT2022ScalaCases.NameGroupSequence] {
    def reads(seq: scala.xml.NodeSeq, stack: List[IPXACT2022scalaxb.ElemName]): Either[String, IPXACT2022ScalaCases.NameGroupSequence] = Left("don't call me.")
    
    def writes(__obj: IPXACT2022ScalaCases.NameGroupSequence, __namespace: Option[String], __elementLabel: Option[String],
        __scope: scala.xml.NamespaceBinding, __typeAttribute: Boolean): scala.xml.NodeSeq =
      Seq.concat(IPXACT2022scalaxb.toXML[String](__obj.name, Some("http://www.accellera.org/XMLSchema/IPXACT/1685-2022"), Some("name"), __scope, false),
        __obj.displayName map { IPXACT2022scalaxb.toXML[String](_, Some("http://www.accellera.org/XMLSchema/IPXACT/1685-2022"), Some("displayName"), __scope, false) } getOrElse {Nil},
        __obj.shortDescription map { IPXACT2022scalaxb.toXML[String](_, Some("http://www.accellera.org/XMLSchema/IPXACT/1685-2022"), Some("shortDescription"), __scope, false) } getOrElse {Nil},
        __obj.description map { IPXACT2022scalaxb.toXML[String](_, Some("http://www.accellera.org/XMLSchema/IPXACT/1685-2022"), Some("description"), __scope, false) } getOrElse {Nil})


  }


/** A group of elements for name (xs:name), displayName and description where the name is optional
*/
  trait IPXACT2022ScalaCases_NameGroupOptionalGroupFormat extends IPXACT2022scalaxb.AnyElemNameParser {
    def parseNameGroupOptionalGroup(node: scala.xml.Node, stack: List[IPXACT2022scalaxb.ElemName]): Parser[IPXACT2022ScalaCases.NameGroupOptionalSequence] =
      ((opt(IPXACT2022scalaxb.ElemName(Some("http://www.accellera.org/XMLSchema/IPXACT/1685-2022"), "name")) ~
      opt(IPXACT2022scalaxb.ElemName(Some("http://www.accellera.org/XMLSchema/IPXACT/1685-2022"), "displayName")) ~
      opt(IPXACT2022scalaxb.ElemName(Some("http://www.accellera.org/XMLSchema/IPXACT/1685-2022"), "shortDescription")) ~
      opt(IPXACT2022scalaxb.ElemName(Some("http://www.accellera.org/XMLSchema/IPXACT/1685-2022"), "description"))) ^^
        { case p1 ~ p2 ~ p3 ~ p4 => IPXACT2022ScalaCases.NameGroupOptionalSequence(p1.headOption map { IPXACT2022scalaxb.fromXML[String](_, IPXACT2022scalaxb.ElemName(node) :: stack) },
        p2.headOption map { IPXACT2022scalaxb.fromXML[String](_, IPXACT2022scalaxb.ElemName(node) :: stack) },
        p3.headOption map { IPXACT2022scalaxb.fromXML[String](_, IPXACT2022scalaxb.ElemName(node) :: stack) },
        p4.headOption map { IPXACT2022scalaxb.fromXML[String](_, IPXACT2022scalaxb.ElemName(node) :: stack) }) })
  
    def parseNameGroupOptionalGroup(node: scala.xml.Node, stack: List[IPXACT2022scalaxb.ElemName], wrap: Boolean): Parser[IPXACT2022scalaxb.DataRecord[Any]] =
      ((opt(IPXACT2022scalaxb.ElemName(Some("http://www.accellera.org/XMLSchema/IPXACT/1685-2022"), "name")) ~
      opt(IPXACT2022scalaxb.ElemName(Some("http://www.accellera.org/XMLSchema/IPXACT/1685-2022"), "displayName")) ~
      opt(IPXACT2022scalaxb.ElemName(Some("http://www.accellera.org/XMLSchema/IPXACT/1685-2022"), "shortDescription")) ~
      opt(IPXACT2022scalaxb.ElemName(Some("http://www.accellera.org/XMLSchema/IPXACT/1685-2022"), "description"))) ^^
        { case p1 ~ p2 ~ p3 ~ p4 => IPXACT2022scalaxb.DataRecord(IPXACT2022ScalaCases.NameGroupOptionalSequence(p1.headOption map { IPXACT2022scalaxb.fromXML[String](_, IPXACT2022scalaxb.ElemName(node) :: stack) },
        p2.headOption map { IPXACT2022scalaxb.fromXML[String](_, IPXACT2022scalaxb.ElemName(node) :: stack) },
        p3.headOption map { IPXACT2022scalaxb.fromXML[String](_, IPXACT2022scalaxb.ElemName(node) :: stack) },
        p4.headOption map { IPXACT2022scalaxb.fromXML[String](_, IPXACT2022scalaxb.ElemName(node) :: stack) })) })
    
    def parsemixedNameGroupOptionalGroup(node: scala.xml.Node, stack: List[IPXACT2022scalaxb.ElemName]): Parser[Seq[IPXACT2022scalaxb.DataRecord[Any]]] =
      (((opt(IPXACT2022scalaxb.ElemName(Some("http://www.accellera.org/XMLSchema/IPXACT/1685-2022"), "name")) ^^
      (_ map { x => IPXACT2022scalaxb.DataRecord(x.namespace, Some(x.name), IPXACT2022scalaxb.fromXML[String](x, IPXACT2022scalaxb.ElemName(node) :: stack)) })) ~
      optTextRecord ~ 
      (opt(IPXACT2022scalaxb.ElemName(Some("http://www.accellera.org/XMLSchema/IPXACT/1685-2022"), "displayName")) ^^
      (_ map { x => IPXACT2022scalaxb.DataRecord(x.namespace, Some(x.name), IPXACT2022scalaxb.fromXML[String](x, IPXACT2022scalaxb.ElemName(node) :: stack)) })) ~
      optTextRecord ~ 
      (opt(IPXACT2022scalaxb.ElemName(Some("http://www.accellera.org/XMLSchema/IPXACT/1685-2022"), "shortDescription")) ^^
      (_ map { x => IPXACT2022scalaxb.DataRecord(x.namespace, Some(x.name), IPXACT2022scalaxb.fromXML[String](x, IPXACT2022scalaxb.ElemName(node) :: stack)) })) ~
      optTextRecord ~ 
      (opt(IPXACT2022scalaxb.ElemName(Some("http://www.accellera.org/XMLSchema/IPXACT/1685-2022"), "description")) ^^
      (_ map { x => IPXACT2022scalaxb.DataRecord(x.namespace, Some(x.name), IPXACT2022scalaxb.fromXML[String](x, IPXACT2022scalaxb.ElemName(node) :: stack)) })) ~
      optTextRecord) ^^ 
        { case p1 ~ p2 ~ p3 ~ p4 ~ p5 ~ p6 ~ p7 ~ p8 => Seq.concat(p1.toList,
        p2.toList,
        p3.toList,
        p4.toList,
        p5.toList,
        p6.toList,
        p7.toList,
        p8.toList) })
  }

  trait DefaultIPXACT2022ScalaCases_NameGroupOptionalSequenceFormat extends IPXACT2022scalaxb.XMLFormat[IPXACT2022ScalaCases.NameGroupOptionalSequence] {
    def reads(seq: scala.xml.NodeSeq, stack: List[IPXACT2022scalaxb.ElemName]): Either[String, IPXACT2022ScalaCases.NameGroupOptionalSequence] = Left("don't call me.")
    
    def writes(__obj: IPXACT2022ScalaCases.NameGroupOptionalSequence, __namespace: Option[String], __elementLabel: Option[String],
        __scope: scala.xml.NamespaceBinding, __typeAttribute: Boolean): scala.xml.NodeSeq =
      Seq.concat(__obj.name map { IPXACT2022scalaxb.toXML[String](_, Some("http://www.accellera.org/XMLSchema/IPXACT/1685-2022"), Some("name"), __scope, false) } getOrElse {Nil},
        __obj.displayName map { IPXACT2022scalaxb.toXML[String](_, Some("http://www.accellera.org/XMLSchema/IPXACT/1685-2022"), Some("displayName"), __scope, false) } getOrElse {Nil},
        __obj.shortDescription map { IPXACT2022scalaxb.toXML[String](_, Some("http://www.accellera.org/XMLSchema/IPXACT/1685-2022"), Some("shortDescription"), __scope, false) } getOrElse {Nil},
        __obj.description map { IPXACT2022scalaxb.toXML[String](_, Some("http://www.accellera.org/XMLSchema/IPXACT/1685-2022"), Some("description"), __scope, false) } getOrElse {Nil})


  }


/** A group of elements for name(portName), displayName and description
*/
  trait IPXACT2022ScalaCases_NameGroupPortGroupFormat extends IPXACT2022scalaxb.AnyElemNameParser {
    def parseNameGroupPortGroup(node: scala.xml.Node, stack: List[IPXACT2022scalaxb.ElemName]): Parser[IPXACT2022ScalaCases.NameGroupPortSequence] =
      (((IPXACT2022scalaxb.ElemName(Some("http://www.accellera.org/XMLSchema/IPXACT/1685-2022"), "name")) ~
      opt(IPXACT2022scalaxb.ElemName(Some("http://www.accellera.org/XMLSchema/IPXACT/1685-2022"), "displayName")) ~
      opt(IPXACT2022scalaxb.ElemName(Some("http://www.accellera.org/XMLSchema/IPXACT/1685-2022"), "shortDescription")) ~
      opt(IPXACT2022scalaxb.ElemName(Some("http://www.accellera.org/XMLSchema/IPXACT/1685-2022"), "description"))) ^^
        { case p1 ~ p2 ~ p3 ~ p4 => IPXACT2022ScalaCases.NameGroupPortSequence(IPXACT2022scalaxb.fromXML[String](p1, IPXACT2022scalaxb.ElemName(node) :: stack),
        p2.headOption map { IPXACT2022scalaxb.fromXML[String](_, IPXACT2022scalaxb.ElemName(node) :: stack) },
        p3.headOption map { IPXACT2022scalaxb.fromXML[String](_, IPXACT2022scalaxb.ElemName(node) :: stack) },
        p4.headOption map { IPXACT2022scalaxb.fromXML[String](_, IPXACT2022scalaxb.ElemName(node) :: stack) }) })
  
    def parseNameGroupPortGroup(node: scala.xml.Node, stack: List[IPXACT2022scalaxb.ElemName], wrap: Boolean): Parser[IPXACT2022scalaxb.DataRecord[Any]] =
      (((IPXACT2022scalaxb.ElemName(Some("http://www.accellera.org/XMLSchema/IPXACT/1685-2022"), "name")) ~
      opt(IPXACT2022scalaxb.ElemName(Some("http://www.accellera.org/XMLSchema/IPXACT/1685-2022"), "displayName")) ~
      opt(IPXACT2022scalaxb.ElemName(Some("http://www.accellera.org/XMLSchema/IPXACT/1685-2022"), "shortDescription")) ~
      opt(IPXACT2022scalaxb.ElemName(Some("http://www.accellera.org/XMLSchema/IPXACT/1685-2022"), "description"))) ^^
        { case p1 ~ p2 ~ p3 ~ p4 => IPXACT2022scalaxb.DataRecord(IPXACT2022ScalaCases.NameGroupPortSequence(IPXACT2022scalaxb.fromXML[String](p1, IPXACT2022scalaxb.ElemName(node) :: stack),
        p2.headOption map { IPXACT2022scalaxb.fromXML[String](_, IPXACT2022scalaxb.ElemName(node) :: stack) },
        p3.headOption map { IPXACT2022scalaxb.fromXML[String](_, IPXACT2022scalaxb.ElemName(node) :: stack) },
        p4.headOption map { IPXACT2022scalaxb.fromXML[String](_, IPXACT2022scalaxb.ElemName(node) :: stack) })) })
    
    def parsemixedNameGroupPortGroup(node: scala.xml.Node, stack: List[IPXACT2022scalaxb.ElemName]): Parser[Seq[IPXACT2022scalaxb.DataRecord[Any]]] =
      ((((IPXACT2022scalaxb.ElemName(Some("http://www.accellera.org/XMLSchema/IPXACT/1685-2022"), "name")) ^^
      (x => IPXACT2022scalaxb.DataRecord(x.namespace, Some(x.name), IPXACT2022scalaxb.fromXML[String](x, IPXACT2022scalaxb.ElemName(node) :: stack)))) ~
      optTextRecord ~ 
      (opt(IPXACT2022scalaxb.ElemName(Some("http://www.accellera.org/XMLSchema/IPXACT/1685-2022"), "displayName")) ^^
      (_ map { x => IPXACT2022scalaxb.DataRecord(x.namespace, Some(x.name), IPXACT2022scalaxb.fromXML[String](x, IPXACT2022scalaxb.ElemName(node) :: stack)) })) ~
      optTextRecord ~ 
      (opt(IPXACT2022scalaxb.ElemName(Some("http://www.accellera.org/XMLSchema/IPXACT/1685-2022"), "shortDescription")) ^^
      (_ map { x => IPXACT2022scalaxb.DataRecord(x.namespace, Some(x.name), IPXACT2022scalaxb.fromXML[String](x, IPXACT2022scalaxb.ElemName(node) :: stack)) })) ~
      optTextRecord ~ 
      (opt(IPXACT2022scalaxb.ElemName(Some("http://www.accellera.org/XMLSchema/IPXACT/1685-2022"), "description")) ^^
      (_ map { x => IPXACT2022scalaxb.DataRecord(x.namespace, Some(x.name), IPXACT2022scalaxb.fromXML[String](x, IPXACT2022scalaxb.ElemName(node) :: stack)) })) ~
      optTextRecord) ^^ 
        { case p1 ~ p2 ~ p3 ~ p4 ~ p5 ~ p6 ~ p7 ~ p8 => Seq.concat(Seq(p1),
        p2.toList,
        p3.toList,
        p4.toList,
        p5.toList,
        p6.toList,
        p7.toList,
        p8.toList) })
  }

  trait DefaultIPXACT2022ScalaCases_NameGroupPortSequenceFormat extends IPXACT2022scalaxb.XMLFormat[IPXACT2022ScalaCases.NameGroupPortSequence] {
    def reads(seq: scala.xml.NodeSeq, stack: List[IPXACT2022scalaxb.ElemName]): Either[String, IPXACT2022ScalaCases.NameGroupPortSequence] = Left("don't call me.")
    
    def writes(__obj: IPXACT2022ScalaCases.NameGroupPortSequence, __namespace: Option[String], __elementLabel: Option[String],
        __scope: scala.xml.NamespaceBinding, __typeAttribute: Boolean): scala.xml.NodeSeq =
      Seq.concat(IPXACT2022scalaxb.toXML[String](__obj.name, Some("http://www.accellera.org/XMLSchema/IPXACT/1685-2022"), Some("name"), __scope, false),
        __obj.displayName map { IPXACT2022scalaxb.toXML[String](_, Some("http://www.accellera.org/XMLSchema/IPXACT/1685-2022"), Some("displayName"), __scope, false) } getOrElse {Nil},
        __obj.shortDescription map { IPXACT2022scalaxb.toXML[String](_, Some("http://www.accellera.org/XMLSchema/IPXACT/1685-2022"), Some("shortDescription"), __scope, false) } getOrElse {Nil},
        __obj.description map { IPXACT2022scalaxb.toXML[String](_, Some("http://www.accellera.org/XMLSchema/IPXACT/1685-2022"), Some("description"), __scope, false) } getOrElse {Nil})


  }


  trait IPXACT2022ScalaCases_FieldReferenceGroupGroupFormat extends IPXACT2022scalaxb.AnyElemNameParser {
    def parseFieldReferenceGroupGroup(node: scala.xml.Node, stack: List[IPXACT2022scalaxb.ElemName]): Parser[IPXACT2022ScalaCases.FieldReferenceGroupSequence] =
      ((opt(((IPXACT2022scalaxb.ElemName(Some("http://www.accellera.org/XMLSchema/IPXACT/1685-2022"), "addressSpaceRef")) ^^
      (x => IPXACT2022scalaxb.DataRecord(x.namespace, Some(x.name), IPXACT2022scalaxb.fromXML[IPXACT2022ScalaCases.AddressSpaceRef2](x, IPXACT2022scalaxb.ElemName(node) :: stack)))) |||
      (((IPXACT2022scalaxb.ElemName(Some("http://www.accellera.org/XMLSchema/IPXACT/1685-2022"), "memoryMapRef")) ~
      opt(IPXACT2022scalaxb.ElemName(Some("http://www.accellera.org/XMLSchema/IPXACT/1685-2022"), "memoryRemapRef"))) ^^
        { case p1 ~ p2 => IPXACT2022scalaxb.DataRecord(IPXACT2022ScalaCases.FieldReferenceGroupSequence2(IPXACT2022scalaxb.fromXML[IPXACT2022ScalaCases.MemoryMapRef2](p1, IPXACT2022scalaxb.ElemName(node) :: stack),
        p2.headOption map { IPXACT2022scalaxb.fromXML[IPXACT2022ScalaCases.MemoryRemapRef](_, IPXACT2022scalaxb.ElemName(node) :: stack) })) })) ~
      safeRep(IPXACT2022scalaxb.ElemName(Some("http://www.accellera.org/XMLSchema/IPXACT/1685-2022"), "bankRef")) ~
      opt(IPXACT2022scalaxb.ElemName(Some("http://www.accellera.org/XMLSchema/IPXACT/1685-2022"), "addressBlockRef")) ~
      safeRep(IPXACT2022scalaxb.ElemName(Some("http://www.accellera.org/XMLSchema/IPXACT/1685-2022"), "registerFileRef")) ~
      opt(IPXACT2022scalaxb.ElemName(Some("http://www.accellera.org/XMLSchema/IPXACT/1685-2022"), "registerRef")) ~
      opt(IPXACT2022scalaxb.ElemName(Some("http://www.accellera.org/XMLSchema/IPXACT/1685-2022"), "alternateRegisterRef")) ~
      (IPXACT2022scalaxb.ElemName(Some("http://www.accellera.org/XMLSchema/IPXACT/1685-2022"), "fieldRef"))) ^^
        { case p1 ~ p2 ~ p3 ~ p4 ~ p5 ~ p6 ~ p7 => IPXACT2022ScalaCases.FieldReferenceGroupSequence(p1,
        p2 map { IPXACT2022scalaxb.fromXML[IPXACT2022ScalaCases.BankRef](_, IPXACT2022scalaxb.ElemName(node) :: stack) },
        p3.headOption map { IPXACT2022scalaxb.fromXML[IPXACT2022ScalaCases.AddressBlockRef](_, IPXACT2022scalaxb.ElemName(node) :: stack) },
        p4 map { IPXACT2022scalaxb.fromXML[IPXACT2022ScalaCases.RegisterFileRef](_, IPXACT2022scalaxb.ElemName(node) :: stack) },
        p5.headOption map { IPXACT2022scalaxb.fromXML[IPXACT2022ScalaCases.RegisterRef](_, IPXACT2022scalaxb.ElemName(node) :: stack) },
        p6.headOption map { IPXACT2022scalaxb.fromXML[IPXACT2022ScalaCases.AlternateRegisterRef](_, IPXACT2022scalaxb.ElemName(node) :: stack) },
        IPXACT2022scalaxb.fromXML[IPXACT2022ScalaCases.FieldRef](p7, IPXACT2022scalaxb.ElemName(node) :: stack)) })
  
    def parseFieldReferenceGroupGroup(node: scala.xml.Node, stack: List[IPXACT2022scalaxb.ElemName], wrap: Boolean): Parser[IPXACT2022scalaxb.DataRecord[Any]] =
      ((opt(((IPXACT2022scalaxb.ElemName(Some("http://www.accellera.org/XMLSchema/IPXACT/1685-2022"), "addressSpaceRef")) ^^
      (x => IPXACT2022scalaxb.DataRecord(x.namespace, Some(x.name), IPXACT2022scalaxb.fromXML[IPXACT2022ScalaCases.AddressSpaceRef2](x, IPXACT2022scalaxb.ElemName(node) :: stack)))) |||
      (((IPXACT2022scalaxb.ElemName(Some("http://www.accellera.org/XMLSchema/IPXACT/1685-2022"), "memoryMapRef")) ~
      opt(IPXACT2022scalaxb.ElemName(Some("http://www.accellera.org/XMLSchema/IPXACT/1685-2022"), "memoryRemapRef"))) ^^
        { case p1 ~ p2 => IPXACT2022scalaxb.DataRecord(IPXACT2022ScalaCases.FieldReferenceGroupSequence2(IPXACT2022scalaxb.fromXML[IPXACT2022ScalaCases.MemoryMapRef2](p1, IPXACT2022scalaxb.ElemName(node) :: stack),
        p2.headOption map { IPXACT2022scalaxb.fromXML[IPXACT2022ScalaCases.MemoryRemapRef](_, IPXACT2022scalaxb.ElemName(node) :: stack) })) })) ~
      safeRep(IPXACT2022scalaxb.ElemName(Some("http://www.accellera.org/XMLSchema/IPXACT/1685-2022"), "bankRef")) ~
      opt(IPXACT2022scalaxb.ElemName(Some("http://www.accellera.org/XMLSchema/IPXACT/1685-2022"), "addressBlockRef")) ~
      safeRep(IPXACT2022scalaxb.ElemName(Some("http://www.accellera.org/XMLSchema/IPXACT/1685-2022"), "registerFileRef")) ~
      opt(IPXACT2022scalaxb.ElemName(Some("http://www.accellera.org/XMLSchema/IPXACT/1685-2022"), "registerRef")) ~
      opt(IPXACT2022scalaxb.ElemName(Some("http://www.accellera.org/XMLSchema/IPXACT/1685-2022"), "alternateRegisterRef")) ~
      (IPXACT2022scalaxb.ElemName(Some("http://www.accellera.org/XMLSchema/IPXACT/1685-2022"), "fieldRef"))) ^^
        { case p1 ~ p2 ~ p3 ~ p4 ~ p5 ~ p6 ~ p7 => IPXACT2022scalaxb.DataRecord(IPXACT2022ScalaCases.FieldReferenceGroupSequence(p1,
        p2 map { IPXACT2022scalaxb.fromXML[IPXACT2022ScalaCases.BankRef](_, IPXACT2022scalaxb.ElemName(node) :: stack) },
        p3.headOption map { IPXACT2022scalaxb.fromXML[IPXACT2022ScalaCases.AddressBlockRef](_, IPXACT2022scalaxb.ElemName(node) :: stack) },
        p4 map { IPXACT2022scalaxb.fromXML[IPXACT2022ScalaCases.RegisterFileRef](_, IPXACT2022scalaxb.ElemName(node) :: stack) },
        p5.headOption map { IPXACT2022scalaxb.fromXML[IPXACT2022ScalaCases.RegisterRef](_, IPXACT2022scalaxb.ElemName(node) :: stack) },
        p6.headOption map { IPXACT2022scalaxb.fromXML[IPXACT2022ScalaCases.AlternateRegisterRef](_, IPXACT2022scalaxb.ElemName(node) :: stack) },
        IPXACT2022scalaxb.fromXML[IPXACT2022ScalaCases.FieldRef](p7, IPXACT2022scalaxb.ElemName(node) :: stack))) })
    
    def parsemixedFieldReferenceGroupGroup(node: scala.xml.Node, stack: List[IPXACT2022scalaxb.ElemName]): Parser[Seq[IPXACT2022scalaxb.DataRecord[Any]]] =
      ((opt(((((IPXACT2022scalaxb.ElemName(Some("http://www.accellera.org/XMLSchema/IPXACT/1685-2022"), "addressSpaceRef")) ^^
      (x => IPXACT2022scalaxb.DataRecord(x.namespace, Some(x.name), IPXACT2022scalaxb.fromXML[IPXACT2022ScalaCases.AddressSpaceRef2](x, IPXACT2022scalaxb.ElemName(node) :: stack)))) ~
      optTextRecord) ^^ 
        { case p1 ~ p2 => Seq.concat(Seq(p1),
        p2.toList) }) ||| 
      ((((IPXACT2022scalaxb.ElemName(Some("http://www.accellera.org/XMLSchema/IPXACT/1685-2022"), "memoryMapRef")) ^^
      (x => IPXACT2022scalaxb.DataRecord(x.namespace, Some(x.name), IPXACT2022scalaxb.fromXML[IPXACT2022ScalaCases.MemoryMapRef2](x, IPXACT2022scalaxb.ElemName(node) :: stack)))) ~
      optTextRecord ~ 
      (opt(IPXACT2022scalaxb.ElemName(Some("http://www.accellera.org/XMLSchema/IPXACT/1685-2022"), "memoryRemapRef")) ^^
      (_ map { x => IPXACT2022scalaxb.DataRecord(x.namespace, Some(x.name), IPXACT2022scalaxb.fromXML[IPXACT2022ScalaCases.MemoryRemapRef](x, IPXACT2022scalaxb.ElemName(node) :: stack)) })) ~
      optTextRecord) ^^ 
        { case p1 ~ p2 ~ p3 ~ p4 => Seq.concat(Seq(p1),
        p2.toList,
        p3.toList,
        p4.toList) })) ~ 
      optTextRecord ~ 
      (safeRep(IPXACT2022scalaxb.ElemName(Some("http://www.accellera.org/XMLSchema/IPXACT/1685-2022"), "bankRef")) ^^
      (_.toSeq map { x => IPXACT2022scalaxb.DataRecord(x.namespace, Some(x.name), IPXACT2022scalaxb.fromXML[IPXACT2022ScalaCases.BankRef](x, IPXACT2022scalaxb.ElemName(node) :: stack)) })) ~
      optTextRecord ~ 
      (opt(IPXACT2022scalaxb.ElemName(Some("http://www.accellera.org/XMLSchema/IPXACT/1685-2022"), "addressBlockRef")) ^^
      (_ map { x => IPXACT2022scalaxb.DataRecord(x.namespace, Some(x.name), IPXACT2022scalaxb.fromXML[IPXACT2022ScalaCases.AddressBlockRef](x, IPXACT2022scalaxb.ElemName(node) :: stack)) })) ~
      optTextRecord ~ 
      (safeRep(IPXACT2022scalaxb.ElemName(Some("http://www.accellera.org/XMLSchema/IPXACT/1685-2022"), "registerFileRef")) ^^
      (_.toSeq map { x => IPXACT2022scalaxb.DataRecord(x.namespace, Some(x.name), IPXACT2022scalaxb.fromXML[IPXACT2022ScalaCases.RegisterFileRef](x, IPXACT2022scalaxb.ElemName(node) :: stack)) })) ~
      optTextRecord ~ 
      (opt(IPXACT2022scalaxb.ElemName(Some("http://www.accellera.org/XMLSchema/IPXACT/1685-2022"), "registerRef")) ^^
      (_ map { x => IPXACT2022scalaxb.DataRecord(x.namespace, Some(x.name), IPXACT2022scalaxb.fromXML[IPXACT2022ScalaCases.RegisterRef](x, IPXACT2022scalaxb.ElemName(node) :: stack)) })) ~
      optTextRecord ~ 
      (opt(IPXACT2022scalaxb.ElemName(Some("http://www.accellera.org/XMLSchema/IPXACT/1685-2022"), "alternateRegisterRef")) ^^
      (_ map { x => IPXACT2022scalaxb.DataRecord(x.namespace, Some(x.name), IPXACT2022scalaxb.fromXML[IPXACT2022ScalaCases.AlternateRegisterRef](x, IPXACT2022scalaxb.ElemName(node) :: stack)) })) ~
      optTextRecord ~ 
      ((IPXACT2022scalaxb.ElemName(Some("http://www.accellera.org/XMLSchema/IPXACT/1685-2022"), "fieldRef")) ^^
      (x => IPXACT2022scalaxb.DataRecord(x.namespace, Some(x.name), IPXACT2022scalaxb.fromXML[IPXACT2022ScalaCases.FieldRef](x, IPXACT2022scalaxb.ElemName(node) :: stack)))) ~
      optTextRecord) ^^ 
        { case p1 ~ p2 ~ p3 ~ p4 ~ p5 ~ p6 ~ p7 ~ p8 ~ p9 ~ p10 ~ p11 ~ p12 ~ p13 ~ p14 => Seq.concat(p1 getOrElse {Nil},
        p2.toList,
        p3,
        p4.toList,
        p5.toList,
        p6.toList,
        p7,
        p8.toList,
        p9.toList,
        p10.toList,
        p11.toList,
        p12.toList,
        Seq(p13),
        p14.toList) })
  }

  trait DefaultIPXACT2022ScalaCases_FieldReferenceGroupSequence2Format extends IPXACT2022scalaxb.XMLFormat[IPXACT2022ScalaCases.FieldReferenceGroupSequence2] {
    def reads(seq: scala.xml.NodeSeq, stack: List[IPXACT2022scalaxb.ElemName]): Either[String, IPXACT2022ScalaCases.FieldReferenceGroupSequence2] = Left("don't call me.")
    
    def writes(__obj: IPXACT2022ScalaCases.FieldReferenceGroupSequence2, __namespace: Option[String], __elementLabel: Option[String],
        __scope: scala.xml.NamespaceBinding, __typeAttribute: Boolean): scala.xml.NodeSeq =
      Seq.concat(IPXACT2022scalaxb.toXML[IPXACT2022ScalaCases.MemoryMapRef2](__obj.memoryMapRef, Some("http://www.accellera.org/XMLSchema/IPXACT/1685-2022"), Some("memoryMapRef"), __scope, false),
        __obj.memoryRemapRef map { IPXACT2022scalaxb.toXML[IPXACT2022ScalaCases.MemoryRemapRef](_, Some("http://www.accellera.org/XMLSchema/IPXACT/1685-2022"), Some("memoryRemapRef"), __scope, false) } getOrElse {Nil})


  }

  trait DefaultIPXACT2022ScalaCases_FieldReferenceGroupSequenceFormat extends IPXACT2022scalaxb.XMLFormat[IPXACT2022ScalaCases.FieldReferenceGroupSequence] {
    def reads(seq: scala.xml.NodeSeq, stack: List[IPXACT2022scalaxb.ElemName]): Either[String, IPXACT2022ScalaCases.FieldReferenceGroupSequence] = Left("don't call me.")
    
    def writes(__obj: IPXACT2022ScalaCases.FieldReferenceGroupSequence, __namespace: Option[String], __elementLabel: Option[String],
        __scope: scala.xml.NamespaceBinding, __typeAttribute: Boolean): scala.xml.NodeSeq =
      Seq.concat(__obj.fieldreferencegroupoption1 map { x => IPXACT2022scalaxb.toXML[IPXACT2022scalaxb.DataRecord[IPXACT2022ScalaCases.FieldReferenceGroupOption1]](x, x.namespace, x.key, __scope, false) } getOrElse {Nil},
        __obj.bankRef flatMap { IPXACT2022scalaxb.toXML[IPXACT2022ScalaCases.BankRef](_, Some("http://www.accellera.org/XMLSchema/IPXACT/1685-2022"), Some("bankRef"), __scope, false) },
        __obj.addressBlockRef map { IPXACT2022scalaxb.toXML[IPXACT2022ScalaCases.AddressBlockRef](_, Some("http://www.accellera.org/XMLSchema/IPXACT/1685-2022"), Some("addressBlockRef"), __scope, false) } getOrElse {Nil},
        __obj.registerFileRef flatMap { IPXACT2022scalaxb.toXML[IPXACT2022ScalaCases.RegisterFileRef](_, Some("http://www.accellera.org/XMLSchema/IPXACT/1685-2022"), Some("registerFileRef"), __scope, false) },
        __obj.registerRef map { IPXACT2022scalaxb.toXML[IPXACT2022ScalaCases.RegisterRef](_, Some("http://www.accellera.org/XMLSchema/IPXACT/1685-2022"), Some("registerRef"), __scope, false) } getOrElse {Nil},
        __obj.alternateRegisterRef map { IPXACT2022scalaxb.toXML[IPXACT2022ScalaCases.AlternateRegisterRef](_, Some("http://www.accellera.org/XMLSchema/IPXACT/1685-2022"), Some("alternateRegisterRef"), __scope, false) } getOrElse {Nil},
        IPXACT2022scalaxb.toXML[IPXACT2022ScalaCases.FieldRef](__obj.fieldRef, Some("http://www.accellera.org/XMLSchema/IPXACT/1685-2022"), Some("fieldRef"), __scope, false))


  }

  trait DefaultIPXACT2022ScalaCases_Parameteru46resolveu46attFormat extends IPXACT2022scalaxb.AttributeGroupFormat[IPXACT2022ScalaCases.Parameteru46resolveu46att] {
    val targetNamespace: Option[String] = Some("http://www.accellera.org/XMLSchema/IPXACT/1685-2022")
    
    def reads(seq: scala.xml.NodeSeq, stack: List[IPXACT2022scalaxb.ElemName]): Either[String, IPXACT2022ScalaCases.Parameteru46resolveu46att] = seq match {
      case node: scala.xml.Node => Right(IPXACT2022ScalaCases.Parameteru46resolveu46att((node \ "@resolve").headOption map { IPXACT2022scalaxb.fromXML[IPXACT2022ScalaCases.Resolve](_, IPXACT2022scalaxb.ElemName(node) :: stack) } getOrElse { IPXACT2022scalaxb.fromXML[IPXACT2022ScalaCases.Resolve](scala.xml.Text("immediate"), IPXACT2022scalaxb.ElemName(node) :: stack) }))
      case _ => Left("reads failed: seq must be scala.xml.Node")
    }
    
    def toAttribute(__obj: IPXACT2022ScalaCases.Parameteru46resolveu46att, __attr: scala.xml.MetaData, __scope: scala.xml.NamespaceBinding): scala.xml.MetaData = {
      var attr: scala.xml.MetaData  = __attr
      if (__obj.resolve.toString != "immediate") attr = scala.xml.Attribute(null, "resolve", __obj.resolve.toString, attr)
      attr
    }
  }
  trait DefaultIPXACT2022ScalaCases_Parameteru46attFormat extends IPXACT2022scalaxb.AttributeGroupFormat[IPXACT2022ScalaCases.Parameteru46att] {
    val targetNamespace: Option[String] = Some("http://www.accellera.org/XMLSchema/IPXACT/1685-2022")
    
    def reads(seq: scala.xml.NodeSeq, stack: List[IPXACT2022scalaxb.ElemName]): Either[String, IPXACT2022ScalaCases.Parameteru46att] = seq match {
      case node: scala.xml.Node => Right(IPXACT2022ScalaCases.Parameteru46att((node \ "@parameterId").headOption map { IPXACT2022scalaxb.fromXML[String](_, IPXACT2022scalaxb.ElemName(node) :: stack) },
      (node \ "@prompt").headOption map { IPXACT2022scalaxb.fromXML[String](_, IPXACT2022scalaxb.ElemName(node) :: stack) },
      (node \ "@choiceRef").headOption map { IPXACT2022scalaxb.fromXML[String](_, IPXACT2022scalaxb.ElemName(node) :: stack) },
      (node \ "@order").headOption map { IPXACT2022scalaxb.fromXML[Float](_, IPXACT2022scalaxb.ElemName(node) :: stack) },
      (node \ "@configGroups").headOption map { IPXACT2022scalaxb.fromXML[Seq[String]](_, IPXACT2022scalaxb.ElemName(node) :: stack) },
      (node \ "@minimum").headOption map { IPXACT2022scalaxb.fromXML[String](_, IPXACT2022scalaxb.ElemName(node) :: stack) },
      (node \ "@maximum").headOption map { IPXACT2022scalaxb.fromXML[String](_, IPXACT2022scalaxb.ElemName(node) :: stack) },
      (node \ "@type").headOption map { IPXACT2022scalaxb.fromXML[IPXACT2022ScalaCases.FormatType](_, IPXACT2022scalaxb.ElemName(node) :: stack) } getOrElse { IPXACT2022scalaxb.fromXML[IPXACT2022ScalaCases.FormatType](scala.xml.Text("string"), IPXACT2022scalaxb.ElemName(node) :: stack) },
      (node \ "@sign").headOption map { IPXACT2022scalaxb.fromXML[IPXACT2022ScalaCases.SignType](_, IPXACT2022scalaxb.ElemName(node) :: stack) },
      (node \ "@prefix").headOption map { IPXACT2022scalaxb.fromXML[IPXACT2022ScalaCases.Prefix](_, IPXACT2022scalaxb.ElemName(node) :: stack) },
      (node \ "@unit").headOption map { IPXACT2022scalaxb.fromXML[IPXACT2022ScalaCases.UnitType](_, IPXACT2022scalaxb.ElemName(node) :: stack) }))
      case _ => Left("reads failed: seq must be scala.xml.Node")
    }
    
    def toAttribute(__obj: IPXACT2022ScalaCases.Parameteru46att, __attr: scala.xml.MetaData, __scope: scala.xml.NamespaceBinding): scala.xml.MetaData = {
      var attr: scala.xml.MetaData  = __attr
      __obj.parameterId foreach { x => attr = scala.xml.Attribute(null, "parameterId", x.toString, attr) }
    __obj.prompt foreach { x => attr = scala.xml.Attribute(null, "prompt", x.toString, attr) }
    __obj.choiceRef foreach { x => attr = scala.xml.Attribute(null, "choiceRef", x.toString, attr) }
    __obj.order foreach { x => attr = scala.xml.Attribute(null, "order", x.toString, attr) }
    __obj.configGroups foreach { x => attr = scala.xml.Attribute(null, "configGroups", x.toString, attr) }
    __obj.minimum foreach { x => attr = scala.xml.Attribute(null, "minimum", x.toString, attr) }
    __obj.maximum foreach { x => attr = scala.xml.Attribute(null, "maximum", x.toString, attr) }
    if (__obj.typeValue.toString != "string") attr = scala.xml.Attribute(null, "type", __obj.typeValue.toString, attr)
    __obj.sign foreach { x => attr = scala.xml.Attribute(null, "sign", x.toString, attr) }
    __obj.prefix foreach { x => attr = scala.xml.Attribute(null, "prefix", x.toString, attr) }
    __obj.unit foreach { x => attr = scala.xml.Attribute(null, "unit", x.toString, attr) }
      attr
    }
  }

  trait DefaultIPXACT2022ScalaCases_Parameteru46unitu46attFormat extends IPXACT2022scalaxb.AttributeGroupFormat[IPXACT2022ScalaCases.Parameteru46unitu46att] {
    val targetNamespace: Option[String] = Some("http://www.accellera.org/XMLSchema/IPXACT/1685-2022")
    
    def reads(seq: scala.xml.NodeSeq, stack: List[IPXACT2022scalaxb.ElemName]): Either[String, IPXACT2022ScalaCases.Parameteru46unitu46att] = seq match {
      case node: scala.xml.Node => Right(IPXACT2022ScalaCases.Parameteru46unitu46att((node \ "@unit").headOption map { IPXACT2022scalaxb.fromXML[IPXACT2022ScalaCases.UnitTypeType](_, IPXACT2022scalaxb.ElemName(node) :: stack) }))
      case _ => Left("reads failed: seq must be scala.xml.Node")
    }
    
    def toAttribute(__obj: IPXACT2022ScalaCases.Parameteru46unitu46att, __attr: scala.xml.MetaData, __scope: scala.xml.NamespaceBinding): scala.xml.MetaData = {
      var attr: scala.xml.MetaData  = __attr
      __obj.unit foreach { x => attr = scala.xml.Attribute(null, "unit", x.toString, attr) }
      attr
    }
  }
  trait DefaultIPXACT2022ScalaCases_TypeDefinitionsFormat extends IPXACT2022scalaxb.ElemNameParser[IPXACT2022ScalaCases.TypeDefinitions] {
    val targetNamespace: Option[String] = Some("http://www.accellera.org/XMLSchema/IPXACT/1685-2022")
    
    def parser(node: scala.xml.Node, stack: List[IPXACT2022scalaxb.ElemName]): Parser[IPXACT2022ScalaCases.TypeDefinitions] =
      phrase(opt((safeRep(IPXACT2022scalaxb.ElemName(Some("http://www.accellera.org/XMLSchema/IPXACT/1685-2022"), "externalTypeDefinitions"))) ^^
        { case p1 => IPXACT2022ScalaCases.TypeDefinitionsSequence1(p1 map { IPXACT2022scalaxb.fromXML[IPXACT2022ScalaCases.ExternalTypeDefinitions](_, IPXACT2022scalaxb.ElemName(node) :: stack) }: _*) }) ^^
      { case p1 =>
      IPXACT2022ScalaCases.TypeDefinitions(p1) })
    
    def writesChildNodes(__obj: IPXACT2022ScalaCases.TypeDefinitions, __scope: scala.xml.NamespaceBinding): Seq[scala.xml.Node] =
      (__obj.typedefinitionssequence1 map { IPXACT2022scalaxb.toXML[IPXACT2022ScalaCases.TypeDefinitionsSequence1](_, None, Some("typedefinitionssequence1"), __scope, false) } getOrElse {Nil})
  }

  trait DefaultIPXACT2022ScalaCases_TypeDefinitionsSequence1Format extends IPXACT2022scalaxb.XMLFormat[IPXACT2022ScalaCases.TypeDefinitionsSequence1] {
    def reads(seq: scala.xml.NodeSeq, stack: List[IPXACT2022scalaxb.ElemName]): Either[String, IPXACT2022ScalaCases.TypeDefinitionsSequence1] = Left("don't call me.")
    
    def writes(__obj: IPXACT2022ScalaCases.TypeDefinitionsSequence1, __namespace: Option[String], __elementLabel: Option[String],
        __scope: scala.xml.NamespaceBinding, __typeAttribute: Boolean): scala.xml.NodeSeq =
      __obj.externalTypeDefinitions flatMap { IPXACT2022scalaxb.toXML[IPXACT2022ScalaCases.ExternalTypeDefinitions](_, Some("http://www.accellera.org/XMLSchema/IPXACT/1685-2022"), Some("externalTypeDefinitions"), __scope, false) }

  }
  trait DefaultIPXACT2022ScalaCases_PowerDomainFormat extends IPXACT2022scalaxb.ElemNameParser[IPXACT2022ScalaCases.PowerDomain] with IPXACT2022ScalaCases_NameGroupGroupFormat {
    val targetNamespace: Option[String] = Some("http://www.accellera.org/XMLSchema/IPXACT/1685-2022")
    
    def parser(node: scala.xml.Node, stack: List[IPXACT2022scalaxb.ElemName]): Parser[IPXACT2022ScalaCases.PowerDomain] =
      phrase((parseNameGroupGroup(node, IPXACT2022scalaxb.ElemName(node) :: stack)) ~
      opt(IPXACT2022scalaxb.ElemName(Some("http://www.accellera.org/XMLSchema/IPXACT/1685-2022"), "alwaysOn")) ~
      opt(IPXACT2022scalaxb.ElemName(Some("http://www.accellera.org/XMLSchema/IPXACT/1685-2022"), "subDomainOf")) ~
      opt(IPXACT2022scalaxb.ElemName(Some("http://www.accellera.org/XMLSchema/IPXACT/1685-2022"), "parameters")) ~
      opt(IPXACT2022scalaxb.ElemName(Some("http://www.accellera.org/XMLSchema/IPXACT/1685-2022"), "vendorExtensions")) ^^
      { case p1 ~ p2 ~ p3 ~ p4 ~ p5 =>
      IPXACT2022ScalaCases.PowerDomain(p1,
        p2.headOption map { IPXACT2022scalaxb.fromXML[IPXACT2022ScalaCases.UnsignedBitExpression](_, IPXACT2022scalaxb.ElemName(node) :: stack) },
        p3.headOption map { IPXACT2022scalaxb.fromXML[String](_, IPXACT2022scalaxb.ElemName(node) :: stack) },
        p4.headOption map { IPXACT2022scalaxb.fromXML[IPXACT2022ScalaCases.Parameters](_, IPXACT2022scalaxb.ElemName(node) :: stack) },
        p5.headOption map { IPXACT2022scalaxb.fromXML[IPXACT2022ScalaCases.VendorExtensions](_, IPXACT2022scalaxb.ElemName(node) :: stack) },
        scala.collection.immutable.ListMap(List(
        (node \ "@{http://www.w3.org/XML/1998/namespace}id").headOption map { x => IPXACT2022scalaxb.DataRecord(x, node, IPXACT2022scalaxb.fromXML[String](x, IPXACT2022scalaxb.ElemName(node) :: stack)) } map { "@{http://www.w3.org/XML/1998/namespace}id" -> _ }
        ).flatten[(String, IPXACT2022scalaxb.DataRecord[Any])]: _*)) })
    
    override def writesAttribute(__obj: IPXACT2022ScalaCases.PowerDomain, __scope: scala.xml.NamespaceBinding): scala.xml.MetaData = {
      var attr: scala.xml.MetaData  = scala.xml.Null
      __obj.attributes.toList map {
        case ("@{http://www.w3.org/XML/1998/namespace}id", _) => __obj.xmlid foreach { x => attr = scala.xml.Attribute(__scope.getPrefix("http://www.w3.org/XML/1998/namespace"), "id", x.toString, attr) }
        case (key, x) => attr = scala.xml.Attribute((x.namespace map { __scope.getPrefix(_) }).orNull, x.key.orNull, x.value.toString, attr)
      }
      attr
    }

    def writesChildNodes(__obj: IPXACT2022ScalaCases.PowerDomain, __scope: scala.xml.NamespaceBinding): Seq[scala.xml.Node] =
      Seq.concat(IPXACT2022scalaxb.toXML[IPXACT2022ScalaCases.NameGroupSequence](__obj.nameGroupSequence1, None, Some("nameGroupSequence1"), __scope, false),
        __obj.alwaysOn map { IPXACT2022scalaxb.toXML[IPXACT2022ScalaCases.UnsignedBitExpression](_, Some("http://www.accellera.org/XMLSchema/IPXACT/1685-2022"), Some("alwaysOn"), __scope, false) } getOrElse {Nil},
        __obj.subDomainOf map { IPXACT2022scalaxb.toXML[String](_, Some("http://www.accellera.org/XMLSchema/IPXACT/1685-2022"), Some("subDomainOf"), __scope, false) } getOrElse {Nil},
        __obj.parameters map { IPXACT2022scalaxb.toXML[IPXACT2022ScalaCases.Parameters](_, Some("http://www.accellera.org/XMLSchema/IPXACT/1685-2022"), Some("parameters"), __scope, false) } getOrElse {Nil},
        __obj.vendorExtensions map { IPXACT2022scalaxb.toXML[IPXACT2022ScalaCases.VendorExtensions](_, Some("http://www.accellera.org/XMLSchema/IPXACT/1685-2022"), Some("vendorExtensions"), __scope, false) } getOrElse {Nil})

  }

  trait DefaultIPXACT2022ScalaCases_PowerDomainsFormat extends IPXACT2022scalaxb.ElemNameParser[IPXACT2022ScalaCases.PowerDomains] {
    val targetNamespace: Option[String] = Some("http://www.accellera.org/XMLSchema/IPXACT/1685-2022")
    
    def parser(node: scala.xml.Node, stack: List[IPXACT2022scalaxb.ElemName]): Parser[IPXACT2022ScalaCases.PowerDomains] =
      phrase(safeRep(IPXACT2022scalaxb.ElemName(Some("http://www.accellera.org/XMLSchema/IPXACT/1685-2022"), "powerDomain")) ^^
      { case p1 =>
      IPXACT2022ScalaCases.PowerDomains(p1 map { IPXACT2022scalaxb.fromXML[IPXACT2022ScalaCases.PowerDomain](_, IPXACT2022scalaxb.ElemName(node) :: stack) }) })
    
    def writesChildNodes(__obj: IPXACT2022ScalaCases.PowerDomains, __scope: scala.xml.NamespaceBinding): Seq[scala.xml.Node] =
      (__obj.powerDomain flatMap { IPXACT2022scalaxb.toXML[IPXACT2022ScalaCases.PowerDomain](_, Some("http://www.accellera.org/XMLSchema/IPXACT/1685-2022"), Some("powerDomain"), __scope, false) })
  }
  trait DefaultIPXACT2022ScalaCases_PortRefFormat extends IPXACT2022scalaxb.XMLFormat[IPXACT2022ScalaCases.PortRef] with IPXACT2022scalaxb.CanWriteChildNodes[IPXACT2022ScalaCases.PortRef] {
    val targetNamespace: Option[String] = Some("http://www.accellera.org/XMLSchema/IPXACT/1685-2022")
    def reads(seq: scala.xml.NodeSeq, stack: List[IPXACT2022scalaxb.ElemName]): Either[String, IPXACT2022ScalaCases.PortRef] = seq match {
      case node: scala.xml.Node => Right(IPXACT2022ScalaCases.PortRef(scala.collection.immutable.ListMap(List(
        (node \ "@portRef").headOption map { x => IPXACT2022scalaxb.DataRecord(x, node, IPXACT2022scalaxb.fromXML[String](x, IPXACT2022scalaxb.ElemName(node) :: stack)) } map { "@portRef" -> _ }
        ).flatten[(String, IPXACT2022scalaxb.DataRecord[Any])]: _*)))
      case _ => Left("reads failed: seq must be scala.xml.Node")
    }
    
    override def writesAttribute(__obj: IPXACT2022ScalaCases.PortRef, __scope: scala.xml.NamespaceBinding): scala.xml.MetaData = {
      var attr: scala.xml.MetaData  = scala.xml.Null
      __obj.attributes.toList map {
        case ("@portRef", _) => attr = scala.xml.Attribute(null, "portRef", __obj.portRef.toString, attr)
        case (key, x) => attr = scala.xml.Attribute((x.namespace map { __scope.getPrefix(_) }).orNull, x.key.orNull, x.value.toString, attr)
      }
      attr
    }

    def writesChildNodes(__obj: IPXACT2022ScalaCases.PortRef, __scope: scala.xml.NamespaceBinding): Seq[scala.xml.Node] =
      Nil

  }

  trait DefaultIPXACT2022ScalaCases_PortSliceFormat extends IPXACT2022scalaxb.ElemNameParser[IPXACT2022ScalaCases.PortSlice] with IPXACT2022ScalaCases_NameGroupGroupFormat {
    val targetNamespace: Option[String] = Some("http://www.accellera.org/XMLSchema/IPXACT/1685-2022")
    
    def parser(node: scala.xml.Node, stack: List[IPXACT2022scalaxb.ElemName]): Parser[IPXACT2022ScalaCases.PortSlice] =
      phrase((parseNameGroupGroup(node, IPXACT2022scalaxb.ElemName(node) :: stack)) ~
      (IPXACT2022scalaxb.ElemName(Some("http://www.accellera.org/XMLSchema/IPXACT/1685-2022"), "portRef")) ~
      safeRep(IPXACT2022scalaxb.ElemName(Some("http://www.accellera.org/XMLSchema/IPXACT/1685-2022"), "subPortReference")) ~
      opt(IPXACT2022scalaxb.ElemName(Some("http://www.accellera.org/XMLSchema/IPXACT/1685-2022"), "partSelect")) ^^
      { case p1 ~ p2 ~ p3 ~ p4 =>
      IPXACT2022ScalaCases.PortSlice(p1,
        IPXACT2022scalaxb.fromXML[IPXACT2022ScalaCases.PortRef](p2, IPXACT2022scalaxb.ElemName(node) :: stack),
        p3 map { IPXACT2022scalaxb.fromXML[IPXACT2022ScalaCases.SubPortReference](_, IPXACT2022scalaxb.ElemName(node) :: stack) },
        p4.headOption map { IPXACT2022scalaxb.fromXML[IPXACT2022ScalaCases.PartSelect](_, IPXACT2022scalaxb.ElemName(node) :: stack) },
        scala.collection.immutable.ListMap(List(
        (node \ "@{http://www.w3.org/XML/1998/namespace}id").headOption map { x => IPXACT2022scalaxb.DataRecord(x, node, IPXACT2022scalaxb.fromXML[String](x, IPXACT2022scalaxb.ElemName(node) :: stack)) } map { "@{http://www.w3.org/XML/1998/namespace}id" -> _ }
        ).flatten[(String, IPXACT2022scalaxb.DataRecord[Any])]: _*)) })
    
    override def writesAttribute(__obj: IPXACT2022ScalaCases.PortSlice, __scope: scala.xml.NamespaceBinding): scala.xml.MetaData = {
      var attr: scala.xml.MetaData  = scala.xml.Null
      __obj.attributes.toList map {
        case ("@{http://www.w3.org/XML/1998/namespace}id", _) => __obj.xmlid foreach { x => attr = scala.xml.Attribute(__scope.getPrefix("http://www.w3.org/XML/1998/namespace"), "id", x.toString, attr) }
        case (key, x) => attr = scala.xml.Attribute((x.namespace map { __scope.getPrefix(_) }).orNull, x.key.orNull, x.value.toString, attr)
      }
      attr
    }

    def writesChildNodes(__obj: IPXACT2022ScalaCases.PortSlice, __scope: scala.xml.NamespaceBinding): Seq[scala.xml.Node] =
      Seq.concat(IPXACT2022scalaxb.toXML[IPXACT2022ScalaCases.NameGroupSequence](__obj.nameGroupSequence1, None, Some("nameGroupSequence1"), __scope, false),
        IPXACT2022scalaxb.toXML[IPXACT2022ScalaCases.PortRef](__obj.portRef, Some("http://www.accellera.org/XMLSchema/IPXACT/1685-2022"), Some("portRef"), __scope, false),
        __obj.subPortReference flatMap { IPXACT2022scalaxb.toXML[IPXACT2022ScalaCases.SubPortReference](_, Some("http://www.accellera.org/XMLSchema/IPXACT/1685-2022"), Some("subPortReference"), __scope, false) },
        __obj.partSelect map { IPXACT2022scalaxb.toXML[IPXACT2022ScalaCases.PartSelect](_, Some("http://www.accellera.org/XMLSchema/IPXACT/1685-2022"), Some("partSelect"), __scope, false) } getOrElse {Nil})

  }

  trait DefaultIPXACT2022ScalaCases_FieldSliceFormat extends IPXACT2022scalaxb.ElemNameParser[IPXACT2022ScalaCases.FieldSlice] with IPXACT2022ScalaCases_NameGroupGroupFormat with IPXACT2022ScalaCases_FieldSliceReferenceGroupGroupFormat {
    val targetNamespace: Option[String] = Some("http://www.accellera.org/XMLSchema/IPXACT/1685-2022")
    
    def parser(node: scala.xml.Node, stack: List[IPXACT2022scalaxb.ElemName]): Parser[IPXACT2022ScalaCases.FieldSlice] =
      phrase((parseNameGroupGroup(node, IPXACT2022scalaxb.ElemName(node) :: stack)) ~
      (parseFieldSliceReferenceGroupGroup(node, IPXACT2022scalaxb.ElemName(node) :: stack)) ^^
      { case p1 ~ p2 =>
      IPXACT2022ScalaCases.FieldSlice(p1,
        p2,
        scala.collection.immutable.ListMap(List(
        (node \ "@{http://www.w3.org/XML/1998/namespace}id").headOption map { x => IPXACT2022scalaxb.DataRecord(x, node, IPXACT2022scalaxb.fromXML[String](x, IPXACT2022scalaxb.ElemName(node) :: stack)) } map { "@{http://www.w3.org/XML/1998/namespace}id" -> _ }
        ).flatten[(String, IPXACT2022scalaxb.DataRecord[Any])]: _*)) })
    
    override def writesAttribute(__obj: IPXACT2022ScalaCases.FieldSlice, __scope: scala.xml.NamespaceBinding): scala.xml.MetaData = {
      var attr: scala.xml.MetaData  = scala.xml.Null
      __obj.attributes.toList map {
        case ("@{http://www.w3.org/XML/1998/namespace}id", _) => __obj.xmlid foreach { x => attr = scala.xml.Attribute(__scope.getPrefix("http://www.w3.org/XML/1998/namespace"), "id", x.toString, attr) }
        case (key, x) => attr = scala.xml.Attribute((x.namespace map { __scope.getPrefix(_) }).orNull, x.key.orNull, x.value.toString, attr)
      }
      attr
    }

    def writesChildNodes(__obj: IPXACT2022ScalaCases.FieldSlice, __scope: scala.xml.NamespaceBinding): Seq[scala.xml.Node] =
      Seq.concat(IPXACT2022scalaxb.toXML[IPXACT2022ScalaCases.NameGroupSequence](__obj.nameGroupSequence1, None, Some("nameGroupSequence1"), __scope, false),
        IPXACT2022scalaxb.toXML[IPXACT2022ScalaCases.FieldSliceReferenceGroupSequence](__obj.fieldSliceReferenceGroupSequence2, None, Some("fieldSliceReferenceGroupSequence2"), __scope, false))

  }

  trait DefaultIPXACT2022ScalaCases_ModeFormat extends IPXACT2022scalaxb.ElemNameParser[IPXACT2022ScalaCases.Mode] with IPXACT2022ScalaCases_NameGroupGroupFormat {
    val targetNamespace: Option[String] = Some("http://www.accellera.org/XMLSchema/IPXACT/1685-2022")
    
    def parser(node: scala.xml.Node, stack: List[IPXACT2022scalaxb.ElemName]): Parser[IPXACT2022ScalaCases.Mode] =
      phrase((parseNameGroupGroup(node, IPXACT2022scalaxb.ElemName(node) :: stack)) ~
      safeRep(IPXACT2022scalaxb.ElemName(Some("http://www.accellera.org/XMLSchema/IPXACT/1685-2022"), "portSlice")) ~
      safeRep(IPXACT2022scalaxb.ElemName(Some("http://www.accellera.org/XMLSchema/IPXACT/1685-2022"), "fieldSlice")) ~
      opt(IPXACT2022scalaxb.ElemName(Some("http://www.accellera.org/XMLSchema/IPXACT/1685-2022"), "condition")) ~
      opt(IPXACT2022scalaxb.ElemName(Some("http://www.accellera.org/XMLSchema/IPXACT/1685-2022"), "vendorExtensions")) ^^
      { case p1 ~ p2 ~ p3 ~ p4 ~ p5 =>
      IPXACT2022ScalaCases.Mode(p1,
        p2 map { IPXACT2022scalaxb.fromXML[IPXACT2022ScalaCases.PortSlice](_, IPXACT2022scalaxb.ElemName(node) :: stack) },
        p3 map { IPXACT2022scalaxb.fromXML[IPXACT2022ScalaCases.FieldSlice](_, IPXACT2022scalaxb.ElemName(node) :: stack) },
        p4.headOption map { IPXACT2022scalaxb.fromXML[IPXACT2022ScalaCases.UnresolvedUnsignedBitExpression](_, IPXACT2022scalaxb.ElemName(node) :: stack) },
        p5.headOption map { IPXACT2022scalaxb.fromXML[IPXACT2022ScalaCases.VendorExtensions](_, IPXACT2022scalaxb.ElemName(node) :: stack) },
        scala.collection.immutable.ListMap(List(
        (node \ "@{http://www.w3.org/XML/1998/namespace}id").headOption map { x => IPXACT2022scalaxb.DataRecord(x, node, IPXACT2022scalaxb.fromXML[String](x, IPXACT2022scalaxb.ElemName(node) :: stack)) } map { "@{http://www.w3.org/XML/1998/namespace}id" -> _ }
        ).flatten[(String, IPXACT2022scalaxb.DataRecord[Any])]: _*)) })
    
    override def writesAttribute(__obj: IPXACT2022ScalaCases.Mode, __scope: scala.xml.NamespaceBinding): scala.xml.MetaData = {
      var attr: scala.xml.MetaData  = scala.xml.Null
      __obj.attributes.toList map {
        case ("@{http://www.w3.org/XML/1998/namespace}id", _) => __obj.xmlid foreach { x => attr = scala.xml.Attribute(__scope.getPrefix("http://www.w3.org/XML/1998/namespace"), "id", x.toString, attr) }
        case (key, x) => attr = scala.xml.Attribute((x.namespace map { __scope.getPrefix(_) }).orNull, x.key.orNull, x.value.toString, attr)
      }
      attr
    }

    def writesChildNodes(__obj: IPXACT2022ScalaCases.Mode, __scope: scala.xml.NamespaceBinding): Seq[scala.xml.Node] =
      Seq.concat(IPXACT2022scalaxb.toXML[IPXACT2022ScalaCases.NameGroupSequence](__obj.nameGroupSequence1, None, Some("nameGroupSequence1"), __scope, false),
        __obj.portSlice flatMap { IPXACT2022scalaxb.toXML[IPXACT2022ScalaCases.PortSlice](_, Some("http://www.accellera.org/XMLSchema/IPXACT/1685-2022"), Some("portSlice"), __scope, false) },
        __obj.fieldSlice flatMap { IPXACT2022scalaxb.toXML[IPXACT2022ScalaCases.FieldSlice](_, Some("http://www.accellera.org/XMLSchema/IPXACT/1685-2022"), Some("fieldSlice"), __scope, false) },
        __obj.condition map { IPXACT2022scalaxb.toXML[IPXACT2022ScalaCases.UnresolvedUnsignedBitExpression](_, Some("http://www.accellera.org/XMLSchema/IPXACT/1685-2022"), Some("condition"), __scope, false) } getOrElse {Nil},
        __obj.vendorExtensions map { IPXACT2022scalaxb.toXML[IPXACT2022ScalaCases.VendorExtensions](_, Some("http://www.accellera.org/XMLSchema/IPXACT/1685-2022"), Some("vendorExtensions"), __scope, false) } getOrElse {Nil})

  }

  trait DefaultIPXACT2022ScalaCases_ModesFormat extends IPXACT2022scalaxb.ElemNameParser[IPXACT2022ScalaCases.Modes] {
    val targetNamespace: Option[String] = Some("http://www.accellera.org/XMLSchema/IPXACT/1685-2022")
    
    def parser(node: scala.xml.Node, stack: List[IPXACT2022scalaxb.ElemName]): Parser[IPXACT2022ScalaCases.Modes] =
      phrase(safeRep(IPXACT2022scalaxb.ElemName(Some("http://www.accellera.org/XMLSchema/IPXACT/1685-2022"), "mode")) ^^
      { case p1 =>
      IPXACT2022ScalaCases.Modes(p1 map { IPXACT2022scalaxb.fromXML[IPXACT2022ScalaCases.Mode](_, IPXACT2022scalaxb.ElemName(node) :: stack) }) })
    
    def writesChildNodes(__obj: IPXACT2022ScalaCases.Modes, __scope: scala.xml.NamespaceBinding): Seq[scala.xml.Node] =
      (__obj.mode flatMap { IPXACT2022scalaxb.toXML[IPXACT2022ScalaCases.Mode](_, Some("http://www.accellera.org/XMLSchema/IPXACT/1685-2022"), Some("mode"), __scope, false) })
  }
  trait DefaultIPXACT2022ScalaCases_ClearboxElementsFormat extends IPXACT2022scalaxb.ElemNameParser[IPXACT2022ScalaCases.ClearboxElements] {
    val targetNamespace: Option[String] = Some("http://www.accellera.org/XMLSchema/IPXACT/1685-2022")
    
    def parser(node: scala.xml.Node, stack: List[IPXACT2022scalaxb.ElemName]): Parser[IPXACT2022ScalaCases.ClearboxElements] =
      phrase(safeRep(IPXACT2022scalaxb.ElemName(Some("http://www.accellera.org/XMLSchema/IPXACT/1685-2022"), "clearboxElement")) ^^
      { case p1 =>
      IPXACT2022ScalaCases.ClearboxElements(p1 map { IPXACT2022scalaxb.fromXML[IPXACT2022ScalaCases.ClearboxElementType](_, IPXACT2022scalaxb.ElemName(node) :: stack) }) })
    
    def writesChildNodes(__obj: IPXACT2022ScalaCases.ClearboxElements, __scope: scala.xml.NamespaceBinding): Seq[scala.xml.Node] =
      (__obj.clearboxElement flatMap { IPXACT2022scalaxb.toXML[IPXACT2022ScalaCases.ClearboxElementType](_, Some("http://www.accellera.org/XMLSchema/IPXACT/1685-2022"), Some("clearboxElement"), __scope, false) })
  }
  trait DefaultIPXACT2022ScalaCases_RegionFormat extends IPXACT2022scalaxb.ElemNameParser[IPXACT2022ScalaCases.Region] with IPXACT2022ScalaCases_NameGroupGroupFormat {
    val targetNamespace: Option[String] = Some("http://www.accellera.org/XMLSchema/IPXACT/1685-2022")
    
    def parser(node: scala.xml.Node, stack: List[IPXACT2022scalaxb.ElemName]): Parser[IPXACT2022ScalaCases.Region] =
      phrase((parseNameGroupGroup(node, IPXACT2022scalaxb.ElemName(node) :: stack)) ~
      (IPXACT2022scalaxb.ElemName(Some("http://www.accellera.org/XMLSchema/IPXACT/1685-2022"), "addressOffset")) ~
      (IPXACT2022scalaxb.ElemName(Some("http://www.accellera.org/XMLSchema/IPXACT/1685-2022"), "range")) ~
      opt(IPXACT2022scalaxb.ElemName(Some("http://www.accellera.org/XMLSchema/IPXACT/1685-2022"), "vendorExtensions")) ^^
      { case p1 ~ p2 ~ p3 ~ p4 =>
      IPXACT2022ScalaCases.Region(p1,
        IPXACT2022scalaxb.fromXML[IPXACT2022ScalaCases.UnsignedLongintExpressionable](p2, IPXACT2022scalaxb.ElemName(node) :: stack),
        IPXACT2022scalaxb.fromXML[IPXACT2022ScalaCases.UnsignedPositiveLongintExpressionable](p3, IPXACT2022scalaxb.ElemName(node) :: stack),
        p4.headOption map { IPXACT2022scalaxb.fromXML[IPXACT2022ScalaCases.VendorExtensions](_, IPXACT2022scalaxb.ElemName(node) :: stack) },
        scala.collection.immutable.ListMap(List(
        (node \ "@{http://www.w3.org/XML/1998/namespace}id").headOption map { x => IPXACT2022scalaxb.DataRecord(x, node, IPXACT2022scalaxb.fromXML[String](x, IPXACT2022scalaxb.ElemName(node) :: stack)) } map { "@{http://www.w3.org/XML/1998/namespace}id" -> _ }
        ).flatten[(String, IPXACT2022scalaxb.DataRecord[Any])]: _*)) })
    
    override def writesAttribute(__obj: IPXACT2022ScalaCases.Region, __scope: scala.xml.NamespaceBinding): scala.xml.MetaData = {
      var attr: scala.xml.MetaData  = scala.xml.Null
      __obj.attributes.toList map {
        case ("@{http://www.w3.org/XML/1998/namespace}id", _) => __obj.xmlid foreach { x => attr = scala.xml.Attribute(__scope.getPrefix("http://www.w3.org/XML/1998/namespace"), "id", x.toString, attr) }
        case (key, x) => attr = scala.xml.Attribute((x.namespace map { __scope.getPrefix(_) }).orNull, x.key.orNull, x.value.toString, attr)
      }
      attr
    }

    def writesChildNodes(__obj: IPXACT2022ScalaCases.Region, __scope: scala.xml.NamespaceBinding): Seq[scala.xml.Node] =
      Seq.concat(IPXACT2022scalaxb.toXML[IPXACT2022ScalaCases.NameGroupSequence](__obj.nameGroupSequence1, None, Some("nameGroupSequence1"), __scope, false),
        IPXACT2022scalaxb.toXML[IPXACT2022ScalaCases.UnsignedLongintExpressionable](__obj.addressOffset, Some("http://www.accellera.org/XMLSchema/IPXACT/1685-2022"), Some("addressOffset"), __scope, false),
        IPXACT2022scalaxb.toXML[IPXACT2022ScalaCases.UnsignedPositiveLongintExpressionable](__obj.range, Some("http://www.accellera.org/XMLSchema/IPXACT/1685-2022"), Some("range"), __scope, false),
        __obj.vendorExtensions map { IPXACT2022scalaxb.toXML[IPXACT2022ScalaCases.VendorExtensions](_, Some("http://www.accellera.org/XMLSchema/IPXACT/1685-2022"), Some("vendorExtensions"), __scope, false) } getOrElse {Nil})

  }

  trait DefaultIPXACT2022ScalaCases_RegionsFormat extends IPXACT2022scalaxb.ElemNameParser[IPXACT2022ScalaCases.Regions] {
    val targetNamespace: Option[String] = Some("http://www.accellera.org/XMLSchema/IPXACT/1685-2022")
    
    def parser(node: scala.xml.Node, stack: List[IPXACT2022scalaxb.ElemName]): Parser[IPXACT2022ScalaCases.Regions] =
      phrase(safeRep(IPXACT2022scalaxb.ElemName(Some("http://www.accellera.org/XMLSchema/IPXACT/1685-2022"), "region")) ^^
      { case p1 =>
      IPXACT2022ScalaCases.Regions(p1 map { IPXACT2022scalaxb.fromXML[IPXACT2022ScalaCases.Region](_, IPXACT2022scalaxb.ElemName(node) :: stack) }) })
    
    def writesChildNodes(__obj: IPXACT2022ScalaCases.Regions, __scope: scala.xml.NamespaceBinding): Seq[scala.xml.Node] =
      (__obj.region flatMap { IPXACT2022scalaxb.toXML[IPXACT2022ScalaCases.Region](_, Some("http://www.accellera.org/XMLSchema/IPXACT/1685-2022"), Some("region"), __scope, false) })
  }
  trait DefaultIPXACT2022ScalaCases_CpuFormat extends IPXACT2022scalaxb.ElemNameParser[IPXACT2022ScalaCases.Cpu] with IPXACT2022ScalaCases_NameGroupGroupFormat with IPXACT2022ScalaCases_BlockSizeGroupFormat {
    val targetNamespace: Option[String] = Some("http://www.accellera.org/XMLSchema/IPXACT/1685-2022")
    
    def parser(node: scala.xml.Node, stack: List[IPXACT2022scalaxb.ElemName]): Parser[IPXACT2022ScalaCases.Cpu] =
      phrase((parseNameGroupGroup(node, IPXACT2022scalaxb.ElemName(node) :: stack)) ~
      (parseBlockSizeGroup(node, IPXACT2022scalaxb.ElemName(node) :: stack)) ~
      opt(IPXACT2022scalaxb.ElemName(Some("http://www.accellera.org/XMLSchema/IPXACT/1685-2022"), "regions")) ~
      opt(IPXACT2022scalaxb.ElemName(Some("http://www.accellera.org/XMLSchema/IPXACT/1685-2022"), "addressUnitBits")) ~
      safeRep(IPXACT2022scalaxb.ElemName(Some("http://www.accellera.org/XMLSchema/IPXACT/1685-2022"), "executableImage")) ~
      (IPXACT2022scalaxb.ElemName(Some("http://www.accellera.org/XMLSchema/IPXACT/1685-2022"), "memoryMapRef")) ~
      opt(IPXACT2022scalaxb.ElemName(Some("http://www.accellera.org/XMLSchema/IPXACT/1685-2022"), "parameters")) ~
      opt(IPXACT2022scalaxb.ElemName(Some("http://www.accellera.org/XMLSchema/IPXACT/1685-2022"), "vendorExtensions")) ^^
      { case p1 ~ p2 ~ p3 ~ p4 ~ p5 ~ p6 ~ p7 ~ p8 =>
      IPXACT2022ScalaCases.Cpu(p1,
        p2,
        p3.headOption map { IPXACT2022scalaxb.fromXML[IPXACT2022ScalaCases.Regions](_, IPXACT2022scalaxb.ElemName(node) :: stack) },
        p4.headOption map { IPXACT2022scalaxb.fromXML[IPXACT2022ScalaCases.UnsignedPositiveLongintExpressionable](_, IPXACT2022scalaxb.ElemName(node) :: stack) },
        p5 map { IPXACT2022scalaxb.fromXML[IPXACT2022ScalaCases.ExecutableImage](_, IPXACT2022scalaxb.ElemName(node) :: stack) },
        IPXACT2022scalaxb.fromXML[String](p6, IPXACT2022scalaxb.ElemName(node) :: stack),
        p7.headOption map { IPXACT2022scalaxb.fromXML[IPXACT2022ScalaCases.Parameters](_, IPXACT2022scalaxb.ElemName(node) :: stack) },
        p8.headOption map { IPXACT2022scalaxb.fromXML[IPXACT2022ScalaCases.VendorExtensions](_, IPXACT2022scalaxb.ElemName(node) :: stack) },
        scala.collection.immutable.ListMap(List(
        (node \ "@{http://www.w3.org/XML/1998/namespace}id").headOption map { x => IPXACT2022scalaxb.DataRecord(x, node, IPXACT2022scalaxb.fromXML[String](x, IPXACT2022scalaxb.ElemName(node) :: stack)) } map { "@{http://www.w3.org/XML/1998/namespace}id" -> _ }
        ).flatten[(String, IPXACT2022scalaxb.DataRecord[Any])]: _*)) })
    
    override def writesAttribute(__obj: IPXACT2022ScalaCases.Cpu, __scope: scala.xml.NamespaceBinding): scala.xml.MetaData = {
      var attr: scala.xml.MetaData  = scala.xml.Null
      __obj.attributes.toList map {
        case ("@{http://www.w3.org/XML/1998/namespace}id", _) => __obj.xmlid foreach { x => attr = scala.xml.Attribute(__scope.getPrefix("http://www.w3.org/XML/1998/namespace"), "id", x.toString, attr) }
        case (key, x) => attr = scala.xml.Attribute((x.namespace map { __scope.getPrefix(_) }).orNull, x.key.orNull, x.value.toString, attr)
      }
      attr
    }

    def writesChildNodes(__obj: IPXACT2022ScalaCases.Cpu, __scope: scala.xml.NamespaceBinding): Seq[scala.xml.Node] =
      Seq.concat(IPXACT2022scalaxb.toXML[IPXACT2022ScalaCases.NameGroupSequence](__obj.nameGroupSequence1, None, Some("nameGroupSequence1"), __scope, false),
        IPXACT2022scalaxb.toXML[IPXACT2022ScalaCases.BlockSizeSequence](__obj.blockSizeSequence2, None, Some("blockSizeSequence2"), __scope, false),
        __obj.regions map { IPXACT2022scalaxb.toXML[IPXACT2022ScalaCases.Regions](_, Some("http://www.accellera.org/XMLSchema/IPXACT/1685-2022"), Some("regions"), __scope, false) } getOrElse {Nil},
        __obj.addressUnitBits map { IPXACT2022scalaxb.toXML[IPXACT2022ScalaCases.UnsignedPositiveLongintExpressionable](_, Some("http://www.accellera.org/XMLSchema/IPXACT/1685-2022"), Some("addressUnitBits"), __scope, false) } getOrElse {Nil},
        __obj.executableImage flatMap { IPXACT2022scalaxb.toXML[IPXACT2022ScalaCases.ExecutableImage](_, Some("http://www.accellera.org/XMLSchema/IPXACT/1685-2022"), Some("executableImage"), __scope, false) },
        IPXACT2022scalaxb.toXML[String](__obj.memoryMapRef, Some("http://www.accellera.org/XMLSchema/IPXACT/1685-2022"), Some("memoryMapRef"), __scope, false),
        __obj.parameters map { IPXACT2022scalaxb.toXML[IPXACT2022ScalaCases.Parameters](_, Some("http://www.accellera.org/XMLSchema/IPXACT/1685-2022"), Some("parameters"), __scope, false) } getOrElse {Nil},
        __obj.vendorExtensions map { IPXACT2022scalaxb.toXML[IPXACT2022ScalaCases.VendorExtensions](_, Some("http://www.accellera.org/XMLSchema/IPXACT/1685-2022"), Some("vendorExtensions"), __scope, false) } getOrElse {Nil})

  }

  trait DefaultIPXACT2022ScalaCases_CpusFormat extends IPXACT2022scalaxb.ElemNameParser[IPXACT2022ScalaCases.Cpus] {
    val targetNamespace: Option[String] = Some("http://www.accellera.org/XMLSchema/IPXACT/1685-2022")
    
    def parser(node: scala.xml.Node, stack: List[IPXACT2022scalaxb.ElemName]): Parser[IPXACT2022ScalaCases.Cpus] =
      phrase(safeRep(IPXACT2022scalaxb.ElemName(Some("http://www.accellera.org/XMLSchema/IPXACT/1685-2022"), "cpu")) ^^
      { case p1 =>
      IPXACT2022ScalaCases.Cpus(p1 map { IPXACT2022scalaxb.fromXML[IPXACT2022ScalaCases.Cpu](_, IPXACT2022scalaxb.ElemName(node) :: stack) }) })
    
    def writesChildNodes(__obj: IPXACT2022ScalaCases.Cpus, __scope: scala.xml.NamespaceBinding): Seq[scala.xml.Node] =
      (__obj.cpu flatMap { IPXACT2022scalaxb.toXML[IPXACT2022ScalaCases.Cpu](_, Some("http://www.accellera.org/XMLSchema/IPXACT/1685-2022"), Some("cpu"), __scope, false) })
  }
  trait DefaultIPXACT2022ScalaCases_ResetTypeFormat extends IPXACT2022scalaxb.ElemNameParser[IPXACT2022ScalaCases.ResetType] with IPXACT2022ScalaCases_NameGroupGroupFormat {
    val targetNamespace: Option[String] = Some("http://www.accellera.org/XMLSchema/IPXACT/1685-2022")
    
    def parser(node: scala.xml.Node, stack: List[IPXACT2022scalaxb.ElemName]): Parser[IPXACT2022ScalaCases.ResetType] =
      phrase((parseNameGroupGroup(node, IPXACT2022scalaxb.ElemName(node) :: stack)) ~
      opt(IPXACT2022scalaxb.ElemName(Some("http://www.accellera.org/XMLSchema/IPXACT/1685-2022"), "vendorExtensions")) ^^
      { case p1 ~ p2 =>
      IPXACT2022ScalaCases.ResetType(p1,
        p2.headOption map { IPXACT2022scalaxb.fromXML[IPXACT2022ScalaCases.VendorExtensions](_, IPXACT2022scalaxb.ElemName(node) :: stack) },
        scala.collection.immutable.ListMap(List(
        (node \ "@{http://www.w3.org/XML/1998/namespace}id").headOption map { x => IPXACT2022scalaxb.DataRecord(x, node, IPXACT2022scalaxb.fromXML[String](x, IPXACT2022scalaxb.ElemName(node) :: stack)) } map { "@{http://www.w3.org/XML/1998/namespace}id" -> _ }
        ).flatten[(String, IPXACT2022scalaxb.DataRecord[Any])]: _*)) })
    
    override def writesAttribute(__obj: IPXACT2022ScalaCases.ResetType, __scope: scala.xml.NamespaceBinding): scala.xml.MetaData = {
      var attr: scala.xml.MetaData  = scala.xml.Null
      __obj.attributes.toList map {
        case ("@{http://www.w3.org/XML/1998/namespace}id", _) => __obj.xmlid foreach { x => attr = scala.xml.Attribute(__scope.getPrefix("http://www.w3.org/XML/1998/namespace"), "id", x.toString, attr) }
        case (key, x) => attr = scala.xml.Attribute((x.namespace map { __scope.getPrefix(_) }).orNull, x.key.orNull, x.value.toString, attr)
      }
      attr
    }

    def writesChildNodes(__obj: IPXACT2022ScalaCases.ResetType, __scope: scala.xml.NamespaceBinding): Seq[scala.xml.Node] =
      Seq.concat(IPXACT2022scalaxb.toXML[IPXACT2022ScalaCases.NameGroupSequence](__obj.nameGroupSequence1, None, Some("nameGroupSequence1"), __scope, false),
        __obj.vendorExtensions map { IPXACT2022scalaxb.toXML[IPXACT2022ScalaCases.VendorExtensions](_, Some("http://www.accellera.org/XMLSchema/IPXACT/1685-2022"), Some("vendorExtensions"), __scope, false) } getOrElse {Nil})

  }

  trait DefaultIPXACT2022ScalaCases_ResetTypesFormat extends IPXACT2022scalaxb.ElemNameParser[IPXACT2022ScalaCases.ResetTypes] {
    val targetNamespace: Option[String] = Some("http://www.accellera.org/XMLSchema/IPXACT/1685-2022")
    
    def parser(node: scala.xml.Node, stack: List[IPXACT2022scalaxb.ElemName]): Parser[IPXACT2022ScalaCases.ResetTypes] =
      phrase(safeRep(IPXACT2022scalaxb.ElemName(Some("http://www.accellera.org/XMLSchema/IPXACT/1685-2022"), "resetType")) ^^
      { case p1 =>
      IPXACT2022ScalaCases.ResetTypes(p1 map { IPXACT2022scalaxb.fromXML[IPXACT2022ScalaCases.ResetType](_, IPXACT2022scalaxb.ElemName(node) :: stack) }) })
    
    def writesChildNodes(__obj: IPXACT2022ScalaCases.ResetTypes, __scope: scala.xml.NamespaceBinding): Seq[scala.xml.Node] =
      (__obj.resetType flatMap { IPXACT2022scalaxb.toXML[IPXACT2022ScalaCases.ResetType](_, Some("http://www.accellera.org/XMLSchema/IPXACT/1685-2022"), Some("resetType"), __scope, false) })
  }
  trait DefaultIPXACT2022ScalaCases_ComponentTypeFormat extends IPXACT2022scalaxb.ElemNameParser[IPXACT2022ScalaCases.ComponentType] with IPXACT2022ScalaCases_DocumentNameGroupGroupFormat {
    val targetNamespace: Option[String] = Some("http://www.accellera.org/XMLSchema/IPXACT/1685-2022")
    
    override def typeName: Option[String] = Some("componentType")

    def parser(node: scala.xml.Node, stack: List[IPXACT2022scalaxb.ElemName]): Parser[IPXACT2022ScalaCases.ComponentType] =
      phrase((parseDocumentNameGroupGroup(node, IPXACT2022scalaxb.ElemName(node) :: stack)) ~
      opt(IPXACT2022scalaxb.ElemName(Some("http://www.accellera.org/XMLSchema/IPXACT/1685-2022"), "typeDefinitions")) ~
      opt(IPXACT2022scalaxb.ElemName(Some("http://www.accellera.org/XMLSchema/IPXACT/1685-2022"), "powerDomains")) ~
      opt(IPXACT2022scalaxb.ElemName(Some("http://www.accellera.org/XMLSchema/IPXACT/1685-2022"), "busInterfaces")) ~
      opt(IPXACT2022scalaxb.ElemName(Some("http://www.accellera.org/XMLSchema/IPXACT/1685-2022"), "indirectInterfaces")) ~
      opt(IPXACT2022scalaxb.ElemName(Some("http://www.accellera.org/XMLSchema/IPXACT/1685-2022"), "channels")) ~
      opt(IPXACT2022scalaxb.ElemName(Some("http://www.accellera.org/XMLSchema/IPXACT/1685-2022"), "modes")) ~
      opt(IPXACT2022scalaxb.ElemName(Some("http://www.accellera.org/XMLSchema/IPXACT/1685-2022"), "addressSpaces")) ~
      opt(IPXACT2022scalaxb.ElemName(Some("http://www.accellera.org/XMLSchema/IPXACT/1685-2022"), "memoryMaps")) ~
      opt(IPXACT2022scalaxb.ElemName(Some("http://www.accellera.org/XMLSchema/IPXACT/1685-2022"), "model")) ~
      opt(IPXACT2022scalaxb.ElemName(Some("http://www.accellera.org/XMLSchema/IPXACT/1685-2022"), "componentGenerators")) ~
      opt(IPXACT2022scalaxb.ElemName(Some("http://www.accellera.org/XMLSchema/IPXACT/1685-2022"), "choices")) ~
      opt(IPXACT2022scalaxb.ElemName(Some("http://www.accellera.org/XMLSchema/IPXACT/1685-2022"), "fileSets")) ~
      opt(IPXACT2022scalaxb.ElemName(Some("http://www.accellera.org/XMLSchema/IPXACT/1685-2022"), "clearboxElements")) ~
      opt(IPXACT2022scalaxb.ElemName(Some("http://www.accellera.org/XMLSchema/IPXACT/1685-2022"), "cpus")) ~
      opt(IPXACT2022scalaxb.ElemName(Some("http://www.accellera.org/XMLSchema/IPXACT/1685-2022"), "otherClockDrivers")) ~
      opt(IPXACT2022scalaxb.ElemName(Some("http://www.accellera.org/XMLSchema/IPXACT/1685-2022"), "resetTypes")) ~
      opt(IPXACT2022scalaxb.ElemName(Some("http://www.accellera.org/XMLSchema/IPXACT/1685-2022"), "parameters")) ~
      opt(IPXACT2022scalaxb.ElemName(Some("http://www.accellera.org/XMLSchema/IPXACT/1685-2022"), "assertions")) ~
      opt(IPXACT2022scalaxb.ElemName(Some("http://www.accellera.org/XMLSchema/IPXACT/1685-2022"), "vendorExtensions")) ^^
      { case p1 ~ p2 ~ p3 ~ p4 ~ p5 ~ p6 ~ p7 ~ p8 ~ p9 ~ p10 ~ p11 ~ p12 ~ p13 ~ p14 ~ p15 ~ p16 ~ p17 ~ p18 ~ p19 ~ p20 =>
      IPXACT2022ScalaCases.ComponentType(p1,
        p2.headOption map { IPXACT2022scalaxb.fromXML[IPXACT2022ScalaCases.TypeDefinitions](_, IPXACT2022scalaxb.ElemName(node) :: stack) },
        p3.headOption map { IPXACT2022scalaxb.fromXML[IPXACT2022ScalaCases.PowerDomains](_, IPXACT2022scalaxb.ElemName(node) :: stack) },
        p4.headOption map { IPXACT2022scalaxb.fromXML[IPXACT2022ScalaCases.BusInterfaces](_, IPXACT2022scalaxb.ElemName(node) :: stack) },
        p5.headOption map { IPXACT2022scalaxb.fromXML[IPXACT2022ScalaCases.IndirectInterfaces](_, IPXACT2022scalaxb.ElemName(node) :: stack) },
        p6.headOption map { IPXACT2022scalaxb.fromXML[IPXACT2022ScalaCases.Channels](_, IPXACT2022scalaxb.ElemName(node) :: stack) },
        p7.headOption map { IPXACT2022scalaxb.fromXML[IPXACT2022ScalaCases.Modes](_, IPXACT2022scalaxb.ElemName(node) :: stack) },
        p8.headOption map { IPXACT2022scalaxb.fromXML[IPXACT2022ScalaCases.AddressSpaces](_, IPXACT2022scalaxb.ElemName(node) :: stack) },
        p9.headOption map { IPXACT2022scalaxb.fromXML[IPXACT2022ScalaCases.MemoryMaps](_, IPXACT2022scalaxb.ElemName(node) :: stack) },
        p10.headOption map { IPXACT2022scalaxb.fromXML[IPXACT2022ScalaCases.ModelType](_, IPXACT2022scalaxb.ElemName(node) :: stack) },
        p11.headOption map { IPXACT2022scalaxb.fromXML[IPXACT2022ScalaCases.ComponentGenerators](_, IPXACT2022scalaxb.ElemName(node) :: stack) },
        p12.headOption map { IPXACT2022scalaxb.fromXML[IPXACT2022ScalaCases.Choices](_, IPXACT2022scalaxb.ElemName(node) :: stack) },
        p13.headOption map { IPXACT2022scalaxb.fromXML[IPXACT2022ScalaCases.FileSets](_, IPXACT2022scalaxb.ElemName(node) :: stack) },
        p14.headOption map { IPXACT2022scalaxb.fromXML[IPXACT2022ScalaCases.ClearboxElements](_, IPXACT2022scalaxb.ElemName(node) :: stack) },
        p15.headOption map { IPXACT2022scalaxb.fromXML[IPXACT2022ScalaCases.Cpus](_, IPXACT2022scalaxb.ElemName(node) :: stack) },
        p16.headOption map { IPXACT2022scalaxb.fromXML[IPXACT2022ScalaCases.OtherClocks](_, IPXACT2022scalaxb.ElemName(node) :: stack) },
        p17.headOption map { IPXACT2022scalaxb.fromXML[IPXACT2022ScalaCases.ResetTypes](_, IPXACT2022scalaxb.ElemName(node) :: stack) },
        p18.headOption map { IPXACT2022scalaxb.fromXML[IPXACT2022ScalaCases.Parameters](_, IPXACT2022scalaxb.ElemName(node) :: stack) },
        p19.headOption map { IPXACT2022scalaxb.fromXML[IPXACT2022ScalaCases.Assertions](_, IPXACT2022scalaxb.ElemName(node) :: stack) },
        p20.headOption map { IPXACT2022scalaxb.fromXML[IPXACT2022ScalaCases.VendorExtensions](_, IPXACT2022scalaxb.ElemName(node) :: stack) },
        scala.collection.immutable.ListMap(List(
        (node \ "@{http://www.w3.org/XML/1998/namespace}id").headOption map { x => IPXACT2022scalaxb.DataRecord(x, node, IPXACT2022scalaxb.fromXML[String](x, IPXACT2022scalaxb.ElemName(node) :: stack)) } map { "@{http://www.w3.org/XML/1998/namespace}id" -> _ }
        ).flatten[(String, IPXACT2022scalaxb.DataRecord[Any])]: _*)) })
    
    override def writesAttribute(__obj: IPXACT2022ScalaCases.ComponentType, __scope: scala.xml.NamespaceBinding): scala.xml.MetaData = {
      var attr: scala.xml.MetaData  = scala.xml.Null
      __obj.attributes.toList map {
        case ("@{http://www.w3.org/XML/1998/namespace}id", _) => __obj.xmlid foreach { x => attr = scala.xml.Attribute(__scope.getPrefix("http://www.w3.org/XML/1998/namespace"), "id", x.toString, attr) }
        case (key, x) => attr = scala.xml.Attribute((x.namespace map { __scope.getPrefix(_) }).orNull, x.key.orNull, x.value.toString, attr)
      }
      attr
    }

    def writesChildNodes(__obj: IPXACT2022ScalaCases.ComponentType, __scope: scala.xml.NamespaceBinding): Seq[scala.xml.Node] =
      Seq.concat(IPXACT2022scalaxb.toXML[IPXACT2022ScalaCases.DocumentNameGroupSequence](__obj.documentNameGroupSequence1, None, Some("documentNameGroupSequence1"), __scope, false),
        __obj.typeDefinitions map { IPXACT2022scalaxb.toXML[IPXACT2022ScalaCases.TypeDefinitions](_, Some("http://www.accellera.org/XMLSchema/IPXACT/1685-2022"), Some("typeDefinitions"), __scope, false) } getOrElse {Nil},
        __obj.powerDomains map { IPXACT2022scalaxb.toXML[IPXACT2022ScalaCases.PowerDomains](_, Some("http://www.accellera.org/XMLSchema/IPXACT/1685-2022"), Some("powerDomains"), __scope, false) } getOrElse {Nil},
        __obj.busInterfaces map { IPXACT2022scalaxb.toXML[IPXACT2022ScalaCases.BusInterfaces](_, Some("http://www.accellera.org/XMLSchema/IPXACT/1685-2022"), Some("busInterfaces"), __scope, false) } getOrElse {Nil},
        __obj.indirectInterfaces map { IPXACT2022scalaxb.toXML[IPXACT2022ScalaCases.IndirectInterfaces](_, Some("http://www.accellera.org/XMLSchema/IPXACT/1685-2022"), Some("indirectInterfaces"), __scope, false) } getOrElse {Nil},
        __obj.channels map { IPXACT2022scalaxb.toXML[IPXACT2022ScalaCases.Channels](_, Some("http://www.accellera.org/XMLSchema/IPXACT/1685-2022"), Some("channels"), __scope, false) } getOrElse {Nil},
        __obj.modes map { IPXACT2022scalaxb.toXML[IPXACT2022ScalaCases.Modes](_, Some("http://www.accellera.org/XMLSchema/IPXACT/1685-2022"), Some("modes"), __scope, false) } getOrElse {Nil},
        __obj.addressSpaces map { IPXACT2022scalaxb.toXML[IPXACT2022ScalaCases.AddressSpaces](_, Some("http://www.accellera.org/XMLSchema/IPXACT/1685-2022"), Some("addressSpaces"), __scope, false) } getOrElse {Nil},
        __obj.memoryMaps map { IPXACT2022scalaxb.toXML[IPXACT2022ScalaCases.MemoryMaps](_, Some("http://www.accellera.org/XMLSchema/IPXACT/1685-2022"), Some("memoryMaps"), __scope, false) } getOrElse {Nil},
        __obj.model map { IPXACT2022scalaxb.toXML[IPXACT2022ScalaCases.ModelType](_, Some("http://www.accellera.org/XMLSchema/IPXACT/1685-2022"), Some("model"), __scope, false) } getOrElse {Nil},
        __obj.componentGenerators map { IPXACT2022scalaxb.toXML[IPXACT2022ScalaCases.ComponentGenerators](_, Some("http://www.accellera.org/XMLSchema/IPXACT/1685-2022"), Some("componentGenerators"), __scope, false) } getOrElse {Nil},
        __obj.choices map { IPXACT2022scalaxb.toXML[IPXACT2022ScalaCases.Choices](_, Some("http://www.accellera.org/XMLSchema/IPXACT/1685-2022"), Some("choices"), __scope, false) } getOrElse {Nil},
        __obj.fileSets map { IPXACT2022scalaxb.toXML[IPXACT2022ScalaCases.FileSets](_, Some("http://www.accellera.org/XMLSchema/IPXACT/1685-2022"), Some("fileSets"), __scope, false) } getOrElse {Nil},
        __obj.clearboxElements map { IPXACT2022scalaxb.toXML[IPXACT2022ScalaCases.ClearboxElements](_, Some("http://www.accellera.org/XMLSchema/IPXACT/1685-2022"), Some("clearboxElements"), __scope, false) } getOrElse {Nil},
        __obj.cpus map { IPXACT2022scalaxb.toXML[IPXACT2022ScalaCases.Cpus](_, Some("http://www.accellera.org/XMLSchema/IPXACT/1685-2022"), Some("cpus"), __scope, false) } getOrElse {Nil},
        __obj.otherClockDrivers map { IPXACT2022scalaxb.toXML[IPXACT2022ScalaCases.OtherClocks](_, Some("http://www.accellera.org/XMLSchema/IPXACT/1685-2022"), Some("otherClockDrivers"), __scope, false) } getOrElse {Nil},
        __obj.resetTypes map { IPXACT2022scalaxb.toXML[IPXACT2022ScalaCases.ResetTypes](_, Some("http://www.accellera.org/XMLSchema/IPXACT/1685-2022"), Some("resetTypes"), __scope, false) } getOrElse {Nil},
        __obj.parameters map { IPXACT2022scalaxb.toXML[IPXACT2022ScalaCases.Parameters](_, Some("http://www.accellera.org/XMLSchema/IPXACT/1685-2022"), Some("parameters"), __scope, false) } getOrElse {Nil},
        __obj.assertions map { IPXACT2022scalaxb.toXML[IPXACT2022ScalaCases.Assertions](_, Some("http://www.accellera.org/XMLSchema/IPXACT/1685-2022"), Some("assertions"), __scope, false) } getOrElse {Nil},
        __obj.vendorExtensions map { IPXACT2022scalaxb.toXML[IPXACT2022ScalaCases.VendorExtensions](_, Some("http://www.accellera.org/XMLSchema/IPXACT/1685-2022"), Some("vendorExtensions"), __scope, false) } getOrElse {Nil})

  }

  def buildIPXACT2022ScalaCases_SimpleClearboxTypeFormat = new DefaultIPXACT2022ScalaCases_SimpleClearboxTypeFormat {}
  trait DefaultIPXACT2022ScalaCases_SimpleClearboxTypeFormat extends IPXACT2022scalaxb.XMLFormat[IPXACT2022ScalaCases.SimpleClearboxType] {
    val targetNamespace: Option[String] = Some("http://www.accellera.org/XMLSchema/IPXACT/1685-2022")
    
    def fromString(value: String, scope: scala.xml.NamespaceBinding): IPXACT2022ScalaCases.SimpleClearboxType =
        (fromString0(value, scope)).apply(IPXACT2022scalaxb.fromXML[String](scala.xml.Text(value)))

    private def fromString0(value: String, scope: scala.xml.NamespaceBinding): PartialFunction[Any, IPXACT2022ScalaCases.SimpleClearboxType] = {
      case x: String if x == IPXACT2022scalaxb.fromXML[String](scala.xml.Text("signal")) => IPXACT2022ScalaCases.Signal
      case x: String if x == IPXACT2022scalaxb.fromXML[String](scala.xml.Text("pin")) => IPXACT2022ScalaCases.Pin
      case x: String if x == IPXACT2022scalaxb.fromXML[String](scala.xml.Text("interface")) => IPXACT2022ScalaCases.InterfaceValue

    }



    def reads(seq: scala.xml.NodeSeq, stack: List[IPXACT2022scalaxb.ElemName]): Either[String, IPXACT2022ScalaCases.SimpleClearboxType] = seq match {
      case elem: scala.xml.Elem => Right(fromString(elem.text, elem.scope))
      case _ => Right(fromString(seq.text, scala.xml.TopScope))
    }
    
    def writes(__obj: IPXACT2022ScalaCases.SimpleClearboxType, __namespace: Option[String], __elementLabel: Option[String],
        __scope: scala.xml.NamespaceBinding, __typeAttribute: Boolean): scala.xml.NodeSeq =
      scala.xml.Elem(IPXACT2022scalaxb.Helper.getPrefix(__namespace, __scope).orNull,
        __elementLabel getOrElse { sys.error("missing element label.") },
        scala.xml.Null, __scope, true, scala.xml.Text(__obj.toString))
  }
  trait DefaultIPXACT2022ScalaCases_ClearboxElementTypeFormat extends IPXACT2022scalaxb.ElemNameParser[IPXACT2022ScalaCases.ClearboxElementType] with IPXACT2022ScalaCases_NameGroupGroupFormat {
    val targetNamespace: Option[String] = Some("http://www.accellera.org/XMLSchema/IPXACT/1685-2022")
    
    override def typeName: Option[String] = Some("clearboxElementType")

    def parser(node: scala.xml.Node, stack: List[IPXACT2022scalaxb.ElemName]): Parser[IPXACT2022ScalaCases.ClearboxElementType] =
      phrase((parseNameGroupGroup(node, IPXACT2022scalaxb.ElemName(node) :: stack)) ~
      (IPXACT2022scalaxb.ElemName(Some("http://www.accellera.org/XMLSchema/IPXACT/1685-2022"), "clearboxType")) ~
      opt(IPXACT2022scalaxb.ElemName(Some("http://www.accellera.org/XMLSchema/IPXACT/1685-2022"), "driveable")) ~
      opt(IPXACT2022scalaxb.ElemName(Some("http://www.accellera.org/XMLSchema/IPXACT/1685-2022"), "parameters")) ~
      opt(IPXACT2022scalaxb.ElemName(Some("http://www.accellera.org/XMLSchema/IPXACT/1685-2022"), "vendorExtensions")) ^^
      { case p1 ~ p2 ~ p3 ~ p4 ~ p5 =>
      IPXACT2022ScalaCases.ClearboxElementType(p1,
        IPXACT2022scalaxb.fromXML[IPXACT2022ScalaCases.SimpleClearboxType](p2, IPXACT2022scalaxb.ElemName(node) :: stack),
        p3.headOption map { IPXACT2022scalaxb.fromXML[Boolean](_, IPXACT2022scalaxb.ElemName(node) :: stack) },
        p4.headOption map { IPXACT2022scalaxb.fromXML[IPXACT2022ScalaCases.Parameters](_, IPXACT2022scalaxb.ElemName(node) :: stack) },
        p5.headOption map { IPXACT2022scalaxb.fromXML[IPXACT2022ScalaCases.VendorExtensions](_, IPXACT2022scalaxb.ElemName(node) :: stack) },
        scala.collection.immutable.ListMap(List(
        (node \ "@{http://www.w3.org/XML/1998/namespace}id").headOption map { x => IPXACT2022scalaxb.DataRecord(x, node, IPXACT2022scalaxb.fromXML[String](x, IPXACT2022scalaxb.ElemName(node) :: stack)) } map { "@{http://www.w3.org/XML/1998/namespace}id" -> _ }
        ).flatten[(String, IPXACT2022scalaxb.DataRecord[Any])]: _*)) })
    
    override def writesAttribute(__obj: IPXACT2022ScalaCases.ClearboxElementType, __scope: scala.xml.NamespaceBinding): scala.xml.MetaData = {
      var attr: scala.xml.MetaData  = scala.xml.Null
      __obj.attributes.toList map {
        case ("@{http://www.w3.org/XML/1998/namespace}id", _) => __obj.xmlid foreach { x => attr = scala.xml.Attribute(__scope.getPrefix("http://www.w3.org/XML/1998/namespace"), "id", x.toString, attr) }
        case (key, x) => attr = scala.xml.Attribute((x.namespace map { __scope.getPrefix(_) }).orNull, x.key.orNull, x.value.toString, attr)
      }
      attr
    }

    def writesChildNodes(__obj: IPXACT2022ScalaCases.ClearboxElementType, __scope: scala.xml.NamespaceBinding): Seq[scala.xml.Node] =
      Seq.concat(IPXACT2022scalaxb.toXML[IPXACT2022ScalaCases.NameGroupSequence](__obj.nameGroupSequence1, None, Some("nameGroupSequence1"), __scope, false),
        IPXACT2022scalaxb.toXML[IPXACT2022ScalaCases.SimpleClearboxType](__obj.clearboxType, Some("http://www.accellera.org/XMLSchema/IPXACT/1685-2022"), Some("clearboxType"), __scope, false),
        __obj.driveable map { IPXACT2022scalaxb.toXML[Boolean](_, Some("http://www.accellera.org/XMLSchema/IPXACT/1685-2022"), Some("driveable"), __scope, false) } getOrElse {Nil},
        __obj.parameters map { IPXACT2022scalaxb.toXML[IPXACT2022ScalaCases.Parameters](_, Some("http://www.accellera.org/XMLSchema/IPXACT/1685-2022"), Some("parameters"), __scope, false) } getOrElse {Nil},
        __obj.vendorExtensions map { IPXACT2022scalaxb.toXML[IPXACT2022ScalaCases.VendorExtensions](_, Some("http://www.accellera.org/XMLSchema/IPXACT/1685-2022"), Some("vendorExtensions"), __scope, false) } getOrElse {Nil})

  }

  def buildIPXACT2022ScalaCases_CellFunctionValueTypeFormat = new DefaultIPXACT2022ScalaCases_CellFunctionValueTypeFormat {}
  trait DefaultIPXACT2022ScalaCases_CellFunctionValueTypeFormat extends IPXACT2022scalaxb.XMLFormat[IPXACT2022ScalaCases.CellFunctionValueType] {
    val targetNamespace: Option[String] = Some("http://www.accellera.org/XMLSchema/IPXACT/1685-2022")
    
    def fromString(value: String, scope: scala.xml.NamespaceBinding): IPXACT2022ScalaCases.CellFunctionValueType =
        (fromString0(value, scope)).apply(IPXACT2022scalaxb.fromXML[String](scala.xml.Text(value)))

    private def fromString0(value: String, scope: scala.xml.NamespaceBinding): PartialFunction[Any, IPXACT2022ScalaCases.CellFunctionValueType] = {
      case x: String if x == IPXACT2022scalaxb.fromXML[String](scala.xml.Text("nand2")) => IPXACT2022ScalaCases.Nand2
      case x: String if x == IPXACT2022scalaxb.fromXML[String](scala.xml.Text("buf")) => IPXACT2022ScalaCases.Buf
      case x: String if x == IPXACT2022scalaxb.fromXML[String](scala.xml.Text("inv")) => IPXACT2022ScalaCases.Inv
      case x: String if x == IPXACT2022scalaxb.fromXML[String](scala.xml.Text("mux21")) => IPXACT2022ScalaCases.Mux21
      case x: String if x == IPXACT2022scalaxb.fromXML[String](scala.xml.Text("dff")) => IPXACT2022ScalaCases.Dff
      case x: String if x == IPXACT2022scalaxb.fromXML[String](scala.xml.Text("latch")) => IPXACT2022ScalaCases.Latch
      case x: String if x == IPXACT2022scalaxb.fromXML[String](scala.xml.Text("xor2")) => IPXACT2022ScalaCases.Xor2
      case x: String if x == IPXACT2022scalaxb.fromXML[String](scala.xml.Text("other")) => IPXACT2022ScalaCases.Other

    }



    def reads(seq: scala.xml.NodeSeq, stack: List[IPXACT2022scalaxb.ElemName]): Either[String, IPXACT2022ScalaCases.CellFunctionValueType] = seq match {
      case elem: scala.xml.Elem => Right(fromString(elem.text, elem.scope))
      case _ => Right(fromString(seq.text, scala.xml.TopScope))
    }
    
    def writes(__obj: IPXACT2022ScalaCases.CellFunctionValueType, __namespace: Option[String], __elementLabel: Option[String],
        __scope: scala.xml.NamespaceBinding, __typeAttribute: Boolean): scala.xml.NodeSeq =
      scala.xml.Elem(IPXACT2022scalaxb.Helper.getPrefix(__namespace, __scope).orNull,
        __elementLabel getOrElse { sys.error("missing element label.") },
        scala.xml.Null, __scope, true, scala.xml.Text(__obj.toString))
  }
  def buildIPXACT2022ScalaCases_CellClassValueTypeFormat = new DefaultIPXACT2022ScalaCases_CellClassValueTypeFormat {}
  trait DefaultIPXACT2022ScalaCases_CellClassValueTypeFormat extends IPXACT2022scalaxb.XMLFormat[IPXACT2022ScalaCases.CellClassValueType] {
    val targetNamespace: Option[String] = Some("http://www.accellera.org/XMLSchema/IPXACT/1685-2022")
    
    def fromString(value: String, scope: scala.xml.NamespaceBinding): IPXACT2022ScalaCases.CellClassValueType =
        (fromString0(value, scope)).apply(IPXACT2022scalaxb.fromXML[String](scala.xml.Text(value)))

    private def fromString0(value: String, scope: scala.xml.NamespaceBinding): PartialFunction[Any, IPXACT2022ScalaCases.CellClassValueType] = {
      case x: String if x == IPXACT2022scalaxb.fromXML[String](scala.xml.Text("combinational")) => IPXACT2022ScalaCases.Combinational
      case x: String if x == IPXACT2022scalaxb.fromXML[String](scala.xml.Text("sequential")) => IPXACT2022ScalaCases.Sequential

    }



    def reads(seq: scala.xml.NodeSeq, stack: List[IPXACT2022scalaxb.ElemName]): Either[String, IPXACT2022ScalaCases.CellClassValueType] = seq match {
      case elem: scala.xml.Elem => Right(fromString(elem.text, elem.scope))
      case _ => Right(fromString(seq.text, scala.xml.TopScope))
    }
    
    def writes(__obj: IPXACT2022ScalaCases.CellClassValueType, __namespace: Option[String], __elementLabel: Option[String],
        __scope: scala.xml.NamespaceBinding, __typeAttribute: Boolean): scala.xml.NodeSeq =
      scala.xml.Elem(IPXACT2022scalaxb.Helper.getPrefix(__namespace, __scope).orNull,
        __elementLabel getOrElse { sys.error("missing element label.") },
        scala.xml.Null, __scope, true, scala.xml.Text(__obj.toString))
  }
  def buildIPXACT2022ScalaCases_CellStrengthValueTypeFormat = new DefaultIPXACT2022ScalaCases_CellStrengthValueTypeFormat {}
  trait DefaultIPXACT2022ScalaCases_CellStrengthValueTypeFormat extends IPXACT2022scalaxb.XMLFormat[IPXACT2022ScalaCases.CellStrengthValueType] {
    val targetNamespace: Option[String] = Some("http://www.accellera.org/XMLSchema/IPXACT/1685-2022")
    
    def fromString(value: String, scope: scala.xml.NamespaceBinding): IPXACT2022ScalaCases.CellStrengthValueType =
        (fromString0(value, scope)).apply(IPXACT2022scalaxb.fromXML[String](scala.xml.Text(value)))

    private def fromString0(value: String, scope: scala.xml.NamespaceBinding): PartialFunction[Any, IPXACT2022ScalaCases.CellStrengthValueType] = {
      case x: String if x == IPXACT2022scalaxb.fromXML[String](scala.xml.Text("low")) => IPXACT2022ScalaCases.Low
      case x: String if x == IPXACT2022scalaxb.fromXML[String](scala.xml.Text("median")) => IPXACT2022ScalaCases.Median
      case x: String if x == IPXACT2022scalaxb.fromXML[String](scala.xml.Text("high")) => IPXACT2022ScalaCases.High

    }



    def reads(seq: scala.xml.NodeSeq, stack: List[IPXACT2022scalaxb.ElemName]): Either[String, IPXACT2022ScalaCases.CellStrengthValueType] = seq match {
      case elem: scala.xml.Elem => Right(fromString(elem.text, elem.scope))
      case _ => Right(fromString(seq.text, scala.xml.TopScope))
    }
    
    def writes(__obj: IPXACT2022ScalaCases.CellStrengthValueType, __namespace: Option[String], __elementLabel: Option[String],
        __scope: scala.xml.NamespaceBinding, __typeAttribute: Boolean): scala.xml.NodeSeq =
      scala.xml.Elem(IPXACT2022scalaxb.Helper.getPrefix(__namespace, __scope).orNull,
        __elementLabel getOrElse { sys.error("missing element label.") },
        scala.xml.Null, __scope, true, scala.xml.Text(__obj.toString))
  }
  def buildIPXACT2022ScalaCases_EdgeValueTypeFormat = new DefaultIPXACT2022ScalaCases_EdgeValueTypeFormat {}
  trait DefaultIPXACT2022ScalaCases_EdgeValueTypeFormat extends IPXACT2022scalaxb.XMLFormat[IPXACT2022ScalaCases.EdgeValueType] {
    val targetNamespace: Option[String] = Some("http://www.accellera.org/XMLSchema/IPXACT/1685-2022")
    
    def fromString(value: String, scope: scala.xml.NamespaceBinding): IPXACT2022ScalaCases.EdgeValueType =
        (fromString0(value, scope)).apply(IPXACT2022scalaxb.fromXML[String](scala.xml.Text(value)))

    private def fromString0(value: String, scope: scala.xml.NamespaceBinding): PartialFunction[Any, IPXACT2022ScalaCases.EdgeValueType] = {
      case x: String if x == IPXACT2022scalaxb.fromXML[String](scala.xml.Text("rise")) => IPXACT2022ScalaCases.Rise
      case x: String if x == IPXACT2022scalaxb.fromXML[String](scala.xml.Text("fall")) => IPXACT2022ScalaCases.Fall

    }



    def reads(seq: scala.xml.NodeSeq, stack: List[IPXACT2022scalaxb.ElemName]): Either[String, IPXACT2022ScalaCases.EdgeValueType] = seq match {
      case elem: scala.xml.Elem => Right(fromString(elem.text, elem.scope))
      case _ => Right(fromString(seq.text, scala.xml.TopScope))
    }
    
    def writes(__obj: IPXACT2022ScalaCases.EdgeValueType, __namespace: Option[String], __elementLabel: Option[String],
        __scope: scala.xml.NamespaceBinding, __typeAttribute: Boolean): scala.xml.NodeSeq =
      scala.xml.Elem(IPXACT2022scalaxb.Helper.getPrefix(__namespace, __scope).orNull,
        __elementLabel getOrElse { sys.error("missing element label.") },
        scala.xml.Null, __scope, true, scala.xml.Text(__obj.toString))
  }
  def buildIPXACT2022ScalaCases_DelayValueTypeFormat = new DefaultIPXACT2022ScalaCases_DelayValueTypeFormat {}
  trait DefaultIPXACT2022ScalaCases_DelayValueTypeFormat extends IPXACT2022scalaxb.XMLFormat[IPXACT2022ScalaCases.DelayValueType] {
    val targetNamespace: Option[String] = Some("http://www.accellera.org/XMLSchema/IPXACT/1685-2022")
    
    def fromString(value: String, scope: scala.xml.NamespaceBinding): IPXACT2022ScalaCases.DelayValueType =
        (fromString0(value, scope)).apply(IPXACT2022scalaxb.fromXML[String](scala.xml.Text(value)))

    private def fromString0(value: String, scope: scala.xml.NamespaceBinding): PartialFunction[Any, IPXACT2022ScalaCases.DelayValueType] = {
      case x: String if x == IPXACT2022scalaxb.fromXML[String](scala.xml.Text("min")) => IPXACT2022ScalaCases.Min
      case x: String if x == IPXACT2022scalaxb.fromXML[String](scala.xml.Text("max")) => IPXACT2022ScalaCases.Max

    }



    def reads(seq: scala.xml.NodeSeq, stack: List[IPXACT2022scalaxb.ElemName]): Either[String, IPXACT2022ScalaCases.DelayValueType] = seq match {
      case elem: scala.xml.Elem => Right(fromString(elem.text, elem.scope))
      case _ => Right(fromString(seq.text, scala.xml.TopScope))
    }
    
    def writes(__obj: IPXACT2022ScalaCases.DelayValueType, __namespace: Option[String], __elementLabel: Option[String],
        __scope: scala.xml.NamespaceBinding, __typeAttribute: Boolean): scala.xml.NodeSeq =
      scala.xml.Elem(IPXACT2022scalaxb.Helper.getPrefix(__namespace, __scope).orNull,
        __elementLabel getOrElse { sys.error("missing element label.") },
        scala.xml.Null, __scope, true, scala.xml.Text(__obj.toString))
  }
  trait DefaultIPXACT2022ScalaCases_OtherClocksFormat extends IPXACT2022scalaxb.ElemNameParser[IPXACT2022ScalaCases.OtherClocks] {
    val targetNamespace: Option[String] = Some("http://www.accellera.org/XMLSchema/IPXACT/1685-2022")
    
    override def typeName: Option[String] = Some("otherClocks")

    def parser(node: scala.xml.Node, stack: List[IPXACT2022scalaxb.ElemName]): Parser[IPXACT2022ScalaCases.OtherClocks] =
      phrase(safeRep(IPXACT2022scalaxb.ElemName(Some("http://www.accellera.org/XMLSchema/IPXACT/1685-2022"), "otherClockDriver")) ^^
      { case p1 =>
      IPXACT2022ScalaCases.OtherClocks(p1 map { IPXACT2022scalaxb.fromXML[IPXACT2022ScalaCases.OtherClockDriver](_, IPXACT2022scalaxb.ElemName(node) :: stack) }) })
    
    def writesChildNodes(__obj: IPXACT2022ScalaCases.OtherClocks, __scope: scala.xml.NamespaceBinding): Seq[scala.xml.Node] =
      (__obj.otherClockDriver flatMap { IPXACT2022scalaxb.toXML[IPXACT2022ScalaCases.OtherClockDriver](_, Some("http://www.accellera.org/XMLSchema/IPXACT/1685-2022"), Some("otherClockDriver"), __scope, false) })
  }

  trait DefaultIPXACT2022ScalaCases_CellFunctionFormat extends IPXACT2022scalaxb.XMLFormat[IPXACT2022ScalaCases.CellFunction] with IPXACT2022scalaxb.CanWriteChildNodes[IPXACT2022ScalaCases.CellFunction] {
    val targetNamespace: Option[String] = Some("http://www.accellera.org/XMLSchema/IPXACT/1685-2022")
    def reads(seq: scala.xml.NodeSeq, stack: List[IPXACT2022scalaxb.ElemName]): Either[String, IPXACT2022ScalaCases.CellFunction] = seq match {
      case node: scala.xml.Node => Right(IPXACT2022ScalaCases.CellFunction(IPXACT2022scalaxb.fromXML[IPXACT2022ScalaCases.CellFunctionValueType](node, IPXACT2022scalaxb.ElemName(node) :: stack),
        scala.collection.immutable.ListMap(List(
        (node \ "@other").headOption map { x => IPXACT2022scalaxb.DataRecord(x, node, IPXACT2022scalaxb.fromXML[String](x, IPXACT2022scalaxb.ElemName(node) :: stack)) } map { "@other" -> _ }
        ).flatten[(String, IPXACT2022scalaxb.DataRecord[Any])]: _*)))
      case _ => Left("reads failed: seq must be scala.xml.Node")
    }
    
    override def writesAttribute(__obj: IPXACT2022ScalaCases.CellFunction, __scope: scala.xml.NamespaceBinding): scala.xml.MetaData = {
      var attr: scala.xml.MetaData  = scala.xml.Null
      __obj.attributes.toList map {
        case ("@other", _) => __obj.other foreach { x => attr = scala.xml.Attribute(null, "other", x.toString, attr) }
        case (key, x) => attr = scala.xml.Attribute((x.namespace map { __scope.getPrefix(_) }).orNull, x.key.orNull, x.value.toString, attr)
      }
      attr
    }

    def writesChildNodes(__obj: IPXACT2022ScalaCases.CellFunction, __scope: scala.xml.NamespaceBinding): Seq[scala.xml.Node] =
      Seq(scala.xml.Text(__obj.value.toString))

  }

  trait DefaultIPXACT2022ScalaCases_CellSpecificationFormat extends IPXACT2022scalaxb.ElemNameParser[IPXACT2022ScalaCases.CellSpecification] {
    val targetNamespace: Option[String] = Some("http://www.accellera.org/XMLSchema/IPXACT/1685-2022")
    
    def parser(node: scala.xml.Node, stack: List[IPXACT2022scalaxb.ElemName]): Parser[IPXACT2022ScalaCases.CellSpecification] =
      phrase((((IPXACT2022scalaxb.ElemName(Some("http://www.accellera.org/XMLSchema/IPXACT/1685-2022"), "cellFunction")) ^^
      (x => IPXACT2022scalaxb.DataRecord(x.namespace, Some(x.name), IPXACT2022scalaxb.fromXML[IPXACT2022ScalaCases.CellFunction](x, IPXACT2022scalaxb.ElemName(node) :: stack)))) |
      ((IPXACT2022scalaxb.ElemName(Some("http://www.accellera.org/XMLSchema/IPXACT/1685-2022"), "cellClass")) ^^
      (x => IPXACT2022scalaxb.DataRecord(x.namespace, Some(x.name), IPXACT2022scalaxb.fromXML[String](x, IPXACT2022scalaxb.ElemName(node) :: stack))))) ^^
      { case p1 =>
      IPXACT2022ScalaCases.CellSpecification(p1,
        scala.collection.immutable.ListMap(List(
        (node \ "@cellStrength").headOption map { x => IPXACT2022scalaxb.DataRecord(x, node, IPXACT2022scalaxb.fromXML[IPXACT2022ScalaCases.CellStrengthValueType](x, IPXACT2022scalaxb.ElemName(node) :: stack)) } map { "@cellStrength" -> _ }
        ).flatten[(String, IPXACT2022scalaxb.DataRecord[Any])]: _*)) })
    
    override def writesAttribute(__obj: IPXACT2022ScalaCases.CellSpecification, __scope: scala.xml.NamespaceBinding): scala.xml.MetaData = {
      var attr: scala.xml.MetaData  = scala.xml.Null
      __obj.attributes.toList map {
        case ("@cellStrength", _) => __obj.cellStrength foreach { x => attr = scala.xml.Attribute(null, "cellStrength", x.toString, attr) }
        case (key, x) => attr = scala.xml.Attribute((x.namespace map { __scope.getPrefix(_) }).orNull, x.key.orNull, x.value.toString, attr)
      }
      attr
    }

    def writesChildNodes(__obj: IPXACT2022ScalaCases.CellSpecification, __scope: scala.xml.NamespaceBinding): Seq[scala.xml.Node] =
      ((Some(__obj.cellspecificationoption) map {x => IPXACT2022scalaxb.toXML[IPXACT2022scalaxb.DataRecord[Any]](x, x.namespace, x.key, __scope, false)}).get)
  }

  trait DefaultIPXACT2022ScalaCases_TimingConstraintFormat extends IPXACT2022scalaxb.XMLFormat[IPXACT2022ScalaCases.TimingConstraint] with IPXACT2022scalaxb.CanWriteChildNodes[IPXACT2022ScalaCases.TimingConstraint] {
    val targetNamespace: Option[String] = Some("http://www.accellera.org/XMLSchema/IPXACT/1685-2022")
    def reads(seq: scala.xml.NodeSeq, stack: List[IPXACT2022scalaxb.ElemName]): Either[String, IPXACT2022ScalaCases.TimingConstraint] = seq match {
      case node: scala.xml.Node => Right(IPXACT2022ScalaCases.TimingConstraint(IPXACT2022scalaxb.fromXML[Float](node, IPXACT2022scalaxb.ElemName(node) :: stack),
        scala.collection.immutable.ListMap(List(
        (node \ "@clockEdge").headOption map { x => IPXACT2022scalaxb.DataRecord(x, node, IPXACT2022scalaxb.fromXML[IPXACT2022ScalaCases.EdgeValueType](x, IPXACT2022scalaxb.ElemName(node) :: stack)) } map { "@clockEdge" -> _ },
        (node \ "@delayType").headOption map { x => IPXACT2022scalaxb.DataRecord(x, node, IPXACT2022scalaxb.fromXML[IPXACT2022ScalaCases.DelayValueType](x, IPXACT2022scalaxb.ElemName(node) :: stack)) } map { "@delayType" -> _ },
        (node \ "@clockName").headOption map { x => IPXACT2022scalaxb.DataRecord(x, node, IPXACT2022scalaxb.fromXML[String](x, IPXACT2022scalaxb.ElemName(node) :: stack)) } map { "@clockName" -> _ },
        (node \ "@{http://www.w3.org/XML/1998/namespace}id").headOption map { x => IPXACT2022scalaxb.DataRecord(x, node, IPXACT2022scalaxb.fromXML[String](x, IPXACT2022scalaxb.ElemName(node) :: stack)) } map { "@{http://www.w3.org/XML/1998/namespace}id" -> _ }
        ).flatten[(String, IPXACT2022scalaxb.DataRecord[Any])]: _*)))
      case _ => Left("reads failed: seq must be scala.xml.Node")
    }
    
    override def writesAttribute(__obj: IPXACT2022ScalaCases.TimingConstraint, __scope: scala.xml.NamespaceBinding): scala.xml.MetaData = {
      var attr: scala.xml.MetaData  = scala.xml.Null
      __obj.attributes.toList map {
        case ("@clockEdge", _) => __obj.clockEdge foreach { x => attr = scala.xml.Attribute(null, "clockEdge", x.toString, attr) }
        case ("@delayType", _) => __obj.delayType foreach { x => attr = scala.xml.Attribute(null, "delayType", x.toString, attr) }
        case ("@clockName", _) => attr = scala.xml.Attribute(null, "clockName", __obj.clockName.toString, attr)
        case ("@{http://www.w3.org/XML/1998/namespace}id", _) => __obj.xmlid foreach { x => attr = scala.xml.Attribute(__scope.getPrefix("http://www.w3.org/XML/1998/namespace"), "id", x.toString, attr) }
        case (key, x) => attr = scala.xml.Attribute((x.namespace map { __scope.getPrefix(_) }).orNull, x.key.orNull, x.value.toString, attr)
      }
      attr
    }

    def writesChildNodes(__obj: IPXACT2022ScalaCases.TimingConstraint, __scope: scala.xml.NamespaceBinding): Seq[scala.xml.Node] =
      Seq(scala.xml.Text(__obj.value.toString))

  }

  trait DefaultIPXACT2022ScalaCases_DriveConstraintFormat extends IPXACT2022scalaxb.ElemNameParser[IPXACT2022ScalaCases.DriveConstraint] {
    val targetNamespace: Option[String] = Some("http://www.accellera.org/XMLSchema/IPXACT/1685-2022")
    
    def parser(node: scala.xml.Node, stack: List[IPXACT2022scalaxb.ElemName]): Parser[IPXACT2022ScalaCases.DriveConstraint] =
      phrase((IPXACT2022scalaxb.ElemName(Some("http://www.accellera.org/XMLSchema/IPXACT/1685-2022"), "cellSpecification")) ^^
      { case p1 =>
      IPXACT2022ScalaCases.DriveConstraint(IPXACT2022scalaxb.fromXML[IPXACT2022ScalaCases.CellSpecification](p1, IPXACT2022scalaxb.ElemName(node) :: stack)) })
    
    def writesChildNodes(__obj: IPXACT2022ScalaCases.DriveConstraint, __scope: scala.xml.NamespaceBinding): Seq[scala.xml.Node] =
      (IPXACT2022scalaxb.toXML[IPXACT2022ScalaCases.CellSpecification](__obj.cellSpecification, Some("http://www.accellera.org/XMLSchema/IPXACT/1685-2022"), Some("cellSpecification"), __scope, false))
  }
  trait DefaultIPXACT2022ScalaCases_LoadConstraintFormat extends IPXACT2022scalaxb.ElemNameParser[IPXACT2022ScalaCases.LoadConstraint] {
    val targetNamespace: Option[String] = Some("http://www.accellera.org/XMLSchema/IPXACT/1685-2022")
    
    def parser(node: scala.xml.Node, stack: List[IPXACT2022scalaxb.ElemName]): Parser[IPXACT2022ScalaCases.LoadConstraint] =
      phrase((IPXACT2022scalaxb.ElemName(Some("http://www.accellera.org/XMLSchema/IPXACT/1685-2022"), "cellSpecification")) ~
      opt(IPXACT2022scalaxb.ElemName(Some("http://www.accellera.org/XMLSchema/IPXACT/1685-2022"), "count")) ^^
      { case p1 ~ p2 =>
      IPXACT2022ScalaCases.LoadConstraint(IPXACT2022scalaxb.fromXML[IPXACT2022ScalaCases.CellSpecification](p1, IPXACT2022scalaxb.ElemName(node) :: stack),
        p2.headOption map { IPXACT2022scalaxb.fromXML[IPXACT2022ScalaCases.UnsignedPositiveIntExpressionable](_, IPXACT2022scalaxb.ElemName(node) :: stack) }) })
    
    def writesChildNodes(__obj: IPXACT2022ScalaCases.LoadConstraint, __scope: scala.xml.NamespaceBinding): Seq[scala.xml.Node] =
      Seq.concat(IPXACT2022scalaxb.toXML[IPXACT2022ScalaCases.CellSpecification](__obj.cellSpecification, Some("http://www.accellera.org/XMLSchema/IPXACT/1685-2022"), Some("cellSpecification"), __scope, false),
        __obj.count map { IPXACT2022scalaxb.toXML[IPXACT2022ScalaCases.UnsignedPositiveIntExpressionable](_, Some("http://www.accellera.org/XMLSchema/IPXACT/1685-2022"), Some("count"), __scope, false) } getOrElse {Nil})

  }

  trait DefaultIPXACT2022ScalaCases_Vector3Format extends IPXACT2022scalaxb.ElemNameParser[IPXACT2022ScalaCases.Vector3] {
    val targetNamespace: Option[String] = Some("http://www.accellera.org/XMLSchema/IPXACT/1685-2022")
    
    def parser(node: scala.xml.Node, stack: List[IPXACT2022scalaxb.ElemName]): Parser[IPXACT2022ScalaCases.Vector3] =
      phrase((IPXACT2022scalaxb.ElemName(Some("http://www.accellera.org/XMLSchema/IPXACT/1685-2022"), "left")) ~
      (IPXACT2022scalaxb.ElemName(Some("http://www.accellera.org/XMLSchema/IPXACT/1685-2022"), "right")) ^^
      { case p1 ~ p2 =>
      IPXACT2022ScalaCases.Vector3(IPXACT2022scalaxb.fromXML[IPXACT2022ScalaCases.UnsignedIntExpressionable](p1, IPXACT2022scalaxb.ElemName(node) :: stack),
        IPXACT2022scalaxb.fromXML[IPXACT2022ScalaCases.UnsignedIntExpressionable](p2, IPXACT2022scalaxb.ElemName(node) :: stack)) })
    
    def writesChildNodes(__obj: IPXACT2022ScalaCases.Vector3, __scope: scala.xml.NamespaceBinding): Seq[scala.xml.Node] =
      Seq.concat(IPXACT2022scalaxb.toXML[IPXACT2022ScalaCases.UnsignedIntExpressionable](__obj.left, Some("http://www.accellera.org/XMLSchema/IPXACT/1685-2022"), Some("left"), __scope, false),
        IPXACT2022scalaxb.toXML[IPXACT2022ScalaCases.UnsignedIntExpressionable](__obj.right, Some("http://www.accellera.org/XMLSchema/IPXACT/1685-2022"), Some("right"), __scope, false))

  }

  trait DefaultIPXACT2022ScalaCases_ConstraintSetFormat extends IPXACT2022scalaxb.ElemNameParser[IPXACT2022ScalaCases.ConstraintSet] with IPXACT2022ScalaCases_NameGroupOptionalGroupFormat {
    val targetNamespace: Option[String] = Some("http://www.accellera.org/XMLSchema/IPXACT/1685-2022")
    
    def parser(node: scala.xml.Node, stack: List[IPXACT2022scalaxb.ElemName]): Parser[IPXACT2022ScalaCases.ConstraintSet] =
      phrase((parseNameGroupOptionalGroup(node, IPXACT2022scalaxb.ElemName(node) :: stack)) ~
      opt(IPXACT2022scalaxb.ElemName(Some("http://www.accellera.org/XMLSchema/IPXACT/1685-2022"), "vector")) ~
      opt(IPXACT2022scalaxb.ElemName(Some("http://www.accellera.org/XMLSchema/IPXACT/1685-2022"), "driveConstraint")) ~
      opt(IPXACT2022scalaxb.ElemName(Some("http://www.accellera.org/XMLSchema/IPXACT/1685-2022"), "loadConstraint")) ~
      safeRep(IPXACT2022scalaxb.ElemName(Some("http://www.accellera.org/XMLSchema/IPXACT/1685-2022"), "timingConstraint")) ^^
      { case p1 ~ p2 ~ p3 ~ p4 ~ p5 =>
      IPXACT2022ScalaCases.ConstraintSet(p1,
        p2.headOption map { IPXACT2022scalaxb.fromXML[IPXACT2022ScalaCases.Vector3](_, IPXACT2022scalaxb.ElemName(node) :: stack) },
        p3.headOption map { IPXACT2022scalaxb.fromXML[IPXACT2022ScalaCases.DriveConstraint](_, IPXACT2022scalaxb.ElemName(node) :: stack) },
        p4.headOption map { IPXACT2022scalaxb.fromXML[IPXACT2022ScalaCases.LoadConstraint](_, IPXACT2022scalaxb.ElemName(node) :: stack) },
        p5 map { IPXACT2022scalaxb.fromXML[IPXACT2022ScalaCases.TimingConstraint](_, IPXACT2022scalaxb.ElemName(node) :: stack) },
        scala.collection.immutable.ListMap(List(
        (node \ "@constraintSetId").headOption map { x => IPXACT2022scalaxb.DataRecord(x, node, IPXACT2022scalaxb.fromXML[String](x, IPXACT2022scalaxb.ElemName(node) :: stack)) } orElse Some(IPXACT2022scalaxb.DataRecord(None, None, IPXACT2022scalaxb.fromXML[String](scala.xml.Text("default"), IPXACT2022scalaxb.ElemName(node) :: stack))) map { "@constraintSetId" -> _ },
        (node \ "@{http://www.w3.org/XML/1998/namespace}id").headOption map { x => IPXACT2022scalaxb.DataRecord(x, node, IPXACT2022scalaxb.fromXML[String](x, IPXACT2022scalaxb.ElemName(node) :: stack)) } map { "@{http://www.w3.org/XML/1998/namespace}id" -> _ }
        ).flatten[(String, IPXACT2022scalaxb.DataRecord[Any])]: _*)) })
    
    override def writesAttribute(__obj: IPXACT2022ScalaCases.ConstraintSet, __scope: scala.xml.NamespaceBinding): scala.xml.MetaData = {
      var attr: scala.xml.MetaData  = scala.xml.Null
      __obj.attributes.toList map {
        case ("@constraintSetId", _) => if (__obj.constraintSetId.toString != "default") attr = scala.xml.Attribute(null, "constraintSetId", __obj.constraintSetId.toString, attr)
        case ("@{http://www.w3.org/XML/1998/namespace}id", _) => __obj.xmlid foreach { x => attr = scala.xml.Attribute(__scope.getPrefix("http://www.w3.org/XML/1998/namespace"), "id", x.toString, attr) }
        case (key, x) => attr = scala.xml.Attribute((x.namespace map { __scope.getPrefix(_) }).orNull, x.key.orNull, x.value.toString, attr)
      }
      attr
    }

    def writesChildNodes(__obj: IPXACT2022ScalaCases.ConstraintSet, __scope: scala.xml.NamespaceBinding): Seq[scala.xml.Node] =
      Seq.concat(IPXACT2022scalaxb.toXML[IPXACT2022ScalaCases.NameGroupOptionalSequence](__obj.nameGroupOptionalSequence1, None, Some("nameGroupOptionalSequence1"), __scope, false),
        __obj.vector map { IPXACT2022scalaxb.toXML[IPXACT2022ScalaCases.Vector3](_, Some("http://www.accellera.org/XMLSchema/IPXACT/1685-2022"), Some("vector"), __scope, false) } getOrElse {Nil},
        __obj.driveConstraint map { IPXACT2022scalaxb.toXML[IPXACT2022ScalaCases.DriveConstraint](_, Some("http://www.accellera.org/XMLSchema/IPXACT/1685-2022"), Some("driveConstraint"), __scope, false) } getOrElse {Nil},
        __obj.loadConstraint map { IPXACT2022scalaxb.toXML[IPXACT2022ScalaCases.LoadConstraint](_, Some("http://www.accellera.org/XMLSchema/IPXACT/1685-2022"), Some("loadConstraint"), __scope, false) } getOrElse {Nil},
        __obj.timingConstraint flatMap { IPXACT2022scalaxb.toXML[IPXACT2022ScalaCases.TimingConstraint](_, Some("http://www.accellera.org/XMLSchema/IPXACT/1685-2022"), Some("timingConstraint"), __scope, false) })

  }

  trait DefaultIPXACT2022ScalaCases_ConstraintSetsFormat extends IPXACT2022scalaxb.ElemNameParser[IPXACT2022ScalaCases.ConstraintSets] {
    val targetNamespace: Option[String] = Some("http://www.accellera.org/XMLSchema/IPXACT/1685-2022")
    
    def parser(node: scala.xml.Node, stack: List[IPXACT2022scalaxb.ElemName]): Parser[IPXACT2022ScalaCases.ConstraintSets] =
      phrase(safeRep(IPXACT2022scalaxb.ElemName(Some("http://www.accellera.org/XMLSchema/IPXACT/1685-2022"), "constraintSet")) ^^
      { case p1 =>
      IPXACT2022ScalaCases.ConstraintSets(p1 map { IPXACT2022scalaxb.fromXML[IPXACT2022ScalaCases.ConstraintSet](_, IPXACT2022scalaxb.ElemName(node) :: stack) }) })
    
    def writesChildNodes(__obj: IPXACT2022ScalaCases.ConstraintSets, __scope: scala.xml.NamespaceBinding): Seq[scala.xml.Node] =
      (__obj.constraintSet flatMap { IPXACT2022scalaxb.toXML[IPXACT2022ScalaCases.ConstraintSet](_, Some("http://www.accellera.org/XMLSchema/IPXACT/1685-2022"), Some("constraintSet"), __scope, false) })
  }
  trait DefaultIPXACT2022ScalaCases_ConstraintSetRefFormat extends IPXACT2022scalaxb.ElemNameParser[IPXACT2022ScalaCases.ConstraintSetRef] {
    val targetNamespace: Option[String] = Some("http://www.accellera.org/XMLSchema/IPXACT/1685-2022")
    
    def parser(node: scala.xml.Node, stack: List[IPXACT2022scalaxb.ElemName]): Parser[IPXACT2022ScalaCases.ConstraintSetRef] =
      phrase((IPXACT2022scalaxb.ElemName(Some("http://www.accellera.org/XMLSchema/IPXACT/1685-2022"), "localName")) ~
      opt(IPXACT2022scalaxb.ElemName(Some("http://www.accellera.org/XMLSchema/IPXACT/1685-2022"), "vendorExtensions")) ^^
      { case p1 ~ p2 =>
      IPXACT2022ScalaCases.ConstraintSetRef(IPXACT2022scalaxb.fromXML[String](p1, IPXACT2022scalaxb.ElemName(node) :: stack),
        p2.headOption map { IPXACT2022scalaxb.fromXML[IPXACT2022ScalaCases.VendorExtensions](_, IPXACT2022scalaxb.ElemName(node) :: stack) },
        scala.collection.immutable.ListMap(List(
        (node \ "@{http://www.w3.org/XML/1998/namespace}id").headOption map { x => IPXACT2022scalaxb.DataRecord(x, node, IPXACT2022scalaxb.fromXML[String](x, IPXACT2022scalaxb.ElemName(node) :: stack)) } map { "@{http://www.w3.org/XML/1998/namespace}id" -> _ }
        ).flatten[(String, IPXACT2022scalaxb.DataRecord[Any])]: _*)) })
    
    override def writesAttribute(__obj: IPXACT2022ScalaCases.ConstraintSetRef, __scope: scala.xml.NamespaceBinding): scala.xml.MetaData = {
      var attr: scala.xml.MetaData  = scala.xml.Null
      __obj.attributes.toList map {
        case ("@{http://www.w3.org/XML/1998/namespace}id", _) => __obj.xmlid foreach { x => attr = scala.xml.Attribute(__scope.getPrefix("http://www.w3.org/XML/1998/namespace"), "id", x.toString, attr) }
        case (key, x) => attr = scala.xml.Attribute((x.namespace map { __scope.getPrefix(_) }).orNull, x.key.orNull, x.value.toString, attr)
      }
      attr
    }

    def writesChildNodes(__obj: IPXACT2022ScalaCases.ConstraintSetRef, __scope: scala.xml.NamespaceBinding): Seq[scala.xml.Node] =
      Seq.concat(IPXACT2022scalaxb.toXML[String](__obj.localName, Some("http://www.accellera.org/XMLSchema/IPXACT/1685-2022"), Some("localName"), __scope, false),
        __obj.vendorExtensions map { IPXACT2022scalaxb.toXML[IPXACT2022ScalaCases.VendorExtensions](_, Some("http://www.accellera.org/XMLSchema/IPXACT/1685-2022"), Some("vendorExtensions"), __scope, false) } getOrElse {Nil})

  }

  trait DefaultIPXACT2022ScalaCases_AbstractionDefPortConstraintsTypeFormat extends IPXACT2022scalaxb.ElemNameParser[IPXACT2022ScalaCases.AbstractionDefPortConstraintsType] {
    val targetNamespace: Option[String] = Some("http://www.accellera.org/XMLSchema/IPXACT/1685-2022")
    
    override def typeName: Option[String] = Some("abstractionDefPortConstraintsType")

    def parser(node: scala.xml.Node, stack: List[IPXACT2022scalaxb.ElemName]): Parser[IPXACT2022ScalaCases.AbstractionDefPortConstraintsType] =
      phrase((((safeRep(IPXACT2022scalaxb.ElemName(Some("http://www.accellera.org/XMLSchema/IPXACT/1685-2022"), "timingConstraint")) ~
      opt(IPXACT2022scalaxb.ElemName(Some("http://www.accellera.org/XMLSchema/IPXACT/1685-2022"), "driveConstraint")) ~
      opt(IPXACT2022scalaxb.ElemName(Some("http://www.accellera.org/XMLSchema/IPXACT/1685-2022"), "loadConstraint"))) ^^
        { case p1 ~ p2 ~ p3 => IPXACT2022scalaxb.DataRecord(IPXACT2022ScalaCases.AbstractionDefPortConstraintsTypeSequence1(p1 map { IPXACT2022scalaxb.fromXML[IPXACT2022ScalaCases.TimingConstraint](_, IPXACT2022scalaxb.ElemName(node) :: stack) },
        p2.headOption map { IPXACT2022scalaxb.fromXML[IPXACT2022ScalaCases.DriveConstraint](_, IPXACT2022scalaxb.ElemName(node) :: stack) },
        p3.headOption map { IPXACT2022scalaxb.fromXML[IPXACT2022ScalaCases.LoadConstraint](_, IPXACT2022scalaxb.ElemName(node) :: stack) })) }) |||
      (((IPXACT2022scalaxb.ElemName(Some("http://www.accellera.org/XMLSchema/IPXACT/1685-2022"), "driveConstraint")) ~
      opt(IPXACT2022scalaxb.ElemName(Some("http://www.accellera.org/XMLSchema/IPXACT/1685-2022"), "loadConstraint"))) ^^
        { case p1 ~ p2 => IPXACT2022scalaxb.DataRecord(IPXACT2022ScalaCases.AbstractionDefPortConstraintsTypeSequence2(IPXACT2022scalaxb.fromXML[IPXACT2022ScalaCases.DriveConstraint](p1, IPXACT2022scalaxb.ElemName(node) :: stack),
        p2.headOption map { IPXACT2022scalaxb.fromXML[IPXACT2022ScalaCases.LoadConstraint](_, IPXACT2022scalaxb.ElemName(node) :: stack) })) }) |||
      (((IPXACT2022scalaxb.ElemName(Some("http://www.accellera.org/XMLSchema/IPXACT/1685-2022"), "loadConstraint"))) ^^
        { case p1 => IPXACT2022scalaxb.DataRecord(IPXACT2022ScalaCases.AbstractionDefPortConstraintsTypeSequence3(IPXACT2022scalaxb.fromXML[IPXACT2022ScalaCases.LoadConstraint](p1, IPXACT2022scalaxb.ElemName(node) :: stack))) })) ^^
      { case p1 =>
      IPXACT2022ScalaCases.AbstractionDefPortConstraintsType(p1) })
    
    def writesChildNodes(__obj: IPXACT2022ScalaCases.AbstractionDefPortConstraintsType, __scope: scala.xml.NamespaceBinding): Seq[scala.xml.Node] =
      ((Some(__obj.abstractiondefportconstraintstypeoption) map {x => IPXACT2022scalaxb.toXML[IPXACT2022scalaxb.DataRecord[IPXACT2022ScalaCases.AbstractionDefPortConstraintsTypeOption]](x, x.namespace, x.key, __scope, false)}).get)
  }

  trait DefaultIPXACT2022ScalaCases_AbstractionDefPortConstraintsTypeSequence3Format extends IPXACT2022scalaxb.XMLFormat[IPXACT2022ScalaCases.AbstractionDefPortConstraintsTypeSequence3] {
    def reads(seq: scala.xml.NodeSeq, stack: List[IPXACT2022scalaxb.ElemName]): Either[String, IPXACT2022ScalaCases.AbstractionDefPortConstraintsTypeSequence3] = Left("don't call me.")
    
    def writes(__obj: IPXACT2022ScalaCases.AbstractionDefPortConstraintsTypeSequence3, __namespace: Option[String], __elementLabel: Option[String],
        __scope: scala.xml.NamespaceBinding, __typeAttribute: Boolean): scala.xml.NodeSeq =
      IPXACT2022scalaxb.toXML[IPXACT2022ScalaCases.LoadConstraint](__obj.loadConstraint, Some("http://www.accellera.org/XMLSchema/IPXACT/1685-2022"), Some("loadConstraint"), __scope, false)

  }
  trait DefaultIPXACT2022ScalaCases_AbstractionDefPortConstraintsTypeSequence2Format extends IPXACT2022scalaxb.XMLFormat[IPXACT2022ScalaCases.AbstractionDefPortConstraintsTypeSequence2] {
    def reads(seq: scala.xml.NodeSeq, stack: List[IPXACT2022scalaxb.ElemName]): Either[String, IPXACT2022ScalaCases.AbstractionDefPortConstraintsTypeSequence2] = Left("don't call me.")
    
    def writes(__obj: IPXACT2022ScalaCases.AbstractionDefPortConstraintsTypeSequence2, __namespace: Option[String], __elementLabel: Option[String],
        __scope: scala.xml.NamespaceBinding, __typeAttribute: Boolean): scala.xml.NodeSeq =
      Seq.concat(IPXACT2022scalaxb.toXML[IPXACT2022ScalaCases.DriveConstraint](__obj.driveConstraint, Some("http://www.accellera.org/XMLSchema/IPXACT/1685-2022"), Some("driveConstraint"), __scope, false),
        __obj.loadConstraint map { IPXACT2022scalaxb.toXML[IPXACT2022ScalaCases.LoadConstraint](_, Some("http://www.accellera.org/XMLSchema/IPXACT/1685-2022"), Some("loadConstraint"), __scope, false) } getOrElse {Nil})


  }

  trait DefaultIPXACT2022ScalaCases_AbstractionDefPortConstraintsTypeSequence1Format extends IPXACT2022scalaxb.XMLFormat[IPXACT2022ScalaCases.AbstractionDefPortConstraintsTypeSequence1] {
    def reads(seq: scala.xml.NodeSeq, stack: List[IPXACT2022scalaxb.ElemName]): Either[String, IPXACT2022ScalaCases.AbstractionDefPortConstraintsTypeSequence1] = Left("don't call me.")
    
    def writes(__obj: IPXACT2022ScalaCases.AbstractionDefPortConstraintsTypeSequence1, __namespace: Option[String], __elementLabel: Option[String],
        __scope: scala.xml.NamespaceBinding, __typeAttribute: Boolean): scala.xml.NodeSeq =
      Seq.concat(__obj.timingConstraint flatMap { IPXACT2022scalaxb.toXML[IPXACT2022ScalaCases.TimingConstraint](_, Some("http://www.accellera.org/XMLSchema/IPXACT/1685-2022"), Some("timingConstraint"), __scope, false) },
        __obj.driveConstraint map { IPXACT2022scalaxb.toXML[IPXACT2022ScalaCases.DriveConstraint](_, Some("http://www.accellera.org/XMLSchema/IPXACT/1685-2022"), Some("driveConstraint"), __scope, false) } getOrElse {Nil},
        __obj.loadConstraint map { IPXACT2022scalaxb.toXML[IPXACT2022ScalaCases.LoadConstraint](_, Some("http://www.accellera.org/XMLSchema/IPXACT/1685-2022"), Some("loadConstraint"), __scope, false) } getOrElse {Nil})


  }

  trait DefaultIPXACT2022ScalaCases_DesignFormat extends IPXACT2022scalaxb.ElemNameParser[IPXACT2022ScalaCases.Design] with IPXACT2022ScalaCases_DocumentNameGroupGroupFormat {
    val targetNamespace: Option[String] = Some("http://www.accellera.org/XMLSchema/IPXACT/1685-2022")
    
    def parser(node: scala.xml.Node, stack: List[IPXACT2022scalaxb.ElemName]): Parser[IPXACT2022ScalaCases.Design] =
      phrase((parseDocumentNameGroupGroup(node, IPXACT2022scalaxb.ElemName(node) :: stack)) ~
      opt(IPXACT2022scalaxb.ElemName(Some("http://www.accellera.org/XMLSchema/IPXACT/1685-2022"), "componentInstances")) ~
      opt(IPXACT2022scalaxb.ElemName(Some("http://www.accellera.org/XMLSchema/IPXACT/1685-2022"), "interconnections")) ~
      opt(IPXACT2022scalaxb.ElemName(Some("http://www.accellera.org/XMLSchema/IPXACT/1685-2022"), "adHocConnections")) ~
      opt(IPXACT2022scalaxb.ElemName(Some("http://www.accellera.org/XMLSchema/IPXACT/1685-2022"), "choices")) ~
      opt(IPXACT2022scalaxb.ElemName(Some("http://www.accellera.org/XMLSchema/IPXACT/1685-2022"), "parameters")) ~
      opt(IPXACT2022scalaxb.ElemName(Some("http://www.accellera.org/XMLSchema/IPXACT/1685-2022"), "assertions")) ~
      opt(IPXACT2022scalaxb.ElemName(Some("http://www.accellera.org/XMLSchema/IPXACT/1685-2022"), "vendorExtensions")) ^^
      { case p1 ~ p2 ~ p3 ~ p4 ~ p5 ~ p6 ~ p7 ~ p8 =>
      IPXACT2022ScalaCases.Design(p1,
        p2.headOption map { IPXACT2022scalaxb.fromXML[IPXACT2022ScalaCases.ComponentInstances](_, IPXACT2022scalaxb.ElemName(node) :: stack) },
        p3.headOption map { IPXACT2022scalaxb.fromXML[IPXACT2022ScalaCases.Interconnections](_, IPXACT2022scalaxb.ElemName(node) :: stack) },
        p4.headOption map { IPXACT2022scalaxb.fromXML[IPXACT2022ScalaCases.AdHocConnections](_, IPXACT2022scalaxb.ElemName(node) :: stack) },
        p5.headOption map { IPXACT2022scalaxb.fromXML[IPXACT2022ScalaCases.Choices](_, IPXACT2022scalaxb.ElemName(node) :: stack) },
        p6.headOption map { IPXACT2022scalaxb.fromXML[IPXACT2022ScalaCases.Parameters](_, IPXACT2022scalaxb.ElemName(node) :: stack) },
        p7.headOption map { IPXACT2022scalaxb.fromXML[IPXACT2022ScalaCases.Assertions](_, IPXACT2022scalaxb.ElemName(node) :: stack) },
        p8.headOption map { IPXACT2022scalaxb.fromXML[IPXACT2022ScalaCases.VendorExtensions](_, IPXACT2022scalaxb.ElemName(node) :: stack) },
        scala.collection.immutable.ListMap(List(
        (node \ "@{http://www.w3.org/XML/1998/namespace}id").headOption map { x => IPXACT2022scalaxb.DataRecord(x, node, IPXACT2022scalaxb.fromXML[String](x, IPXACT2022scalaxb.ElemName(node) :: stack)) } map { "@{http://www.w3.org/XML/1998/namespace}id" -> _ }
        ).flatten[(String, IPXACT2022scalaxb.DataRecord[Any])]: _*)) })
    
    override def writesAttribute(__obj: IPXACT2022ScalaCases.Design, __scope: scala.xml.NamespaceBinding): scala.xml.MetaData = {
      var attr: scala.xml.MetaData  = scala.xml.Null
      __obj.attributes.toList map {
        case ("@{http://www.w3.org/XML/1998/namespace}id", _) => __obj.xmlid foreach { x => attr = scala.xml.Attribute(__scope.getPrefix("http://www.w3.org/XML/1998/namespace"), "id", x.toString, attr) }
        case (key, x) => attr = scala.xml.Attribute((x.namespace map { __scope.getPrefix(_) }).orNull, x.key.orNull, x.value.toString, attr)
      }
      attr
    }

    def writesChildNodes(__obj: IPXACT2022ScalaCases.Design, __scope: scala.xml.NamespaceBinding): Seq[scala.xml.Node] =
      Seq.concat(IPXACT2022scalaxb.toXML[IPXACT2022ScalaCases.DocumentNameGroupSequence](__obj.documentNameGroupSequence1, None, Some("documentNameGroupSequence1"), __scope, false),
        __obj.componentInstances map { IPXACT2022scalaxb.toXML[IPXACT2022ScalaCases.ComponentInstances](_, Some("http://www.accellera.org/XMLSchema/IPXACT/1685-2022"), Some("componentInstances"), __scope, false) } getOrElse {Nil},
        __obj.interconnections map { IPXACT2022scalaxb.toXML[IPXACT2022ScalaCases.Interconnections](_, Some("http://www.accellera.org/XMLSchema/IPXACT/1685-2022"), Some("interconnections"), __scope, false) } getOrElse {Nil},
        __obj.adHocConnections map { IPXACT2022scalaxb.toXML[IPXACT2022ScalaCases.AdHocConnections](_, Some("http://www.accellera.org/XMLSchema/IPXACT/1685-2022"), Some("adHocConnections"), __scope, false) } getOrElse {Nil},
        __obj.choices map { IPXACT2022scalaxb.toXML[IPXACT2022ScalaCases.Choices](_, Some("http://www.accellera.org/XMLSchema/IPXACT/1685-2022"), Some("choices"), __scope, false) } getOrElse {Nil},
        __obj.parameters map { IPXACT2022scalaxb.toXML[IPXACT2022ScalaCases.Parameters](_, Some("http://www.accellera.org/XMLSchema/IPXACT/1685-2022"), Some("parameters"), __scope, false) } getOrElse {Nil},
        __obj.assertions map { IPXACT2022scalaxb.toXML[IPXACT2022ScalaCases.Assertions](_, Some("http://www.accellera.org/XMLSchema/IPXACT/1685-2022"), Some("assertions"), __scope, false) } getOrElse {Nil},
        __obj.vendorExtensions map { IPXACT2022scalaxb.toXML[IPXACT2022ScalaCases.VendorExtensions](_, Some("http://www.accellera.org/XMLSchema/IPXACT/1685-2022"), Some("vendorExtensions"), __scope, false) } getOrElse {Nil})

  }

  trait DefaultIPXACT2022ScalaCases_InterfaceRefFormat extends IPXACT2022scalaxb.ElemNameParser[IPXACT2022ScalaCases.InterfaceRef] {
    val targetNamespace: Option[String] = Some("http://www.accellera.org/XMLSchema/IPXACT/1685-2022")
    
    def parser(node: scala.xml.Node, stack: List[IPXACT2022scalaxb.ElemName]): Parser[IPXACT2022ScalaCases.InterfaceRef] =
      phrase(opt((opt(IPXACT2022scalaxb.ElemName(Some("http://www.accellera.org/XMLSchema/IPXACT/1685-2022"), "vendorExtensions"))) ^^
        { case p1 => IPXACT2022ScalaCases.InterfaceRefSequence1(p1.headOption map { IPXACT2022scalaxb.fromXML[IPXACT2022ScalaCases.VendorExtensions](_, IPXACT2022scalaxb.ElemName(node) :: stack) }) }) ^^
      { case p1 =>
      IPXACT2022ScalaCases.InterfaceRef(p1,
        scala.collection.immutable.ListMap(List(
        (node \ "@componentRef").headOption map { x => IPXACT2022scalaxb.DataRecord(x, node, IPXACT2022scalaxb.fromXML[String](x, IPXACT2022scalaxb.ElemName(node) :: stack)) } map { "@componentRef" -> _ },
        (node \ "@busRef").headOption map { x => IPXACT2022scalaxb.DataRecord(x, node, IPXACT2022scalaxb.fromXML[String](x, IPXACT2022scalaxb.ElemName(node) :: stack)) } map { "@busRef" -> _ },
        (node \ "@{http://www.w3.org/XML/1998/namespace}id").headOption map { x => IPXACT2022scalaxb.DataRecord(x, node, IPXACT2022scalaxb.fromXML[String](x, IPXACT2022scalaxb.ElemName(node) :: stack)) } map { "@{http://www.w3.org/XML/1998/namespace}id" -> _ }
        ).flatten[(String, IPXACT2022scalaxb.DataRecord[Any])]: _*)) })
    
    override def writesAttribute(__obj: IPXACT2022ScalaCases.InterfaceRef, __scope: scala.xml.NamespaceBinding): scala.xml.MetaData = {
      var attr: scala.xml.MetaData  = scala.xml.Null
      __obj.attributes.toList map {
        case ("@componentRef", _) => attr = scala.xml.Attribute(null, "componentRef", __obj.componentRef.toString, attr)
        case ("@busRef", _) => attr = scala.xml.Attribute(null, "busRef", __obj.busRef.toString, attr)
        case ("@{http://www.w3.org/XML/1998/namespace}id", _) => __obj.xmlid foreach { x => attr = scala.xml.Attribute(__scope.getPrefix("http://www.w3.org/XML/1998/namespace"), "id", x.toString, attr) }
        case (key, x) => attr = scala.xml.Attribute((x.namespace map { __scope.getPrefix(_) }).orNull, x.key.orNull, x.value.toString, attr)
      }
      attr
    }

    def writesChildNodes(__obj: IPXACT2022ScalaCases.InterfaceRef, __scope: scala.xml.NamespaceBinding): Seq[scala.xml.Node] =
      (__obj.interfacerefsequence1 map { IPXACT2022scalaxb.toXML[IPXACT2022ScalaCases.InterfaceRefSequence1](_, None, Some("interfacerefsequence1"), __scope, false) } getOrElse {Nil})
  }

  trait DefaultIPXACT2022ScalaCases_InterfaceRefSequence1Format extends IPXACT2022scalaxb.XMLFormat[IPXACT2022ScalaCases.InterfaceRefSequence1] {
    def reads(seq: scala.xml.NodeSeq, stack: List[IPXACT2022scalaxb.ElemName]): Either[String, IPXACT2022ScalaCases.InterfaceRefSequence1] = Left("don't call me.")
    
    def writes(__obj: IPXACT2022ScalaCases.InterfaceRefSequence1, __namespace: Option[String], __elementLabel: Option[String],
        __scope: scala.xml.NamespaceBinding, __typeAttribute: Boolean): scala.xml.NodeSeq =
      __obj.vendorExtensions map { IPXACT2022scalaxb.toXML[IPXACT2022ScalaCases.VendorExtensions](_, Some("http://www.accellera.org/XMLSchema/IPXACT/1685-2022"), Some("vendorExtensions"), __scope, false) } getOrElse {Nil}

  }
  trait DefaultIPXACT2022ScalaCases_AbstractorInstanceFormat extends IPXACT2022scalaxb.ElemNameParser[IPXACT2022ScalaCases.AbstractorInstance] {
    val targetNamespace: Option[String] = Some("http://www.accellera.org/XMLSchema/IPXACT/1685-2022")
    
    def parser(node: scala.xml.Node, stack: List[IPXACT2022scalaxb.ElemName]): Parser[IPXACT2022ScalaCases.AbstractorInstance] =
      phrase((IPXACT2022scalaxb.ElemName(Some("http://www.accellera.org/XMLSchema/IPXACT/1685-2022"), "instanceName")) ~
      opt(IPXACT2022scalaxb.ElemName(Some("http://www.accellera.org/XMLSchema/IPXACT/1685-2022"), "displayName")) ~
      opt(IPXACT2022scalaxb.ElemName(Some("http://www.accellera.org/XMLSchema/IPXACT/1685-2022"), "shortDescription")) ~
      opt(IPXACT2022scalaxb.ElemName(Some("http://www.accellera.org/XMLSchema/IPXACT/1685-2022"), "description")) ~
      (IPXACT2022scalaxb.ElemName(Some("http://www.accellera.org/XMLSchema/IPXACT/1685-2022"), "abstractorRef")) ~
      (IPXACT2022scalaxb.ElemName(Some("http://www.accellera.org/XMLSchema/IPXACT/1685-2022"), "viewName")) ^^
      { case p1 ~ p2 ~ p3 ~ p4 ~ p5 ~ p6 =>
      IPXACT2022ScalaCases.AbstractorInstance(IPXACT2022scalaxb.fromXML[String](p1, IPXACT2022scalaxb.ElemName(node) :: stack),
        p2.headOption map { IPXACT2022scalaxb.fromXML[String](_, IPXACT2022scalaxb.ElemName(node) :: stack) },
        p3.headOption map { IPXACT2022scalaxb.fromXML[String](_, IPXACT2022scalaxb.ElemName(node) :: stack) },
        p4.headOption map { IPXACT2022scalaxb.fromXML[String](_, IPXACT2022scalaxb.ElemName(node) :: stack) },
        IPXACT2022scalaxb.fromXML[IPXACT2022ScalaCases.ConfigurableLibraryRefType](p5, IPXACT2022scalaxb.ElemName(node) :: stack),
        IPXACT2022scalaxb.fromXML[String](p6, IPXACT2022scalaxb.ElemName(node) :: stack),
        scala.collection.immutable.ListMap(List(
        (node \ "@{http://www.w3.org/XML/1998/namespace}id").headOption map { x => IPXACT2022scalaxb.DataRecord(x, node, IPXACT2022scalaxb.fromXML[String](x, IPXACT2022scalaxb.ElemName(node) :: stack)) } map { "@{http://www.w3.org/XML/1998/namespace}id" -> _ }
        ).flatten[(String, IPXACT2022scalaxb.DataRecord[Any])]: _*)) })
    
    override def writesAttribute(__obj: IPXACT2022ScalaCases.AbstractorInstance, __scope: scala.xml.NamespaceBinding): scala.xml.MetaData = {
      var attr: scala.xml.MetaData  = scala.xml.Null
      __obj.attributes.toList map {
        case ("@{http://www.w3.org/XML/1998/namespace}id", _) => __obj.xmlid foreach { x => attr = scala.xml.Attribute(__scope.getPrefix("http://www.w3.org/XML/1998/namespace"), "id", x.toString, attr) }
        case (key, x) => attr = scala.xml.Attribute((x.namespace map { __scope.getPrefix(_) }).orNull, x.key.orNull, x.value.toString, attr)
      }
      attr
    }

    def writesChildNodes(__obj: IPXACT2022ScalaCases.AbstractorInstance, __scope: scala.xml.NamespaceBinding): Seq[scala.xml.Node] =
      Seq.concat(IPXACT2022scalaxb.toXML[String](__obj.instanceName, Some("http://www.accellera.org/XMLSchema/IPXACT/1685-2022"), Some("instanceName"), __scope, false),
        __obj.displayName map { IPXACT2022scalaxb.toXML[String](_, Some("http://www.accellera.org/XMLSchema/IPXACT/1685-2022"), Some("displayName"), __scope, false) } getOrElse {Nil},
        __obj.shortDescription map { IPXACT2022scalaxb.toXML[String](_, Some("http://www.accellera.org/XMLSchema/IPXACT/1685-2022"), Some("shortDescription"), __scope, false) } getOrElse {Nil},
        __obj.description map { IPXACT2022scalaxb.toXML[String](_, Some("http://www.accellera.org/XMLSchema/IPXACT/1685-2022"), Some("description"), __scope, false) } getOrElse {Nil},
        IPXACT2022scalaxb.toXML[IPXACT2022ScalaCases.ConfigurableLibraryRefType](__obj.abstractorRef, Some("http://www.accellera.org/XMLSchema/IPXACT/1685-2022"), Some("abstractorRef"), __scope, false),
        IPXACT2022scalaxb.toXML[String](__obj.viewName, Some("http://www.accellera.org/XMLSchema/IPXACT/1685-2022"), Some("viewName"), __scope, false))

  }

  trait DefaultIPXACT2022ScalaCases_AbstractorInstancesFormat extends IPXACT2022scalaxb.ElemNameParser[IPXACT2022ScalaCases.AbstractorInstances] {
    val targetNamespace: Option[String] = Some("http://www.accellera.org/XMLSchema/IPXACT/1685-2022")
    
    def parser(node: scala.xml.Node, stack: List[IPXACT2022scalaxb.ElemName]): Parser[IPXACT2022ScalaCases.AbstractorInstances] =
      phrase(safeRep(IPXACT2022scalaxb.ElemName(Some("http://www.accellera.org/XMLSchema/IPXACT/1685-2022"), "interfaceRef")) ~
      safeRep(IPXACT2022scalaxb.ElemName(Some("http://www.accellera.org/XMLSchema/IPXACT/1685-2022"), "abstractorInstance")) ~
      opt(IPXACT2022scalaxb.ElemName(Some("http://www.accellera.org/XMLSchema/IPXACT/1685-2022"), "vendorExtensions")) ^^
      { case p1 ~ p2 ~ p3 =>
      IPXACT2022ScalaCases.AbstractorInstances(p1 map { IPXACT2022scalaxb.fromXML[IPXACT2022ScalaCases.InterfaceRef](_, IPXACT2022scalaxb.ElemName(node) :: stack) },
        p2 map { IPXACT2022scalaxb.fromXML[IPXACT2022ScalaCases.AbstractorInstance](_, IPXACT2022scalaxb.ElemName(node) :: stack) },
        p3.headOption map { IPXACT2022scalaxb.fromXML[IPXACT2022ScalaCases.VendorExtensions](_, IPXACT2022scalaxb.ElemName(node) :: stack) },
        scala.collection.immutable.ListMap(List(
        (node \ "@{http://www.w3.org/XML/1998/namespace}id").headOption map { x => IPXACT2022scalaxb.DataRecord(x, node, IPXACT2022scalaxb.fromXML[String](x, IPXACT2022scalaxb.ElemName(node) :: stack)) } map { "@{http://www.w3.org/XML/1998/namespace}id" -> _ }
        ).flatten[(String, IPXACT2022scalaxb.DataRecord[Any])]: _*)) })
    
    override def writesAttribute(__obj: IPXACT2022ScalaCases.AbstractorInstances, __scope: scala.xml.NamespaceBinding): scala.xml.MetaData = {
      var attr: scala.xml.MetaData  = scala.xml.Null
      __obj.attributes.toList map {
        case ("@{http://www.w3.org/XML/1998/namespace}id", _) => __obj.xmlid foreach { x => attr = scala.xml.Attribute(__scope.getPrefix("http://www.w3.org/XML/1998/namespace"), "id", x.toString, attr) }
        case (key, x) => attr = scala.xml.Attribute((x.namespace map { __scope.getPrefix(_) }).orNull, x.key.orNull, x.value.toString, attr)
      }
      attr
    }

    def writesChildNodes(__obj: IPXACT2022ScalaCases.AbstractorInstances, __scope: scala.xml.NamespaceBinding): Seq[scala.xml.Node] =
      Seq.concat(__obj.interfaceRef flatMap { IPXACT2022scalaxb.toXML[IPXACT2022ScalaCases.InterfaceRef](_, Some("http://www.accellera.org/XMLSchema/IPXACT/1685-2022"), Some("interfaceRef"), __scope, false) },
        __obj.abstractorInstance flatMap { IPXACT2022scalaxb.toXML[IPXACT2022ScalaCases.AbstractorInstance](_, Some("http://www.accellera.org/XMLSchema/IPXACT/1685-2022"), Some("abstractorInstance"), __scope, false) },
        __obj.vendorExtensions map { IPXACT2022scalaxb.toXML[IPXACT2022ScalaCases.VendorExtensions](_, Some("http://www.accellera.org/XMLSchema/IPXACT/1685-2022"), Some("vendorExtensions"), __scope, false) } getOrElse {Nil})

  }

  trait DefaultIPXACT2022ScalaCases_InterconnectionConfigurationFormat extends IPXACT2022scalaxb.ElemNameParser[IPXACT2022ScalaCases.InterconnectionConfiguration] {
    val targetNamespace: Option[String] = Some("http://www.accellera.org/XMLSchema/IPXACT/1685-2022")
    
    def parser(node: scala.xml.Node, stack: List[IPXACT2022scalaxb.ElemName]): Parser[IPXACT2022ScalaCases.InterconnectionConfiguration] =
      phrase((IPXACT2022scalaxb.ElemName(Some("http://www.accellera.org/XMLSchema/IPXACT/1685-2022"), "interconnectionRef")) ~
      safeRep(IPXACT2022scalaxb.ElemName(Some("http://www.accellera.org/XMLSchema/IPXACT/1685-2022"), "abstractorInstances")) ~
      opt(IPXACT2022scalaxb.ElemName(Some("http://www.accellera.org/XMLSchema/IPXACT/1685-2022"), "vendorExtensions")) ^^
      { case p1 ~ p2 ~ p3 =>
      IPXACT2022ScalaCases.InterconnectionConfiguration(IPXACT2022scalaxb.fromXML[String](p1, IPXACT2022scalaxb.ElemName(node) :: stack),
        p2 map { IPXACT2022scalaxb.fromXML[IPXACT2022ScalaCases.AbstractorInstances](_, IPXACT2022scalaxb.ElemName(node) :: stack) },
        p3.headOption map { IPXACT2022scalaxb.fromXML[IPXACT2022ScalaCases.VendorExtensions](_, IPXACT2022scalaxb.ElemName(node) :: stack) },
        scala.collection.immutable.ListMap(List(
        (node \ "@{http://www.w3.org/XML/1998/namespace}id").headOption map { x => IPXACT2022scalaxb.DataRecord(x, node, IPXACT2022scalaxb.fromXML[String](x, IPXACT2022scalaxb.ElemName(node) :: stack)) } map { "@{http://www.w3.org/XML/1998/namespace}id" -> _ }
        ).flatten[(String, IPXACT2022scalaxb.DataRecord[Any])]: _*)) })
    
    override def writesAttribute(__obj: IPXACT2022ScalaCases.InterconnectionConfiguration, __scope: scala.xml.NamespaceBinding): scala.xml.MetaData = {
      var attr: scala.xml.MetaData  = scala.xml.Null
      __obj.attributes.toList map {
        case ("@{http://www.w3.org/XML/1998/namespace}id", _) => __obj.xmlid foreach { x => attr = scala.xml.Attribute(__scope.getPrefix("http://www.w3.org/XML/1998/namespace"), "id", x.toString, attr) }
        case (key, x) => attr = scala.xml.Attribute((x.namespace map { __scope.getPrefix(_) }).orNull, x.key.orNull, x.value.toString, attr)
      }
      attr
    }

    def writesChildNodes(__obj: IPXACT2022ScalaCases.InterconnectionConfiguration, __scope: scala.xml.NamespaceBinding): Seq[scala.xml.Node] =
      Seq.concat(IPXACT2022scalaxb.toXML[String](__obj.interconnectionRef, Some("http://www.accellera.org/XMLSchema/IPXACT/1685-2022"), Some("interconnectionRef"), __scope, false),
        __obj.abstractorInstances flatMap { IPXACT2022scalaxb.toXML[IPXACT2022ScalaCases.AbstractorInstances](_, Some("http://www.accellera.org/XMLSchema/IPXACT/1685-2022"), Some("abstractorInstances"), __scope, false) },
        __obj.vendorExtensions map { IPXACT2022scalaxb.toXML[IPXACT2022ScalaCases.VendorExtensions](_, Some("http://www.accellera.org/XMLSchema/IPXACT/1685-2022"), Some("vendorExtensions"), __scope, false) } getOrElse {Nil})

  }

  trait DefaultIPXACT2022ScalaCases_View3Format extends IPXACT2022scalaxb.ElemNameParser[IPXACT2022ScalaCases.View3] {
    val targetNamespace: Option[String] = Some("http://www.accellera.org/XMLSchema/IPXACT/1685-2022")
    
    def parser(node: scala.xml.Node, stack: List[IPXACT2022scalaxb.ElemName]): Parser[IPXACT2022ScalaCases.View3] =
      phrase(opt(IPXACT2022scalaxb.ElemName(Some("http://www.accellera.org/XMLSchema/IPXACT/1685-2022"), "configurableElementValues")) ^^
      { case p1 =>
      IPXACT2022ScalaCases.View3(p1.headOption map { IPXACT2022scalaxb.fromXML[IPXACT2022ScalaCases.ConfigurableElementValues](_, IPXACT2022scalaxb.ElemName(node) :: stack) },
        scala.collection.immutable.ListMap(List(
        (node \ "@viewRef").headOption map { x => IPXACT2022scalaxb.DataRecord(x, node, IPXACT2022scalaxb.fromXML[String](x, IPXACT2022scalaxb.ElemName(node) :: stack)) } map { "@viewRef" -> _ }
        ).flatten[(String, IPXACT2022scalaxb.DataRecord[Any])]: _*)) })
    
    override def writesAttribute(__obj: IPXACT2022ScalaCases.View3, __scope: scala.xml.NamespaceBinding): scala.xml.MetaData = {
      var attr: scala.xml.MetaData  = scala.xml.Null
      __obj.attributes.toList map {
        case ("@viewRef", _) => attr = scala.xml.Attribute(null, "viewRef", __obj.viewRef.toString, attr)
        case (key, x) => attr = scala.xml.Attribute((x.namespace map { __scope.getPrefix(_) }).orNull, x.key.orNull, x.value.toString, attr)
      }
      attr
    }

    def writesChildNodes(__obj: IPXACT2022ScalaCases.View3, __scope: scala.xml.NamespaceBinding): Seq[scala.xml.Node] =
      (__obj.configurableElementValues map { IPXACT2022scalaxb.toXML[IPXACT2022ScalaCases.ConfigurableElementValues](_, Some("http://www.accellera.org/XMLSchema/IPXACT/1685-2022"), Some("configurableElementValues"), __scope, false) } getOrElse {Nil})
  }

  trait DefaultIPXACT2022ScalaCases_ViewConfigurationFormat extends IPXACT2022scalaxb.ElemNameParser[IPXACT2022ScalaCases.ViewConfiguration] {
    val targetNamespace: Option[String] = Some("http://www.accellera.org/XMLSchema/IPXACT/1685-2022")
    
    def parser(node: scala.xml.Node, stack: List[IPXACT2022scalaxb.ElemName]): Parser[IPXACT2022ScalaCases.ViewConfiguration] =
      phrase((IPXACT2022scalaxb.ElemName(Some("http://www.accellera.org/XMLSchema/IPXACT/1685-2022"), "instanceName")) ~
      (IPXACT2022scalaxb.ElemName(Some("http://www.accellera.org/XMLSchema/IPXACT/1685-2022"), "view")) ~
      opt(IPXACT2022scalaxb.ElemName(Some("http://www.accellera.org/XMLSchema/IPXACT/1685-2022"), "vendorExtensions")) ^^
      { case p1 ~ p2 ~ p3 =>
      IPXACT2022ScalaCases.ViewConfiguration(IPXACT2022scalaxb.fromXML[String](p1, IPXACT2022scalaxb.ElemName(node) :: stack),
        IPXACT2022scalaxb.fromXML[IPXACT2022ScalaCases.View3](p2, IPXACT2022scalaxb.ElemName(node) :: stack),
        p3.headOption map { IPXACT2022scalaxb.fromXML[IPXACT2022ScalaCases.VendorExtensions](_, IPXACT2022scalaxb.ElemName(node) :: stack) },
        scala.collection.immutable.ListMap(List(
        (node \ "@{http://www.w3.org/XML/1998/namespace}id").headOption map { x => IPXACT2022scalaxb.DataRecord(x, node, IPXACT2022scalaxb.fromXML[String](x, IPXACT2022scalaxb.ElemName(node) :: stack)) } map { "@{http://www.w3.org/XML/1998/namespace}id" -> _ }
        ).flatten[(String, IPXACT2022scalaxb.DataRecord[Any])]: _*)) })
    
    override def writesAttribute(__obj: IPXACT2022ScalaCases.ViewConfiguration, __scope: scala.xml.NamespaceBinding): scala.xml.MetaData = {
      var attr: scala.xml.MetaData  = scala.xml.Null
      __obj.attributes.toList map {
        case ("@{http://www.w3.org/XML/1998/namespace}id", _) => __obj.xmlid foreach { x => attr = scala.xml.Attribute(__scope.getPrefix("http://www.w3.org/XML/1998/namespace"), "id", x.toString, attr) }
        case (key, x) => attr = scala.xml.Attribute((x.namespace map { __scope.getPrefix(_) }).orNull, x.key.orNull, x.value.toString, attr)
      }
      attr
    }

    def writesChildNodes(__obj: IPXACT2022ScalaCases.ViewConfiguration, __scope: scala.xml.NamespaceBinding): Seq[scala.xml.Node] =
      Seq.concat(IPXACT2022scalaxb.toXML[String](__obj.instanceName, Some("http://www.accellera.org/XMLSchema/IPXACT/1685-2022"), Some("instanceName"), __scope, false),
        IPXACT2022scalaxb.toXML[IPXACT2022ScalaCases.View3](__obj.view, Some("http://www.accellera.org/XMLSchema/IPXACT/1685-2022"), Some("view"), __scope, false),
        __obj.vendorExtensions map { IPXACT2022scalaxb.toXML[IPXACT2022ScalaCases.VendorExtensions](_, Some("http://www.accellera.org/XMLSchema/IPXACT/1685-2022"), Some("vendorExtensions"), __scope, false) } getOrElse {Nil})

  }

  trait DefaultIPXACT2022ScalaCases_DesignConfigurationFormat extends IPXACT2022scalaxb.ElemNameParser[IPXACT2022ScalaCases.DesignConfiguration] with IPXACT2022ScalaCases_DocumentNameGroupGroupFormat {
    val targetNamespace: Option[String] = Some("http://www.accellera.org/XMLSchema/IPXACT/1685-2022")
    
    def parser(node: scala.xml.Node, stack: List[IPXACT2022scalaxb.ElemName]): Parser[IPXACT2022ScalaCases.DesignConfiguration] =
      phrase((parseDocumentNameGroupGroup(node, IPXACT2022scalaxb.ElemName(node) :: stack)) ~
      opt(IPXACT2022scalaxb.ElemName(Some("http://www.accellera.org/XMLSchema/IPXACT/1685-2022"), "designRef")) ~
      safeRep(IPXACT2022scalaxb.ElemName(Some("http://www.accellera.org/XMLSchema/IPXACT/1685-2022"), "generatorChainConfiguration")) ~
      safeRep(IPXACT2022scalaxb.ElemName(Some("http://www.accellera.org/XMLSchema/IPXACT/1685-2022"), "interconnectionConfiguration")) ~
      safeRep(IPXACT2022scalaxb.ElemName(Some("http://www.accellera.org/XMLSchema/IPXACT/1685-2022"), "viewConfiguration")) ~
      opt(IPXACT2022scalaxb.ElemName(Some("http://www.accellera.org/XMLSchema/IPXACT/1685-2022"), "choices")) ~
      opt(IPXACT2022scalaxb.ElemName(Some("http://www.accellera.org/XMLSchema/IPXACT/1685-2022"), "parameters")) ~
      opt(IPXACT2022scalaxb.ElemName(Some("http://www.accellera.org/XMLSchema/IPXACT/1685-2022"), "assertions")) ~
      opt(IPXACT2022scalaxb.ElemName(Some("http://www.accellera.org/XMLSchema/IPXACT/1685-2022"), "vendorExtensions")) ^^
      { case p1 ~ p2 ~ p3 ~ p4 ~ p5 ~ p6 ~ p7 ~ p8 ~ p9 =>
      IPXACT2022ScalaCases.DesignConfiguration(p1,
        p2.headOption map { IPXACT2022scalaxb.fromXML[IPXACT2022ScalaCases.LibraryRefType](_, IPXACT2022scalaxb.ElemName(node) :: stack) },
        p3 map { IPXACT2022scalaxb.fromXML[IPXACT2022ScalaCases.ConfigurableLibraryRefType](_, IPXACT2022scalaxb.ElemName(node) :: stack) },
        p4 map { IPXACT2022scalaxb.fromXML[IPXACT2022ScalaCases.InterconnectionConfiguration](_, IPXACT2022scalaxb.ElemName(node) :: stack) },
        p5 map { IPXACT2022scalaxb.fromXML[IPXACT2022ScalaCases.ViewConfiguration](_, IPXACT2022scalaxb.ElemName(node) :: stack) },
        p6.headOption map { IPXACT2022scalaxb.fromXML[IPXACT2022ScalaCases.Choices](_, IPXACT2022scalaxb.ElemName(node) :: stack) },
        p7.headOption map { IPXACT2022scalaxb.fromXML[IPXACT2022ScalaCases.Parameters](_, IPXACT2022scalaxb.ElemName(node) :: stack) },
        p8.headOption map { IPXACT2022scalaxb.fromXML[IPXACT2022ScalaCases.Assertions](_, IPXACT2022scalaxb.ElemName(node) :: stack) },
        p9.headOption map { IPXACT2022scalaxb.fromXML[IPXACT2022ScalaCases.VendorExtensions](_, IPXACT2022scalaxb.ElemName(node) :: stack) },
        scala.collection.immutable.ListMap(List(
        (node \ "@{http://www.w3.org/XML/1998/namespace}id").headOption map { x => IPXACT2022scalaxb.DataRecord(x, node, IPXACT2022scalaxb.fromXML[String](x, IPXACT2022scalaxb.ElemName(node) :: stack)) } map { "@{http://www.w3.org/XML/1998/namespace}id" -> _ }
        ).flatten[(String, IPXACT2022scalaxb.DataRecord[Any])]: _*)) })
    
    override def writesAttribute(__obj: IPXACT2022ScalaCases.DesignConfiguration, __scope: scala.xml.NamespaceBinding): scala.xml.MetaData = {
      var attr: scala.xml.MetaData  = scala.xml.Null
      __obj.attributes.toList map {
        case ("@{http://www.w3.org/XML/1998/namespace}id", _) => __obj.xmlid foreach { x => attr = scala.xml.Attribute(__scope.getPrefix("http://www.w3.org/XML/1998/namespace"), "id", x.toString, attr) }
        case (key, x) => attr = scala.xml.Attribute((x.namespace map { __scope.getPrefix(_) }).orNull, x.key.orNull, x.value.toString, attr)
      }
      attr
    }

    def writesChildNodes(__obj: IPXACT2022ScalaCases.DesignConfiguration, __scope: scala.xml.NamespaceBinding): Seq[scala.xml.Node] =
      Seq.concat(IPXACT2022scalaxb.toXML[IPXACT2022ScalaCases.DocumentNameGroupSequence](__obj.documentNameGroupSequence1, None, Some("documentNameGroupSequence1"), __scope, false),
        __obj.designRef map { IPXACT2022scalaxb.toXML[IPXACT2022ScalaCases.LibraryRefType](_, Some("http://www.accellera.org/XMLSchema/IPXACT/1685-2022"), Some("designRef"), __scope, false) } getOrElse {Nil},
        __obj.generatorChainConfiguration flatMap { IPXACT2022scalaxb.toXML[IPXACT2022ScalaCases.ConfigurableLibraryRefType](_, Some("http://www.accellera.org/XMLSchema/IPXACT/1685-2022"), Some("generatorChainConfiguration"), __scope, false) },
        __obj.interconnectionConfiguration flatMap { IPXACT2022scalaxb.toXML[IPXACT2022ScalaCases.InterconnectionConfiguration](_, Some("http://www.accellera.org/XMLSchema/IPXACT/1685-2022"), Some("interconnectionConfiguration"), __scope, false) },
        __obj.viewConfiguration flatMap { IPXACT2022scalaxb.toXML[IPXACT2022ScalaCases.ViewConfiguration](_, Some("http://www.accellera.org/XMLSchema/IPXACT/1685-2022"), Some("viewConfiguration"), __scope, false) },
        __obj.choices map { IPXACT2022scalaxb.toXML[IPXACT2022ScalaCases.Choices](_, Some("http://www.accellera.org/XMLSchema/IPXACT/1685-2022"), Some("choices"), __scope, false) } getOrElse {Nil},
        __obj.parameters map { IPXACT2022scalaxb.toXML[IPXACT2022ScalaCases.Parameters](_, Some("http://www.accellera.org/XMLSchema/IPXACT/1685-2022"), Some("parameters"), __scope, false) } getOrElse {Nil},
        __obj.assertions map { IPXACT2022scalaxb.toXML[IPXACT2022ScalaCases.Assertions](_, Some("http://www.accellera.org/XMLSchema/IPXACT/1685-2022"), Some("assertions"), __scope, false) } getOrElse {Nil},
        __obj.vendorExtensions map { IPXACT2022scalaxb.toXML[IPXACT2022ScalaCases.VendorExtensions](_, Some("http://www.accellera.org/XMLSchema/IPXACT/1685-2022"), Some("vendorExtensions"), __scope, false) } getOrElse {Nil})

  }

  trait DefaultIPXACT2022ScalaCases_IsIncludeFileFormat extends IPXACT2022scalaxb.XMLFormat[IPXACT2022ScalaCases.IsIncludeFile] with IPXACT2022scalaxb.CanWriteChildNodes[IPXACT2022ScalaCases.IsIncludeFile] {
    val targetNamespace: Option[String] = Some("http://www.accellera.org/XMLSchema/IPXACT/1685-2022")
    def reads(seq: scala.xml.NodeSeq, stack: List[IPXACT2022scalaxb.ElemName]): Either[String, IPXACT2022ScalaCases.IsIncludeFile] = seq match {
      case node: scala.xml.Node => Right(IPXACT2022ScalaCases.IsIncludeFile(IPXACT2022scalaxb.fromXML[Boolean](node, IPXACT2022scalaxb.ElemName(node) :: stack),
        scala.collection.immutable.ListMap(List(
        (node \ "@externalDeclarations").headOption map { x => IPXACT2022scalaxb.DataRecord(x, node, IPXACT2022scalaxb.fromXML[Boolean](x, IPXACT2022scalaxb.ElemName(node) :: stack)) } orElse Some(IPXACT2022scalaxb.DataRecord(None, None, IPXACT2022scalaxb.fromXML[Boolean](scala.xml.Text("false"), IPXACT2022scalaxb.ElemName(node) :: stack))) map { "@externalDeclarations" -> _ }
        ).flatten[(String, IPXACT2022scalaxb.DataRecord[Any])]: _*)))
      case _ => Left("reads failed: seq must be scala.xml.Node")
    }
    
    override def writesAttribute(__obj: IPXACT2022ScalaCases.IsIncludeFile, __scope: scala.xml.NamespaceBinding): scala.xml.MetaData = {
      var attr: scala.xml.MetaData  = scala.xml.Null
      __obj.attributes.toList map {
        case ("@externalDeclarations", _) => if (__obj.externalDeclarations.toString != "false") attr = scala.xml.Attribute(null, "externalDeclarations", __obj.externalDeclarations.toString, attr)
        case (key, x) => attr = scala.xml.Attribute((x.namespace map { __scope.getPrefix(_) }).orNull, x.key.orNull, x.value.toString, attr)
      }
      attr
    }

    def writesChildNodes(__obj: IPXACT2022ScalaCases.IsIncludeFile, __scope: scala.xml.NamespaceBinding): Seq[scala.xml.Node] =
      Seq(scala.xml.Text(__obj.value.toString))

  }

  trait DefaultIPXACT2022ScalaCases_LogicalNameFormat extends IPXACT2022scalaxb.XMLFormat[IPXACT2022ScalaCases.LogicalName] with IPXACT2022scalaxb.CanWriteChildNodes[IPXACT2022ScalaCases.LogicalName] {
    val targetNamespace: Option[String] = Some("http://www.accellera.org/XMLSchema/IPXACT/1685-2022")
    def reads(seq: scala.xml.NodeSeq, stack: List[IPXACT2022scalaxb.ElemName]): Either[String, IPXACT2022ScalaCases.LogicalName] = seq match {
      case node: scala.xml.Node => Right(IPXACT2022ScalaCases.LogicalName(IPXACT2022scalaxb.fromXML[String](node, IPXACT2022scalaxb.ElemName(node) :: stack),
        scala.collection.immutable.ListMap(List(
        (node \ "@default").headOption map { x => IPXACT2022scalaxb.DataRecord(x, node, IPXACT2022scalaxb.fromXML[Boolean](x, IPXACT2022scalaxb.ElemName(node) :: stack)) } orElse Some(IPXACT2022scalaxb.DataRecord(None, None, IPXACT2022scalaxb.fromXML[Boolean](scala.xml.Text("false"), IPXACT2022scalaxb.ElemName(node) :: stack))) map { "@default" -> _ }
        ).flatten[(String, IPXACT2022scalaxb.DataRecord[Any])]: _*)))
      case _ => Left("reads failed: seq must be scala.xml.Node")
    }
    
    override def writesAttribute(__obj: IPXACT2022ScalaCases.LogicalName, __scope: scala.xml.NamespaceBinding): scala.xml.MetaData = {
      var attr: scala.xml.MetaData  = scala.xml.Null
      __obj.attributes.toList map {
        case ("@default", _) => if (__obj.default.toString != "false") attr = scala.xml.Attribute(null, "default", __obj.default.toString, attr)
        case (key, x) => attr = scala.xml.Attribute((x.namespace map { __scope.getPrefix(_) }).orNull, x.key.orNull, x.value.toString, attr)
      }
      attr
    }

    def writesChildNodes(__obj: IPXACT2022ScalaCases.LogicalName, __scope: scala.xml.NamespaceBinding): Seq[scala.xml.Node] =
      Seq(scala.xml.Text(__obj.value.toString))

  }

  trait DefaultIPXACT2022ScalaCases_ExportedNameFormat extends IPXACT2022scalaxb.XMLFormat[IPXACT2022ScalaCases.ExportedName] with IPXACT2022scalaxb.CanWriteChildNodes[IPXACT2022ScalaCases.ExportedName] {
    val targetNamespace: Option[String] = Some("http://www.accellera.org/XMLSchema/IPXACT/1685-2022")
    def reads(seq: scala.xml.NodeSeq, stack: List[IPXACT2022scalaxb.ElemName]): Either[String, IPXACT2022ScalaCases.ExportedName] = seq match {
      case node: scala.xml.Node => Right(IPXACT2022ScalaCases.ExportedName(IPXACT2022scalaxb.fromXML[String](node, IPXACT2022scalaxb.ElemName(node) :: stack),
        scala.collection.immutable.ListMap(List(
        (node \ "@{http://www.w3.org/XML/1998/namespace}id").headOption map { x => IPXACT2022scalaxb.DataRecord(x, node, IPXACT2022scalaxb.fromXML[String](x, IPXACT2022scalaxb.ElemName(node) :: stack)) } map { "@{http://www.w3.org/XML/1998/namespace}id" -> _ }
        ).flatten[(String, IPXACT2022scalaxb.DataRecord[Any])]: _*)))
      case _ => Left("reads failed: seq must be scala.xml.Node")
    }
    
    override def writesAttribute(__obj: IPXACT2022ScalaCases.ExportedName, __scope: scala.xml.NamespaceBinding): scala.xml.MetaData = {
      var attr: scala.xml.MetaData  = scala.xml.Null
      __obj.attributes.toList map {
        case ("@{http://www.w3.org/XML/1998/namespace}id", _) => __obj.xmlid foreach { x => attr = scala.xml.Attribute(__scope.getPrefix("http://www.w3.org/XML/1998/namespace"), "id", x.toString, attr) }
        case (key, x) => attr = scala.xml.Attribute((x.namespace map { __scope.getPrefix(_) }).orNull, x.key.orNull, x.value.toString, attr)
      }
      attr
    }

    def writesChildNodes(__obj: IPXACT2022ScalaCases.ExportedName, __scope: scala.xml.NamespaceBinding): Seq[scala.xml.Node] =
      Seq(scala.xml.Text(__obj.value.toString))

  }

  trait DefaultIPXACT2022ScalaCases_FlagsFormat extends IPXACT2022scalaxb.XMLFormat[IPXACT2022ScalaCases.Flags] with IPXACT2022scalaxb.CanWriteChildNodes[IPXACT2022ScalaCases.Flags] {
    val targetNamespace: Option[String] = Some("http://www.accellera.org/XMLSchema/IPXACT/1685-2022")
    def reads(seq: scala.xml.NodeSeq, stack: List[IPXACT2022scalaxb.ElemName]): Either[String, IPXACT2022ScalaCases.Flags] = seq match {
      case node: scala.xml.Node => Right(IPXACT2022ScalaCases.Flags(IPXACT2022scalaxb.fromXML[String](node, IPXACT2022scalaxb.ElemName(node) :: stack),
        scala.collection.immutable.ListMap(List(
        (node \ "@append").headOption map { x => IPXACT2022scalaxb.DataRecord(x, node, IPXACT2022scalaxb.fromXML[Boolean](x, IPXACT2022scalaxb.ElemName(node) :: stack)) } map { "@append" -> _ }
        ).flatten[(String, IPXACT2022scalaxb.DataRecord[Any])] ::: (node match {
          case elem: scala.xml.Elem =>
            elem.attributes.toList flatMap {
              case scala.xml.UnprefixedAttribute(key, value, _) if key == "append" => Nil
              case scala.xml.UnprefixedAttribute(key, value, _) =>
                List(("@" + key, IPXACT2022scalaxb.DataRecord(None, Some(key), value.text)))
              case scala.xml.PrefixedAttribute(pre, key, value, _) =>
                val ns = elem.scope.getURI(pre)
                List(("@{" + ns + "}" + key, IPXACT2022scalaxb.DataRecord(Option[String](ns), Some(key), value.text)))
              case _ => Nil
            }
          case _ => Nil
        }): _*)))
      case _ => Left("reads failed: seq must be scala.xml.Node")
    }
    
    override def writesAttribute(__obj: IPXACT2022ScalaCases.Flags, __scope: scala.xml.NamespaceBinding): scala.xml.MetaData = {
      var attr: scala.xml.MetaData  = scala.xml.Null
      __obj.attributes.toList map {
        case ("@append", _) => __obj.append foreach { x => attr = scala.xml.Attribute(null, "append", x.toString, attr) }
        case (key, x) => attr = scala.xml.Attribute((x.namespace map { __scope.getPrefix(_) }).orNull, x.key.orNull, x.value.toString, attr)
      }
      attr
    }

    def writesChildNodes(__obj: IPXACT2022ScalaCases.Flags, __scope: scala.xml.NamespaceBinding): Seq[scala.xml.Node] =
      Seq(scala.xml.Text(__obj.value.toString))

  }

  trait DefaultIPXACT2022ScalaCases_BuildCommandFormat extends IPXACT2022scalaxb.ElemNameParser[IPXACT2022ScalaCases.BuildCommand] {
    val targetNamespace: Option[String] = Some("http://www.accellera.org/XMLSchema/IPXACT/1685-2022")
    
    def parser(node: scala.xml.Node, stack: List[IPXACT2022scalaxb.ElemName]): Parser[IPXACT2022ScalaCases.BuildCommand] =
      phrase(opt(IPXACT2022scalaxb.ElemName(Some("http://www.accellera.org/XMLSchema/IPXACT/1685-2022"), "command")) ~
      opt(IPXACT2022scalaxb.ElemName(Some("http://www.accellera.org/XMLSchema/IPXACT/1685-2022"), "flags")) ~
      opt(IPXACT2022scalaxb.ElemName(Some("http://www.accellera.org/XMLSchema/IPXACT/1685-2022"), "replaceDefaultFlags")) ~
      opt(IPXACT2022scalaxb.ElemName(Some("http://www.accellera.org/XMLSchema/IPXACT/1685-2022"), "targetName")) ^^
      { case p1 ~ p2 ~ p3 ~ p4 =>
      IPXACT2022ScalaCases.BuildCommand(p1.headOption map { IPXACT2022scalaxb.fromXML[IPXACT2022ScalaCases.StringExpressionable](_, IPXACT2022scalaxb.ElemName(node) :: stack) },
        p2.headOption map { IPXACT2022scalaxb.fromXML[IPXACT2022ScalaCases.Flags](_, IPXACT2022scalaxb.ElemName(node) :: stack) },
        p3.headOption map { IPXACT2022scalaxb.fromXML[IPXACT2022ScalaCases.UnsignedBitExpression](_, IPXACT2022scalaxb.ElemName(node) :: stack) },
        p4.headOption map { IPXACT2022scalaxb.fromXML[IPXACT2022ScalaCases.IpxactURIable](_, IPXACT2022scalaxb.ElemName(node) :: stack) }) })
    
    def writesChildNodes(__obj: IPXACT2022ScalaCases.BuildCommand, __scope: scala.xml.NamespaceBinding): Seq[scala.xml.Node] =
      Seq.concat(__obj.command map { IPXACT2022scalaxb.toXML[IPXACT2022ScalaCases.StringExpressionable](_, Some("http://www.accellera.org/XMLSchema/IPXACT/1685-2022"), Some("command"), __scope, false) } getOrElse {Nil},
        __obj.flags map { IPXACT2022scalaxb.toXML[IPXACT2022ScalaCases.Flags](_, Some("http://www.accellera.org/XMLSchema/IPXACT/1685-2022"), Some("flags"), __scope, false) } getOrElse {Nil},
        __obj.replaceDefaultFlags map { IPXACT2022scalaxb.toXML[IPXACT2022ScalaCases.UnsignedBitExpression](_, Some("http://www.accellera.org/XMLSchema/IPXACT/1685-2022"), Some("replaceDefaultFlags"), __scope, false) } getOrElse {Nil},
        __obj.targetName map { IPXACT2022scalaxb.toXML[IPXACT2022ScalaCases.IpxactURIable](_, Some("http://www.accellera.org/XMLSchema/IPXACT/1685-2022"), Some("targetName"), __scope, false) } getOrElse {Nil})

  }

  trait DefaultIPXACT2022ScalaCases_ImageTypeFormat extends IPXACT2022scalaxb.XMLFormat[IPXACT2022ScalaCases.ImageType] with IPXACT2022scalaxb.CanWriteChildNodes[IPXACT2022ScalaCases.ImageType] {
    val targetNamespace: Option[String] = Some("http://www.accellera.org/XMLSchema/IPXACT/1685-2022")
    def reads(seq: scala.xml.NodeSeq, stack: List[IPXACT2022scalaxb.ElemName]): Either[String, IPXACT2022ScalaCases.ImageType] = seq match {
      case node: scala.xml.Node => Right(IPXACT2022ScalaCases.ImageType(IPXACT2022scalaxb.fromXML[String](node, IPXACT2022scalaxb.ElemName(node) :: stack),
        scala.collection.immutable.ListMap(List(
        (node \ "@{http://www.w3.org/XML/1998/namespace}id").headOption map { x => IPXACT2022scalaxb.DataRecord(x, node, IPXACT2022scalaxb.fromXML[String](x, IPXACT2022scalaxb.ElemName(node) :: stack)) } map { "@{http://www.w3.org/XML/1998/namespace}id" -> _ }
        ).flatten[(String, IPXACT2022scalaxb.DataRecord[Any])]: _*)))
      case _ => Left("reads failed: seq must be scala.xml.Node")
    }
    
    override def writesAttribute(__obj: IPXACT2022ScalaCases.ImageType, __scope: scala.xml.NamespaceBinding): scala.xml.MetaData = {
      var attr: scala.xml.MetaData  = scala.xml.Null
      __obj.attributes.toList map {
        case ("@{http://www.w3.org/XML/1998/namespace}id", _) => __obj.xmlid foreach { x => attr = scala.xml.Attribute(__scope.getPrefix("http://www.w3.org/XML/1998/namespace"), "id", x.toString, attr) }
        case (key, x) => attr = scala.xml.Attribute((x.namespace map { __scope.getPrefix(_) }).orNull, x.key.orNull, x.value.toString, attr)
      }
      attr
    }

    def writesChildNodes(__obj: IPXACT2022ScalaCases.ImageType, __scope: scala.xml.NamespaceBinding): Seq[scala.xml.Node] =
      Seq(scala.xml.Text(__obj.value.toString))

  }

  trait DefaultIPXACT2022ScalaCases_FileFormat extends IPXACT2022scalaxb.ElemNameParser[IPXACT2022ScalaCases.File] {
    val targetNamespace: Option[String] = Some("http://www.accellera.org/XMLSchema/IPXACT/1685-2022")
    
    def parser(node: scala.xml.Node, stack: List[IPXACT2022scalaxb.ElemName]): Parser[IPXACT2022ScalaCases.File] =
      phrase((IPXACT2022scalaxb.ElemName(Some("http://www.accellera.org/XMLSchema/IPXACT/1685-2022"), "name")) ~
      safeRep(IPXACT2022scalaxb.ElemName(Some("http://www.accellera.org/XMLSchema/IPXACT/1685-2022"), "fileType")) ~
      opt(IPXACT2022scalaxb.ElemName(Some("http://www.accellera.org/XMLSchema/IPXACT/1685-2022"), "isStructural")) ~
      opt(IPXACT2022scalaxb.ElemName(Some("http://www.accellera.org/XMLSchema/IPXACT/1685-2022"), "isIncludeFile")) ~
      opt(IPXACT2022scalaxb.ElemName(Some("http://www.accellera.org/XMLSchema/IPXACT/1685-2022"), "logicalName")) ~
      safeRep(IPXACT2022scalaxb.ElemName(Some("http://www.accellera.org/XMLSchema/IPXACT/1685-2022"), "exportedName")) ~
      opt(IPXACT2022scalaxb.ElemName(Some("http://www.accellera.org/XMLSchema/IPXACT/1685-2022"), "buildCommand")) ~
      safeRep(IPXACT2022scalaxb.ElemName(Some("http://www.accellera.org/XMLSchema/IPXACT/1685-2022"), "dependency")) ~
      safeRep(IPXACT2022scalaxb.ElemName(Some("http://www.accellera.org/XMLSchema/IPXACT/1685-2022"), "define")) ~
      safeRep(IPXACT2022scalaxb.ElemName(Some("http://www.accellera.org/XMLSchema/IPXACT/1685-2022"), "imageType")) ~
      opt(IPXACT2022scalaxb.ElemName(Some("http://www.accellera.org/XMLSchema/IPXACT/1685-2022"), "description")) ~
      opt(IPXACT2022scalaxb.ElemName(Some("http://www.accellera.org/XMLSchema/IPXACT/1685-2022"), "vendorExtensions")) ^^
      { case p1 ~ p2 ~ p3 ~ p4 ~ p5 ~ p6 ~ p7 ~ p8 ~ p9 ~ p10 ~ p11 ~ p12 =>
      IPXACT2022ScalaCases.File(IPXACT2022scalaxb.fromXML[IPXACT2022ScalaCases.IpxactURIable](p1, IPXACT2022scalaxb.ElemName(node) :: stack),
        p2 map { IPXACT2022scalaxb.fromXML[IPXACT2022ScalaCases.FileType](_, IPXACT2022scalaxb.ElemName(node) :: stack) },
        p3.headOption map { IPXACT2022scalaxb.fromXML[Boolean](_, IPXACT2022scalaxb.ElemName(node) :: stack) },
        p4.headOption map { IPXACT2022scalaxb.fromXML[IPXACT2022ScalaCases.IsIncludeFile](_, IPXACT2022scalaxb.ElemName(node) :: stack) },
        p5.headOption map { IPXACT2022scalaxb.fromXML[IPXACT2022ScalaCases.LogicalName](_, IPXACT2022scalaxb.ElemName(node) :: stack) },
        p6 map { IPXACT2022scalaxb.fromXML[IPXACT2022ScalaCases.ExportedName](_, IPXACT2022scalaxb.ElemName(node) :: stack) },
        p7.headOption map { IPXACT2022scalaxb.fromXML[IPXACT2022ScalaCases.BuildCommand](_, IPXACT2022scalaxb.ElemName(node) :: stack) },
        p8 map { IPXACT2022scalaxb.fromXML[IPXACT2022ScalaCases.Dependency](_, IPXACT2022scalaxb.ElemName(node) :: stack) },
        p9 map { IPXACT2022scalaxb.fromXML[IPXACT2022ScalaCases.NameValuePairTypable](_, IPXACT2022scalaxb.ElemName(node) :: stack) },
        p10 map { IPXACT2022scalaxb.fromXML[IPXACT2022ScalaCases.ImageType](_, IPXACT2022scalaxb.ElemName(node) :: stack) },
        p11.headOption map { IPXACT2022scalaxb.fromXML[String](_, IPXACT2022scalaxb.ElemName(node) :: stack) },
        p12.headOption map { IPXACT2022scalaxb.fromXML[IPXACT2022ScalaCases.VendorExtensions](_, IPXACT2022scalaxb.ElemName(node) :: stack) },
        scala.collection.immutable.ListMap(List(
        (node \ "@fileId").headOption map { x => IPXACT2022scalaxb.DataRecord(x, node, IPXACT2022scalaxb.fromXML[String](x, IPXACT2022scalaxb.ElemName(node) :: stack)) } map { "@fileId" -> _ },
        (node \ "@{http://www.w3.org/XML/1998/namespace}id").headOption map { x => IPXACT2022scalaxb.DataRecord(x, node, IPXACT2022scalaxb.fromXML[String](x, IPXACT2022scalaxb.ElemName(node) :: stack)) } map { "@{http://www.w3.org/XML/1998/namespace}id" -> _ }
        ).flatten[(String, IPXACT2022scalaxb.DataRecord[Any])] ::: (node match {
          case elem: scala.xml.Elem =>
            elem.attributes.toList flatMap {
              case scala.xml.UnprefixedAttribute(key, value, _) if key == "fileId" => Nil
              case scala.xml.PrefixedAttribute(pre, key, value, _) if pre == elem.scope.getPrefix("http://www.w3.org/XML/1998/namespace") &&
                key == "id" => Nil
              case scala.xml.UnprefixedAttribute(key, value, _) =>
                List(("@" + key, IPXACT2022scalaxb.DataRecord(None, Some(key), value.text)))
              case scala.xml.PrefixedAttribute(pre, key, value, _) =>
                val ns = elem.scope.getURI(pre)
                List(("@{" + ns + "}" + key, IPXACT2022scalaxb.DataRecord(Option[String](ns), Some(key), value.text)))
              case _ => Nil
            }
          case _ => Nil
        }): _*)) })
    
    override def writesAttribute(__obj: IPXACT2022ScalaCases.File, __scope: scala.xml.NamespaceBinding): scala.xml.MetaData = {
      var attr: scala.xml.MetaData  = scala.xml.Null
      __obj.attributes.toList map {
        case ("@fileId", _) => __obj.fileId foreach { x => attr = scala.xml.Attribute(null, "fileId", x.toString, attr) }
        case ("@{http://www.w3.org/XML/1998/namespace}id", _) => __obj.xmlid foreach { x => attr = scala.xml.Attribute(__scope.getPrefix("http://www.w3.org/XML/1998/namespace"), "id", x.toString, attr) }
        case (key, x) => attr = scala.xml.Attribute((x.namespace map { __scope.getPrefix(_) }).orNull, x.key.orNull, x.value.toString, attr)
      }
      attr
    }

    def writesChildNodes(__obj: IPXACT2022ScalaCases.File, __scope: scala.xml.NamespaceBinding): Seq[scala.xml.Node] =
      Seq.concat(IPXACT2022scalaxb.toXML[IPXACT2022ScalaCases.IpxactURIable](__obj.name, Some("http://www.accellera.org/XMLSchema/IPXACT/1685-2022"), Some("name"), __scope, false),
        __obj.fileType flatMap { IPXACT2022scalaxb.toXML[IPXACT2022ScalaCases.FileType](_, Some("http://www.accellera.org/XMLSchema/IPXACT/1685-2022"), Some("fileType"), __scope, false) },
        __obj.isStructural map { IPXACT2022scalaxb.toXML[Boolean](_, Some("http://www.accellera.org/XMLSchema/IPXACT/1685-2022"), Some("isStructural"), __scope, false) } getOrElse {Nil},
        __obj.isIncludeFile map { IPXACT2022scalaxb.toXML[IPXACT2022ScalaCases.IsIncludeFile](_, Some("http://www.accellera.org/XMLSchema/IPXACT/1685-2022"), Some("isIncludeFile"), __scope, false) } getOrElse {Nil},
        __obj.logicalName map { IPXACT2022scalaxb.toXML[IPXACT2022ScalaCases.LogicalName](_, Some("http://www.accellera.org/XMLSchema/IPXACT/1685-2022"), Some("logicalName"), __scope, false) } getOrElse {Nil},
        __obj.exportedName flatMap { IPXACT2022scalaxb.toXML[IPXACT2022ScalaCases.ExportedName](_, Some("http://www.accellera.org/XMLSchema/IPXACT/1685-2022"), Some("exportedName"), __scope, false) },
        __obj.buildCommand map { IPXACT2022scalaxb.toXML[IPXACT2022ScalaCases.BuildCommand](_, Some("http://www.accellera.org/XMLSchema/IPXACT/1685-2022"), Some("buildCommand"), __scope, false) } getOrElse {Nil},
        __obj.dependency flatMap { IPXACT2022scalaxb.toXML[IPXACT2022ScalaCases.Dependency](_, Some("http://www.accellera.org/XMLSchema/IPXACT/1685-2022"), Some("dependency"), __scope, false) },
        __obj.define flatMap { IPXACT2022scalaxb.toXML[IPXACT2022ScalaCases.NameValuePairTypable](_, Some("http://www.accellera.org/XMLSchema/IPXACT/1685-2022"), Some("define"), __scope, false) },
        __obj.imageType flatMap { IPXACT2022scalaxb.toXML[IPXACT2022ScalaCases.ImageType](_, Some("http://www.accellera.org/XMLSchema/IPXACT/1685-2022"), Some("imageType"), __scope, false) },
        __obj.description map { IPXACT2022scalaxb.toXML[String](_, Some("http://www.accellera.org/XMLSchema/IPXACT/1685-2022"), Some("description"), __scope, false) } getOrElse {Nil},
        __obj.vendorExtensions map { IPXACT2022scalaxb.toXML[IPXACT2022ScalaCases.VendorExtensions](_, Some("http://www.accellera.org/XMLSchema/IPXACT/1685-2022"), Some("vendorExtensions"), __scope, false) } getOrElse {Nil})

  }

  trait DefaultIPXACT2022ScalaCases_FileBuilderFormat extends IPXACT2022scalaxb.ElemNameParser[IPXACT2022ScalaCases.FileBuilder] {
    val targetNamespace: Option[String] = Some("http://www.accellera.org/XMLSchema/IPXACT/1685-2022")
    
    def parser(node: scala.xml.Node, stack: List[IPXACT2022scalaxb.ElemName]): Parser[IPXACT2022ScalaCases.FileBuilder] =
      phrase((IPXACT2022scalaxb.ElemName(Some("http://www.accellera.org/XMLSchema/IPXACT/1685-2022"), "fileType")) ~
      (IPXACT2022scalaxb.ElemName(Some("http://www.accellera.org/XMLSchema/IPXACT/1685-2022"), "command")) ~
      opt(IPXACT2022scalaxb.ElemName(Some("http://www.accellera.org/XMLSchema/IPXACT/1685-2022"), "flags")) ~
      opt(IPXACT2022scalaxb.ElemName(Some("http://www.accellera.org/XMLSchema/IPXACT/1685-2022"), "replaceDefaultFlags")) ~
      opt(IPXACT2022scalaxb.ElemName(Some("http://www.accellera.org/XMLSchema/IPXACT/1685-2022"), "vendorExtensions")) ^^
      { case p1 ~ p2 ~ p3 ~ p4 ~ p5 =>
      IPXACT2022ScalaCases.FileBuilder(IPXACT2022scalaxb.fromXML[IPXACT2022ScalaCases.FileType](p1, IPXACT2022scalaxb.ElemName(node) :: stack),
        IPXACT2022scalaxb.fromXML[IPXACT2022ScalaCases.StringExpressionable](p2, IPXACT2022scalaxb.ElemName(node) :: stack),
        p3.headOption map { IPXACT2022scalaxb.fromXML[IPXACT2022ScalaCases.StringExpressionable](_, IPXACT2022scalaxb.ElemName(node) :: stack) },
        p4.headOption map { IPXACT2022scalaxb.fromXML[IPXACT2022ScalaCases.UnsignedBitExpression](_, IPXACT2022scalaxb.ElemName(node) :: stack) },
        p5.headOption map { IPXACT2022scalaxb.fromXML[IPXACT2022ScalaCases.VendorExtensions](_, IPXACT2022scalaxb.ElemName(node) :: stack) },
        scala.collection.immutable.ListMap(List(
        (node \ "@{http://www.w3.org/XML/1998/namespace}id").headOption map { x => IPXACT2022scalaxb.DataRecord(x, node, IPXACT2022scalaxb.fromXML[String](x, IPXACT2022scalaxb.ElemName(node) :: stack)) } map { "@{http://www.w3.org/XML/1998/namespace}id" -> _ }
        ).flatten[(String, IPXACT2022scalaxb.DataRecord[Any])]: _*)) })
    
    override def writesAttribute(__obj: IPXACT2022ScalaCases.FileBuilder, __scope: scala.xml.NamespaceBinding): scala.xml.MetaData = {
      var attr: scala.xml.MetaData  = scala.xml.Null
      __obj.attributes.toList map {
        case ("@{http://www.w3.org/XML/1998/namespace}id", _) => __obj.xmlid foreach { x => attr = scala.xml.Attribute(__scope.getPrefix("http://www.w3.org/XML/1998/namespace"), "id", x.toString, attr) }
        case (key, x) => attr = scala.xml.Attribute((x.namespace map { __scope.getPrefix(_) }).orNull, x.key.orNull, x.value.toString, attr)
      }
      attr
    }

    def writesChildNodes(__obj: IPXACT2022ScalaCases.FileBuilder, __scope: scala.xml.NamespaceBinding): Seq[scala.xml.Node] =
      Seq.concat(IPXACT2022scalaxb.toXML[IPXACT2022ScalaCases.FileType](__obj.fileType, Some("http://www.accellera.org/XMLSchema/IPXACT/1685-2022"), Some("fileType"), __scope, false),
        IPXACT2022scalaxb.toXML[IPXACT2022ScalaCases.StringExpressionable](__obj.command, Some("http://www.accellera.org/XMLSchema/IPXACT/1685-2022"), Some("command"), __scope, false),
        __obj.flags map { IPXACT2022scalaxb.toXML[IPXACT2022ScalaCases.StringExpressionable](_, Some("http://www.accellera.org/XMLSchema/IPXACT/1685-2022"), Some("flags"), __scope, false) } getOrElse {Nil},
        __obj.replaceDefaultFlags map { IPXACT2022scalaxb.toXML[IPXACT2022ScalaCases.UnsignedBitExpression](_, Some("http://www.accellera.org/XMLSchema/IPXACT/1685-2022"), Some("replaceDefaultFlags"), __scope, false) } getOrElse {Nil},
        __obj.vendorExtensions map { IPXACT2022scalaxb.toXML[IPXACT2022ScalaCases.VendorExtensions](_, Some("http://www.accellera.org/XMLSchema/IPXACT/1685-2022"), Some("vendorExtensions"), __scope, false) } getOrElse {Nil})

  }

  trait DefaultIPXACT2022ScalaCases_LanguageToolsFormat extends IPXACT2022scalaxb.ElemNameParser[IPXACT2022ScalaCases.LanguageTools] {
    val targetNamespace: Option[String] = Some("http://www.accellera.org/XMLSchema/IPXACT/1685-2022")
    
    def parser(node: scala.xml.Node, stack: List[IPXACT2022scalaxb.ElemName]): Parser[IPXACT2022ScalaCases.LanguageTools] =
      phrase(safeRep(IPXACT2022scalaxb.ElemName(Some("http://www.accellera.org/XMLSchema/IPXACT/1685-2022"), "fileBuilder")) ~
      opt(((IPXACT2022scalaxb.ElemName(Some("http://www.accellera.org/XMLSchema/IPXACT/1685-2022"), "linker")) ~
      ((((IPXACT2022scalaxb.ElemName(Some("http://www.accellera.org/XMLSchema/IPXACT/1685-2022"), "linkerFlags")) ~
      opt(IPXACT2022scalaxb.ElemName(Some("http://www.accellera.org/XMLSchema/IPXACT/1685-2022"), "linkerCommandFile"))) ^^
        { case p1 ~ p2 => IPXACT2022scalaxb.DataRecord(IPXACT2022ScalaCases.LanguageToolsSequence2(IPXACT2022scalaxb.fromXML[IPXACT2022ScalaCases.StringExpressionable](p1, IPXACT2022scalaxb.ElemName(node) :: stack),
        p2.headOption map { IPXACT2022scalaxb.fromXML[IPXACT2022ScalaCases.LinkerCommandFile](_, IPXACT2022scalaxb.ElemName(node) :: stack) })) }) |||
      ((IPXACT2022scalaxb.ElemName(Some("http://www.accellera.org/XMLSchema/IPXACT/1685-2022"), "linkerCommandFile")) ^^
      (x => IPXACT2022scalaxb.DataRecord(x.namespace, Some(x.name), IPXACT2022scalaxb.fromXML[IPXACT2022ScalaCases.LinkerCommandFile](x, IPXACT2022scalaxb.ElemName(node) :: stack)))))) ^^
        { case p1 ~ p2 => IPXACT2022ScalaCases.LanguageToolsSequence1(IPXACT2022scalaxb.fromXML[IPXACT2022ScalaCases.StringExpressionable](p1, IPXACT2022scalaxb.ElemName(node) :: stack),
        p2) }) ^^
      { case p1 ~ p2 =>
      IPXACT2022ScalaCases.LanguageTools(p1 map { IPXACT2022scalaxb.fromXML[IPXACT2022ScalaCases.FileBuilder](_, IPXACT2022scalaxb.ElemName(node) :: stack) },
        p2) })
    
    def writesChildNodes(__obj: IPXACT2022ScalaCases.LanguageTools, __scope: scala.xml.NamespaceBinding): Seq[scala.xml.Node] =
      Seq.concat(__obj.fileBuilder flatMap { IPXACT2022scalaxb.toXML[IPXACT2022ScalaCases.FileBuilder](_, Some("http://www.accellera.org/XMLSchema/IPXACT/1685-2022"), Some("fileBuilder"), __scope, false) },
        __obj.languagetoolssequence1 map { IPXACT2022scalaxb.toXML[IPXACT2022ScalaCases.LanguageToolsSequence1](_, None, Some("languagetoolssequence1"), __scope, false) } getOrElse {Nil})

  }

  trait DefaultIPXACT2022ScalaCases_LanguageToolsSequence2Format extends IPXACT2022scalaxb.XMLFormat[IPXACT2022ScalaCases.LanguageToolsSequence2] {
    def reads(seq: scala.xml.NodeSeq, stack: List[IPXACT2022scalaxb.ElemName]): Either[String, IPXACT2022ScalaCases.LanguageToolsSequence2] = Left("don't call me.")
    
    def writes(__obj: IPXACT2022ScalaCases.LanguageToolsSequence2, __namespace: Option[String], __elementLabel: Option[String],
        __scope: scala.xml.NamespaceBinding, __typeAttribute: Boolean): scala.xml.NodeSeq =
      Seq.concat(IPXACT2022scalaxb.toXML[IPXACT2022ScalaCases.StringExpressionable](__obj.linkerFlags, Some("http://www.accellera.org/XMLSchema/IPXACT/1685-2022"), Some("linkerFlags"), __scope, false),
        __obj.linkerCommandFile map { IPXACT2022scalaxb.toXML[IPXACT2022ScalaCases.LinkerCommandFile](_, Some("http://www.accellera.org/XMLSchema/IPXACT/1685-2022"), Some("linkerCommandFile"), __scope, false) } getOrElse {Nil})


  }

  trait DefaultIPXACT2022ScalaCases_LanguageToolsSequence1Format extends IPXACT2022scalaxb.XMLFormat[IPXACT2022ScalaCases.LanguageToolsSequence1] {
    def reads(seq: scala.xml.NodeSeq, stack: List[IPXACT2022scalaxb.ElemName]): Either[String, IPXACT2022ScalaCases.LanguageToolsSequence1] = Left("don't call me.")
    
    def writes(__obj: IPXACT2022ScalaCases.LanguageToolsSequence1, __namespace: Option[String], __elementLabel: Option[String],
        __scope: scala.xml.NamespaceBinding, __typeAttribute: Boolean): scala.xml.NodeSeq =
      Seq.concat(IPXACT2022scalaxb.toXML[IPXACT2022ScalaCases.StringExpressionable](__obj.linker, Some("http://www.accellera.org/XMLSchema/IPXACT/1685-2022"), Some("linker"), __scope, false),
        (Some(__obj.languagetoolsoption) map {x => IPXACT2022scalaxb.toXML[IPXACT2022scalaxb.DataRecord[IPXACT2022ScalaCases.LanguageToolsOption]](x, x.namespace, x.key, __scope, false)}).get)


  }

  trait DefaultIPXACT2022ScalaCases_FileSetRefGroupFormat extends IPXACT2022scalaxb.ElemNameParser[IPXACT2022ScalaCases.FileSetRefGroup] {
    val targetNamespace: Option[String] = Some("http://www.accellera.org/XMLSchema/IPXACT/1685-2022")
    
    def parser(node: scala.xml.Node, stack: List[IPXACT2022scalaxb.ElemName]): Parser[IPXACT2022ScalaCases.FileSetRefGroup] =
      phrase(safeRep(IPXACT2022scalaxb.ElemName(Some("http://www.accellera.org/XMLSchema/IPXACT/1685-2022"), "fileSetRef")) ^^
      { case p1 =>
      IPXACT2022ScalaCases.FileSetRefGroup(p1 map { IPXACT2022scalaxb.fromXML[IPXACT2022ScalaCases.FileSetRef](_, IPXACT2022scalaxb.ElemName(node) :: stack) }) })
    
    def writesChildNodes(__obj: IPXACT2022ScalaCases.FileSetRefGroup, __scope: scala.xml.NamespaceBinding): Seq[scala.xml.Node] =
      (__obj.fileSetRef flatMap { IPXACT2022scalaxb.toXML[IPXACT2022ScalaCases.FileSetRef](_, Some("http://www.accellera.org/XMLSchema/IPXACT/1685-2022"), Some("fileSetRef"), __scope, false) })
  }
  trait DefaultIPXACT2022ScalaCases_ExecutableImageFormat extends IPXACT2022scalaxb.ElemNameParser[IPXACT2022ScalaCases.ExecutableImage] with IPXACT2022ScalaCases_NameGroupGroupFormat {
    val targetNamespace: Option[String] = Some("http://www.accellera.org/XMLSchema/IPXACT/1685-2022")
    
    def parser(node: scala.xml.Node, stack: List[IPXACT2022scalaxb.ElemName]): Parser[IPXACT2022ScalaCases.ExecutableImage] =
      phrase((parseNameGroupGroup(node, IPXACT2022scalaxb.ElemName(node) :: stack)) ~
      opt(IPXACT2022scalaxb.ElemName(Some("http://www.accellera.org/XMLSchema/IPXACT/1685-2022"), "parameters")) ~
      opt(IPXACT2022scalaxb.ElemName(Some("http://www.accellera.org/XMLSchema/IPXACT/1685-2022"), "languageTools")) ~
      opt(IPXACT2022scalaxb.ElemName(Some("http://www.accellera.org/XMLSchema/IPXACT/1685-2022"), "fileSetRefGroup")) ~
      opt(IPXACT2022scalaxb.ElemName(Some("http://www.accellera.org/XMLSchema/IPXACT/1685-2022"), "vendorExtensions")) ^^
      { case p1 ~ p2 ~ p3 ~ p4 ~ p5 =>
      IPXACT2022ScalaCases.ExecutableImage(p1,
        p2.headOption map { IPXACT2022scalaxb.fromXML[IPXACT2022ScalaCases.Parameters](_, IPXACT2022scalaxb.ElemName(node) :: stack) },
        p3.headOption map { IPXACT2022scalaxb.fromXML[IPXACT2022ScalaCases.LanguageTools](_, IPXACT2022scalaxb.ElemName(node) :: stack) },
        p4.headOption map { IPXACT2022scalaxb.fromXML[IPXACT2022ScalaCases.FileSetRefGroup](_, IPXACT2022scalaxb.ElemName(node) :: stack) },
        p5.headOption map { IPXACT2022scalaxb.fromXML[IPXACT2022ScalaCases.VendorExtensions](_, IPXACT2022scalaxb.ElemName(node) :: stack) },
        scala.collection.immutable.ListMap(List(
        (node \ "@imageId").headOption map { x => IPXACT2022scalaxb.DataRecord(x, node, IPXACT2022scalaxb.fromXML[String](x, IPXACT2022scalaxb.ElemName(node) :: stack)) } map { "@imageId" -> _ },
        (node \ "@imageType").headOption map { x => IPXACT2022scalaxb.DataRecord(x, node, IPXACT2022scalaxb.fromXML[String](x, IPXACT2022scalaxb.ElemName(node) :: stack)) } map { "@imageType" -> _ },
        (node \ "@{http://www.w3.org/XML/1998/namespace}id").headOption map { x => IPXACT2022scalaxb.DataRecord(x, node, IPXACT2022scalaxb.fromXML[String](x, IPXACT2022scalaxb.ElemName(node) :: stack)) } map { "@{http://www.w3.org/XML/1998/namespace}id" -> _ }
        ).flatten[(String, IPXACT2022scalaxb.DataRecord[Any])]: _*)) })
    
    override def writesAttribute(__obj: IPXACT2022ScalaCases.ExecutableImage, __scope: scala.xml.NamespaceBinding): scala.xml.MetaData = {
      var attr: scala.xml.MetaData  = scala.xml.Null
      __obj.attributes.toList map {
        case ("@imageId", _) => attr = scala.xml.Attribute(null, "imageId", __obj.imageId.toString, attr)
        case ("@imageType", _) => __obj.imageType foreach { x => attr = scala.xml.Attribute(null, "imageType", x.toString, attr) }
        case ("@{http://www.w3.org/XML/1998/namespace}id", _) => __obj.xmlid foreach { x => attr = scala.xml.Attribute(__scope.getPrefix("http://www.w3.org/XML/1998/namespace"), "id", x.toString, attr) }
        case (key, x) => attr = scala.xml.Attribute((x.namespace map { __scope.getPrefix(_) }).orNull, x.key.orNull, x.value.toString, attr)
      }
      attr
    }

    def writesChildNodes(__obj: IPXACT2022ScalaCases.ExecutableImage, __scope: scala.xml.NamespaceBinding): Seq[scala.xml.Node] =
      Seq.concat(IPXACT2022scalaxb.toXML[IPXACT2022ScalaCases.NameGroupSequence](__obj.nameGroupSequence1, None, Some("nameGroupSequence1"), __scope, false),
        __obj.parameters map { IPXACT2022scalaxb.toXML[IPXACT2022ScalaCases.Parameters](_, Some("http://www.accellera.org/XMLSchema/IPXACT/1685-2022"), Some("parameters"), __scope, false) } getOrElse {Nil},
        __obj.languageTools map { IPXACT2022scalaxb.toXML[IPXACT2022ScalaCases.LanguageTools](_, Some("http://www.accellera.org/XMLSchema/IPXACT/1685-2022"), Some("languageTools"), __scope, false) } getOrElse {Nil},
        __obj.fileSetRefGroup map { IPXACT2022scalaxb.toXML[IPXACT2022ScalaCases.FileSetRefGroup](_, Some("http://www.accellera.org/XMLSchema/IPXACT/1685-2022"), Some("fileSetRefGroup"), __scope, false) } getOrElse {Nil},
        __obj.vendorExtensions map { IPXACT2022scalaxb.toXML[IPXACT2022ScalaCases.VendorExtensions](_, Some("http://www.accellera.org/XMLSchema/IPXACT/1685-2022"), Some("vendorExtensions"), __scope, false) } getOrElse {Nil})

  }

  trait DefaultIPXACT2022ScalaCases_LinkerCommandFileFormat extends IPXACT2022scalaxb.ElemNameParser[IPXACT2022ScalaCases.LinkerCommandFile] {
    val targetNamespace: Option[String] = Some("http://www.accellera.org/XMLSchema/IPXACT/1685-2022")
    
    def parser(node: scala.xml.Node, stack: List[IPXACT2022scalaxb.ElemName]): Parser[IPXACT2022ScalaCases.LinkerCommandFile] =
      phrase((IPXACT2022scalaxb.ElemName(Some("http://www.accellera.org/XMLSchema/IPXACT/1685-2022"), "name")) ~
      (IPXACT2022scalaxb.ElemName(Some("http://www.accellera.org/XMLSchema/IPXACT/1685-2022"), "commandLineSwitch")) ~
      (IPXACT2022scalaxb.ElemName(Some("http://www.accellera.org/XMLSchema/IPXACT/1685-2022"), "enable")) ~
      safeRep(IPXACT2022scalaxb.ElemName(Some("http://www.accellera.org/XMLSchema/IPXACT/1685-2022"), "generatorRef")) ~
      opt(IPXACT2022scalaxb.ElemName(Some("http://www.accellera.org/XMLSchema/IPXACT/1685-2022"), "vendorExtensions")) ^^
      { case p1 ~ p2 ~ p3 ~ p4 ~ p5 =>
      IPXACT2022ScalaCases.LinkerCommandFile(IPXACT2022scalaxb.fromXML[IPXACT2022ScalaCases.StringExpressionable](p1, IPXACT2022scalaxb.ElemName(node) :: stack),
        IPXACT2022scalaxb.fromXML[IPXACT2022ScalaCases.StringExpressionable](p2, IPXACT2022scalaxb.ElemName(node) :: stack),
        IPXACT2022scalaxb.fromXML[IPXACT2022ScalaCases.UnsignedBitExpression](p3, IPXACT2022scalaxb.ElemName(node) :: stack),
        p4 map { IPXACT2022scalaxb.fromXML[IPXACT2022ScalaCases.GeneratorRef](_, IPXACT2022scalaxb.ElemName(node) :: stack) },
        p5.headOption map { IPXACT2022scalaxb.fromXML[IPXACT2022ScalaCases.VendorExtensions](_, IPXACT2022scalaxb.ElemName(node) :: stack) },
        scala.collection.immutable.ListMap(List(
        (node \ "@{http://www.w3.org/XML/1998/namespace}id").headOption map { x => IPXACT2022scalaxb.DataRecord(x, node, IPXACT2022scalaxb.fromXML[String](x, IPXACT2022scalaxb.ElemName(node) :: stack)) } map { "@{http://www.w3.org/XML/1998/namespace}id" -> _ }
        ).flatten[(String, IPXACT2022scalaxb.DataRecord[Any])]: _*)) })
    
    override def writesAttribute(__obj: IPXACT2022ScalaCases.LinkerCommandFile, __scope: scala.xml.NamespaceBinding): scala.xml.MetaData = {
      var attr: scala.xml.MetaData  = scala.xml.Null
      __obj.attributes.toList map {
        case ("@{http://www.w3.org/XML/1998/namespace}id", _) => __obj.xmlid foreach { x => attr = scala.xml.Attribute(__scope.getPrefix("http://www.w3.org/XML/1998/namespace"), "id", x.toString, attr) }
        case (key, x) => attr = scala.xml.Attribute((x.namespace map { __scope.getPrefix(_) }).orNull, x.key.orNull, x.value.toString, attr)
      }
      attr
    }

    def writesChildNodes(__obj: IPXACT2022ScalaCases.LinkerCommandFile, __scope: scala.xml.NamespaceBinding): Seq[scala.xml.Node] =
      Seq.concat(IPXACT2022scalaxb.toXML[IPXACT2022ScalaCases.StringExpressionable](__obj.name, Some("http://www.accellera.org/XMLSchema/IPXACT/1685-2022"), Some("name"), __scope, false),
        IPXACT2022scalaxb.toXML[IPXACT2022ScalaCases.StringExpressionable](__obj.commandLineSwitch, Some("http://www.accellera.org/XMLSchema/IPXACT/1685-2022"), Some("commandLineSwitch"), __scope, false),
        IPXACT2022scalaxb.toXML[IPXACT2022ScalaCases.UnsignedBitExpression](__obj.enable, Some("http://www.accellera.org/XMLSchema/IPXACT/1685-2022"), Some("enable"), __scope, false),
        __obj.generatorRef flatMap { IPXACT2022scalaxb.toXML[IPXACT2022ScalaCases.GeneratorRef](_, Some("http://www.accellera.org/XMLSchema/IPXACT/1685-2022"), Some("generatorRef"), __scope, false) },
        __obj.vendorExtensions map { IPXACT2022scalaxb.toXML[IPXACT2022ScalaCases.VendorExtensions](_, Some("http://www.accellera.org/XMLSchema/IPXACT/1685-2022"), Some("vendorExtensions"), __scope, false) } getOrElse {Nil})

  }

  trait DefaultIPXACT2022ScalaCases_FileSetRefFormat extends IPXACT2022scalaxb.ElemNameParser[IPXACT2022ScalaCases.FileSetRef] {
    val targetNamespace: Option[String] = Some("http://www.accellera.org/XMLSchema/IPXACT/1685-2022")
    
    def parser(node: scala.xml.Node, stack: List[IPXACT2022scalaxb.ElemName]): Parser[IPXACT2022ScalaCases.FileSetRef] =
      phrase((IPXACT2022scalaxb.ElemName(Some("http://www.accellera.org/XMLSchema/IPXACT/1685-2022"), "localName")) ~
      opt(IPXACT2022scalaxb.ElemName(Some("http://www.accellera.org/XMLSchema/IPXACT/1685-2022"), "vendorExtensions")) ^^
      { case p1 ~ p2 =>
      IPXACT2022ScalaCases.FileSetRef(IPXACT2022scalaxb.fromXML[String](p1, IPXACT2022scalaxb.ElemName(node) :: stack),
        p2.headOption map { IPXACT2022scalaxb.fromXML[IPXACT2022ScalaCases.VendorExtensions](_, IPXACT2022scalaxb.ElemName(node) :: stack) },
        scala.collection.immutable.ListMap(List(
        (node \ "@{http://www.w3.org/XML/1998/namespace}id").headOption map { x => IPXACT2022scalaxb.DataRecord(x, node, IPXACT2022scalaxb.fromXML[String](x, IPXACT2022scalaxb.ElemName(node) :: stack)) } map { "@{http://www.w3.org/XML/1998/namespace}id" -> _ }
        ).flatten[(String, IPXACT2022scalaxb.DataRecord[Any])]: _*)) })
    
    override def writesAttribute(__obj: IPXACT2022ScalaCases.FileSetRef, __scope: scala.xml.NamespaceBinding): scala.xml.MetaData = {
      var attr: scala.xml.MetaData  = scala.xml.Null
      __obj.attributes.toList map {
        case ("@{http://www.w3.org/XML/1998/namespace}id", _) => __obj.xmlid foreach { x => attr = scala.xml.Attribute(__scope.getPrefix("http://www.w3.org/XML/1998/namespace"), "id", x.toString, attr) }
        case (key, x) => attr = scala.xml.Attribute((x.namespace map { __scope.getPrefix(_) }).orNull, x.key.orNull, x.value.toString, attr)
      }
      attr
    }

    def writesChildNodes(__obj: IPXACT2022ScalaCases.FileSetRef, __scope: scala.xml.NamespaceBinding): Seq[scala.xml.Node] =
      Seq.concat(IPXACT2022scalaxb.toXML[String](__obj.localName, Some("http://www.accellera.org/XMLSchema/IPXACT/1685-2022"), Some("localName"), __scope, false),
        __obj.vendorExtensions map { IPXACT2022scalaxb.toXML[IPXACT2022ScalaCases.VendorExtensions](_, Some("http://www.accellera.org/XMLSchema/IPXACT/1685-2022"), Some("vendorExtensions"), __scope, false) } getOrElse {Nil})

  }

  trait DefaultIPXACT2022ScalaCases_DependencyFormat extends IPXACT2022scalaxb.XMLFormat[IPXACT2022ScalaCases.Dependency] with IPXACT2022scalaxb.CanWriteChildNodes[IPXACT2022ScalaCases.Dependency] {
    val targetNamespace: Option[String] = Some("http://www.accellera.org/XMLSchema/IPXACT/1685-2022")
    def reads(seq: scala.xml.NodeSeq, stack: List[IPXACT2022scalaxb.ElemName]): Either[String, IPXACT2022ScalaCases.Dependency] = seq match {
      case node: scala.xml.Node => Right(IPXACT2022ScalaCases.Dependency(IPXACT2022scalaxb.fromXML[String](node, IPXACT2022scalaxb.ElemName(node) :: stack),
        scala.collection.immutable.ListMap(List(
        (node \ "@{http://www.w3.org/XML/1998/namespace}id").headOption map { x => IPXACT2022scalaxb.DataRecord(x, node, IPXACT2022scalaxb.fromXML[String](x, IPXACT2022scalaxb.ElemName(node) :: stack)) } map { "@{http://www.w3.org/XML/1998/namespace}id" -> _ }
        ).flatten[(String, IPXACT2022scalaxb.DataRecord[Any])]: _*)))
      case _ => Left("reads failed: seq must be scala.xml.Node")
    }
    
    override def writesAttribute(__obj: IPXACT2022ScalaCases.Dependency, __scope: scala.xml.NamespaceBinding): scala.xml.MetaData = {
      var attr: scala.xml.MetaData  = scala.xml.Null
      __obj.attributes.toList map {
        case ("@{http://www.w3.org/XML/1998/namespace}id", _) => __obj.xmlid foreach { x => attr = scala.xml.Attribute(__scope.getPrefix("http://www.w3.org/XML/1998/namespace"), "id", x.toString, attr) }
        case (key, x) => attr = scala.xml.Attribute((x.namespace map { __scope.getPrefix(_) }).orNull, x.key.orNull, x.value.toString, attr)
      }
      attr
    }

    def writesChildNodes(__obj: IPXACT2022ScalaCases.Dependency, __scope: scala.xml.NamespaceBinding): Seq[scala.xml.Node] =
      Seq(scala.xml.Text(__obj.value.toString))

  }

  trait DefaultIPXACT2022ScalaCases_FileSetsFormat extends IPXACT2022scalaxb.ElemNameParser[IPXACT2022ScalaCases.FileSets] {
    val targetNamespace: Option[String] = Some("http://www.accellera.org/XMLSchema/IPXACT/1685-2022")
    
    def parser(node: scala.xml.Node, stack: List[IPXACT2022scalaxb.ElemName]): Parser[IPXACT2022ScalaCases.FileSets] =
      phrase(safeRep(IPXACT2022scalaxb.ElemName(Some("http://www.accellera.org/XMLSchema/IPXACT/1685-2022"), "fileSet")) ^^
      { case p1 =>
      IPXACT2022ScalaCases.FileSets(p1 map { IPXACT2022scalaxb.fromXML[IPXACT2022ScalaCases.FileSetType](_, IPXACT2022scalaxb.ElemName(node) :: stack) }) })
    
    def writesChildNodes(__obj: IPXACT2022ScalaCases.FileSets, __scope: scala.xml.NamespaceBinding): Seq[scala.xml.Node] =
      (__obj.fileSet flatMap { IPXACT2022scalaxb.toXML[IPXACT2022ScalaCases.FileSetType](_, Some("http://www.accellera.org/XMLSchema/IPXACT/1685-2022"), Some("fileSet"), __scope, false) })
  }
  trait DefaultIPXACT2022ScalaCases_FileBuilderTypeFormat extends IPXACT2022scalaxb.ElemNameParser[IPXACT2022ScalaCases.FileBuilderType] {
    val targetNamespace: Option[String] = Some("http://www.accellera.org/XMLSchema/IPXACT/1685-2022")
    
    override def typeName: Option[String] = Some("fileBuilderType")

    def parser(node: scala.xml.Node, stack: List[IPXACT2022scalaxb.ElemName]): Parser[IPXACT2022ScalaCases.FileBuilderType] =
      phrase((IPXACT2022scalaxb.ElemName(Some("http://www.accellera.org/XMLSchema/IPXACT/1685-2022"), "fileType")) ~
      opt(IPXACT2022scalaxb.ElemName(Some("http://www.accellera.org/XMLSchema/IPXACT/1685-2022"), "command")) ~
      opt(IPXACT2022scalaxb.ElemName(Some("http://www.accellera.org/XMLSchema/IPXACT/1685-2022"), "flags")) ~
      opt(IPXACT2022scalaxb.ElemName(Some("http://www.accellera.org/XMLSchema/IPXACT/1685-2022"), "replaceDefaultFlags")) ^^
      { case p1 ~ p2 ~ p3 ~ p4 =>
      IPXACT2022ScalaCases.FileBuilderType(IPXACT2022scalaxb.fromXML[IPXACT2022ScalaCases.FileType](p1, IPXACT2022scalaxb.ElemName(node) :: stack),
        p2.headOption map { IPXACT2022scalaxb.fromXML[IPXACT2022ScalaCases.StringExpressionable](_, IPXACT2022scalaxb.ElemName(node) :: stack) },
        p3.headOption map { IPXACT2022scalaxb.fromXML[IPXACT2022ScalaCases.StringExpressionable](_, IPXACT2022scalaxb.ElemName(node) :: stack) },
        p4.headOption map { IPXACT2022scalaxb.fromXML[IPXACT2022ScalaCases.UnsignedBitExpression](_, IPXACT2022scalaxb.ElemName(node) :: stack) },
        scala.collection.immutable.ListMap(List(
        (node \ "@{http://www.w3.org/XML/1998/namespace}id").headOption map { x => IPXACT2022scalaxb.DataRecord(x, node, IPXACT2022scalaxb.fromXML[String](x, IPXACT2022scalaxb.ElemName(node) :: stack)) } map { "@{http://www.w3.org/XML/1998/namespace}id" -> _ }
        ).flatten[(String, IPXACT2022scalaxb.DataRecord[Any])]: _*)) })
    
    override def writesAttribute(__obj: IPXACT2022ScalaCases.FileBuilderType, __scope: scala.xml.NamespaceBinding): scala.xml.MetaData = {
      var attr: scala.xml.MetaData  = scala.xml.Null
      __obj.attributes.toList map {
        case ("@{http://www.w3.org/XML/1998/namespace}id", _) => __obj.xmlid foreach { x => attr = scala.xml.Attribute(__scope.getPrefix("http://www.w3.org/XML/1998/namespace"), "id", x.toString, attr) }
        case (key, x) => attr = scala.xml.Attribute((x.namespace map { __scope.getPrefix(_) }).orNull, x.key.orNull, x.value.toString, attr)
      }
      attr
    }

    def writesChildNodes(__obj: IPXACT2022ScalaCases.FileBuilderType, __scope: scala.xml.NamespaceBinding): Seq[scala.xml.Node] =
      Seq.concat(IPXACT2022scalaxb.toXML[IPXACT2022ScalaCases.FileType](__obj.fileType, Some("http://www.accellera.org/XMLSchema/IPXACT/1685-2022"), Some("fileType"), __scope, false),
        __obj.command map { IPXACT2022scalaxb.toXML[IPXACT2022ScalaCases.StringExpressionable](_, Some("http://www.accellera.org/XMLSchema/IPXACT/1685-2022"), Some("command"), __scope, false) } getOrElse {Nil},
        __obj.flags map { IPXACT2022scalaxb.toXML[IPXACT2022ScalaCases.StringExpressionable](_, Some("http://www.accellera.org/XMLSchema/IPXACT/1685-2022"), Some("flags"), __scope, false) } getOrElse {Nil},
        __obj.replaceDefaultFlags map { IPXACT2022scalaxb.toXML[IPXACT2022ScalaCases.UnsignedBitExpression](_, Some("http://www.accellera.org/XMLSchema/IPXACT/1685-2022"), Some("replaceDefaultFlags"), __scope, false) } getOrElse {Nil})

  }

  def buildIPXACT2022ScalaCases_ReturnTypeTypeFormat = new DefaultIPXACT2022ScalaCases_ReturnTypeTypeFormat {}
  trait DefaultIPXACT2022ScalaCases_ReturnTypeTypeFormat extends IPXACT2022scalaxb.XMLFormat[IPXACT2022ScalaCases.ReturnTypeType] {
    val targetNamespace: Option[String] = Some("http://www.accellera.org/XMLSchema/IPXACT/1685-2022")
    
    def fromString(value: String, scope: scala.xml.NamespaceBinding): IPXACT2022ScalaCases.ReturnTypeType =
        (fromString0(value, scope)).apply(IPXACT2022scalaxb.fromXML[String](scala.xml.Text(value)))

    private def fromString0(value: String, scope: scala.xml.NamespaceBinding): PartialFunction[Any, IPXACT2022ScalaCases.ReturnTypeType] = {
      case x: String if x == IPXACT2022scalaxb.fromXML[String](scala.xml.Text("void")) => IPXACT2022ScalaCases.Void
      case x: String if x == IPXACT2022scalaxb.fromXML[String](scala.xml.Text("int")) => IPXACT2022ScalaCases.IntTypeValue

    }



    def reads(seq: scala.xml.NodeSeq, stack: List[IPXACT2022scalaxb.ElemName]): Either[String, IPXACT2022ScalaCases.ReturnTypeType] = seq match {
      case elem: scala.xml.Elem => Right(fromString(elem.text, elem.scope))
      case _ => Right(fromString(seq.text, scala.xml.TopScope))
    }
    
    def writes(__obj: IPXACT2022ScalaCases.ReturnTypeType, __namespace: Option[String], __elementLabel: Option[String],
        __scope: scala.xml.NamespaceBinding, __typeAttribute: Boolean): scala.xml.NodeSeq =
      scala.xml.Elem(IPXACT2022scalaxb.Helper.getPrefix(__namespace, __scope).orNull,
        __elementLabel getOrElse { sys.error("missing element label.") },
        scala.xml.Null, __scope, true, scala.xml.Text(__obj.toString))
  }
  trait DefaultIPXACT2022ScalaCases_Group2Format extends IPXACT2022scalaxb.XMLFormat[IPXACT2022ScalaCases.Group2] with IPXACT2022scalaxb.CanWriteChildNodes[IPXACT2022ScalaCases.Group2] {
    val targetNamespace: Option[String] = Some("http://www.accellera.org/XMLSchema/IPXACT/1685-2022")
    def reads(seq: scala.xml.NodeSeq, stack: List[IPXACT2022scalaxb.ElemName]): Either[String, IPXACT2022ScalaCases.Group2] = seq match {
      case node: scala.xml.Node => Right(IPXACT2022ScalaCases.Group2(IPXACT2022scalaxb.fromXML[String](node, IPXACT2022scalaxb.ElemName(node) :: stack),
        scala.collection.immutable.ListMap(List(
        (node \ "@{http://www.w3.org/XML/1998/namespace}id").headOption map { x => IPXACT2022scalaxb.DataRecord(x, node, IPXACT2022scalaxb.fromXML[String](x, IPXACT2022scalaxb.ElemName(node) :: stack)) } map { "@{http://www.w3.org/XML/1998/namespace}id" -> _ }
        ).flatten[(String, IPXACT2022scalaxb.DataRecord[Any])]: _*)))
      case _ => Left("reads failed: seq must be scala.xml.Node")
    }
    
    override def writesAttribute(__obj: IPXACT2022ScalaCases.Group2, __scope: scala.xml.NamespaceBinding): scala.xml.MetaData = {
      var attr: scala.xml.MetaData  = scala.xml.Null
      __obj.attributes.toList map {
        case ("@{http://www.w3.org/XML/1998/namespace}id", _) => __obj.xmlid foreach { x => attr = scala.xml.Attribute(__scope.getPrefix("http://www.w3.org/XML/1998/namespace"), "id", x.toString, attr) }
        case (key, x) => attr = scala.xml.Attribute((x.namespace map { __scope.getPrefix(_) }).orNull, x.key.orNull, x.value.toString, attr)
      }
      attr
    }

    def writesChildNodes(__obj: IPXACT2022ScalaCases.Group2, __scope: scala.xml.NamespaceBinding): Seq[scala.xml.Node] =
      Seq(scala.xml.Text(__obj.value.toString))

  }

  trait DefaultIPXACT2022ScalaCases_ArgumentFormat extends IPXACT2022scalaxb.ElemNameParser[IPXACT2022ScalaCases.Argument] with IPXACT2022ScalaCases_NameGroupStringGroupFormat {
    val targetNamespace: Option[String] = Some("http://www.accellera.org/XMLSchema/IPXACT/1685-2022")
    
    def parser(node: scala.xml.Node, stack: List[IPXACT2022scalaxb.ElemName]): Parser[IPXACT2022ScalaCases.Argument] =
      phrase((parseNameGroupStringGroup(node, IPXACT2022scalaxb.ElemName(node) :: stack)) ~
      (IPXACT2022scalaxb.ElemName(Some("http://www.accellera.org/XMLSchema/IPXACT/1685-2022"), "value")) ~
      opt(IPXACT2022scalaxb.ElemName(Some("http://www.accellera.org/XMLSchema/IPXACT/1685-2022"), "vendorExtensions")) ^^
      { case p1 ~ p2 ~ p3 =>
      IPXACT2022ScalaCases.Argument(p1,
        IPXACT2022scalaxb.fromXML[IPXACT2022ScalaCases.StringExpressionable](p2, IPXACT2022scalaxb.ElemName(node) :: stack),
        p3.headOption map { IPXACT2022scalaxb.fromXML[IPXACT2022ScalaCases.VendorExtensions](_, IPXACT2022scalaxb.ElemName(node) :: stack) },
        scala.collection.immutable.ListMap(List(
        (node \ "@{http://www.w3.org/XML/1998/namespace}id").headOption map { x => IPXACT2022scalaxb.DataRecord(x, node, IPXACT2022scalaxb.fromXML[String](x, IPXACT2022scalaxb.ElemName(node) :: stack)) } map { "@{http://www.w3.org/XML/1998/namespace}id" -> _ },
        (node \ "@dataType").headOption map { x => IPXACT2022scalaxb.DataRecord(x, node, IPXACT2022scalaxb.fromXML[IPXACT2022ScalaCases.DataTypeType](x, IPXACT2022scalaxb.ElemName(node) :: stack)) } map { "@dataType" -> _ }
        ).flatten[(String, IPXACT2022scalaxb.DataRecord[Any])]: _*)) })
    
    override def writesAttribute(__obj: IPXACT2022ScalaCases.Argument, __scope: scala.xml.NamespaceBinding): scala.xml.MetaData = {
      var attr: scala.xml.MetaData  = scala.xml.Null
      __obj.attributes.toList map {
        case ("@{http://www.w3.org/XML/1998/namespace}id", _) => __obj.xmlid foreach { x => attr = scala.xml.Attribute(__scope.getPrefix("http://www.w3.org/XML/1998/namespace"), "id", x.toString, attr) }
        case ("@dataType", _) => attr = scala.xml.Attribute(null, "dataType", __obj.dataType.toString, attr)
        case (key, x) => attr = scala.xml.Attribute((x.namespace map { __scope.getPrefix(_) }).orNull, x.key.orNull, x.value.toString, attr)
      }
      attr
    }

    def writesChildNodes(__obj: IPXACT2022ScalaCases.Argument, __scope: scala.xml.NamespaceBinding): Seq[scala.xml.Node] =
      Seq.concat(IPXACT2022scalaxb.toXML[IPXACT2022ScalaCases.NameGroupStringSequence](__obj.nameGroupStringSequence1, None, Some("nameGroupStringSequence1"), __scope, false),
        IPXACT2022scalaxb.toXML[IPXACT2022ScalaCases.StringExpressionable](__obj.value, Some("http://www.accellera.org/XMLSchema/IPXACT/1685-2022"), Some("value"), __scope, false),
        __obj.vendorExtensions map { IPXACT2022scalaxb.toXML[IPXACT2022ScalaCases.VendorExtensions](_, Some("http://www.accellera.org/XMLSchema/IPXACT/1685-2022"), Some("vendorExtensions"), __scope, false) } getOrElse {Nil})

  }

  trait DefaultIPXACT2022ScalaCases_SourceFileFormat extends IPXACT2022scalaxb.ElemNameParser[IPXACT2022ScalaCases.SourceFile] {
    val targetNamespace: Option[String] = Some("http://www.accellera.org/XMLSchema/IPXACT/1685-2022")
    
    def parser(node: scala.xml.Node, stack: List[IPXACT2022scalaxb.ElemName]): Parser[IPXACT2022ScalaCases.SourceFile] =
      phrase((IPXACT2022scalaxb.ElemName(Some("http://www.accellera.org/XMLSchema/IPXACT/1685-2022"), "sourceName")) ~
      (IPXACT2022scalaxb.ElemName(Some("http://www.accellera.org/XMLSchema/IPXACT/1685-2022"), "fileType")) ^^
      { case p1 ~ p2 =>
      IPXACT2022ScalaCases.SourceFile(IPXACT2022scalaxb.fromXML[IPXACT2022ScalaCases.IpxactURIable](p1, IPXACT2022scalaxb.ElemName(node) :: stack),
        IPXACT2022scalaxb.fromXML[IPXACT2022ScalaCases.FileType](p2, IPXACT2022scalaxb.ElemName(node) :: stack),
        scala.collection.immutable.ListMap(List(
        (node \ "@{http://www.w3.org/XML/1998/namespace}id").headOption map { x => IPXACT2022scalaxb.DataRecord(x, node, IPXACT2022scalaxb.fromXML[String](x, IPXACT2022scalaxb.ElemName(node) :: stack)) } map { "@{http://www.w3.org/XML/1998/namespace}id" -> _ }
        ).flatten[(String, IPXACT2022scalaxb.DataRecord[Any])]: _*)) })
    
    override def writesAttribute(__obj: IPXACT2022ScalaCases.SourceFile, __scope: scala.xml.NamespaceBinding): scala.xml.MetaData = {
      var attr: scala.xml.MetaData  = scala.xml.Null
      __obj.attributes.toList map {
        case ("@{http://www.w3.org/XML/1998/namespace}id", _) => __obj.xmlid foreach { x => attr = scala.xml.Attribute(__scope.getPrefix("http://www.w3.org/XML/1998/namespace"), "id", x.toString, attr) }
        case (key, x) => attr = scala.xml.Attribute((x.namespace map { __scope.getPrefix(_) }).orNull, x.key.orNull, x.value.toString, attr)
      }
      attr
    }

    def writesChildNodes(__obj: IPXACT2022ScalaCases.SourceFile, __scope: scala.xml.NamespaceBinding): Seq[scala.xml.Node] =
      Seq.concat(IPXACT2022scalaxb.toXML[IPXACT2022ScalaCases.IpxactURIable](__obj.sourceName, Some("http://www.accellera.org/XMLSchema/IPXACT/1685-2022"), Some("sourceName"), __scope, false),
        IPXACT2022scalaxb.toXML[IPXACT2022ScalaCases.FileType](__obj.fileType, Some("http://www.accellera.org/XMLSchema/IPXACT/1685-2022"), Some("fileType"), __scope, false))

  }

  trait DefaultIPXACT2022ScalaCases_FunctionTypeFormat extends IPXACT2022scalaxb.ElemNameParser[IPXACT2022ScalaCases.FunctionType] {
    val targetNamespace: Option[String] = Some("http://www.accellera.org/XMLSchema/IPXACT/1685-2022")
    
    def parser(node: scala.xml.Node, stack: List[IPXACT2022scalaxb.ElemName]): Parser[IPXACT2022ScalaCases.FunctionType] =
      phrase(opt(IPXACT2022scalaxb.ElemName(Some("http://www.accellera.org/XMLSchema/IPXACT/1685-2022"), "entryPoint")) ~
      (IPXACT2022scalaxb.ElemName(Some("http://www.accellera.org/XMLSchema/IPXACT/1685-2022"), "fileRef")) ~
      opt(IPXACT2022scalaxb.ElemName(Some("http://www.accellera.org/XMLSchema/IPXACT/1685-2022"), "returnType")) ~
      safeRep(IPXACT2022scalaxb.ElemName(Some("http://www.accellera.org/XMLSchema/IPXACT/1685-2022"), "argument")) ~
      opt(IPXACT2022scalaxb.ElemName(Some("http://www.accellera.org/XMLSchema/IPXACT/1685-2022"), "disabled")) ~
      safeRep(IPXACT2022scalaxb.ElemName(Some("http://www.accellera.org/XMLSchema/IPXACT/1685-2022"), "sourceFile")) ^^
      { case p1 ~ p2 ~ p3 ~ p4 ~ p5 ~ p6 =>
      IPXACT2022ScalaCases.FunctionType(p1.headOption map { IPXACT2022scalaxb.fromXML[String](_, IPXACT2022scalaxb.ElemName(node) :: stack) },
        IPXACT2022scalaxb.fromXML[String](p2, IPXACT2022scalaxb.ElemName(node) :: stack),
        p3.headOption map { IPXACT2022scalaxb.fromXML[IPXACT2022ScalaCases.ReturnTypeType](_, IPXACT2022scalaxb.ElemName(node) :: stack) },
        p4 map { IPXACT2022scalaxb.fromXML[IPXACT2022ScalaCases.Argument](_, IPXACT2022scalaxb.ElemName(node) :: stack) },
        p5.headOption map { IPXACT2022scalaxb.fromXML[IPXACT2022ScalaCases.UnsignedBitExpression](_, IPXACT2022scalaxb.ElemName(node) :: stack) },
        p6 map { IPXACT2022scalaxb.fromXML[IPXACT2022ScalaCases.SourceFile](_, IPXACT2022scalaxb.ElemName(node) :: stack) },
        scala.collection.immutable.ListMap(List(
        (node \ "@replicate").headOption map { x => IPXACT2022scalaxb.DataRecord(x, node, IPXACT2022scalaxb.fromXML[Boolean](x, IPXACT2022scalaxb.ElemName(node) :: stack)) } orElse Some(IPXACT2022scalaxb.DataRecord(None, None, IPXACT2022scalaxb.fromXML[Boolean](scala.xml.Text("false"), IPXACT2022scalaxb.ElemName(node) :: stack))) map { "@replicate" -> _ },
        (node \ "@{http://www.w3.org/XML/1998/namespace}id").headOption map { x => IPXACT2022scalaxb.DataRecord(x, node, IPXACT2022scalaxb.fromXML[String](x, IPXACT2022scalaxb.ElemName(node) :: stack)) } map { "@{http://www.w3.org/XML/1998/namespace}id" -> _ }
        ).flatten[(String, IPXACT2022scalaxb.DataRecord[Any])]: _*)) })
    
    override def writesAttribute(__obj: IPXACT2022ScalaCases.FunctionType, __scope: scala.xml.NamespaceBinding): scala.xml.MetaData = {
      var attr: scala.xml.MetaData  = scala.xml.Null
      __obj.attributes.toList map {
        case ("@replicate", _) => if (__obj.replicate.toString != "false") attr = scala.xml.Attribute(null, "replicate", __obj.replicate.toString, attr)
        case ("@{http://www.w3.org/XML/1998/namespace}id", _) => __obj.xmlid foreach { x => attr = scala.xml.Attribute(__scope.getPrefix("http://www.w3.org/XML/1998/namespace"), "id", x.toString, attr) }
        case (key, x) => attr = scala.xml.Attribute((x.namespace map { __scope.getPrefix(_) }).orNull, x.key.orNull, x.value.toString, attr)
      }
      attr
    }

    def writesChildNodes(__obj: IPXACT2022ScalaCases.FunctionType, __scope: scala.xml.NamespaceBinding): Seq[scala.xml.Node] =
      Seq.concat(__obj.entryPoint map { IPXACT2022scalaxb.toXML[String](_, Some("http://www.accellera.org/XMLSchema/IPXACT/1685-2022"), Some("entryPoint"), __scope, false) } getOrElse {Nil},
        IPXACT2022scalaxb.toXML[String](__obj.fileRef, Some("http://www.accellera.org/XMLSchema/IPXACT/1685-2022"), Some("fileRef"), __scope, false),
        __obj.returnType map { IPXACT2022scalaxb.toXML[IPXACT2022ScalaCases.ReturnTypeType](_, Some("http://www.accellera.org/XMLSchema/IPXACT/1685-2022"), Some("returnType"), __scope, false) } getOrElse {Nil},
        __obj.argument flatMap { IPXACT2022scalaxb.toXML[IPXACT2022ScalaCases.Argument](_, Some("http://www.accellera.org/XMLSchema/IPXACT/1685-2022"), Some("argument"), __scope, false) },
        __obj.disabled map { IPXACT2022scalaxb.toXML[IPXACT2022ScalaCases.UnsignedBitExpression](_, Some("http://www.accellera.org/XMLSchema/IPXACT/1685-2022"), Some("disabled"), __scope, false) } getOrElse {Nil},
        __obj.sourceFile flatMap { IPXACT2022scalaxb.toXML[IPXACT2022ScalaCases.SourceFile](_, Some("http://www.accellera.org/XMLSchema/IPXACT/1685-2022"), Some("sourceFile"), __scope, false) })

  }

  trait DefaultIPXACT2022ScalaCases_FileSetTypeFormat extends IPXACT2022scalaxb.ElemNameParser[IPXACT2022ScalaCases.FileSetType] with IPXACT2022ScalaCases_NameGroupGroupFormat {
    val targetNamespace: Option[String] = Some("http://www.accellera.org/XMLSchema/IPXACT/1685-2022")
    
    override def typeName: Option[String] = Some("fileSetType")

    def parser(node: scala.xml.Node, stack: List[IPXACT2022scalaxb.ElemName]): Parser[IPXACT2022ScalaCases.FileSetType] =
      phrase((parseNameGroupGroup(node, IPXACT2022scalaxb.ElemName(node) :: stack)) ~
      safeRep(IPXACT2022scalaxb.ElemName(Some("http://www.accellera.org/XMLSchema/IPXACT/1685-2022"), "group")) ~
      safeRep(IPXACT2022scalaxb.ElemName(Some("http://www.accellera.org/XMLSchema/IPXACT/1685-2022"), "file")) ~
      safeRep(IPXACT2022scalaxb.ElemName(Some("http://www.accellera.org/XMLSchema/IPXACT/1685-2022"), "defaultFileBuilder")) ~
      safeRep(IPXACT2022scalaxb.ElemName(Some("http://www.accellera.org/XMLSchema/IPXACT/1685-2022"), "dependency")) ~
      safeRep(IPXACT2022scalaxb.ElemName(Some("http://www.accellera.org/XMLSchema/IPXACT/1685-2022"), "function")) ~
      opt(IPXACT2022scalaxb.ElemName(Some("http://www.accellera.org/XMLSchema/IPXACT/1685-2022"), "vendorExtensions")) ^^
      { case p1 ~ p2 ~ p3 ~ p4 ~ p5 ~ p6 ~ p7 =>
      IPXACT2022ScalaCases.FileSetType(p1,
        p2 map { IPXACT2022scalaxb.fromXML[IPXACT2022ScalaCases.Group2](_, IPXACT2022scalaxb.ElemName(node) :: stack) },
        p3 map { IPXACT2022scalaxb.fromXML[IPXACT2022ScalaCases.File](_, IPXACT2022scalaxb.ElemName(node) :: stack) },
        p4 map { IPXACT2022scalaxb.fromXML[IPXACT2022ScalaCases.FileBuilderType](_, IPXACT2022scalaxb.ElemName(node) :: stack) },
        p5 map { IPXACT2022scalaxb.fromXML[IPXACT2022ScalaCases.Dependency](_, IPXACT2022scalaxb.ElemName(node) :: stack) },
        p6 map { IPXACT2022scalaxb.fromXML[IPXACT2022ScalaCases.FunctionType](_, IPXACT2022scalaxb.ElemName(node) :: stack) },
        p7.headOption map { IPXACT2022scalaxb.fromXML[IPXACT2022ScalaCases.VendorExtensions](_, IPXACT2022scalaxb.ElemName(node) :: stack) },
        scala.collection.immutable.ListMap(List(
        (node \ "@{http://www.w3.org/XML/1998/namespace}id").headOption map { x => IPXACT2022scalaxb.DataRecord(x, node, IPXACT2022scalaxb.fromXML[String](x, IPXACT2022scalaxb.ElemName(node) :: stack)) } map { "@{http://www.w3.org/XML/1998/namespace}id" -> _ }
        ).flatten[(String, IPXACT2022scalaxb.DataRecord[Any])]: _*)) })
    
    override def writesAttribute(__obj: IPXACT2022ScalaCases.FileSetType, __scope: scala.xml.NamespaceBinding): scala.xml.MetaData = {
      var attr: scala.xml.MetaData  = scala.xml.Null
      __obj.attributes.toList map {
        case ("@{http://www.w3.org/XML/1998/namespace}id", _) => __obj.xmlid foreach { x => attr = scala.xml.Attribute(__scope.getPrefix("http://www.w3.org/XML/1998/namespace"), "id", x.toString, attr) }
        case (key, x) => attr = scala.xml.Attribute((x.namespace map { __scope.getPrefix(_) }).orNull, x.key.orNull, x.value.toString, attr)
      }
      attr
    }

    def writesChildNodes(__obj: IPXACT2022ScalaCases.FileSetType, __scope: scala.xml.NamespaceBinding): Seq[scala.xml.Node] =
      Seq.concat(IPXACT2022scalaxb.toXML[IPXACT2022ScalaCases.NameGroupSequence](__obj.nameGroupSequence1, None, Some("nameGroupSequence1"), __scope, false),
        __obj.group flatMap { IPXACT2022scalaxb.toXML[IPXACT2022ScalaCases.Group2](_, Some("http://www.accellera.org/XMLSchema/IPXACT/1685-2022"), Some("group"), __scope, false) },
        __obj.file flatMap { IPXACT2022scalaxb.toXML[IPXACT2022ScalaCases.File](_, Some("http://www.accellera.org/XMLSchema/IPXACT/1685-2022"), Some("file"), __scope, false) },
        __obj.defaultFileBuilder flatMap { IPXACT2022scalaxb.toXML[IPXACT2022ScalaCases.FileBuilderType](_, Some("http://www.accellera.org/XMLSchema/IPXACT/1685-2022"), Some("defaultFileBuilder"), __scope, false) },
        __obj.dependency flatMap { IPXACT2022scalaxb.toXML[IPXACT2022ScalaCases.Dependency](_, Some("http://www.accellera.org/XMLSchema/IPXACT/1685-2022"), Some("dependency"), __scope, false) },
        __obj.function flatMap { IPXACT2022scalaxb.toXML[IPXACT2022ScalaCases.FunctionType](_, Some("http://www.accellera.org/XMLSchema/IPXACT/1685-2022"), Some("function"), __scope, false) },
        __obj.vendorExtensions map { IPXACT2022scalaxb.toXML[IPXACT2022ScalaCases.VendorExtensions](_, Some("http://www.accellera.org/XMLSchema/IPXACT/1685-2022"), Some("vendorExtensions"), __scope, false) } getOrElse {Nil})

  }

  def buildIPXACT2022ScalaCases_DataTypeTypeFormat = new DefaultIPXACT2022ScalaCases_DataTypeTypeFormat {}
  trait DefaultIPXACT2022ScalaCases_DataTypeTypeFormat extends IPXACT2022scalaxb.XMLFormat[IPXACT2022ScalaCases.DataTypeType] {
    val targetNamespace: Option[String] = Some("http://www.accellera.org/XMLSchema/IPXACT/1685-2022")
    
    def fromString(value: String, scope: scala.xml.NamespaceBinding): IPXACT2022ScalaCases.DataTypeType =
        (fromString0(value, scope)).apply(IPXACT2022scalaxb.fromXML[String](scala.xml.Text(value)))

    private def fromString0(value: String, scope: scala.xml.NamespaceBinding): PartialFunction[Any, IPXACT2022ScalaCases.DataTypeType] = {
      case x: String if x == IPXACT2022scalaxb.fromXML[String](scala.xml.Text("int")) => IPXACT2022ScalaCases.IntType
      case x: String if x == IPXACT2022scalaxb.fromXML[String](scala.xml.Text("unsigned int")) => IPXACT2022ScalaCases.Unsignedint
      case x: String if x == IPXACT2022scalaxb.fromXML[String](scala.xml.Text("long")) => IPXACT2022ScalaCases.LongType
      case x: String if x == IPXACT2022scalaxb.fromXML[String](scala.xml.Text("unsigned long")) => IPXACT2022ScalaCases.Unsignedlong
      case x: String if x == IPXACT2022scalaxb.fromXML[String](scala.xml.Text("float")) => IPXACT2022ScalaCases.FloatType
      case x: String if x == IPXACT2022scalaxb.fromXML[String](scala.xml.Text("double")) => IPXACT2022ScalaCases.DoubleType
      case x: String if x == IPXACT2022scalaxb.fromXML[String](scala.xml.Text("char *")) => IPXACT2022ScalaCases.Charu42
      case x: String if x == IPXACT2022scalaxb.fromXML[String](scala.xml.Text("void *")) => IPXACT2022ScalaCases.Voidu42

    }



    def reads(seq: scala.xml.NodeSeq, stack: List[IPXACT2022scalaxb.ElemName]): Either[String, IPXACT2022ScalaCases.DataTypeType] = seq match {
      case elem: scala.xml.Elem => Right(fromString(elem.text, elem.scope))
      case _ => Right(fromString(seq.text, scala.xml.TopScope))
    }
    
    def writes(__obj: IPXACT2022ScalaCases.DataTypeType, __namespace: Option[String], __elementLabel: Option[String],
        __scope: scala.xml.NamespaceBinding, __typeAttribute: Boolean): scala.xml.NodeSeq =
      scala.xml.Elem(IPXACT2022scalaxb.Helper.getPrefix(__namespace, __scope).orNull,
        __elementLabel getOrElse { sys.error("missing element label.") },
        scala.xml.Null, __scope, true, scala.xml.Text(__obj.toString))
  }
  trait DefaultIPXACT2022ScalaCases_GeneratorRefFormat extends IPXACT2022scalaxb.XMLFormat[IPXACT2022ScalaCases.GeneratorRef] with IPXACT2022scalaxb.CanWriteChildNodes[IPXACT2022ScalaCases.GeneratorRef] {
    val targetNamespace: Option[String] = Some("http://www.accellera.org/XMLSchema/IPXACT/1685-2022")
    def reads(seq: scala.xml.NodeSeq, stack: List[IPXACT2022scalaxb.ElemName]): Either[String, IPXACT2022ScalaCases.GeneratorRef] = seq match {
      case node: scala.xml.Node => Right(IPXACT2022ScalaCases.GeneratorRef(IPXACT2022scalaxb.fromXML[String](node, IPXACT2022scalaxb.ElemName(node) :: stack),
        scala.collection.immutable.ListMap(List(
        (node \ "@{http://www.w3.org/XML/1998/namespace}id").headOption map { x => IPXACT2022scalaxb.DataRecord(x, node, IPXACT2022scalaxb.fromXML[String](x, IPXACT2022scalaxb.ElemName(node) :: stack)) } map { "@{http://www.w3.org/XML/1998/namespace}id" -> _ }
        ).flatten[(String, IPXACT2022scalaxb.DataRecord[Any])]: _*)))
      case _ => Left("reads failed: seq must be scala.xml.Node")
    }
    
    override def writesAttribute(__obj: IPXACT2022ScalaCases.GeneratorRef, __scope: scala.xml.NamespaceBinding): scala.xml.MetaData = {
      var attr: scala.xml.MetaData  = scala.xml.Null
      __obj.attributes.toList map {
        case ("@{http://www.w3.org/XML/1998/namespace}id", _) => __obj.xmlid foreach { x => attr = scala.xml.Attribute(__scope.getPrefix("http://www.w3.org/XML/1998/namespace"), "id", x.toString, attr) }
        case (key, x) => attr = scala.xml.Attribute((x.namespace map { __scope.getPrefix(_) }).orNull, x.key.orNull, x.value.toString, attr)
      }
      attr
    }

    def writesChildNodes(__obj: IPXACT2022ScalaCases.GeneratorRef, __scope: scala.xml.NamespaceBinding): Seq[scala.xml.Node] =
      Seq(scala.xml.Text(__obj.value.toString))

  }

  def buildIPXACT2022ScalaCases_SimpleFileTypeFormat = new DefaultIPXACT2022ScalaCases_SimpleFileTypeFormat {}
  trait DefaultIPXACT2022ScalaCases_SimpleFileTypeFormat extends IPXACT2022scalaxb.XMLFormat[IPXACT2022ScalaCases.SimpleFileType] {
    val targetNamespace: Option[String] = Some("http://www.accellera.org/XMLSchema/IPXACT/1685-2022")
    
    def fromString(value: String, scope: scala.xml.NamespaceBinding): IPXACT2022ScalaCases.SimpleFileType =
        (fromString0(value, scope)).apply(IPXACT2022scalaxb.fromXML[String](scala.xml.Text(value)))

    private def fromString0(value: String, scope: scala.xml.NamespaceBinding): PartialFunction[Any, IPXACT2022ScalaCases.SimpleFileType] = {
      case x: String if x == IPXACT2022scalaxb.fromXML[String](scala.xml.Text("unknown")) => IPXACT2022ScalaCases.Unknown
      case x: String if x == IPXACT2022scalaxb.fromXML[String](scala.xml.Text("cSource")) => IPXACT2022ScalaCases.CSource
      case x: String if x == IPXACT2022scalaxb.fromXML[String](scala.xml.Text("cppSource")) => IPXACT2022ScalaCases.CppSource
      case x: String if x == IPXACT2022scalaxb.fromXML[String](scala.xml.Text("asmSource")) => IPXACT2022ScalaCases.AsmSource
      case x: String if x == IPXACT2022scalaxb.fromXML[String](scala.xml.Text("vhdlSource")) => IPXACT2022ScalaCases.VhdlSource
      case x: String if x == IPXACT2022scalaxb.fromXML[String](scala.xml.Text("vhdlSource-87")) => IPXACT2022ScalaCases.VhdlSourceu4587
      case x: String if x == IPXACT2022scalaxb.fromXML[String](scala.xml.Text("vhdlSource-93")) => IPXACT2022ScalaCases.VhdlSourceu4593
      case x: String if x == IPXACT2022scalaxb.fromXML[String](scala.xml.Text("vhdlSource-2002")) => IPXACT2022ScalaCases.VhdlSourceu452002
      case x: String if x == IPXACT2022scalaxb.fromXML[String](scala.xml.Text("vhdlSource-2008")) => IPXACT2022ScalaCases.VhdlSourceu452008
      case x: String if x == IPXACT2022scalaxb.fromXML[String](scala.xml.Text("verilogSource")) => IPXACT2022ScalaCases.VerilogSource
      case x: String if x == IPXACT2022scalaxb.fromXML[String](scala.xml.Text("verilogSource-95")) => IPXACT2022ScalaCases.VerilogSourceu4595
      case x: String if x == IPXACT2022scalaxb.fromXML[String](scala.xml.Text("verilogSource-2001")) => IPXACT2022ScalaCases.VerilogSourceu452001
      case x: String if x == IPXACT2022scalaxb.fromXML[String](scala.xml.Text("verilogSource-2005")) => IPXACT2022ScalaCases.VerilogSourceu452005
      case x: String if x == IPXACT2022scalaxb.fromXML[String](scala.xml.Text("swObject")) => IPXACT2022ScalaCases.SwObject
      case x: String if x == IPXACT2022scalaxb.fromXML[String](scala.xml.Text("swObjectLibrary")) => IPXACT2022ScalaCases.SwObjectLibrary
      case x: String if x == IPXACT2022scalaxb.fromXML[String](scala.xml.Text("vhdlBinaryLibrary")) => IPXACT2022ScalaCases.VhdlBinaryLibrary
      case x: String if x == IPXACT2022scalaxb.fromXML[String](scala.xml.Text("verilogBinaryLibrary")) => IPXACT2022ScalaCases.VerilogBinaryLibrary
      case x: String if x == IPXACT2022scalaxb.fromXML[String](scala.xml.Text("unelaboratedHdl")) => IPXACT2022ScalaCases.UnelaboratedHdl
      case x: String if x == IPXACT2022scalaxb.fromXML[String](scala.xml.Text("executableHdl")) => IPXACT2022ScalaCases.ExecutableHdl
      case x: String if x == IPXACT2022scalaxb.fromXML[String](scala.xml.Text("systemVerilogSource")) => IPXACT2022ScalaCases.SystemVerilogSource
      case x: String if x == IPXACT2022scalaxb.fromXML[String](scala.xml.Text("systemVerilogSource-3.0")) => IPXACT2022ScalaCases.SystemVerilogSourceu453u460
      case x: String if x == IPXACT2022scalaxb.fromXML[String](scala.xml.Text("systemVerilogSource-3.1")) => IPXACT2022ScalaCases.SystemVerilogSourceu453u461
      case x: String if x == IPXACT2022scalaxb.fromXML[String](scala.xml.Text("systemVerilogSource-3.1a")) => IPXACT2022ScalaCases.SystemVerilogSourceu453u461a
      case x: String if x == IPXACT2022scalaxb.fromXML[String](scala.xml.Text("systemVerilogSource-2009")) => IPXACT2022ScalaCases.SystemVerilogSourceu452009
      case x: String if x == IPXACT2022scalaxb.fromXML[String](scala.xml.Text("systemVerilogSource-2012")) => IPXACT2022ScalaCases.SystemVerilogSourceu452012
      case x: String if x == IPXACT2022scalaxb.fromXML[String](scala.xml.Text("systemVerilogSource-2017")) => IPXACT2022ScalaCases.SystemVerilogSourceu452017
      case x: String if x == IPXACT2022scalaxb.fromXML[String](scala.xml.Text("systemCSource")) => IPXACT2022ScalaCases.SystemCSource
      case x: String if x == IPXACT2022scalaxb.fromXML[String](scala.xml.Text("systemCSource-2.0")) => IPXACT2022ScalaCases.SystemCSourceu452u460
      case x: String if x == IPXACT2022scalaxb.fromXML[String](scala.xml.Text("systemCSource-2.0.1")) => IPXACT2022ScalaCases.SystemCSourceu452u460u461
      case x: String if x == IPXACT2022scalaxb.fromXML[String](scala.xml.Text("systemCSource-2.1")) => IPXACT2022ScalaCases.SystemCSourceu452u461
      case x: String if x == IPXACT2022scalaxb.fromXML[String](scala.xml.Text("systemCSource-2.2")) => IPXACT2022ScalaCases.SystemCSourceu452u462
      case x: String if x == IPXACT2022scalaxb.fromXML[String](scala.xml.Text("systemCSource-2.3")) => IPXACT2022ScalaCases.SystemCSourceu452u463
      case x: String if x == IPXACT2022scalaxb.fromXML[String](scala.xml.Text("systemCBinaryLibrary")) => IPXACT2022ScalaCases.SystemCBinaryLibrary
      case x: String if x == IPXACT2022scalaxb.fromXML[String](scala.xml.Text("veraSource")) => IPXACT2022ScalaCases.VeraSource
      case x: String if x == IPXACT2022scalaxb.fromXML[String](scala.xml.Text("eSource")) => IPXACT2022ScalaCases.ESource
      case x: String if x == IPXACT2022scalaxb.fromXML[String](scala.xml.Text("perlSource")) => IPXACT2022ScalaCases.PerlSource
      case x: String if x == IPXACT2022scalaxb.fromXML[String](scala.xml.Text("tclSource")) => IPXACT2022ScalaCases.TclSource
      case x: String if x == IPXACT2022scalaxb.fromXML[String](scala.xml.Text("OVASource")) => IPXACT2022ScalaCases.OVASource
      case x: String if x == IPXACT2022scalaxb.fromXML[String](scala.xml.Text("SVASource")) => IPXACT2022ScalaCases.SVASource
      case x: String if x == IPXACT2022scalaxb.fromXML[String](scala.xml.Text("pslSource")) => IPXACT2022ScalaCases.PslSource
      case x: String if x == IPXACT2022scalaxb.fromXML[String](scala.xml.Text("SDC")) => IPXACT2022ScalaCases.SDC
      case x: String if x == IPXACT2022scalaxb.fromXML[String](scala.xml.Text("vhdlAmsSource")) => IPXACT2022ScalaCases.VhdlAmsSource
      case x: String if x == IPXACT2022scalaxb.fromXML[String](scala.xml.Text("verilogAmsSource")) => IPXACT2022ScalaCases.VerilogAmsSource
      case x: String if x == IPXACT2022scalaxb.fromXML[String](scala.xml.Text("systemCAmsSource")) => IPXACT2022ScalaCases.SystemCAmsSource
      case x: String if x == IPXACT2022scalaxb.fromXML[String](scala.xml.Text("libertySource")) => IPXACT2022ScalaCases.LibertySource
      case x: String if x == IPXACT2022scalaxb.fromXML[String](scala.xml.Text("spiceSource")) => IPXACT2022ScalaCases.SpiceSource
      case x: String if x == IPXACT2022scalaxb.fromXML[String](scala.xml.Text("systemRDL")) => IPXACT2022ScalaCases.SystemRDL
      case x: String if x == IPXACT2022scalaxb.fromXML[String](scala.xml.Text("systemRDL-1.0")) => IPXACT2022ScalaCases.SystemRDLu451u460
      case x: String if x == IPXACT2022scalaxb.fromXML[String](scala.xml.Text("systemRDL-2.0")) => IPXACT2022ScalaCases.SystemRDLu452u460
      case x: String if x == IPXACT2022scalaxb.fromXML[String](scala.xml.Text("user")) => IPXACT2022ScalaCases.User

    }



    def reads(seq: scala.xml.NodeSeq, stack: List[IPXACT2022scalaxb.ElemName]): Either[String, IPXACT2022ScalaCases.SimpleFileType] = seq match {
      case elem: scala.xml.Elem => Right(fromString(elem.text, elem.scope))
      case _ => Right(fromString(seq.text, scala.xml.TopScope))
    }
    
    def writes(__obj: IPXACT2022ScalaCases.SimpleFileType, __namespace: Option[String], __elementLabel: Option[String],
        __scope: scala.xml.NamespaceBinding, __typeAttribute: Boolean): scala.xml.NodeSeq =
      scala.xml.Elem(IPXACT2022scalaxb.Helper.getPrefix(__namespace, __scope).orNull,
        __elementLabel getOrElse { sys.error("missing element label.") },
        scala.xml.Null, __scope, true, scala.xml.Text(__obj.toString))
  }
  trait DefaultIPXACT2022ScalaCases_FileTypeFormat extends IPXACT2022scalaxb.XMLFormat[IPXACT2022ScalaCases.FileType] with IPXACT2022scalaxb.CanWriteChildNodes[IPXACT2022ScalaCases.FileType] {
    val targetNamespace: Option[String] = Some("http://www.accellera.org/XMLSchema/IPXACT/1685-2022")
    def reads(seq: scala.xml.NodeSeq, stack: List[IPXACT2022scalaxb.ElemName]): Either[String, IPXACT2022ScalaCases.FileType] = seq match {
      case node: scala.xml.Node => Right(IPXACT2022ScalaCases.FileType(IPXACT2022scalaxb.fromXML[IPXACT2022ScalaCases.SimpleFileType](node, IPXACT2022scalaxb.ElemName(node) :: stack),
        scala.collection.immutable.ListMap(List(
        (node \ "@user").headOption map { x => IPXACT2022scalaxb.DataRecord(x, node, IPXACT2022scalaxb.fromXML[String](x, IPXACT2022scalaxb.ElemName(node) :: stack)) } map { "@user" -> _ },
        (node \ "@libext").headOption map { x => IPXACT2022scalaxb.DataRecord(x, node, IPXACT2022scalaxb.fromXML[String](x, IPXACT2022scalaxb.ElemName(node) :: stack)) } map { "@libext" -> _ },
        (node \ "@{http://www.w3.org/XML/1998/namespace}id").headOption map { x => IPXACT2022scalaxb.DataRecord(x, node, IPXACT2022scalaxb.fromXML[String](x, IPXACT2022scalaxb.ElemName(node) :: stack)) } map { "@{http://www.w3.org/XML/1998/namespace}id" -> _ }
        ).flatten[(String, IPXACT2022scalaxb.DataRecord[Any])]: _*)))
      case _ => Left("reads failed: seq must be scala.xml.Node")
    }
    
    override def writesAttribute(__obj: IPXACT2022ScalaCases.FileType, __scope: scala.xml.NamespaceBinding): scala.xml.MetaData = {
      var attr: scala.xml.MetaData  = scala.xml.Null
      __obj.attributes.toList map {
        case ("@user", _) => __obj.user foreach { x => attr = scala.xml.Attribute(null, "user", x.toString, attr) }
        case ("@libext", _) => __obj.libext foreach { x => attr = scala.xml.Attribute(null, "libext", x.toString, attr) }
        case ("@{http://www.w3.org/XML/1998/namespace}id", _) => __obj.xmlid foreach { x => attr = scala.xml.Attribute(__scope.getPrefix("http://www.w3.org/XML/1998/namespace"), "id", x.toString, attr) }
        case (key, x) => attr = scala.xml.Attribute((x.namespace map { __scope.getPrefix(_) }).orNull, x.key.orNull, x.value.toString, attr)
      }
      attr
    }

    def writesChildNodes(__obj: IPXACT2022ScalaCases.FileType, __scope: scala.xml.NamespaceBinding): Seq[scala.xml.Node] =
      Seq(scala.xml.Text(__obj.value.toString))

  }

  trait DefaultIPXACT2022ScalaCases_GeneratorChainSelectorFormat extends IPXACT2022scalaxb.ElemNameParser[IPXACT2022ScalaCases.GeneratorChainSelector] {
    val targetNamespace: Option[String] = Some("http://www.accellera.org/XMLSchema/IPXACT/1685-2022")
    
    def parser(node: scala.xml.Node, stack: List[IPXACT2022scalaxb.ElemName]): Parser[IPXACT2022ScalaCases.GeneratorChainSelector] =
      phrase((((IPXACT2022scalaxb.ElemName(Some("http://www.accellera.org/XMLSchema/IPXACT/1685-2022"), "groupSelector")) ^^
      (x => IPXACT2022scalaxb.DataRecord(x.namespace, Some(x.name), IPXACT2022scalaxb.fromXML[IPXACT2022ScalaCases.GroupSelector](x, IPXACT2022scalaxb.ElemName(node) :: stack)))) |
      ((IPXACT2022scalaxb.ElemName(Some("http://www.accellera.org/XMLSchema/IPXACT/1685-2022"), "generatorChainRef")) ^^
      (x => IPXACT2022scalaxb.DataRecord(x.namespace, Some(x.name), IPXACT2022scalaxb.fromXML[IPXACT2022ScalaCases.ConfigurableLibraryRefType](x, IPXACT2022scalaxb.ElemName(node) :: stack))))) ^^
      { case p1 =>
      IPXACT2022ScalaCases.GeneratorChainSelector(p1,
        scala.collection.immutable.ListMap(List(
        (node \ "@unique").headOption map { x => IPXACT2022scalaxb.DataRecord(x, node, IPXACT2022scalaxb.fromXML[Boolean](x, IPXACT2022scalaxb.ElemName(node) :: stack)) } orElse Some(IPXACT2022scalaxb.DataRecord(None, None, IPXACT2022scalaxb.fromXML[Boolean](scala.xml.Text("false"), IPXACT2022scalaxb.ElemName(node) :: stack))) map { "@unique" -> _ },
        (node \ "@{http://www.w3.org/XML/1998/namespace}id").headOption map { x => IPXACT2022scalaxb.DataRecord(x, node, IPXACT2022scalaxb.fromXML[String](x, IPXACT2022scalaxb.ElemName(node) :: stack)) } map { "@{http://www.w3.org/XML/1998/namespace}id" -> _ }
        ).flatten[(String, IPXACT2022scalaxb.DataRecord[Any])]: _*)) })
    
    override def writesAttribute(__obj: IPXACT2022ScalaCases.GeneratorChainSelector, __scope: scala.xml.NamespaceBinding): scala.xml.MetaData = {
      var attr: scala.xml.MetaData  = scala.xml.Null
      __obj.attributes.toList map {
        case ("@unique", _) => if (__obj.unique.toString != "false") attr = scala.xml.Attribute(null, "unique", __obj.unique.toString, attr)
        case ("@{http://www.w3.org/XML/1998/namespace}id", _) => __obj.xmlid foreach { x => attr = scala.xml.Attribute(__scope.getPrefix("http://www.w3.org/XML/1998/namespace"), "id", x.toString, attr) }
        case (key, x) => attr = scala.xml.Attribute((x.namespace map { __scope.getPrefix(_) }).orNull, x.key.orNull, x.value.toString, attr)
      }
      attr
    }

    def writesChildNodes(__obj: IPXACT2022ScalaCases.GeneratorChainSelector, __scope: scala.xml.NamespaceBinding): Seq[scala.xml.Node] =
      ((Some(__obj.generatorchainselectoroption) map {x => IPXACT2022scalaxb.toXML[IPXACT2022scalaxb.DataRecord[IPXACT2022ScalaCases.GeneratorChainSelectorOption]](x, x.namespace, x.key, __scope, false)}).get)
  }

  trait DefaultIPXACT2022ScalaCases_ChainGroupFormat extends IPXACT2022scalaxb.XMLFormat[IPXACT2022ScalaCases.ChainGroup] with IPXACT2022scalaxb.CanWriteChildNodes[IPXACT2022ScalaCases.ChainGroup] {
    val targetNamespace: Option[String] = Some("http://www.accellera.org/XMLSchema/IPXACT/1685-2022")
    def reads(seq: scala.xml.NodeSeq, stack: List[IPXACT2022scalaxb.ElemName]): Either[String, IPXACT2022ScalaCases.ChainGroup] = seq match {
      case node: scala.xml.Node => Right(IPXACT2022ScalaCases.ChainGroup(IPXACT2022scalaxb.fromXML[String](node, IPXACT2022scalaxb.ElemName(node) :: stack),
        scala.collection.immutable.ListMap(List(
        (node \ "@{http://www.w3.org/XML/1998/namespace}id").headOption map { x => IPXACT2022scalaxb.DataRecord(x, node, IPXACT2022scalaxb.fromXML[String](x, IPXACT2022scalaxb.ElemName(node) :: stack)) } map { "@{http://www.w3.org/XML/1998/namespace}id" -> _ }
        ).flatten[(String, IPXACT2022scalaxb.DataRecord[Any])]: _*)))
      case _ => Left("reads failed: seq must be scala.xml.Node")
    }
    
    override def writesAttribute(__obj: IPXACT2022ScalaCases.ChainGroup, __scope: scala.xml.NamespaceBinding): scala.xml.MetaData = {
      var attr: scala.xml.MetaData  = scala.xml.Null
      __obj.attributes.toList map {
        case ("@{http://www.w3.org/XML/1998/namespace}id", _) => __obj.xmlid foreach { x => attr = scala.xml.Attribute(__scope.getPrefix("http://www.w3.org/XML/1998/namespace"), "id", x.toString, attr) }
        case (key, x) => attr = scala.xml.Attribute((x.namespace map { __scope.getPrefix(_) }).orNull, x.key.orNull, x.value.toString, attr)
      }
      attr
    }

    def writesChildNodes(__obj: IPXACT2022ScalaCases.ChainGroup, __scope: scala.xml.NamespaceBinding): Seq[scala.xml.Node] =
      Seq(scala.xml.Text(__obj.value.toString))

  }

  trait DefaultIPXACT2022ScalaCases_GeneratorChainFormat extends IPXACT2022scalaxb.ElemNameParser[IPXACT2022ScalaCases.GeneratorChain] with IPXACT2022ScalaCases_DocumentNameGroupGroupFormat {
    val targetNamespace: Option[String] = Some("http://www.accellera.org/XMLSchema/IPXACT/1685-2022")
    
    def parser(node: scala.xml.Node, stack: List[IPXACT2022scalaxb.ElemName]): Parser[IPXACT2022ScalaCases.GeneratorChain] =
      phrase((parseDocumentNameGroupGroup(node, IPXACT2022scalaxb.ElemName(node) :: stack)) ~
      safeRep(((IPXACT2022scalaxb.ElemName(Some("http://www.accellera.org/XMLSchema/IPXACT/1685-2022"), "generatorChainSelector")) ^^
      (x => IPXACT2022scalaxb.DataRecord(x.namespace, Some(x.name), IPXACT2022scalaxb.fromXML[IPXACT2022ScalaCases.GeneratorChainSelector](x, IPXACT2022scalaxb.ElemName(node) :: stack)))) |
      ((IPXACT2022scalaxb.ElemName(Some("http://www.accellera.org/XMLSchema/IPXACT/1685-2022"), "componentGeneratorSelector")) ^^
      (x => IPXACT2022scalaxb.DataRecord(x.namespace, Some(x.name), IPXACT2022scalaxb.fromXML[IPXACT2022ScalaCases.GeneratorSelectorType](x, IPXACT2022scalaxb.ElemName(node) :: stack)))) |
      ((IPXACT2022scalaxb.ElemName(Some("http://www.accellera.org/XMLSchema/IPXACT/1685-2022"), "generator")) ^^
      (x => IPXACT2022scalaxb.DataRecord(x.namespace, Some(x.name), IPXACT2022scalaxb.fromXML[IPXACT2022ScalaCases.Generator](x, IPXACT2022scalaxb.ElemName(node) :: stack))))) ~
      safeRep(IPXACT2022scalaxb.ElemName(Some("http://www.accellera.org/XMLSchema/IPXACT/1685-2022"), "chainGroup")) ~
      opt(IPXACT2022scalaxb.ElemName(Some("http://www.accellera.org/XMLSchema/IPXACT/1685-2022"), "choices")) ~
      opt(IPXACT2022scalaxb.ElemName(Some("http://www.accellera.org/XMLSchema/IPXACT/1685-2022"), "parameters")) ~
      opt(IPXACT2022scalaxb.ElemName(Some("http://www.accellera.org/XMLSchema/IPXACT/1685-2022"), "assertions")) ~
      opt(IPXACT2022scalaxb.ElemName(Some("http://www.accellera.org/XMLSchema/IPXACT/1685-2022"), "vendorExtensions")) ^^
      { case p1 ~ p2 ~ p3 ~ p4 ~ p5 ~ p6 ~ p7 =>
      IPXACT2022ScalaCases.GeneratorChain(p1,
        p2,
        p3 map { IPXACT2022scalaxb.fromXML[IPXACT2022ScalaCases.ChainGroup](_, IPXACT2022scalaxb.ElemName(node) :: stack) },
        p4.headOption map { IPXACT2022scalaxb.fromXML[IPXACT2022ScalaCases.Choices](_, IPXACT2022scalaxb.ElemName(node) :: stack) },
        p5.headOption map { IPXACT2022scalaxb.fromXML[IPXACT2022ScalaCases.Parameters](_, IPXACT2022scalaxb.ElemName(node) :: stack) },
        p6.headOption map { IPXACT2022scalaxb.fromXML[IPXACT2022ScalaCases.Assertions](_, IPXACT2022scalaxb.ElemName(node) :: stack) },
        p7.headOption map { IPXACT2022scalaxb.fromXML[IPXACT2022ScalaCases.VendorExtensions](_, IPXACT2022scalaxb.ElemName(node) :: stack) },
        scala.collection.immutable.ListMap(List(
        (node \ "@hidden").headOption map { x => IPXACT2022scalaxb.DataRecord(x, node, IPXACT2022scalaxb.fromXML[Boolean](x, IPXACT2022scalaxb.ElemName(node) :: stack)) } orElse Some(IPXACT2022scalaxb.DataRecord(None, None, IPXACT2022scalaxb.fromXML[Boolean](scala.xml.Text("false"), IPXACT2022scalaxb.ElemName(node) :: stack))) map { "@hidden" -> _ },
        (node \ "@{http://www.w3.org/XML/1998/namespace}id").headOption map { x => IPXACT2022scalaxb.DataRecord(x, node, IPXACT2022scalaxb.fromXML[String](x, IPXACT2022scalaxb.ElemName(node) :: stack)) } map { "@{http://www.w3.org/XML/1998/namespace}id" -> _ }
        ).flatten[(String, IPXACT2022scalaxb.DataRecord[Any])]: _*)) })
    
    override def writesAttribute(__obj: IPXACT2022ScalaCases.GeneratorChain, __scope: scala.xml.NamespaceBinding): scala.xml.MetaData = {
      var attr: scala.xml.MetaData  = scala.xml.Null
      __obj.attributes.toList map {
        case ("@hidden", _) => if (__obj.hidden.toString != "false") attr = scala.xml.Attribute(null, "hidden", __obj.hidden.toString, attr)
        case ("@{http://www.w3.org/XML/1998/namespace}id", _) => __obj.xmlid foreach { x => attr = scala.xml.Attribute(__scope.getPrefix("http://www.w3.org/XML/1998/namespace"), "id", x.toString, attr) }
        case (key, x) => attr = scala.xml.Attribute((x.namespace map { __scope.getPrefix(_) }).orNull, x.key.orNull, x.value.toString, attr)
      }
      attr
    }

    def writesChildNodes(__obj: IPXACT2022ScalaCases.GeneratorChain, __scope: scala.xml.NamespaceBinding): Seq[scala.xml.Node] =
      Seq.concat(IPXACT2022scalaxb.toXML[IPXACT2022ScalaCases.DocumentNameGroupSequence](__obj.documentNameGroupSequence1, None, Some("documentNameGroupSequence1"), __scope, false),
        __obj.generatorchainoption flatMap { x => IPXACT2022scalaxb.toXML[IPXACT2022scalaxb.DataRecord[IPXACT2022ScalaCases.GeneratorChainOption]](x, x.namespace, x.key, __scope, false) },
        __obj.chainGroup flatMap { IPXACT2022scalaxb.toXML[IPXACT2022ScalaCases.ChainGroup](_, Some("http://www.accellera.org/XMLSchema/IPXACT/1685-2022"), Some("chainGroup"), __scope, false) },
        __obj.choices map { IPXACT2022scalaxb.toXML[IPXACT2022ScalaCases.Choices](_, Some("http://www.accellera.org/XMLSchema/IPXACT/1685-2022"), Some("choices"), __scope, false) } getOrElse {Nil},
        __obj.parameters map { IPXACT2022scalaxb.toXML[IPXACT2022ScalaCases.Parameters](_, Some("http://www.accellera.org/XMLSchema/IPXACT/1685-2022"), Some("parameters"), __scope, false) } getOrElse {Nil},
        __obj.assertions map { IPXACT2022scalaxb.toXML[IPXACT2022ScalaCases.Assertions](_, Some("http://www.accellera.org/XMLSchema/IPXACT/1685-2022"), Some("assertions"), __scope, false) } getOrElse {Nil},
        __obj.vendorExtensions map { IPXACT2022scalaxb.toXML[IPXACT2022ScalaCases.VendorExtensions](_, Some("http://www.accellera.org/XMLSchema/IPXACT/1685-2022"), Some("vendorExtensions"), __scope, false) } getOrElse {Nil})

  }

  trait DefaultIPXACT2022ScalaCases_GeneratorFormat extends IPXACT2022scalaxb.ElemNameParser[IPXACT2022ScalaCases.Generator] with IPXACT2022ScalaCases_NameGroupGroupFormat {
    val targetNamespace: Option[String] = Some("http://www.accellera.org/XMLSchema/IPXACT/1685-2022")
    
    def parser(node: scala.xml.Node, stack: List[IPXACT2022scalaxb.ElemName]): Parser[IPXACT2022ScalaCases.Generator] =
      phrase((parseNameGroupGroup(node, IPXACT2022scalaxb.ElemName(node) :: stack)) ~
      opt(IPXACT2022scalaxb.ElemName(Some("http://www.accellera.org/XMLSchema/IPXACT/1685-2022"), "phase")) ~
      opt(IPXACT2022scalaxb.ElemName(Some("http://www.accellera.org/XMLSchema/IPXACT/1685-2022"), "parameters")) ~
      opt(IPXACT2022scalaxb.ElemName(Some("http://www.accellera.org/XMLSchema/IPXACT/1685-2022"), "apiType")) ~
      opt(IPXACT2022scalaxb.ElemName(Some("http://www.accellera.org/XMLSchema/IPXACT/1685-2022"), "apiService")) ~
      opt(IPXACT2022scalaxb.ElemName(Some("http://www.accellera.org/XMLSchema/IPXACT/1685-2022"), "transportMethods")) ~
      (IPXACT2022scalaxb.ElemName(Some("http://www.accellera.org/XMLSchema/IPXACT/1685-2022"), "generatorExe")) ~
      opt(IPXACT2022scalaxb.ElemName(Some("http://www.accellera.org/XMLSchema/IPXACT/1685-2022"), "vendorExtensions")) ^^
      { case p1 ~ p2 ~ p3 ~ p4 ~ p5 ~ p6 ~ p7 ~ p8 =>
      IPXACT2022ScalaCases.Generator(p1,
        p2.headOption map { IPXACT2022scalaxb.fromXML[IPXACT2022ScalaCases.RealExpressionable](_, IPXACT2022scalaxb.ElemName(node) :: stack) },
        p3.headOption map { IPXACT2022scalaxb.fromXML[IPXACT2022ScalaCases.Parameters](_, IPXACT2022scalaxb.ElemName(node) :: stack) },
        p4.headOption map { IPXACT2022scalaxb.fromXML[IPXACT2022ScalaCases.ApiType](_, IPXACT2022scalaxb.ElemName(node) :: stack) },
        p5.headOption map { IPXACT2022scalaxb.fromXML[IPXACT2022ScalaCases.ApiService](_, IPXACT2022scalaxb.ElemName(node) :: stack) },
        p6.headOption map { IPXACT2022scalaxb.fromXML[IPXACT2022ScalaCases.TransportMethods](_, IPXACT2022scalaxb.ElemName(node) :: stack) },
        IPXACT2022scalaxb.fromXML[IPXACT2022ScalaCases.IpxactURIable](p7, IPXACT2022scalaxb.ElemName(node) :: stack),
        p8.headOption map { IPXACT2022scalaxb.fromXML[IPXACT2022ScalaCases.VendorExtensions](_, IPXACT2022scalaxb.ElemName(node) :: stack) },
        scala.collection.immutable.ListMap(List(
        (node \ "@hidden").headOption map { x => IPXACT2022scalaxb.DataRecord(x, node, IPXACT2022scalaxb.fromXML[Boolean](x, IPXACT2022scalaxb.ElemName(node) :: stack)) } orElse Some(IPXACT2022scalaxb.DataRecord(None, None, IPXACT2022scalaxb.fromXML[Boolean](scala.xml.Text("false"), IPXACT2022scalaxb.ElemName(node) :: stack))) map { "@hidden" -> _ },
        (node \ "@{http://www.w3.org/XML/1998/namespace}id").headOption map { x => IPXACT2022scalaxb.DataRecord(x, node, IPXACT2022scalaxb.fromXML[String](x, IPXACT2022scalaxb.ElemName(node) :: stack)) } map { "@{http://www.w3.org/XML/1998/namespace}id" -> _ }
        ).flatten[(String, IPXACT2022scalaxb.DataRecord[Any])]: _*)) })
    
    override def writesAttribute(__obj: IPXACT2022ScalaCases.Generator, __scope: scala.xml.NamespaceBinding): scala.xml.MetaData = {
      var attr: scala.xml.MetaData  = scala.xml.Null
      __obj.attributes.toList map {
        case ("@hidden", _) => if (__obj.hidden.toString != "false") attr = scala.xml.Attribute(null, "hidden", __obj.hidden.toString, attr)
        case ("@{http://www.w3.org/XML/1998/namespace}id", _) => __obj.xmlid foreach { x => attr = scala.xml.Attribute(__scope.getPrefix("http://www.w3.org/XML/1998/namespace"), "id", x.toString, attr) }
        case (key, x) => attr = scala.xml.Attribute((x.namespace map { __scope.getPrefix(_) }).orNull, x.key.orNull, x.value.toString, attr)
      }
      attr
    }

    def writesChildNodes(__obj: IPXACT2022ScalaCases.Generator, __scope: scala.xml.NamespaceBinding): Seq[scala.xml.Node] =
      Seq.concat(IPXACT2022scalaxb.toXML[IPXACT2022ScalaCases.NameGroupSequence](__obj.nameGroupSequence1, None, Some("nameGroupSequence1"), __scope, false),
        __obj.phase map { IPXACT2022scalaxb.toXML[IPXACT2022ScalaCases.RealExpressionable](_, Some("http://www.accellera.org/XMLSchema/IPXACT/1685-2022"), Some("phase"), __scope, false) } getOrElse {Nil},
        __obj.parameters map { IPXACT2022scalaxb.toXML[IPXACT2022ScalaCases.Parameters](_, Some("http://www.accellera.org/XMLSchema/IPXACT/1685-2022"), Some("parameters"), __scope, false) } getOrElse {Nil},
        __obj.apiType map { IPXACT2022scalaxb.toXML[IPXACT2022ScalaCases.ApiType](_, Some("http://www.accellera.org/XMLSchema/IPXACT/1685-2022"), Some("apiType"), __scope, false) } getOrElse {Nil},
        __obj.apiService map { IPXACT2022scalaxb.toXML[IPXACT2022ScalaCases.ApiService](_, Some("http://www.accellera.org/XMLSchema/IPXACT/1685-2022"), Some("apiService"), __scope, false) } getOrElse {Nil},
        __obj.transportMethods map { IPXACT2022scalaxb.toXML[IPXACT2022ScalaCases.TransportMethods](_, Some("http://www.accellera.org/XMLSchema/IPXACT/1685-2022"), Some("transportMethods"), __scope, false) } getOrElse {Nil},
        IPXACT2022scalaxb.toXML[IPXACT2022ScalaCases.IpxactURIable](__obj.generatorExe, Some("http://www.accellera.org/XMLSchema/IPXACT/1685-2022"), Some("generatorExe"), __scope, false),
        __obj.vendorExtensions map { IPXACT2022scalaxb.toXML[IPXACT2022ScalaCases.VendorExtensions](_, Some("http://www.accellera.org/XMLSchema/IPXACT/1685-2022"), Some("vendorExtensions"), __scope, false) } getOrElse {Nil})

  }

  def buildIPXACT2022ScalaCases_MultipleGroupSelectionOperatorFormat = new DefaultIPXACT2022ScalaCases_MultipleGroupSelectionOperatorFormat {}
  trait DefaultIPXACT2022ScalaCases_MultipleGroupSelectionOperatorFormat extends IPXACT2022scalaxb.XMLFormat[IPXACT2022ScalaCases.MultipleGroupSelectionOperator] {
    val targetNamespace: Option[String] = Some("http://www.accellera.org/XMLSchema/IPXACT/1685-2022")
    
    def fromString(value: String, scope: scala.xml.NamespaceBinding): IPXACT2022ScalaCases.MultipleGroupSelectionOperator =
        (fromString0(value, scope)).apply(IPXACT2022scalaxb.fromXML[String](scala.xml.Text(value)))

    private def fromString0(value: String, scope: scala.xml.NamespaceBinding): PartialFunction[Any, IPXACT2022ScalaCases.MultipleGroupSelectionOperator] = {
      case x: String if x == IPXACT2022scalaxb.fromXML[String](scala.xml.Text("and")) => IPXACT2022ScalaCases.And
      case x: String if x == IPXACT2022scalaxb.fromXML[String](scala.xml.Text("or")) => IPXACT2022ScalaCases.Or

    }



    def reads(seq: scala.xml.NodeSeq, stack: List[IPXACT2022scalaxb.ElemName]): Either[String, IPXACT2022ScalaCases.MultipleGroupSelectionOperator] = seq match {
      case elem: scala.xml.Elem => Right(fromString(elem.text, elem.scope))
      case _ => Right(fromString(seq.text, scala.xml.TopScope))
    }
    
    def writes(__obj: IPXACT2022ScalaCases.MultipleGroupSelectionOperator, __namespace: Option[String], __elementLabel: Option[String],
        __scope: scala.xml.NamespaceBinding, __typeAttribute: Boolean): scala.xml.NodeSeq =
      scala.xml.Elem(IPXACT2022scalaxb.Helper.getPrefix(__namespace, __scope).orNull,
        __elementLabel getOrElse { sys.error("missing element label.") },
        scala.xml.Null, __scope, true, scala.xml.Text(__obj.toString))
  }
  trait DefaultIPXACT2022ScalaCases_NameFormat extends IPXACT2022scalaxb.XMLFormat[IPXACT2022ScalaCases.Name] with IPXACT2022scalaxb.CanWriteChildNodes[IPXACT2022ScalaCases.Name] {
    val targetNamespace: Option[String] = Some("http://www.accellera.org/XMLSchema/IPXACT/1685-2022")
    def reads(seq: scala.xml.NodeSeq, stack: List[IPXACT2022scalaxb.ElemName]): Either[String, IPXACT2022ScalaCases.Name] = seq match {
      case node: scala.xml.Node => Right(IPXACT2022ScalaCases.Name(IPXACT2022scalaxb.fromXML[String](node, IPXACT2022scalaxb.ElemName(node) :: stack),
        scala.collection.immutable.ListMap(List(
        (node \ "@{http://www.w3.org/XML/1998/namespace}id").headOption map { x => IPXACT2022scalaxb.DataRecord(x, node, IPXACT2022scalaxb.fromXML[String](x, IPXACT2022scalaxb.ElemName(node) :: stack)) } map { "@{http://www.w3.org/XML/1998/namespace}id" -> _ }
        ).flatten[(String, IPXACT2022scalaxb.DataRecord[Any])]: _*)))
      case _ => Left("reads failed: seq must be scala.xml.Node")
    }
    
    override def writesAttribute(__obj: IPXACT2022ScalaCases.Name, __scope: scala.xml.NamespaceBinding): scala.xml.MetaData = {
      var attr: scala.xml.MetaData  = scala.xml.Null
      __obj.attributes.toList map {
        case ("@{http://www.w3.org/XML/1998/namespace}id", _) => __obj.xmlid foreach { x => attr = scala.xml.Attribute(__scope.getPrefix("http://www.w3.org/XML/1998/namespace"), "id", x.toString, attr) }
        case (key, x) => attr = scala.xml.Attribute((x.namespace map { __scope.getPrefix(_) }).orNull, x.key.orNull, x.value.toString, attr)
      }
      attr
    }

    def writesChildNodes(__obj: IPXACT2022ScalaCases.Name, __scope: scala.xml.NamespaceBinding): Seq[scala.xml.Node] =
      Seq(scala.xml.Text(__obj.value.toString))

  }

  trait DefaultIPXACT2022ScalaCases_GroupSelectorFormat extends IPXACT2022scalaxb.ElemNameParser[IPXACT2022ScalaCases.GroupSelector] {
    val targetNamespace: Option[String] = Some("http://www.accellera.org/XMLSchema/IPXACT/1685-2022")
    
    def parser(node: scala.xml.Node, stack: List[IPXACT2022scalaxb.ElemName]): Parser[IPXACT2022ScalaCases.GroupSelector] =
      phrase(safeRep(IPXACT2022scalaxb.ElemName(Some("http://www.accellera.org/XMLSchema/IPXACT/1685-2022"), "name")) ^^
      { case p1 =>
      IPXACT2022ScalaCases.GroupSelector(p1 map { IPXACT2022scalaxb.fromXML[IPXACT2022ScalaCases.Name](_, IPXACT2022scalaxb.ElemName(node) :: stack) },
        scala.collection.immutable.ListMap(List(
        (node \ "@multipleGroupSelectionOperator").headOption map { x => IPXACT2022scalaxb.DataRecord(x, node, IPXACT2022scalaxb.fromXML[IPXACT2022ScalaCases.MultipleGroupSelectionOperator](x, IPXACT2022scalaxb.ElemName(node) :: stack)) } orElse Some(IPXACT2022scalaxb.DataRecord(None, None, IPXACT2022scalaxb.fromXML[IPXACT2022ScalaCases.MultipleGroupSelectionOperator](scala.xml.Text("or"), IPXACT2022scalaxb.ElemName(node) :: stack))) map { "@multipleGroupSelectionOperator" -> _ },
        (node \ "@{http://www.w3.org/XML/1998/namespace}id").headOption map { x => IPXACT2022scalaxb.DataRecord(x, node, IPXACT2022scalaxb.fromXML[String](x, IPXACT2022scalaxb.ElemName(node) :: stack)) } map { "@{http://www.w3.org/XML/1998/namespace}id" -> _ }
        ).flatten[(String, IPXACT2022scalaxb.DataRecord[Any])]: _*)) })
    
    override def writesAttribute(__obj: IPXACT2022ScalaCases.GroupSelector, __scope: scala.xml.NamespaceBinding): scala.xml.MetaData = {
      var attr: scala.xml.MetaData  = scala.xml.Null
      __obj.attributes.toList map {
        case ("@multipleGroupSelectionOperator", _) => if (__obj.multipleGroupSelectionOperator.toString != "or") attr = scala.xml.Attribute(null, "multipleGroupSelectionOperator", __obj.multipleGroupSelectionOperator.toString, attr)
        case ("@{http://www.w3.org/XML/1998/namespace}id", _) => __obj.xmlid foreach { x => attr = scala.xml.Attribute(__scope.getPrefix("http://www.w3.org/XML/1998/namespace"), "id", x.toString, attr) }
        case (key, x) => attr = scala.xml.Attribute((x.namespace map { __scope.getPrefix(_) }).orNull, x.key.orNull, x.value.toString, attr)
      }
      attr
    }

    def writesChildNodes(__obj: IPXACT2022ScalaCases.GroupSelector, __scope: scala.xml.NamespaceBinding): Seq[scala.xml.Node] =
      (__obj.name flatMap { IPXACT2022scalaxb.toXML[IPXACT2022ScalaCases.Name](_, Some("http://www.accellera.org/XMLSchema/IPXACT/1685-2022"), Some("name"), __scope, false) })
  }

  trait DefaultIPXACT2022ScalaCases_GroupFormat extends IPXACT2022scalaxb.XMLFormat[IPXACT2022ScalaCases.Group] with IPXACT2022scalaxb.CanWriteChildNodes[IPXACT2022ScalaCases.Group] {
    val targetNamespace: Option[String] = Some("http://www.accellera.org/XMLSchema/IPXACT/1685-2022")
    def reads(seq: scala.xml.NodeSeq, stack: List[IPXACT2022scalaxb.ElemName]): Either[String, IPXACT2022ScalaCases.Group] = seq match {
      case node: scala.xml.Node => Right(IPXACT2022ScalaCases.Group(IPXACT2022scalaxb.fromXML[String](node, IPXACT2022scalaxb.ElemName(node) :: stack),
        scala.collection.immutable.ListMap(List(
        (node \ "@{http://www.w3.org/XML/1998/namespace}id").headOption map { x => IPXACT2022scalaxb.DataRecord(x, node, IPXACT2022scalaxb.fromXML[String](x, IPXACT2022scalaxb.ElemName(node) :: stack)) } map { "@{http://www.w3.org/XML/1998/namespace}id" -> _ }
        ).flatten[(String, IPXACT2022scalaxb.DataRecord[Any])]: _*)))
      case _ => Left("reads failed: seq must be scala.xml.Node")
    }
    
    override def writesAttribute(__obj: IPXACT2022ScalaCases.Group, __scope: scala.xml.NamespaceBinding): scala.xml.MetaData = {
      var attr: scala.xml.MetaData  = scala.xml.Null
      __obj.attributes.toList map {
        case ("@{http://www.w3.org/XML/1998/namespace}id", _) => __obj.xmlid foreach { x => attr = scala.xml.Attribute(__scope.getPrefix("http://www.w3.org/XML/1998/namespace"), "id", x.toString, attr) }
        case (key, x) => attr = scala.xml.Attribute((x.namespace map { __scope.getPrefix(_) }).orNull, x.key.orNull, x.value.toString, attr)
      }
      attr
    }

    def writesChildNodes(__obj: IPXACT2022ScalaCases.Group, __scope: scala.xml.NamespaceBinding): Seq[scala.xml.Node] =
      Seq(scala.xml.Text(__obj.value.toString))

  }

  def buildIPXACT2022ScalaCases_ScopeFormat = new DefaultIPXACT2022ScalaCases_ScopeFormat {}
  trait DefaultIPXACT2022ScalaCases_ScopeFormat extends IPXACT2022scalaxb.XMLFormat[IPXACT2022ScalaCases.Scope] {
    val targetNamespace: Option[String] = Some("http://www.accellera.org/XMLSchema/IPXACT/1685-2022")
    
    def fromString(value: String, scope: scala.xml.NamespaceBinding): IPXACT2022ScalaCases.Scope =
        (fromString0(value, scope)).apply(IPXACT2022scalaxb.fromXML[String](scala.xml.Text(value)))

    private def fromString0(value: String, scope: scala.xml.NamespaceBinding): PartialFunction[Any, IPXACT2022ScalaCases.Scope] = {
      case x: String if x == IPXACT2022scalaxb.fromXML[String](scala.xml.Text("instance")) => IPXACT2022ScalaCases.Instance
      case x: String if x == IPXACT2022scalaxb.fromXML[String](scala.xml.Text("entity")) => IPXACT2022ScalaCases.Entity

    }



    def reads(seq: scala.xml.NodeSeq, stack: List[IPXACT2022scalaxb.ElemName]): Either[String, IPXACT2022ScalaCases.Scope] = seq match {
      case elem: scala.xml.Elem => Right(fromString(elem.text, elem.scope))
      case _ => Right(fromString(seq.text, scala.xml.TopScope))
    }
    
    def writes(__obj: IPXACT2022ScalaCases.Scope, __namespace: Option[String], __elementLabel: Option[String],
        __scope: scala.xml.NamespaceBinding, __typeAttribute: Boolean): scala.xml.NodeSeq =
      scala.xml.Elem(IPXACT2022scalaxb.Helper.getPrefix(__namespace, __scope).orNull,
        __elementLabel getOrElse { sys.error("missing element label.") },
        scala.xml.Null, __scope, true, scala.xml.Text(__obj.toString))
  }
  trait DefaultIPXACT2022ScalaCases_InstanceGeneratorTypeFormat extends IPXACT2022scalaxb.ElemNameParser[IPXACT2022ScalaCases.InstanceGeneratorType] with IPXACT2022ScalaCases_NameGroupGroupFormat {
    val targetNamespace: Option[String] = Some("http://www.accellera.org/XMLSchema/IPXACT/1685-2022")
    
    override def typeName: Option[String] = Some("instanceGeneratorType")

    def parser(node: scala.xml.Node, stack: List[IPXACT2022scalaxb.ElemName]): Parser[IPXACT2022ScalaCases.InstanceGeneratorType] =
      phrase((parseNameGroupGroup(node, IPXACT2022scalaxb.ElemName(node) :: stack)) ~
      opt(IPXACT2022scalaxb.ElemName(Some("http://www.accellera.org/XMLSchema/IPXACT/1685-2022"), "phase")) ~
      opt(IPXACT2022scalaxb.ElemName(Some("http://www.accellera.org/XMLSchema/IPXACT/1685-2022"), "parameters")) ~
      opt(IPXACT2022scalaxb.ElemName(Some("http://www.accellera.org/XMLSchema/IPXACT/1685-2022"), "apiType")) ~
      opt(IPXACT2022scalaxb.ElemName(Some("http://www.accellera.org/XMLSchema/IPXACT/1685-2022"), "apiService")) ~
      opt(IPXACT2022scalaxb.ElemName(Some("http://www.accellera.org/XMLSchema/IPXACT/1685-2022"), "transportMethods")) ~
      (IPXACT2022scalaxb.ElemName(Some("http://www.accellera.org/XMLSchema/IPXACT/1685-2022"), "generatorExe")) ~
      opt(IPXACT2022scalaxb.ElemName(Some("http://www.accellera.org/XMLSchema/IPXACT/1685-2022"), "vendorExtensions")) ~
      safeRep(IPXACT2022scalaxb.ElemName(Some("http://www.accellera.org/XMLSchema/IPXACT/1685-2022"), "group")) ^^
      { case p1 ~ p2 ~ p3 ~ p4 ~ p5 ~ p6 ~ p7 ~ p8 ~ p9 =>
      IPXACT2022ScalaCases.InstanceGeneratorType(p1,
        p2.headOption map { IPXACT2022scalaxb.fromXML[IPXACT2022ScalaCases.RealExpressionable](_, IPXACT2022scalaxb.ElemName(node) :: stack) },
        p3.headOption map { IPXACT2022scalaxb.fromXML[IPXACT2022ScalaCases.Parameters](_, IPXACT2022scalaxb.ElemName(node) :: stack) },
        p4.headOption map { IPXACT2022scalaxb.fromXML[IPXACT2022ScalaCases.ApiType](_, IPXACT2022scalaxb.ElemName(node) :: stack) },
        p5.headOption map { IPXACT2022scalaxb.fromXML[IPXACT2022ScalaCases.ApiService](_, IPXACT2022scalaxb.ElemName(node) :: stack) },
        p6.headOption map { IPXACT2022scalaxb.fromXML[IPXACT2022ScalaCases.TransportMethods](_, IPXACT2022scalaxb.ElemName(node) :: stack) },
        IPXACT2022scalaxb.fromXML[IPXACT2022ScalaCases.IpxactURIable](p7, IPXACT2022scalaxb.ElemName(node) :: stack),
        p8.headOption map { IPXACT2022scalaxb.fromXML[IPXACT2022ScalaCases.VendorExtensions](_, IPXACT2022scalaxb.ElemName(node) :: stack) },
        p9 map { IPXACT2022scalaxb.fromXML[IPXACT2022ScalaCases.Group](_, IPXACT2022scalaxb.ElemName(node) :: stack) },
        scala.collection.immutable.ListMap(List(
        (node \ "@hidden").headOption map { x => IPXACT2022scalaxb.DataRecord(x, node, IPXACT2022scalaxb.fromXML[Boolean](x, IPXACT2022scalaxb.ElemName(node) :: stack)) } orElse Some(IPXACT2022scalaxb.DataRecord(None, None, IPXACT2022scalaxb.fromXML[Boolean](scala.xml.Text("false"), IPXACT2022scalaxb.ElemName(node) :: stack))) map { "@hidden" -> _ },
        (node \ "@{http://www.w3.org/XML/1998/namespace}id").headOption map { x => IPXACT2022scalaxb.DataRecord(x, node, IPXACT2022scalaxb.fromXML[String](x, IPXACT2022scalaxb.ElemName(node) :: stack)) } map { "@{http://www.w3.org/XML/1998/namespace}id" -> _ },
        (node \ "@scope").headOption map { x => IPXACT2022scalaxb.DataRecord(x, node, IPXACT2022scalaxb.fromXML[IPXACT2022ScalaCases.Scope](x, IPXACT2022scalaxb.ElemName(node) :: stack)) } orElse Some(IPXACT2022scalaxb.DataRecord(None, None, IPXACT2022scalaxb.fromXML[IPXACT2022ScalaCases.Scope](scala.xml.Text("instance"), IPXACT2022scalaxb.ElemName(node) :: stack))) map { "@scope" -> _ }
        ).flatten[(String, IPXACT2022scalaxb.DataRecord[Any])]: _*)) })
    
    override def writesAttribute(__obj: IPXACT2022ScalaCases.InstanceGeneratorType, __scope: scala.xml.NamespaceBinding): scala.xml.MetaData = {
      var attr: scala.xml.MetaData  = scala.xml.Null
      __obj.attributes.toList map {
        case ("@hidden", _) => if (__obj.hidden.toString != "false") attr = scala.xml.Attribute(null, "hidden", __obj.hidden.toString, attr)
        case ("@{http://www.w3.org/XML/1998/namespace}id", _) => __obj.xmlid foreach { x => attr = scala.xml.Attribute(__scope.getPrefix("http://www.w3.org/XML/1998/namespace"), "id", x.toString, attr) }
        case ("@scope", _) => if (__obj.scope.toString != "instance") attr = scala.xml.Attribute(null, "scope", __obj.scope.toString, attr)
        case (key, x) => attr = scala.xml.Attribute((x.namespace map { __scope.getPrefix(_) }).orNull, x.key.orNull, x.value.toString, attr)
      }
      attr
    }

    def writesChildNodes(__obj: IPXACT2022ScalaCases.InstanceGeneratorType, __scope: scala.xml.NamespaceBinding): Seq[scala.xml.Node] =
      Seq.concat(IPXACT2022scalaxb.toXML[IPXACT2022ScalaCases.NameGroupSequence](__obj.nameGroupSequence1, None, Some("nameGroupSequence1"), __scope, false),
        __obj.phase map { IPXACT2022scalaxb.toXML[IPXACT2022ScalaCases.RealExpressionable](_, Some("http://www.accellera.org/XMLSchema/IPXACT/1685-2022"), Some("phase"), __scope, false) } getOrElse {Nil},
        __obj.parameters map { IPXACT2022scalaxb.toXML[IPXACT2022ScalaCases.Parameters](_, Some("http://www.accellera.org/XMLSchema/IPXACT/1685-2022"), Some("parameters"), __scope, false) } getOrElse {Nil},
        __obj.apiType map { IPXACT2022scalaxb.toXML[IPXACT2022ScalaCases.ApiType](_, Some("http://www.accellera.org/XMLSchema/IPXACT/1685-2022"), Some("apiType"), __scope, false) } getOrElse {Nil},
        __obj.apiService map { IPXACT2022scalaxb.toXML[IPXACT2022ScalaCases.ApiService](_, Some("http://www.accellera.org/XMLSchema/IPXACT/1685-2022"), Some("apiService"), __scope, false) } getOrElse {Nil},
        __obj.transportMethods map { IPXACT2022scalaxb.toXML[IPXACT2022ScalaCases.TransportMethods](_, Some("http://www.accellera.org/XMLSchema/IPXACT/1685-2022"), Some("transportMethods"), __scope, false) } getOrElse {Nil},
        IPXACT2022scalaxb.toXML[IPXACT2022ScalaCases.IpxactURIable](__obj.generatorExe, Some("http://www.accellera.org/XMLSchema/IPXACT/1685-2022"), Some("generatorExe"), __scope, false),
        __obj.vendorExtensions map { IPXACT2022scalaxb.toXML[IPXACT2022ScalaCases.VendorExtensions](_, Some("http://www.accellera.org/XMLSchema/IPXACT/1685-2022"), Some("vendorExtensions"), __scope, false) } getOrElse {Nil},
        __obj.group flatMap { IPXACT2022scalaxb.toXML[IPXACT2022ScalaCases.Group](_, Some("http://www.accellera.org/XMLSchema/IPXACT/1685-2022"), Some("group"), __scope, false) })

  }

  trait DefaultIPXACT2022ScalaCases_GeneratorSelectorTypeFormat extends IPXACT2022scalaxb.ElemNameParser[IPXACT2022ScalaCases.GeneratorSelectorType] {
    val targetNamespace: Option[String] = Some("http://www.accellera.org/XMLSchema/IPXACT/1685-2022")
    
    override def typeName: Option[String] = Some("generatorSelectorType")

    def parser(node: scala.xml.Node, stack: List[IPXACT2022scalaxb.ElemName]): Parser[IPXACT2022ScalaCases.GeneratorSelectorType] =
      phrase((IPXACT2022scalaxb.ElemName(Some("http://www.accellera.org/XMLSchema/IPXACT/1685-2022"), "groupSelector")) ^^
      { case p1 =>
      IPXACT2022ScalaCases.GeneratorSelectorType(IPXACT2022scalaxb.fromXML[IPXACT2022ScalaCases.GroupSelector](p1, IPXACT2022scalaxb.ElemName(node) :: stack),
        scala.collection.immutable.ListMap(List(
        (node \ "@{http://www.w3.org/XML/1998/namespace}id").headOption map { x => IPXACT2022scalaxb.DataRecord(x, node, IPXACT2022scalaxb.fromXML[String](x, IPXACT2022scalaxb.ElemName(node) :: stack)) } map { "@{http://www.w3.org/XML/1998/namespace}id" -> _ }
        ).flatten[(String, IPXACT2022scalaxb.DataRecord[Any])]: _*)) })
    
    override def writesAttribute(__obj: IPXACT2022ScalaCases.GeneratorSelectorType, __scope: scala.xml.NamespaceBinding): scala.xml.MetaData = {
      var attr: scala.xml.MetaData  = scala.xml.Null
      __obj.attributes.toList map {
        case ("@{http://www.w3.org/XML/1998/namespace}id", _) => __obj.xmlid foreach { x => attr = scala.xml.Attribute(__scope.getPrefix("http://www.w3.org/XML/1998/namespace"), "id", x.toString, attr) }
        case (key, x) => attr = scala.xml.Attribute((x.namespace map { __scope.getPrefix(_) }).orNull, x.key.orNull, x.value.toString, attr)
      }
      attr
    }

    def writesChildNodes(__obj: IPXACT2022ScalaCases.GeneratorSelectorType, __scope: scala.xml.NamespaceBinding): Seq[scala.xml.Node] =
      (IPXACT2022scalaxb.toXML[IPXACT2022ScalaCases.GroupSelector](__obj.groupSelector, Some("http://www.accellera.org/XMLSchema/IPXACT/1685-2022"), Some("groupSelector"), __scope, false))
  }

  trait DefaultIPXACT2022ScalaCases_ComponentGeneratorsFormat extends IPXACT2022scalaxb.ElemNameParser[IPXACT2022ScalaCases.ComponentGenerators] {
    val targetNamespace: Option[String] = Some("http://www.accellera.org/XMLSchema/IPXACT/1685-2022")
    
    def parser(node: scala.xml.Node, stack: List[IPXACT2022scalaxb.ElemName]): Parser[IPXACT2022ScalaCases.ComponentGenerators] =
      phrase(safeRep(IPXACT2022scalaxb.ElemName(Some("http://www.accellera.org/XMLSchema/IPXACT/1685-2022"), "componentGenerator")) ^^
      { case p1 =>
      IPXACT2022ScalaCases.ComponentGenerators(p1 map { IPXACT2022scalaxb.fromXML[IPXACT2022ScalaCases.InstanceGeneratorType](_, IPXACT2022scalaxb.ElemName(node) :: stack) }) })
    
    def writesChildNodes(__obj: IPXACT2022ScalaCases.ComponentGenerators, __scope: scala.xml.NamespaceBinding): Seq[scala.xml.Node] =
      (__obj.componentGenerator flatMap { IPXACT2022scalaxb.toXML[IPXACT2022ScalaCases.InstanceGeneratorType](_, Some("http://www.accellera.org/XMLSchema/IPXACT/1685-2022"), Some("componentGenerator"), __scope, false) })
  }
  trait DefaultIPXACT2022ScalaCases_AbstractorGeneratorsFormat extends IPXACT2022scalaxb.ElemNameParser[IPXACT2022ScalaCases.AbstractorGenerators] {
    val targetNamespace: Option[String] = Some("http://www.accellera.org/XMLSchema/IPXACT/1685-2022")
    
    def parser(node: scala.xml.Node, stack: List[IPXACT2022scalaxb.ElemName]): Parser[IPXACT2022ScalaCases.AbstractorGenerators] =
      phrase(safeRep(IPXACT2022scalaxb.ElemName(Some("http://www.accellera.org/XMLSchema/IPXACT/1685-2022"), "abstractorGenerator")) ^^
      { case p1 =>
      IPXACT2022ScalaCases.AbstractorGenerators(p1 map { IPXACT2022scalaxb.fromXML[IPXACT2022ScalaCases.InstanceGeneratorType](_, IPXACT2022scalaxb.ElemName(node) :: stack) }) })
    
    def writesChildNodes(__obj: IPXACT2022ScalaCases.AbstractorGenerators, __scope: scala.xml.NamespaceBinding): Seq[scala.xml.Node] =
      (__obj.abstractorGenerator flatMap { IPXACT2022scalaxb.toXML[IPXACT2022ScalaCases.InstanceGeneratorType](_, Some("http://www.accellera.org/XMLSchema/IPXACT/1685-2022"), Some("abstractorGenerator"), __scope, false) })
  }
  def buildIPXACT2022ScalaCases_ApiTypeTypeFormat = new DefaultIPXACT2022ScalaCases_ApiTypeTypeFormat {}
  trait DefaultIPXACT2022ScalaCases_ApiTypeTypeFormat extends IPXACT2022scalaxb.XMLFormat[IPXACT2022ScalaCases.ApiTypeType] {
    val targetNamespace: Option[String] = Some("http://www.accellera.org/XMLSchema/IPXACT/1685-2022")
    
    def fromString(value: String, scope: scala.xml.NamespaceBinding): IPXACT2022ScalaCases.ApiTypeType =
        (fromString0(value, scope)).apply(IPXACT2022scalaxb.fromXML[String](scala.xml.Text(value)))

    private def fromString0(value: String, scope: scala.xml.NamespaceBinding): PartialFunction[Any, IPXACT2022ScalaCases.ApiTypeType] = {
      case x: String if x == IPXACT2022scalaxb.fromXML[String](scala.xml.Text("TGI_2009")) => IPXACT2022ScalaCases.TGI_2009
      case x: String if x == IPXACT2022scalaxb.fromXML[String](scala.xml.Text("TGI_2014_BASE")) => IPXACT2022ScalaCases.TGI_2014_BASE
      case x: String if x == IPXACT2022scalaxb.fromXML[String](scala.xml.Text("TGI_2014_EXTENDED")) => IPXACT2022ScalaCases.TGI_2014_EXTENDED
      case x: String if x == IPXACT2022scalaxb.fromXML[String](scala.xml.Text("TGI_2022_BASE")) => IPXACT2022ScalaCases.TGI_2022_BASE
      case x: String if x == IPXACT2022scalaxb.fromXML[String](scala.xml.Text("TGI_2022_EXTENDED")) => IPXACT2022ScalaCases.TGI_2022_EXTENDED
      case x: String if x == IPXACT2022scalaxb.fromXML[String](scala.xml.Text("none")) => IPXACT2022ScalaCases.NoneType

    }



    def reads(seq: scala.xml.NodeSeq, stack: List[IPXACT2022scalaxb.ElemName]): Either[String, IPXACT2022ScalaCases.ApiTypeType] = seq match {
      case elem: scala.xml.Elem => Right(fromString(elem.text, elem.scope))
      case _ => Right(fromString(seq.text, scala.xml.TopScope))
    }
    
    def writes(__obj: IPXACT2022ScalaCases.ApiTypeType, __namespace: Option[String], __elementLabel: Option[String],
        __scope: scala.xml.NamespaceBinding, __typeAttribute: Boolean): scala.xml.NodeSeq =
      scala.xml.Elem(IPXACT2022scalaxb.Helper.getPrefix(__namespace, __scope).orNull,
        __elementLabel getOrElse { sys.error("missing element label.") },
        scala.xml.Null, __scope, true, scala.xml.Text(__obj.toString))
  }
  def buildIPXACT2022ScalaCases_TransportMethodTypeFormat = new DefaultIPXACT2022ScalaCases_TransportMethodTypeFormat {}
  trait DefaultIPXACT2022ScalaCases_TransportMethodTypeFormat extends IPXACT2022scalaxb.XMLFormat[IPXACT2022ScalaCases.TransportMethodType] {
    val targetNamespace: Option[String] = Some("http://www.accellera.org/XMLSchema/IPXACT/1685-2022")
    
    def fromString(value: String, scope: scala.xml.NamespaceBinding): IPXACT2022ScalaCases.TransportMethodType =
        (fromString0(value, scope)).apply(IPXACT2022scalaxb.fromXML[String](scala.xml.Text(value)))

    private def fromString0(value: String, scope: scala.xml.NamespaceBinding): PartialFunction[Any, IPXACT2022ScalaCases.TransportMethodType] = {
      case x: String if x == IPXACT2022scalaxb.fromXML[String](scala.xml.Text("file")) => IPXACT2022ScalaCases.FileValue

    }



    def reads(seq: scala.xml.NodeSeq, stack: List[IPXACT2022scalaxb.ElemName]): Either[String, IPXACT2022ScalaCases.TransportMethodType] = seq match {
      case elem: scala.xml.Elem => Right(fromString(elem.text, elem.scope))
      case _ => Right(fromString(seq.text, scala.xml.TopScope))
    }
    
    def writes(__obj: IPXACT2022ScalaCases.TransportMethodType, __namespace: Option[String], __elementLabel: Option[String],
        __scope: scala.xml.NamespaceBinding, __typeAttribute: Boolean): scala.xml.NodeSeq =
      scala.xml.Elem(IPXACT2022scalaxb.Helper.getPrefix(__namespace, __scope).orNull,
        __elementLabel getOrElse { sys.error("missing element label.") },
        scala.xml.Null, __scope, true, scala.xml.Text(__obj.toString))
  }
  trait DefaultIPXACT2022ScalaCases_ApiTypeFormat extends IPXACT2022scalaxb.XMLFormat[IPXACT2022ScalaCases.ApiType] with IPXACT2022scalaxb.CanWriteChildNodes[IPXACT2022ScalaCases.ApiType] {
    val targetNamespace: Option[String] = Some("http://www.accellera.org/XMLSchema/IPXACT/1685-2022")
    def reads(seq: scala.xml.NodeSeq, stack: List[IPXACT2022scalaxb.ElemName]): Either[String, IPXACT2022ScalaCases.ApiType] = seq match {
      case node: scala.xml.Node => Right(IPXACT2022ScalaCases.ApiType(IPXACT2022scalaxb.fromXML[IPXACT2022ScalaCases.ApiTypeType](node, IPXACT2022scalaxb.ElemName(node) :: stack),
        scala.collection.immutable.ListMap(List(
        (node \ "@{http://www.w3.org/XML/1998/namespace}id").headOption map { x => IPXACT2022scalaxb.DataRecord(x, node, IPXACT2022scalaxb.fromXML[String](x, IPXACT2022scalaxb.ElemName(node) :: stack)) } map { "@{http://www.w3.org/XML/1998/namespace}id" -> _ }
        ).flatten[(String, IPXACT2022scalaxb.DataRecord[Any])]: _*)))
      case _ => Left("reads failed: seq must be scala.xml.Node")
    }
    
    override def writesAttribute(__obj: IPXACT2022ScalaCases.ApiType, __scope: scala.xml.NamespaceBinding): scala.xml.MetaData = {
      var attr: scala.xml.MetaData  = scala.xml.Null
      __obj.attributes.toList map {
        case ("@{http://www.w3.org/XML/1998/namespace}id", _) => __obj.xmlid foreach { x => attr = scala.xml.Attribute(__scope.getPrefix("http://www.w3.org/XML/1998/namespace"), "id", x.toString, attr) }
        case (key, x) => attr = scala.xml.Attribute((x.namespace map { __scope.getPrefix(_) }).orNull, x.key.orNull, x.value.toString, attr)
      }
      attr
    }

    def writesChildNodes(__obj: IPXACT2022ScalaCases.ApiType, __scope: scala.xml.NamespaceBinding): Seq[scala.xml.Node] =
      Seq(scala.xml.Text(__obj.value.toString))

  }

  def buildIPXACT2022ScalaCases_ApiServiceFormat = new DefaultIPXACT2022ScalaCases_ApiServiceFormat {}
  trait DefaultIPXACT2022ScalaCases_ApiServiceFormat extends IPXACT2022scalaxb.XMLFormat[IPXACT2022ScalaCases.ApiService] {
    val targetNamespace: Option[String] = Some("http://www.accellera.org/XMLSchema/IPXACT/1685-2022")
    
    def fromString(value: String, scope: scala.xml.NamespaceBinding): IPXACT2022ScalaCases.ApiService =
        (fromString0(value, scope)).apply(IPXACT2022scalaxb.fromXML[String](scala.xml.Text(value)))

    private def fromString0(value: String, scope: scala.xml.NamespaceBinding): PartialFunction[Any, IPXACT2022ScalaCases.ApiService] = {
      case x: String if x == IPXACT2022scalaxb.fromXML[String](scala.xml.Text("SOAP")) => IPXACT2022ScalaCases.SOAP
      case x: String if x == IPXACT2022scalaxb.fromXML[String](scala.xml.Text("REST")) => IPXACT2022ScalaCases.REST

    }



    def reads(seq: scala.xml.NodeSeq, stack: List[IPXACT2022scalaxb.ElemName]): Either[String, IPXACT2022ScalaCases.ApiService] = seq match {
      case elem: scala.xml.Elem => Right(fromString(elem.text, elem.scope))
      case _ => Right(fromString(seq.text, scala.xml.TopScope))
    }
    
    def writes(__obj: IPXACT2022ScalaCases.ApiService, __namespace: Option[String], __elementLabel: Option[String],
        __scope: scala.xml.NamespaceBinding, __typeAttribute: Boolean): scala.xml.NodeSeq =
      scala.xml.Elem(IPXACT2022scalaxb.Helper.getPrefix(__namespace, __scope).orNull,
        __elementLabel getOrElse { sys.error("missing element label.") },
        scala.xml.Null, __scope, true, scala.xml.Text(__obj.toString))
  }
  trait DefaultIPXACT2022ScalaCases_TransportMethodFormat extends IPXACT2022scalaxb.XMLFormat[IPXACT2022ScalaCases.TransportMethod] with IPXACT2022scalaxb.CanWriteChildNodes[IPXACT2022ScalaCases.TransportMethod] {
    val targetNamespace: Option[String] = Some("http://www.accellera.org/XMLSchema/IPXACT/1685-2022")
    def reads(seq: scala.xml.NodeSeq, stack: List[IPXACT2022scalaxb.ElemName]): Either[String, IPXACT2022ScalaCases.TransportMethod] = seq match {
      case node: scala.xml.Node => Right(IPXACT2022ScalaCases.TransportMethod(IPXACT2022scalaxb.fromXML[IPXACT2022ScalaCases.TransportMethodType](node, IPXACT2022scalaxb.ElemName(node) :: stack),
        scala.collection.immutable.ListMap(List(
        (node \ "@{http://www.w3.org/XML/1998/namespace}id").headOption map { x => IPXACT2022scalaxb.DataRecord(x, node, IPXACT2022scalaxb.fromXML[String](x, IPXACT2022scalaxb.ElemName(node) :: stack)) } map { "@{http://www.w3.org/XML/1998/namespace}id" -> _ }
        ).flatten[(String, IPXACT2022scalaxb.DataRecord[Any])]: _*)))
      case _ => Left("reads failed: seq must be scala.xml.Node")
    }
    
    override def writesAttribute(__obj: IPXACT2022ScalaCases.TransportMethod, __scope: scala.xml.NamespaceBinding): scala.xml.MetaData = {
      var attr: scala.xml.MetaData  = scala.xml.Null
      __obj.attributes.toList map {
        case ("@{http://www.w3.org/XML/1998/namespace}id", _) => __obj.xmlid foreach { x => attr = scala.xml.Attribute(__scope.getPrefix("http://www.w3.org/XML/1998/namespace"), "id", x.toString, attr) }
        case (key, x) => attr = scala.xml.Attribute((x.namespace map { __scope.getPrefix(_) }).orNull, x.key.orNull, x.value.toString, attr)
      }
      attr
    }

    def writesChildNodes(__obj: IPXACT2022ScalaCases.TransportMethod, __scope: scala.xml.NamespaceBinding): Seq[scala.xml.Node] =
      Seq(scala.xml.Text(__obj.value.toString))

  }

  trait DefaultIPXACT2022ScalaCases_TransportMethodsFormat extends IPXACT2022scalaxb.ElemNameParser[IPXACT2022ScalaCases.TransportMethods] {
    val targetNamespace: Option[String] = Some("http://www.accellera.org/XMLSchema/IPXACT/1685-2022")
    
    def parser(node: scala.xml.Node, stack: List[IPXACT2022scalaxb.ElemName]): Parser[IPXACT2022ScalaCases.TransportMethods] =
      phrase((IPXACT2022scalaxb.ElemName(Some("http://www.accellera.org/XMLSchema/IPXACT/1685-2022"), "transportMethod")) ^^
      { case p1 =>
      IPXACT2022ScalaCases.TransportMethods(IPXACT2022scalaxb.fromXML[IPXACT2022ScalaCases.TransportMethod](p1, IPXACT2022scalaxb.ElemName(node) :: stack),
        scala.collection.immutable.ListMap(List(
        (node \ "@{http://www.w3.org/XML/1998/namespace}id").headOption map { x => IPXACT2022scalaxb.DataRecord(x, node, IPXACT2022scalaxb.fromXML[String](x, IPXACT2022scalaxb.ElemName(node) :: stack)) } map { "@{http://www.w3.org/XML/1998/namespace}id" -> _ }
        ).flatten[(String, IPXACT2022scalaxb.DataRecord[Any])]: _*)) })
    
    override def writesAttribute(__obj: IPXACT2022ScalaCases.TransportMethods, __scope: scala.xml.NamespaceBinding): scala.xml.MetaData = {
      var attr: scala.xml.MetaData  = scala.xml.Null
      __obj.attributes.toList map {
        case ("@{http://www.w3.org/XML/1998/namespace}id", _) => __obj.xmlid foreach { x => attr = scala.xml.Attribute(__scope.getPrefix("http://www.w3.org/XML/1998/namespace"), "id", x.toString, attr) }
        case (key, x) => attr = scala.xml.Attribute((x.namespace map { __scope.getPrefix(_) }).orNull, x.key.orNull, x.value.toString, attr)
      }
      attr
    }

    def writesChildNodes(__obj: IPXACT2022ScalaCases.TransportMethods, __scope: scala.xml.NamespaceBinding): Seq[scala.xml.Node] =
      (IPXACT2022scalaxb.toXML[IPXACT2022ScalaCases.TransportMethod](__obj.transportMethod, Some("http://www.accellera.org/XMLSchema/IPXACT/1685-2022"), Some("transportMethod"), __scope, false))
  }

  trait DefaultIPXACT2022ScalaCases_GeneratorTypableFormat extends IPXACT2022scalaxb.XMLFormat[IPXACT2022ScalaCases.GeneratorTypable] {
    def reads(seq: scala.xml.NodeSeq, stack: List[IPXACT2022scalaxb.ElemName]): Either[String, IPXACT2022ScalaCases.GeneratorTypable] = seq match {
      case node: scala.xml.Node =>     
        IPXACT2022scalaxb.Helper.instanceType(node) match {
          case (Some("http://www.accellera.org/XMLSchema/IPXACT/1685-2022"), Some("instanceGeneratorType")) => Right(IPXACT2022scalaxb.fromXML[IPXACT2022ScalaCases.InstanceGeneratorType](node, stack))
          case _ => Right(IPXACT2022scalaxb.fromXML[IPXACT2022ScalaCases.GeneratorType](node, stack))
        }
      case _ => Left("reads failed: seq must be scala.xml.Node")  
    }
    
    def writes(__obj: IPXACT2022ScalaCases.GeneratorTypable, __namespace: Option[String], __elementLabel: Option[String],
        __scope: scala.xml.NamespaceBinding, __typeAttribute: Boolean): scala.xml.NodeSeq = __obj match {
      case x: IPXACT2022ScalaCases.InstanceGeneratorType => IPXACT2022scalaxb.toXML[IPXACT2022ScalaCases.InstanceGeneratorType](x, __namespace, __elementLabel, __scope, true)
      case x: IPXACT2022ScalaCases.Generator => IPXACT2022scalaxb.toXML[IPXACT2022ScalaCases.Generator](x, __namespace, __elementLabel, __scope, true)
      case x: IPXACT2022ScalaCases.GeneratorType => IPXACT2022scalaxb.toXML[IPXACT2022ScalaCases.GeneratorType](x, __namespace, __elementLabel, __scope, __typeAttribute)
    }
  }

  trait DefaultIPXACT2022ScalaCases_GeneratorTypeFormat extends IPXACT2022scalaxb.ElemNameParser[IPXACT2022ScalaCases.GeneratorType] with IPXACT2022ScalaCases_NameGroupGroupFormat {
    val targetNamespace: Option[String] = Some("http://www.accellera.org/XMLSchema/IPXACT/1685-2022")
    
    override def typeName: Option[String] = Some("generatorType")

    def parser(node: scala.xml.Node, stack: List[IPXACT2022scalaxb.ElemName]): Parser[IPXACT2022ScalaCases.GeneratorType] =
      phrase((parseNameGroupGroup(node, IPXACT2022scalaxb.ElemName(node) :: stack)) ~
      opt(IPXACT2022scalaxb.ElemName(Some("http://www.accellera.org/XMLSchema/IPXACT/1685-2022"), "phase")) ~
      opt(IPXACT2022scalaxb.ElemName(Some("http://www.accellera.org/XMLSchema/IPXACT/1685-2022"), "parameters")) ~
      opt(IPXACT2022scalaxb.ElemName(Some("http://www.accellera.org/XMLSchema/IPXACT/1685-2022"), "apiType")) ~
      opt(IPXACT2022scalaxb.ElemName(Some("http://www.accellera.org/XMLSchema/IPXACT/1685-2022"), "apiService")) ~
      opt(IPXACT2022scalaxb.ElemName(Some("http://www.accellera.org/XMLSchema/IPXACT/1685-2022"), "transportMethods")) ~
      (IPXACT2022scalaxb.ElemName(Some("http://www.accellera.org/XMLSchema/IPXACT/1685-2022"), "generatorExe")) ~
      opt(IPXACT2022scalaxb.ElemName(Some("http://www.accellera.org/XMLSchema/IPXACT/1685-2022"), "vendorExtensions")) ^^
      { case p1 ~ p2 ~ p3 ~ p4 ~ p5 ~ p6 ~ p7 ~ p8 =>
      IPXACT2022ScalaCases.GeneratorType(p1,
        p2.headOption map { IPXACT2022scalaxb.fromXML[IPXACT2022ScalaCases.RealExpressionable](_, IPXACT2022scalaxb.ElemName(node) :: stack) },
        p3.headOption map { IPXACT2022scalaxb.fromXML[IPXACT2022ScalaCases.Parameters](_, IPXACT2022scalaxb.ElemName(node) :: stack) },
        p4.headOption map { IPXACT2022scalaxb.fromXML[IPXACT2022ScalaCases.ApiType](_, IPXACT2022scalaxb.ElemName(node) :: stack) },
        p5.headOption map { IPXACT2022scalaxb.fromXML[IPXACT2022ScalaCases.ApiService](_, IPXACT2022scalaxb.ElemName(node) :: stack) },
        p6.headOption map { IPXACT2022scalaxb.fromXML[IPXACT2022ScalaCases.TransportMethods](_, IPXACT2022scalaxb.ElemName(node) :: stack) },
        IPXACT2022scalaxb.fromXML[IPXACT2022ScalaCases.IpxactURIable](p7, IPXACT2022scalaxb.ElemName(node) :: stack),
        p8.headOption map { IPXACT2022scalaxb.fromXML[IPXACT2022ScalaCases.VendorExtensions](_, IPXACT2022scalaxb.ElemName(node) :: stack) },
        scala.collection.immutable.ListMap(List(
        (node \ "@hidden").headOption map { x => IPXACT2022scalaxb.DataRecord(x, node, IPXACT2022scalaxb.fromXML[Boolean](x, IPXACT2022scalaxb.ElemName(node) :: stack)) } orElse Some(IPXACT2022scalaxb.DataRecord(None, None, IPXACT2022scalaxb.fromXML[Boolean](scala.xml.Text("false"), IPXACT2022scalaxb.ElemName(node) :: stack))) map { "@hidden" -> _ },
        (node \ "@{http://www.w3.org/XML/1998/namespace}id").headOption map { x => IPXACT2022scalaxb.DataRecord(x, node, IPXACT2022scalaxb.fromXML[String](x, IPXACT2022scalaxb.ElemName(node) :: stack)) } map { "@{http://www.w3.org/XML/1998/namespace}id" -> _ }
        ).flatten[(String, IPXACT2022scalaxb.DataRecord[Any])]: _*)) })
    
    override def writesAttribute(__obj: IPXACT2022ScalaCases.GeneratorType, __scope: scala.xml.NamespaceBinding): scala.xml.MetaData = {
      var attr: scala.xml.MetaData  = scala.xml.Null
      __obj.attributes.toList map {
        case ("@hidden", _) => if (__obj.hidden.toString != "false") attr = scala.xml.Attribute(null, "hidden", __obj.hidden.toString, attr)
        case ("@{http://www.w3.org/XML/1998/namespace}id", _) => __obj.xmlid foreach { x => attr = scala.xml.Attribute(__scope.getPrefix("http://www.w3.org/XML/1998/namespace"), "id", x.toString, attr) }
        case (key, x) => attr = scala.xml.Attribute((x.namespace map { __scope.getPrefix(_) }).orNull, x.key.orNull, x.value.toString, attr)
      }
      attr
    }

    def writesChildNodes(__obj: IPXACT2022ScalaCases.GeneratorType, __scope: scala.xml.NamespaceBinding): Seq[scala.xml.Node] =
      Seq.concat(IPXACT2022scalaxb.toXML[IPXACT2022ScalaCases.NameGroupSequence](__obj.nameGroupSequence1, None, Some("nameGroupSequence1"), __scope, false),
        __obj.phase map { IPXACT2022scalaxb.toXML[IPXACT2022ScalaCases.RealExpressionable](_, Some("http://www.accellera.org/XMLSchema/IPXACT/1685-2022"), Some("phase"), __scope, false) } getOrElse {Nil},
        __obj.parameters map { IPXACT2022scalaxb.toXML[IPXACT2022ScalaCases.Parameters](_, Some("http://www.accellera.org/XMLSchema/IPXACT/1685-2022"), Some("parameters"), __scope, false) } getOrElse {Nil},
        __obj.apiType map { IPXACT2022scalaxb.toXML[IPXACT2022ScalaCases.ApiType](_, Some("http://www.accellera.org/XMLSchema/IPXACT/1685-2022"), Some("apiType"), __scope, false) } getOrElse {Nil},
        __obj.apiService map { IPXACT2022scalaxb.toXML[IPXACT2022ScalaCases.ApiService](_, Some("http://www.accellera.org/XMLSchema/IPXACT/1685-2022"), Some("apiService"), __scope, false) } getOrElse {Nil},
        __obj.transportMethods map { IPXACT2022scalaxb.toXML[IPXACT2022ScalaCases.TransportMethods](_, Some("http://www.accellera.org/XMLSchema/IPXACT/1685-2022"), Some("transportMethods"), __scope, false) } getOrElse {Nil},
        IPXACT2022scalaxb.toXML[IPXACT2022ScalaCases.IpxactURIable](__obj.generatorExe, Some("http://www.accellera.org/XMLSchema/IPXACT/1685-2022"), Some("generatorExe"), __scope, false),
        __obj.vendorExtensions map { IPXACT2022scalaxb.toXML[IPXACT2022ScalaCases.VendorExtensions](_, Some("http://www.accellera.org/XMLSchema/IPXACT/1685-2022"), Some("vendorExtensions"), __scope, false) } getOrElse {Nil})

  }

  trait DefaultIPXACT2022ScalaCases_LibraryRefTypeFormat extends IPXACT2022scalaxb.XMLFormat[IPXACT2022ScalaCases.LibraryRefType] with IPXACT2022scalaxb.CanWriteChildNodes[IPXACT2022ScalaCases.LibraryRefType] {
    val targetNamespace: Option[String] = Some("http://www.accellera.org/XMLSchema/IPXACT/1685-2022")
    def reads(seq: scala.xml.NodeSeq, stack: List[IPXACT2022scalaxb.ElemName]): Either[String, IPXACT2022ScalaCases.LibraryRefType] = seq match {
      case node: scala.xml.Node => Right(IPXACT2022ScalaCases.LibraryRefType(scala.collection.immutable.ListMap(List(
        (node \ "@vendor").headOption map { x => IPXACT2022scalaxb.DataRecord(x, node, IPXACT2022scalaxb.fromXML[String](x, IPXACT2022scalaxb.ElemName(node) :: stack)) } map { "@vendor" -> _ },
        (node \ "@library").headOption map { x => IPXACT2022scalaxb.DataRecord(x, node, IPXACT2022scalaxb.fromXML[String](x, IPXACT2022scalaxb.ElemName(node) :: stack)) } map { "@library" -> _ },
        (node \ "@name").headOption map { x => IPXACT2022scalaxb.DataRecord(x, node, IPXACT2022scalaxb.fromXML[String](x, IPXACT2022scalaxb.ElemName(node) :: stack)) } map { "@name" -> _ },
        (node \ "@version").headOption map { x => IPXACT2022scalaxb.DataRecord(x, node, IPXACT2022scalaxb.fromXML[String](x, IPXACT2022scalaxb.ElemName(node) :: stack)) } map { "@version" -> _ },
        (node \ "@{http://www.w3.org/XML/1998/namespace}id").headOption map { x => IPXACT2022scalaxb.DataRecord(x, node, IPXACT2022scalaxb.fromXML[String](x, IPXACT2022scalaxb.ElemName(node) :: stack)) } map { "@{http://www.w3.org/XML/1998/namespace}id" -> _ }
        ).flatten[(String, IPXACT2022scalaxb.DataRecord[Any])]: _*)))
      case _ => Left("reads failed: seq must be scala.xml.Node")
    }
    
    override def writesAttribute(__obj: IPXACT2022ScalaCases.LibraryRefType, __scope: scala.xml.NamespaceBinding): scala.xml.MetaData = {
      var attr: scala.xml.MetaData  = scala.xml.Null
      __obj.attributes.toList map {
        case ("@vendor", _) => attr = scala.xml.Attribute(null, "vendor", __obj.vendor.toString, attr)
        case ("@library", _) => attr = scala.xml.Attribute(null, "library", __obj.library.toString, attr)
        case ("@name", _) => attr = scala.xml.Attribute(null, "name", __obj.name.toString, attr)
        case ("@version", _) => attr = scala.xml.Attribute(null, "version", __obj.version.toString, attr)
        case ("@{http://www.w3.org/XML/1998/namespace}id", _) => __obj.xmlid foreach { x => attr = scala.xml.Attribute(__scope.getPrefix("http://www.w3.org/XML/1998/namespace"), "id", x.toString, attr) }
        case (key, x) => attr = scala.xml.Attribute((x.namespace map { __scope.getPrefix(_) }).orNull, x.key.orNull, x.value.toString, attr)
      }
      attr
    }

    def writesChildNodes(__obj: IPXACT2022ScalaCases.LibraryRefType, __scope: scala.xml.NamespaceBinding): Seq[scala.xml.Node] =
      Nil

  }

  trait DefaultIPXACT2022ScalaCases_ConfigurableLibraryRefTypeFormat extends IPXACT2022scalaxb.ElemNameParser[IPXACT2022ScalaCases.ConfigurableLibraryRefType] {
    val targetNamespace: Option[String] = Some("http://www.accellera.org/XMLSchema/IPXACT/1685-2022")
    
    override def typeName: Option[String] = Some("configurableLibraryRefType")

    def parser(node: scala.xml.Node, stack: List[IPXACT2022scalaxb.ElemName]): Parser[IPXACT2022ScalaCases.ConfigurableLibraryRefType] =
      phrase(opt(IPXACT2022scalaxb.ElemName(Some("http://www.accellera.org/XMLSchema/IPXACT/1685-2022"), "configurableElementValues")) ^^
      { case p1 =>
      IPXACT2022ScalaCases.ConfigurableLibraryRefType(p1.headOption map { IPXACT2022scalaxb.fromXML[IPXACT2022ScalaCases.ConfigurableElementValues](_, IPXACT2022scalaxb.ElemName(node) :: stack) },
        scala.collection.immutable.ListMap(List(
        (node \ "@vendor").headOption map { x => IPXACT2022scalaxb.DataRecord(x, node, IPXACT2022scalaxb.fromXML[String](x, IPXACT2022scalaxb.ElemName(node) :: stack)) } map { "@vendor" -> _ },
        (node \ "@library").headOption map { x => IPXACT2022scalaxb.DataRecord(x, node, IPXACT2022scalaxb.fromXML[String](x, IPXACT2022scalaxb.ElemName(node) :: stack)) } map { "@library" -> _ },
        (node \ "@name").headOption map { x => IPXACT2022scalaxb.DataRecord(x, node, IPXACT2022scalaxb.fromXML[String](x, IPXACT2022scalaxb.ElemName(node) :: stack)) } map { "@name" -> _ },
        (node \ "@version").headOption map { x => IPXACT2022scalaxb.DataRecord(x, node, IPXACT2022scalaxb.fromXML[String](x, IPXACT2022scalaxb.ElemName(node) :: stack)) } map { "@version" -> _ },
        (node \ "@{http://www.w3.org/XML/1998/namespace}id").headOption map { x => IPXACT2022scalaxb.DataRecord(x, node, IPXACT2022scalaxb.fromXML[String](x, IPXACT2022scalaxb.ElemName(node) :: stack)) } map { "@{http://www.w3.org/XML/1998/namespace}id" -> _ }
        ).flatten[(String, IPXACT2022scalaxb.DataRecord[Any])]: _*)) })
    
    override def writesAttribute(__obj: IPXACT2022ScalaCases.ConfigurableLibraryRefType, __scope: scala.xml.NamespaceBinding): scala.xml.MetaData = {
      var attr: scala.xml.MetaData  = scala.xml.Null
      __obj.attributes.toList map {
        case ("@vendor", _) => attr = scala.xml.Attribute(null, "vendor", __obj.vendor.toString, attr)
        case ("@library", _) => attr = scala.xml.Attribute(null, "library", __obj.library.toString, attr)
        case ("@name", _) => attr = scala.xml.Attribute(null, "name", __obj.name.toString, attr)
        case ("@version", _) => attr = scala.xml.Attribute(null, "version", __obj.version.toString, attr)
        case ("@{http://www.w3.org/XML/1998/namespace}id", _) => __obj.xmlid foreach { x => attr = scala.xml.Attribute(__scope.getPrefix("http://www.w3.org/XML/1998/namespace"), "id", x.toString, attr) }
        case (key, x) => attr = scala.xml.Attribute((x.namespace map { __scope.getPrefix(_) }).orNull, x.key.orNull, x.value.toString, attr)
      }
      attr
    }

    def writesChildNodes(__obj: IPXACT2022ScalaCases.ConfigurableLibraryRefType, __scope: scala.xml.NamespaceBinding): Seq[scala.xml.Node] =
      (__obj.configurableElementValues map { IPXACT2022scalaxb.toXML[IPXACT2022ScalaCases.ConfigurableElementValues](_, Some("http://www.accellera.org/XMLSchema/IPXACT/1685-2022"), Some("configurableElementValues"), __scope, false) } getOrElse {Nil})
  }


/** Base IP-XACT document reference type. Contains vendor, library, name and version attributes.
*/
  trait IPXACT2022ScalaCases_DocumentNameGroupGroupFormat extends IPXACT2022ScalaCases_VersionedIdentifierGroupFormat {
    def parseDocumentNameGroupGroup(node: scala.xml.Node, stack: List[IPXACT2022scalaxb.ElemName]): Parser[IPXACT2022ScalaCases.DocumentNameGroupSequence] =
      (((parseVersionedIdentifierGroup(node, IPXACT2022scalaxb.ElemName(node) :: stack)) ~
      opt(IPXACT2022scalaxb.ElemName(Some("http://www.accellera.org/XMLSchema/IPXACT/1685-2022"), "displayName")) ~
      opt(IPXACT2022scalaxb.ElemName(Some("http://www.accellera.org/XMLSchema/IPXACT/1685-2022"), "shortDescription")) ~
      opt(IPXACT2022scalaxb.ElemName(Some("http://www.accellera.org/XMLSchema/IPXACT/1685-2022"), "description"))) ^^
        { case p1 ~ p2 ~ p3 ~ p4 => IPXACT2022ScalaCases.DocumentNameGroupSequence(p1,
        p2.headOption map { IPXACT2022scalaxb.fromXML[String](_, IPXACT2022scalaxb.ElemName(node) :: stack) },
        p3.headOption map { IPXACT2022scalaxb.fromXML[String](_, IPXACT2022scalaxb.ElemName(node) :: stack) },
        p4.headOption map { IPXACT2022scalaxb.fromXML[String](_, IPXACT2022scalaxb.ElemName(node) :: stack) }) })
  
    def parseDocumentNameGroupGroup(node: scala.xml.Node, stack: List[IPXACT2022scalaxb.ElemName], wrap: Boolean): Parser[IPXACT2022scalaxb.DataRecord[Any]] =
      (((parseVersionedIdentifierGroup(node, IPXACT2022scalaxb.ElemName(node) :: stack)) ~
      opt(IPXACT2022scalaxb.ElemName(Some("http://www.accellera.org/XMLSchema/IPXACT/1685-2022"), "displayName")) ~
      opt(IPXACT2022scalaxb.ElemName(Some("http://www.accellera.org/XMLSchema/IPXACT/1685-2022"), "shortDescription")) ~
      opt(IPXACT2022scalaxb.ElemName(Some("http://www.accellera.org/XMLSchema/IPXACT/1685-2022"), "description"))) ^^
        { case p1 ~ p2 ~ p3 ~ p4 => IPXACT2022scalaxb.DataRecord(IPXACT2022ScalaCases.DocumentNameGroupSequence(p1,
        p2.headOption map { IPXACT2022scalaxb.fromXML[String](_, IPXACT2022scalaxb.ElemName(node) :: stack) },
        p3.headOption map { IPXACT2022scalaxb.fromXML[String](_, IPXACT2022scalaxb.ElemName(node) :: stack) },
        p4.headOption map { IPXACT2022scalaxb.fromXML[String](_, IPXACT2022scalaxb.ElemName(node) :: stack) })) })
    
    def parsemixedDocumentNameGroupGroup(node: scala.xml.Node, stack: List[IPXACT2022scalaxb.ElemName]): Parser[Seq[IPXACT2022scalaxb.DataRecord[Any]]] =
      (((parsemixedVersionedIdentifierGroup(node, IPXACT2022scalaxb.ElemName(node) :: stack)) ~
      optTextRecord ~ 
      (opt(IPXACT2022scalaxb.ElemName(Some("http://www.accellera.org/XMLSchema/IPXACT/1685-2022"), "displayName")) ^^
      (_ map { x => IPXACT2022scalaxb.DataRecord(x.namespace, Some(x.name), IPXACT2022scalaxb.fromXML[String](x, IPXACT2022scalaxb.ElemName(node) :: stack)) })) ~
      optTextRecord ~ 
      (opt(IPXACT2022scalaxb.ElemName(Some("http://www.accellera.org/XMLSchema/IPXACT/1685-2022"), "shortDescription")) ^^
      (_ map { x => IPXACT2022scalaxb.DataRecord(x.namespace, Some(x.name), IPXACT2022scalaxb.fromXML[String](x, IPXACT2022scalaxb.ElemName(node) :: stack)) })) ~
      optTextRecord ~ 
      (opt(IPXACT2022scalaxb.ElemName(Some("http://www.accellera.org/XMLSchema/IPXACT/1685-2022"), "description")) ^^
      (_ map { x => IPXACT2022scalaxb.DataRecord(x.namespace, Some(x.name), IPXACT2022scalaxb.fromXML[String](x, IPXACT2022scalaxb.ElemName(node) :: stack)) })) ~
      optTextRecord) ^^ 
        { case p1 ~ p2 ~ p3 ~ p4 ~ p5 ~ p6 ~ p7 ~ p8 => Seq.concat(p1,
        p2.toList,
        p3.toList,
        p4.toList,
        p5.toList,
        p6.toList,
        p7.toList,
        p8.toList) })
  }

  trait DefaultIPXACT2022ScalaCases_DocumentNameGroupSequenceFormat extends IPXACT2022scalaxb.XMLFormat[IPXACT2022ScalaCases.DocumentNameGroupSequence] {
    def reads(seq: scala.xml.NodeSeq, stack: List[IPXACT2022scalaxb.ElemName]): Either[String, IPXACT2022ScalaCases.DocumentNameGroupSequence] = Left("don't call me.")
    
    def writes(__obj: IPXACT2022ScalaCases.DocumentNameGroupSequence, __namespace: Option[String], __elementLabel: Option[String],
        __scope: scala.xml.NamespaceBinding, __typeAttribute: Boolean): scala.xml.NodeSeq =
      Seq.concat(IPXACT2022scalaxb.toXML[IPXACT2022ScalaCases.VersionedIdentifierSequence](__obj.versionedIdentifierSequence1, None, Some("versionedIdentifierSequence1"), __scope, false),
        __obj.displayName map { IPXACT2022scalaxb.toXML[String](_, Some("http://www.accellera.org/XMLSchema/IPXACT/1685-2022"), Some("displayName"), __scope, false) } getOrElse {Nil},
        __obj.shortDescription map { IPXACT2022scalaxb.toXML[String](_, Some("http://www.accellera.org/XMLSchema/IPXACT/1685-2022"), Some("shortDescription"), __scope, false) } getOrElse {Nil},
        __obj.description map { IPXACT2022scalaxb.toXML[String](_, Some("http://www.accellera.org/XMLSchema/IPXACT/1685-2022"), Some("description"), __scope, false) } getOrElse {Nil})


  }

  trait DefaultIPXACT2022ScalaCases_BaseIdentifierSequenceFormat extends IPXACT2022scalaxb.XMLFormat[IPXACT2022ScalaCases.BaseIdentifierSequence] {
    def reads(seq: scala.xml.NodeSeq, stack: List[IPXACT2022scalaxb.ElemName]): Either[String, IPXACT2022ScalaCases.BaseIdentifierSequence] = Left("don't call me.")
    
    def writes(__obj: IPXACT2022ScalaCases.BaseIdentifierSequence, __namespace: Option[String], __elementLabel: Option[String],
        __scope: scala.xml.NamespaceBinding, __typeAttribute: Boolean): scala.xml.NodeSeq =
      Nil

  }

/** This group of elements identifies a top level item (e.g. a component or a bus definition)  with vendor, library, name and a version number. 
*/
  trait IPXACT2022ScalaCases_VersionedIdentifierGroupFormat extends IPXACT2022scalaxb.AnyElemNameParser {
    def parseVersionedIdentifierGroup(node: scala.xml.Node, stack: List[IPXACT2022scalaxb.ElemName]): Parser[IPXACT2022ScalaCases.VersionedIdentifierSequence] =
      (((IPXACT2022scalaxb.ElemName(Some("http://www.accellera.org/XMLSchema/IPXACT/1685-2022"), "vendor")) ~
      (IPXACT2022scalaxb.ElemName(Some("http://www.accellera.org/XMLSchema/IPXACT/1685-2022"), "library")) ~
      (IPXACT2022scalaxb.ElemName(Some("http://www.accellera.org/XMLSchema/IPXACT/1685-2022"), "name")) ~
      (IPXACT2022scalaxb.ElemName(Some("http://www.accellera.org/XMLSchema/IPXACT/1685-2022"), "version"))) ^^
        { case p1 ~ p2 ~ p3 ~ p4 => IPXACT2022ScalaCases.VersionedIdentifierSequence(IPXACT2022scalaxb.fromXML[String](p1, IPXACT2022scalaxb.ElemName(node) :: stack),
        IPXACT2022scalaxb.fromXML[String](p2, IPXACT2022scalaxb.ElemName(node) :: stack),
        IPXACT2022scalaxb.fromXML[String](p3, IPXACT2022scalaxb.ElemName(node) :: stack),
        IPXACT2022scalaxb.fromXML[String](p4, IPXACT2022scalaxb.ElemName(node) :: stack)) })
  
    def parseVersionedIdentifierGroup(node: scala.xml.Node, stack: List[IPXACT2022scalaxb.ElemName], wrap: Boolean): Parser[IPXACT2022scalaxb.DataRecord[Any]] =
      (((IPXACT2022scalaxb.ElemName(Some("http://www.accellera.org/XMLSchema/IPXACT/1685-2022"), "vendor")) ~
      (IPXACT2022scalaxb.ElemName(Some("http://www.accellera.org/XMLSchema/IPXACT/1685-2022"), "library")) ~
      (IPXACT2022scalaxb.ElemName(Some("http://www.accellera.org/XMLSchema/IPXACT/1685-2022"), "name")) ~
      (IPXACT2022scalaxb.ElemName(Some("http://www.accellera.org/XMLSchema/IPXACT/1685-2022"), "version"))) ^^
        { case p1 ~ p2 ~ p3 ~ p4 => IPXACT2022scalaxb.DataRecord(IPXACT2022ScalaCases.VersionedIdentifierSequence(IPXACT2022scalaxb.fromXML[String](p1, IPXACT2022scalaxb.ElemName(node) :: stack),
        IPXACT2022scalaxb.fromXML[String](p2, IPXACT2022scalaxb.ElemName(node) :: stack),
        IPXACT2022scalaxb.fromXML[String](p3, IPXACT2022scalaxb.ElemName(node) :: stack),
        IPXACT2022scalaxb.fromXML[String](p4, IPXACT2022scalaxb.ElemName(node) :: stack))) })
    
    def parsemixedVersionedIdentifierGroup(node: scala.xml.Node, stack: List[IPXACT2022scalaxb.ElemName]): Parser[Seq[IPXACT2022scalaxb.DataRecord[Any]]] =
      ((((IPXACT2022scalaxb.ElemName(Some("http://www.accellera.org/XMLSchema/IPXACT/1685-2022"), "vendor")) ^^
      (x => IPXACT2022scalaxb.DataRecord(x.namespace, Some(x.name), IPXACT2022scalaxb.fromXML[String](x, IPXACT2022scalaxb.ElemName(node) :: stack)))) ~
      optTextRecord ~ 
      ((IPXACT2022scalaxb.ElemName(Some("http://www.accellera.org/XMLSchema/IPXACT/1685-2022"), "library")) ^^
      (x => IPXACT2022scalaxb.DataRecord(x.namespace, Some(x.name), IPXACT2022scalaxb.fromXML[String](x, IPXACT2022scalaxb.ElemName(node) :: stack)))) ~
      optTextRecord ~ 
      ((IPXACT2022scalaxb.ElemName(Some("http://www.accellera.org/XMLSchema/IPXACT/1685-2022"), "name")) ^^
      (x => IPXACT2022scalaxb.DataRecord(x.namespace, Some(x.name), IPXACT2022scalaxb.fromXML[String](x, IPXACT2022scalaxb.ElemName(node) :: stack)))) ~
      optTextRecord ~ 
      ((IPXACT2022scalaxb.ElemName(Some("http://www.accellera.org/XMLSchema/IPXACT/1685-2022"), "version")) ^^
      (x => IPXACT2022scalaxb.DataRecord(x.namespace, Some(x.name), IPXACT2022scalaxb.fromXML[String](x, IPXACT2022scalaxb.ElemName(node) :: stack)))) ~
      optTextRecord) ^^ 
        { case p1 ~ p2 ~ p3 ~ p4 ~ p5 ~ p6 ~ p7 ~ p8 => Seq.concat(Seq(p1),
        p2.toList,
        Seq(p3),
        p4.toList,
        Seq(p5),
        p6.toList,
        Seq(p7),
        p8.toList) })
  }

  trait DefaultIPXACT2022ScalaCases_VersionedIdentifierSequenceFormat extends IPXACT2022scalaxb.XMLFormat[IPXACT2022ScalaCases.VersionedIdentifierSequence] {
    def reads(seq: scala.xml.NodeSeq, stack: List[IPXACT2022scalaxb.ElemName]): Either[String, IPXACT2022ScalaCases.VersionedIdentifierSequence] = Left("don't call me.")
    
    def writes(__obj: IPXACT2022ScalaCases.VersionedIdentifierSequence, __namespace: Option[String], __elementLabel: Option[String],
        __scope: scala.xml.NamespaceBinding, __typeAttribute: Boolean): scala.xml.NodeSeq =
      Seq.concat(IPXACT2022scalaxb.toXML[String](__obj.vendor, Some("http://www.accellera.org/XMLSchema/IPXACT/1685-2022"), Some("vendor"), __scope, false),
        IPXACT2022scalaxb.toXML[String](__obj.library, Some("http://www.accellera.org/XMLSchema/IPXACT/1685-2022"), Some("library"), __scope, false),
        IPXACT2022scalaxb.toXML[String](__obj.name, Some("http://www.accellera.org/XMLSchema/IPXACT/1685-2022"), Some("name"), __scope, false),
        IPXACT2022scalaxb.toXML[String](__obj.version, Some("http://www.accellera.org/XMLSchema/IPXACT/1685-2022"), Some("version"), __scope, false))


  }

  trait DefaultIPXACT2022ScalaCases_LibraryRefGroupFormat extends IPXACT2022scalaxb.AttributeGroupFormat[IPXACT2022ScalaCases.LibraryRefGroup] {
    val targetNamespace: Option[String] = Some("http://www.accellera.org/XMLSchema/IPXACT/1685-2022")
    
    def reads(seq: scala.xml.NodeSeq, stack: List[IPXACT2022scalaxb.ElemName]): Either[String, IPXACT2022ScalaCases.LibraryRefGroup] = seq match {
      case node: scala.xml.Node => Right(IPXACT2022ScalaCases.LibraryRefGroup(IPXACT2022scalaxb.fromXML[String]((node \ "@vendor"), IPXACT2022scalaxb.ElemName(node) :: stack),
      IPXACT2022scalaxb.fromXML[String]((node \ "@library"), IPXACT2022scalaxb.ElemName(node) :: stack),
      IPXACT2022scalaxb.fromXML[String]((node \ "@name"), IPXACT2022scalaxb.ElemName(node) :: stack),
      IPXACT2022scalaxb.fromXML[String]((node \ "@version"), IPXACT2022scalaxb.ElemName(node) :: stack),
      (node \ "@{http://www.w3.org/XML/1998/namespace}id").headOption map { IPXACT2022scalaxb.fromXML[String](_, IPXACT2022scalaxb.ElemName(node) :: stack) }))
      case _ => Left("reads failed: seq must be scala.xml.Node")
    }
    
    def toAttribute(__obj: IPXACT2022ScalaCases.LibraryRefGroup, __attr: scala.xml.MetaData, __scope: scala.xml.NamespaceBinding): scala.xml.MetaData = {
      var attr: scala.xml.MetaData  = __attr
      attr = scala.xml.Attribute(null, "vendor", __obj.vendor.toString, attr)
    attr = scala.xml.Attribute(null, "library", __obj.library.toString, attr)
    attr = scala.xml.Attribute(null, "name", __obj.name.toString, attr)
    attr = scala.xml.Attribute(null, "version", __obj.version.toString, attr)
    __obj.xmlid foreach { x => attr = scala.xml.Attribute(__scope.getPrefix("http://www.w3.org/XML/1998/namespace"), "id", x.toString, attr) }
      attr
    }
  }


/** This IP-XACT schema documentation is part of the IP-XACT standard deliverables. The diagrams in this documentation represent the relationships between elements of the schema together with their attributes and expected values. Valid IP-XACT XML files must have a top-level type that is one of the elements listed here.
*/
  trait IPXACT2022ScalaCases_IPXACTDocumentTypesGroupFormat extends IPXACT2022scalaxb.AnyElemNameParser {
    def parseIPXACTDocumentTypesGroup(node: scala.xml.Node, stack: List[IPXACT2022scalaxb.ElemName]): Parser[IPXACT2022scalaxb.DataRecord[IPXACT2022ScalaCases.IPXACTDocumentTypesOption]] =
      (((IPXACT2022scalaxb.ElemName(Some("http://www.accellera.org/XMLSchema/IPXACT/1685-2022"), "busDefinition")) ^^
      (x => IPXACT2022scalaxb.DataRecord(x.namespace, Some(x.name), IPXACT2022scalaxb.fromXML[IPXACT2022ScalaCases.BusDefinition](x, IPXACT2022scalaxb.ElemName(node) :: stack)))) |
      ((IPXACT2022scalaxb.ElemName(Some("http://www.accellera.org/XMLSchema/IPXACT/1685-2022"), "abstractionDefinition")) ^^
      (x => IPXACT2022scalaxb.DataRecord(x.namespace, Some(x.name), IPXACT2022scalaxb.fromXML[IPXACT2022ScalaCases.AbstractionDefinition](x, IPXACT2022scalaxb.ElemName(node) :: stack)))) |
      ((IPXACT2022scalaxb.ElemName(Some("http://www.accellera.org/XMLSchema/IPXACT/1685-2022"), "component")) ^^
      (x => IPXACT2022scalaxb.DataRecord(x.namespace, Some(x.name), IPXACT2022scalaxb.fromXML[IPXACT2022ScalaCases.ComponentType](x, IPXACT2022scalaxb.ElemName(node) :: stack)))) |
      ((IPXACT2022scalaxb.ElemName(Some("http://www.accellera.org/XMLSchema/IPXACT/1685-2022"), "abstractor")) ^^
      (x => IPXACT2022scalaxb.DataRecord(x.namespace, Some(x.name), IPXACT2022scalaxb.fromXML[IPXACT2022ScalaCases.AbstractorType](x, IPXACT2022scalaxb.ElemName(node) :: stack)))) |
      ((IPXACT2022scalaxb.ElemName(Some("http://www.accellera.org/XMLSchema/IPXACT/1685-2022"), "design")) ^^
      (x => IPXACT2022scalaxb.DataRecord(x.namespace, Some(x.name), IPXACT2022scalaxb.fromXML[IPXACT2022ScalaCases.Design](x, IPXACT2022scalaxb.ElemName(node) :: stack)))) |
      ((IPXACT2022scalaxb.ElemName(Some("http://www.accellera.org/XMLSchema/IPXACT/1685-2022"), "generatorChain")) ^^
      (x => IPXACT2022scalaxb.DataRecord(x.namespace, Some(x.name), IPXACT2022scalaxb.fromXML[IPXACT2022ScalaCases.GeneratorChain](x, IPXACT2022scalaxb.ElemName(node) :: stack)))) |
      ((IPXACT2022scalaxb.ElemName(Some("http://www.accellera.org/XMLSchema/IPXACT/1685-2022"), "designConfiguration")) ^^
      (x => IPXACT2022scalaxb.DataRecord(x.namespace, Some(x.name), IPXACT2022scalaxb.fromXML[IPXACT2022ScalaCases.DesignConfiguration](x, IPXACT2022scalaxb.ElemName(node) :: stack)))) |
      ((IPXACT2022scalaxb.ElemName(Some("http://www.accellera.org/XMLSchema/IPXACT/1685-2022"), "catalog")) ^^
      (x => IPXACT2022scalaxb.DataRecord(x.namespace, Some(x.name), IPXACT2022scalaxb.fromXML[IPXACT2022ScalaCases.Catalog](x, IPXACT2022scalaxb.ElemName(node) :: stack)))) |
      ((IPXACT2022scalaxb.ElemName(Some("http://www.accellera.org/XMLSchema/IPXACT/1685-2022"), "typeDefinitions")) ^^
      (x => IPXACT2022scalaxb.DataRecord(x.namespace, Some(x.name), IPXACT2022scalaxb.fromXML[IPXACT2022ScalaCases.TypeDefinitions2](x, IPXACT2022scalaxb.ElemName(node) :: stack)))))
  
    def parseIPXACTDocumentTypesGroup(node: scala.xml.Node, stack: List[IPXACT2022scalaxb.ElemName], wrap: Boolean): Parser[IPXACT2022scalaxb.DataRecord[IPXACT2022ScalaCases.IPXACTDocumentTypesOption]] =
      (((IPXACT2022scalaxb.ElemName(Some("http://www.accellera.org/XMLSchema/IPXACT/1685-2022"), "busDefinition")) ^^
      (x => IPXACT2022scalaxb.DataRecord(x.namespace, Some(x.name), IPXACT2022scalaxb.fromXML[IPXACT2022ScalaCases.BusDefinition](x, IPXACT2022scalaxb.ElemName(node) :: stack)))) |
      ((IPXACT2022scalaxb.ElemName(Some("http://www.accellera.org/XMLSchema/IPXACT/1685-2022"), "abstractionDefinition")) ^^
      (x => IPXACT2022scalaxb.DataRecord(x.namespace, Some(x.name), IPXACT2022scalaxb.fromXML[IPXACT2022ScalaCases.AbstractionDefinition](x, IPXACT2022scalaxb.ElemName(node) :: stack)))) |
      ((IPXACT2022scalaxb.ElemName(Some("http://www.accellera.org/XMLSchema/IPXACT/1685-2022"), "component")) ^^
      (x => IPXACT2022scalaxb.DataRecord(x.namespace, Some(x.name), IPXACT2022scalaxb.fromXML[IPXACT2022ScalaCases.ComponentType](x, IPXACT2022scalaxb.ElemName(node) :: stack)))) |
      ((IPXACT2022scalaxb.ElemName(Some("http://www.accellera.org/XMLSchema/IPXACT/1685-2022"), "abstractor")) ^^
      (x => IPXACT2022scalaxb.DataRecord(x.namespace, Some(x.name), IPXACT2022scalaxb.fromXML[IPXACT2022ScalaCases.AbstractorType](x, IPXACT2022scalaxb.ElemName(node) :: stack)))) |
      ((IPXACT2022scalaxb.ElemName(Some("http://www.accellera.org/XMLSchema/IPXACT/1685-2022"), "design")) ^^
      (x => IPXACT2022scalaxb.DataRecord(x.namespace, Some(x.name), IPXACT2022scalaxb.fromXML[IPXACT2022ScalaCases.Design](x, IPXACT2022scalaxb.ElemName(node) :: stack)))) |
      ((IPXACT2022scalaxb.ElemName(Some("http://www.accellera.org/XMLSchema/IPXACT/1685-2022"), "generatorChain")) ^^
      (x => IPXACT2022scalaxb.DataRecord(x.namespace, Some(x.name), IPXACT2022scalaxb.fromXML[IPXACT2022ScalaCases.GeneratorChain](x, IPXACT2022scalaxb.ElemName(node) :: stack)))) |
      ((IPXACT2022scalaxb.ElemName(Some("http://www.accellera.org/XMLSchema/IPXACT/1685-2022"), "designConfiguration")) ^^
      (x => IPXACT2022scalaxb.DataRecord(x.namespace, Some(x.name), IPXACT2022scalaxb.fromXML[IPXACT2022ScalaCases.DesignConfiguration](x, IPXACT2022scalaxb.ElemName(node) :: stack)))) |
      ((IPXACT2022scalaxb.ElemName(Some("http://www.accellera.org/XMLSchema/IPXACT/1685-2022"), "catalog")) ^^
      (x => IPXACT2022scalaxb.DataRecord(x.namespace, Some(x.name), IPXACT2022scalaxb.fromXML[IPXACT2022ScalaCases.Catalog](x, IPXACT2022scalaxb.ElemName(node) :: stack)))) |
      ((IPXACT2022scalaxb.ElemName(Some("http://www.accellera.org/XMLSchema/IPXACT/1685-2022"), "typeDefinitions")) ^^
      (x => IPXACT2022scalaxb.DataRecord(x.namespace, Some(x.name), IPXACT2022scalaxb.fromXML[IPXACT2022ScalaCases.TypeDefinitions2](x, IPXACT2022scalaxb.ElemName(node) :: stack)))))
    
    def parsemixedIPXACTDocumentTypesGroup(node: scala.xml.Node, stack: List[IPXACT2022scalaxb.ElemName]): Parser[Seq[IPXACT2022scalaxb.DataRecord[Any]]] =
      (((((IPXACT2022scalaxb.ElemName(Some("http://www.accellera.org/XMLSchema/IPXACT/1685-2022"), "busDefinition")) ^^
      (x => IPXACT2022scalaxb.DataRecord(x.namespace, Some(x.name), IPXACT2022scalaxb.fromXML[IPXACT2022ScalaCases.BusDefinition](x, IPXACT2022scalaxb.ElemName(node) :: stack)))) ~
      optTextRecord) ^^ 
        { case p1 ~ p2 => Seq.concat(Seq(p1),
        p2.toList) }) ||| 
      ((((IPXACT2022scalaxb.ElemName(Some("http://www.accellera.org/XMLSchema/IPXACT/1685-2022"), "abstractionDefinition")) ^^
      (x => IPXACT2022scalaxb.DataRecord(x.namespace, Some(x.name), IPXACT2022scalaxb.fromXML[IPXACT2022ScalaCases.AbstractionDefinition](x, IPXACT2022scalaxb.ElemName(node) :: stack)))) ~
      optTextRecord) ^^ 
        { case p1 ~ p2 => Seq.concat(Seq(p1),
        p2.toList) }) ||| 
      ((((IPXACT2022scalaxb.ElemName(Some("http://www.accellera.org/XMLSchema/IPXACT/1685-2022"), "component")) ^^
      (x => IPXACT2022scalaxb.DataRecord(x.namespace, Some(x.name), IPXACT2022scalaxb.fromXML[IPXACT2022ScalaCases.ComponentType](x, IPXACT2022scalaxb.ElemName(node) :: stack)))) ~
      optTextRecord) ^^ 
        { case p1 ~ p2 => Seq.concat(Seq(p1),
        p2.toList) }) ||| 
      ((((IPXACT2022scalaxb.ElemName(Some("http://www.accellera.org/XMLSchema/IPXACT/1685-2022"), "abstractor")) ^^
      (x => IPXACT2022scalaxb.DataRecord(x.namespace, Some(x.name), IPXACT2022scalaxb.fromXML[IPXACT2022ScalaCases.AbstractorType](x, IPXACT2022scalaxb.ElemName(node) :: stack)))) ~
      optTextRecord) ^^ 
        { case p1 ~ p2 => Seq.concat(Seq(p1),
        p2.toList) }) ||| 
      ((((IPXACT2022scalaxb.ElemName(Some("http://www.accellera.org/XMLSchema/IPXACT/1685-2022"), "design")) ^^
      (x => IPXACT2022scalaxb.DataRecord(x.namespace, Some(x.name), IPXACT2022scalaxb.fromXML[IPXACT2022ScalaCases.Design](x, IPXACT2022scalaxb.ElemName(node) :: stack)))) ~
      optTextRecord) ^^ 
        { case p1 ~ p2 => Seq.concat(Seq(p1),
        p2.toList) }) ||| 
      ((((IPXACT2022scalaxb.ElemName(Some("http://www.accellera.org/XMLSchema/IPXACT/1685-2022"), "generatorChain")) ^^
      (x => IPXACT2022scalaxb.DataRecord(x.namespace, Some(x.name), IPXACT2022scalaxb.fromXML[IPXACT2022ScalaCases.GeneratorChain](x, IPXACT2022scalaxb.ElemName(node) :: stack)))) ~
      optTextRecord) ^^ 
        { case p1 ~ p2 => Seq.concat(Seq(p1),
        p2.toList) }) ||| 
      ((((IPXACT2022scalaxb.ElemName(Some("http://www.accellera.org/XMLSchema/IPXACT/1685-2022"), "designConfiguration")) ^^
      (x => IPXACT2022scalaxb.DataRecord(x.namespace, Some(x.name), IPXACT2022scalaxb.fromXML[IPXACT2022ScalaCases.DesignConfiguration](x, IPXACT2022scalaxb.ElemName(node) :: stack)))) ~
      optTextRecord) ^^ 
        { case p1 ~ p2 => Seq.concat(Seq(p1),
        p2.toList) }) ||| 
      ((((IPXACT2022scalaxb.ElemName(Some("http://www.accellera.org/XMLSchema/IPXACT/1685-2022"), "catalog")) ^^
      (x => IPXACT2022scalaxb.DataRecord(x.namespace, Some(x.name), IPXACT2022scalaxb.fromXML[IPXACT2022ScalaCases.Catalog](x, IPXACT2022scalaxb.ElemName(node) :: stack)))) ~
      optTextRecord) ^^ 
        { case p1 ~ p2 => Seq.concat(Seq(p1),
        p2.toList) }) ||| 
      ((((IPXACT2022scalaxb.ElemName(Some("http://www.accellera.org/XMLSchema/IPXACT/1685-2022"), "typeDefinitions")) ^^
      (x => IPXACT2022scalaxb.DataRecord(x.namespace, Some(x.name), IPXACT2022scalaxb.fromXML[IPXACT2022ScalaCases.TypeDefinitions2](x, IPXACT2022scalaxb.ElemName(node) :: stack)))) ~
      optTextRecord) ^^ 
        { case p1 ~ p2 => Seq.concat(Seq(p1),
        p2.toList) }))
  }

  def buildIPXACT2022ScalaCases_AccessTypeFormat = new DefaultIPXACT2022ScalaCases_AccessTypeFormat {}
  trait DefaultIPXACT2022ScalaCases_AccessTypeFormat extends IPXACT2022scalaxb.XMLFormat[IPXACT2022ScalaCases.AccessType] {
    val targetNamespace: Option[String] = Some("http://www.accellera.org/XMLSchema/IPXACT/1685-2022")
    
    def fromString(value: String, scope: scala.xml.NamespaceBinding): IPXACT2022ScalaCases.AccessType =
        (fromString0(value, scope)).apply(IPXACT2022scalaxb.fromXML[String](scala.xml.Text(value)))

    private def fromString0(value: String, scope: scala.xml.NamespaceBinding): PartialFunction[Any, IPXACT2022ScalaCases.AccessType] = {
      case x: String if x == IPXACT2022scalaxb.fromXML[String](scala.xml.Text("read-only")) => IPXACT2022ScalaCases.Readu45only
      case x: String if x == IPXACT2022scalaxb.fromXML[String](scala.xml.Text("write-only")) => IPXACT2022ScalaCases.Writeu45only
      case x: String if x == IPXACT2022scalaxb.fromXML[String](scala.xml.Text("read-write")) => IPXACT2022ScalaCases.Readu45write
      case x: String if x == IPXACT2022scalaxb.fromXML[String](scala.xml.Text("writeOnce")) => IPXACT2022ScalaCases.WriteOnce
      case x: String if x == IPXACT2022scalaxb.fromXML[String](scala.xml.Text("read-writeOnce")) => IPXACT2022ScalaCases.Readu45writeOnce
      case x: String if x == IPXACT2022scalaxb.fromXML[String](scala.xml.Text("no-access")) => IPXACT2022ScalaCases.Nou45access

    }



    def reads(seq: scala.xml.NodeSeq, stack: List[IPXACT2022scalaxb.ElemName]): Either[String, IPXACT2022ScalaCases.AccessType] = seq match {
      case elem: scala.xml.Elem => Right(fromString(elem.text, elem.scope))
      case _ => Right(fromString(seq.text, scala.xml.TopScope))
    }
    
    def writes(__obj: IPXACT2022ScalaCases.AccessType, __namespace: Option[String], __elementLabel: Option[String],
        __scope: scala.xml.NamespaceBinding, __typeAttribute: Boolean): scala.xml.NodeSeq =
      scala.xml.Elem(IPXACT2022scalaxb.Helper.getPrefix(__namespace, __scope).orNull,
        __elementLabel getOrElse { sys.error("missing element label.") },
        scala.xml.Null, __scope, true, scala.xml.Text(__obj.toString))
  }
  def buildIPXACT2022ScalaCases_SharedTypeFormat = new DefaultIPXACT2022ScalaCases_SharedTypeFormat {}
  trait DefaultIPXACT2022ScalaCases_SharedTypeFormat extends IPXACT2022scalaxb.XMLFormat[IPXACT2022ScalaCases.SharedType] {
    val targetNamespace: Option[String] = Some("http://www.accellera.org/XMLSchema/IPXACT/1685-2022")
    
    def fromString(value: String, scope: scala.xml.NamespaceBinding): IPXACT2022ScalaCases.SharedType =
        (fromString0(value, scope)).apply(IPXACT2022scalaxb.fromXML[String](scala.xml.Text(value)))

    private def fromString0(value: String, scope: scala.xml.NamespaceBinding): PartialFunction[Any, IPXACT2022ScalaCases.SharedType] = {
      case x: String if x == IPXACT2022scalaxb.fromXML[String](scala.xml.Text("yes")) => IPXACT2022ScalaCases.Yes
      case x: String if x == IPXACT2022scalaxb.fromXML[String](scala.xml.Text("no")) => IPXACT2022ScalaCases.No
      case x: String if x == IPXACT2022scalaxb.fromXML[String](scala.xml.Text("undefined")) => IPXACT2022ScalaCases.Undefined

    }



    def reads(seq: scala.xml.NodeSeq, stack: List[IPXACT2022scalaxb.ElemName]): Either[String, IPXACT2022ScalaCases.SharedType] = seq match {
      case elem: scala.xml.Elem => Right(fromString(elem.text, elem.scope))
      case _ => Right(fromString(seq.text, scala.xml.TopScope))
    }
    
    def writes(__obj: IPXACT2022ScalaCases.SharedType, __namespace: Option[String], __elementLabel: Option[String],
        __scope: scala.xml.NamespaceBinding, __typeAttribute: Boolean): scala.xml.NodeSeq =
      scala.xml.Elem(IPXACT2022scalaxb.Helper.getPrefix(__namespace, __scope).orNull,
        __elementLabel getOrElse { sys.error("missing element label.") },
        scala.xml.Null, __scope, true, scala.xml.Text(__obj.toString))
  }
  def buildIPXACT2022ScalaCases_BankAlignmentTypeFormat = new DefaultIPXACT2022ScalaCases_BankAlignmentTypeFormat {}
  trait DefaultIPXACT2022ScalaCases_BankAlignmentTypeFormat extends IPXACT2022scalaxb.XMLFormat[IPXACT2022ScalaCases.BankAlignmentType] {
    val targetNamespace: Option[String] = Some("http://www.accellera.org/XMLSchema/IPXACT/1685-2022")
    
    def fromString(value: String, scope: scala.xml.NamespaceBinding): IPXACT2022ScalaCases.BankAlignmentType =
        (fromString0(value, scope)).apply(IPXACT2022scalaxb.fromXML[String](scala.xml.Text(value)))

    private def fromString0(value: String, scope: scala.xml.NamespaceBinding): PartialFunction[Any, IPXACT2022ScalaCases.BankAlignmentType] = {
      case x: String if x == IPXACT2022scalaxb.fromXML[String](scala.xml.Text("serial")) => IPXACT2022ScalaCases.Serial
      case x: String if x == IPXACT2022scalaxb.fromXML[String](scala.xml.Text("parallel")) => IPXACT2022ScalaCases.Parallel

    }



    def reads(seq: scala.xml.NodeSeq, stack: List[IPXACT2022scalaxb.ElemName]): Either[String, IPXACT2022ScalaCases.BankAlignmentType] = seq match {
      case elem: scala.xml.Elem => Right(fromString(elem.text, elem.scope))
      case _ => Right(fromString(seq.text, scala.xml.TopScope))
    }
    
    def writes(__obj: IPXACT2022ScalaCases.BankAlignmentType, __namespace: Option[String], __elementLabel: Option[String],
        __scope: scala.xml.NamespaceBinding, __typeAttribute: Boolean): scala.xml.NodeSeq =
      scala.xml.Elem(IPXACT2022scalaxb.Helper.getPrefix(__namespace, __scope).orNull,
        __elementLabel getOrElse { sys.error("missing element label.") },
        scala.xml.Null, __scope, true, scala.xml.Text(__obj.toString))
  }
  def buildIPXACT2022ScalaCases_UsageTypeFormat = new DefaultIPXACT2022ScalaCases_UsageTypeFormat {}
  trait DefaultIPXACT2022ScalaCases_UsageTypeFormat extends IPXACT2022scalaxb.XMLFormat[IPXACT2022ScalaCases.UsageType] {
    val targetNamespace: Option[String] = Some("http://www.accellera.org/XMLSchema/IPXACT/1685-2022")
    
    def fromString(value: String, scope: scala.xml.NamespaceBinding): IPXACT2022ScalaCases.UsageType =
        (fromString0(value, scope)).apply(IPXACT2022scalaxb.fromXML[String](scala.xml.Text(value)))

    private def fromString0(value: String, scope: scala.xml.NamespaceBinding): PartialFunction[Any, IPXACT2022ScalaCases.UsageType] = {
      case x: String if x == IPXACT2022scalaxb.fromXML[String](scala.xml.Text("memory")) => IPXACT2022ScalaCases.Memory
      case x: String if x == IPXACT2022scalaxb.fromXML[String](scala.xml.Text("register")) => IPXACT2022ScalaCases.RegisterValue
      case x: String if x == IPXACT2022scalaxb.fromXML[String](scala.xml.Text("reserved")) => IPXACT2022ScalaCases.Reserved

    }



    def reads(seq: scala.xml.NodeSeq, stack: List[IPXACT2022scalaxb.ElemName]): Either[String, IPXACT2022ScalaCases.UsageType] = seq match {
      case elem: scala.xml.Elem => Right(fromString(elem.text, elem.scope))
      case _ => Right(fromString(seq.text, scala.xml.TopScope))
    }
    
    def writes(__obj: IPXACT2022ScalaCases.UsageType, __namespace: Option[String], __elementLabel: Option[String],
        __scope: scala.xml.NamespaceBinding, __typeAttribute: Boolean): scala.xml.NodeSeq =
      scala.xml.Elem(IPXACT2022scalaxb.Helper.getPrefix(__namespace, __scope).orNull,
        __elementLabel getOrElse { sys.error("missing element label.") },
        scala.xml.Null, __scope, true, scala.xml.Text(__obj.toString))
  }
  trait DefaultIPXACT2022ScalaCases_AccessHandlesFormat extends IPXACT2022scalaxb.ElemNameParser[IPXACT2022ScalaCases.AccessHandles] {
    val targetNamespace: Option[String] = Some("http://www.accellera.org/XMLSchema/IPXACT/1685-2022")
    
    def parser(node: scala.xml.Node, stack: List[IPXACT2022scalaxb.ElemName]): Parser[IPXACT2022ScalaCases.AccessHandles] =
      phrase(safeRep(((IPXACT2022scalaxb.ElemName(Some("http://www.accellera.org/XMLSchema/IPXACT/1685-2022"), "accessHandle"))) ^^
        { case p1 => IPXACT2022ScalaCases.AccessHandlesSequence1(IPXACT2022scalaxb.fromXML[IPXACT2022ScalaCases.SimpleAccessHandle](p1, IPXACT2022scalaxb.ElemName(node) :: stack)) }) ^^
      { case p1 =>
      IPXACT2022ScalaCases.AccessHandles(p1) })
    
    def writesChildNodes(__obj: IPXACT2022ScalaCases.AccessHandles, __scope: scala.xml.NamespaceBinding): Seq[scala.xml.Node] =
      (__obj.accesshandlessequence1 flatMap { IPXACT2022scalaxb.toXML[IPXACT2022ScalaCases.AccessHandlesSequence1](_, None, Some("accesshandlessequence1"), __scope, false) })
  }

  trait DefaultIPXACT2022ScalaCases_AccessHandlesSequence1Format extends IPXACT2022scalaxb.XMLFormat[IPXACT2022ScalaCases.AccessHandlesSequence1] {
    def reads(seq: scala.xml.NodeSeq, stack: List[IPXACT2022scalaxb.ElemName]): Either[String, IPXACT2022ScalaCases.AccessHandlesSequence1] = Left("don't call me.")
    
    def writes(__obj: IPXACT2022ScalaCases.AccessHandlesSequence1, __namespace: Option[String], __elementLabel: Option[String],
        __scope: scala.xml.NamespaceBinding, __typeAttribute: Boolean): scala.xml.NodeSeq =
      IPXACT2022scalaxb.toXML[IPXACT2022ScalaCases.SimpleAccessHandle](__obj.accessHandle, Some("http://www.accellera.org/XMLSchema/IPXACT/1685-2022"), Some("accessHandle"), __scope, false)

  }
  trait DefaultIPXACT2022ScalaCases_BankDefinitionRefFormat extends IPXACT2022scalaxb.XMLFormat[IPXACT2022ScalaCases.BankDefinitionRef] with IPXACT2022scalaxb.CanWriteChildNodes[IPXACT2022ScalaCases.BankDefinitionRef] {
    val targetNamespace: Option[String] = Some("http://www.accellera.org/XMLSchema/IPXACT/1685-2022")
    def reads(seq: scala.xml.NodeSeq, stack: List[IPXACT2022scalaxb.ElemName]): Either[String, IPXACT2022ScalaCases.BankDefinitionRef] = seq match {
      case node: scala.xml.Node => Right(IPXACT2022ScalaCases.BankDefinitionRef(IPXACT2022scalaxb.fromXML[String](node, IPXACT2022scalaxb.ElemName(node) :: stack),
        scala.collection.immutable.ListMap(List(
        (node \ "@typeDefinitions").headOption map { x => IPXACT2022scalaxb.DataRecord(x, node, IPXACT2022scalaxb.fromXML[String](x, IPXACT2022scalaxb.ElemName(node) :: stack)) } map { "@typeDefinitions" -> _ }
        ).flatten[(String, IPXACT2022scalaxb.DataRecord[Any])]: _*)))
      case _ => Left("reads failed: seq must be scala.xml.Node")
    }
    
    override def writesAttribute(__obj: IPXACT2022ScalaCases.BankDefinitionRef, __scope: scala.xml.NamespaceBinding): scala.xml.MetaData = {
      var attr: scala.xml.MetaData  = scala.xml.Null
      __obj.attributes.toList map {
        case ("@typeDefinitions", _) => attr = scala.xml.Attribute(null, "typeDefinitions", __obj.typeDefinitions.toString, attr)
        case (key, x) => attr = scala.xml.Attribute((x.namespace map { __scope.getPrefix(_) }).orNull, x.key.orNull, x.value.toString, attr)
      }
      attr
    }

    def writesChildNodes(__obj: IPXACT2022ScalaCases.BankDefinitionRef, __scope: scala.xml.NamespaceBinding): Seq[scala.xml.Node] =
      Seq(scala.xml.Text(__obj.value.toString))

  }

  trait DefaultIPXACT2022ScalaCases_AddressBankTypeFormat extends IPXACT2022scalaxb.ElemNameParser[IPXACT2022ScalaCases.AddressBankType] with IPXACT2022ScalaCases_NameGroupGroupFormat with IPXACT2022ScalaCases_AddressSpecifierGroupFormat with IPXACT2022ScalaCases_BankBaseGroupFormat {
    val targetNamespace: Option[String] = Some("http://www.accellera.org/XMLSchema/IPXACT/1685-2022")
    
    override def typeName: Option[String] = Some("addressBankType")

    def parser(node: scala.xml.Node, stack: List[IPXACT2022scalaxb.ElemName]): Parser[IPXACT2022ScalaCases.AddressBankType] =
      phrase((parseNameGroupGroup(node, IPXACT2022scalaxb.ElemName(node) :: stack)) ~
      opt(IPXACT2022scalaxb.ElemName(Some("http://www.accellera.org/XMLSchema/IPXACT/1685-2022"), "accessHandles")) ~
      (parseAddressSpecifierGroup(node, IPXACT2022scalaxb.ElemName(node) :: stack)) ~
      (((IPXACT2022scalaxb.ElemName(Some("http://www.accellera.org/XMLSchema/IPXACT/1685-2022"), "bankDefinitionRef")) ^^
      (x => IPXACT2022scalaxb.DataRecord(x.namespace, Some(x.name), IPXACT2022scalaxb.fromXML[IPXACT2022ScalaCases.BankDefinitionRef](x, IPXACT2022scalaxb.ElemName(node) :: stack)))) |||
      (parseBankBaseGroup(node, IPXACT2022scalaxb.ElemName(node) :: stack, true))) ~
      opt(IPXACT2022scalaxb.ElemName(Some("http://www.accellera.org/XMLSchema/IPXACT/1685-2022"), "vendorExtensions")) ^^
      { case p1 ~ p2 ~ p3 ~ p4 ~ p5 =>
      IPXACT2022ScalaCases.AddressBankType(p1,
        p2.headOption map { IPXACT2022scalaxb.fromXML[IPXACT2022ScalaCases.AccessHandles](_, IPXACT2022scalaxb.ElemName(node) :: stack) },
        p3,
        p4,
        p5.headOption map { IPXACT2022scalaxb.fromXML[IPXACT2022ScalaCases.VendorExtensions](_, IPXACT2022scalaxb.ElemName(node) :: stack) },
        scala.collection.immutable.ListMap(List(
        (node \ "@bankAlignment").headOption map { x => IPXACT2022scalaxb.DataRecord(x, node, IPXACT2022scalaxb.fromXML[IPXACT2022ScalaCases.BankAlignmentType](x, IPXACT2022scalaxb.ElemName(node) :: stack)) } map { "@bankAlignment" -> _ },
        (node \ "@{http://www.w3.org/XML/1998/namespace}id").headOption map { x => IPXACT2022scalaxb.DataRecord(x, node, IPXACT2022scalaxb.fromXML[String](x, IPXACT2022scalaxb.ElemName(node) :: stack)) } map { "@{http://www.w3.org/XML/1998/namespace}id" -> _ }
        ).flatten[(String, IPXACT2022scalaxb.DataRecord[Any])]: _*)) })
    
    override def writesAttribute(__obj: IPXACT2022ScalaCases.AddressBankType, __scope: scala.xml.NamespaceBinding): scala.xml.MetaData = {
      var attr: scala.xml.MetaData  = scala.xml.Null
      __obj.attributes.toList map {
        case ("@bankAlignment", _) => attr = scala.xml.Attribute(null, "bankAlignment", __obj.bankAlignment.toString, attr)
        case ("@{http://www.w3.org/XML/1998/namespace}id", _) => __obj.xmlid foreach { x => attr = scala.xml.Attribute(__scope.getPrefix("http://www.w3.org/XML/1998/namespace"), "id", x.toString, attr) }
        case (key, x) => attr = scala.xml.Attribute((x.namespace map { __scope.getPrefix(_) }).orNull, x.key.orNull, x.value.toString, attr)
      }
      attr
    }

    def writesChildNodes(__obj: IPXACT2022ScalaCases.AddressBankType, __scope: scala.xml.NamespaceBinding): Seq[scala.xml.Node] =
      Seq.concat(IPXACT2022scalaxb.toXML[IPXACT2022ScalaCases.NameGroupSequence](__obj.nameGroupSequence1, None, Some("nameGroupSequence1"), __scope, false),
        __obj.accessHandles map { IPXACT2022scalaxb.toXML[IPXACT2022ScalaCases.AccessHandles](_, Some("http://www.accellera.org/XMLSchema/IPXACT/1685-2022"), Some("accessHandles"), __scope, false) } getOrElse {Nil},
        IPXACT2022scalaxb.toXML[IPXACT2022ScalaCases.AddressSpecifierSequence](__obj.addressSpecifierSequence3, None, Some("addressSpecifierSequence3"), __scope, false),
        (Some(__obj.addressbanktypeoption) map {x => IPXACT2022scalaxb.toXML[IPXACT2022scalaxb.DataRecord[Any]](x, x.namespace, x.key, __scope, false)}).get,
        __obj.vendorExtensions map { IPXACT2022scalaxb.toXML[IPXACT2022ScalaCases.VendorExtensions](_, Some("http://www.accellera.org/XMLSchema/IPXACT/1685-2022"), Some("vendorExtensions"), __scope, false) } getOrElse {Nil})

  }

  trait DefaultIPXACT2022ScalaCases_AccessHandles2Format extends IPXACT2022scalaxb.ElemNameParser[IPXACT2022ScalaCases.AccessHandles2] {
    val targetNamespace: Option[String] = Some("http://www.accellera.org/XMLSchema/IPXACT/1685-2022")
    
    def parser(node: scala.xml.Node, stack: List[IPXACT2022scalaxb.ElemName]): Parser[IPXACT2022ScalaCases.AccessHandles2] =
      phrase(safeRep(((IPXACT2022scalaxb.ElemName(Some("http://www.accellera.org/XMLSchema/IPXACT/1685-2022"), "accessHandle"))) ^^
        { case p1 => IPXACT2022ScalaCases.AccessHandles2Sequence1(IPXACT2022scalaxb.fromXML[IPXACT2022ScalaCases.SimpleAccessHandle](p1, IPXACT2022scalaxb.ElemName(node) :: stack)) }) ^^
      { case p1 =>
      IPXACT2022ScalaCases.AccessHandles2(p1) })
    
    def writesChildNodes(__obj: IPXACT2022ScalaCases.AccessHandles2, __scope: scala.xml.NamespaceBinding): Seq[scala.xml.Node] =
      (__obj.accesshandles2sequence1 flatMap { IPXACT2022scalaxb.toXML[IPXACT2022ScalaCases.AccessHandles2Sequence1](_, None, Some("accesshandles2sequence1"), __scope, false) })
  }

  trait DefaultIPXACT2022ScalaCases_AccessHandles2Sequence1Format extends IPXACT2022scalaxb.XMLFormat[IPXACT2022ScalaCases.AccessHandles2Sequence1] {
    def reads(seq: scala.xml.NodeSeq, stack: List[IPXACT2022scalaxb.ElemName]): Either[String, IPXACT2022ScalaCases.AccessHandles2Sequence1] = Left("don't call me.")
    
    def writes(__obj: IPXACT2022ScalaCases.AccessHandles2Sequence1, __namespace: Option[String], __elementLabel: Option[String],
        __scope: scala.xml.NamespaceBinding, __typeAttribute: Boolean): scala.xml.NodeSeq =
      IPXACT2022scalaxb.toXML[IPXACT2022ScalaCases.SimpleAccessHandle](__obj.accessHandle, Some("http://www.accellera.org/XMLSchema/IPXACT/1685-2022"), Some("accessHandle"), __scope, false)

  }
  trait DefaultIPXACT2022ScalaCases_BankDefinitionRef2Format extends IPXACT2022scalaxb.XMLFormat[IPXACT2022ScalaCases.BankDefinitionRef2] with IPXACT2022scalaxb.CanWriteChildNodes[IPXACT2022ScalaCases.BankDefinitionRef2] {
    val targetNamespace: Option[String] = Some("http://www.accellera.org/XMLSchema/IPXACT/1685-2022")
    def reads(seq: scala.xml.NodeSeq, stack: List[IPXACT2022scalaxb.ElemName]): Either[String, IPXACT2022ScalaCases.BankDefinitionRef2] = seq match {
      case node: scala.xml.Node => Right(IPXACT2022ScalaCases.BankDefinitionRef2(IPXACT2022scalaxb.fromXML[String](node, IPXACT2022scalaxb.ElemName(node) :: stack),
        scala.collection.immutable.ListMap(List(
        (node \ "@typeDefinitions").headOption map { x => IPXACT2022scalaxb.DataRecord(x, node, IPXACT2022scalaxb.fromXML[String](x, IPXACT2022scalaxb.ElemName(node) :: stack)) } map { "@typeDefinitions" -> _ }
        ).flatten[(String, IPXACT2022scalaxb.DataRecord[Any])]: _*)))
      case _ => Left("reads failed: seq must be scala.xml.Node")
    }
    
    override def writesAttribute(__obj: IPXACT2022ScalaCases.BankDefinitionRef2, __scope: scala.xml.NamespaceBinding): scala.xml.MetaData = {
      var attr: scala.xml.MetaData  = scala.xml.Null
      __obj.attributes.toList map {
        case ("@typeDefinitions", _) => attr = scala.xml.Attribute(null, "typeDefinitions", __obj.typeDefinitions.toString, attr)
        case (key, x) => attr = scala.xml.Attribute((x.namespace map { __scope.getPrefix(_) }).orNull, x.key.orNull, x.value.toString, attr)
      }
      attr
    }

    def writesChildNodes(__obj: IPXACT2022ScalaCases.BankDefinitionRef2, __scope: scala.xml.NamespaceBinding): Seq[scala.xml.Node] =
      Seq(scala.xml.Text(__obj.value.toString))

  }

  trait DefaultIPXACT2022ScalaCases_AddressBankDefinitionTypeFormat extends IPXACT2022scalaxb.ElemNameParser[IPXACT2022ScalaCases.AddressBankDefinitionType] with IPXACT2022ScalaCases_NameGroupGroupFormat with IPXACT2022ScalaCases_AddressSpecifierGroupFormat with IPXACT2022ScalaCases_BankDefinitionBaseGroupFormat {
    val targetNamespace: Option[String] = Some("http://www.accellera.org/XMLSchema/IPXACT/1685-2022")
    
    override def typeName: Option[String] = Some("addressBankDefinitionType")

    def parser(node: scala.xml.Node, stack: List[IPXACT2022scalaxb.ElemName]): Parser[IPXACT2022ScalaCases.AddressBankDefinitionType] =
      phrase((parseNameGroupGroup(node, IPXACT2022scalaxb.ElemName(node) :: stack)) ~
      opt(IPXACT2022scalaxb.ElemName(Some("http://www.accellera.org/XMLSchema/IPXACT/1685-2022"), "accessHandles")) ~
      (parseAddressSpecifierGroup(node, IPXACT2022scalaxb.ElemName(node) :: stack)) ~
      (((IPXACT2022scalaxb.ElemName(Some("http://www.accellera.org/XMLSchema/IPXACT/1685-2022"), "bankDefinitionRef")) ^^
      (x => IPXACT2022scalaxb.DataRecord(x.namespace, Some(x.name), IPXACT2022scalaxb.fromXML[IPXACT2022ScalaCases.BankDefinitionRef2](x, IPXACT2022scalaxb.ElemName(node) :: stack)))) |||
      (parseBankDefinitionBaseGroup(node, IPXACT2022scalaxb.ElemName(node) :: stack, true))) ~
      opt(IPXACT2022scalaxb.ElemName(Some("http://www.accellera.org/XMLSchema/IPXACT/1685-2022"), "vendorExtensions")) ^^
      { case p1 ~ p2 ~ p3 ~ p4 ~ p5 =>
      IPXACT2022ScalaCases.AddressBankDefinitionType(p1,
        p2.headOption map { IPXACT2022scalaxb.fromXML[IPXACT2022ScalaCases.AccessHandles2](_, IPXACT2022scalaxb.ElemName(node) :: stack) },
        p3,
        p4,
        p5.headOption map { IPXACT2022scalaxb.fromXML[IPXACT2022ScalaCases.VendorExtensions](_, IPXACT2022scalaxb.ElemName(node) :: stack) },
        scala.collection.immutable.ListMap(List(
        (node \ "@bankAlignment").headOption map { x => IPXACT2022scalaxb.DataRecord(x, node, IPXACT2022scalaxb.fromXML[IPXACT2022ScalaCases.BankAlignmentType](x, IPXACT2022scalaxb.ElemName(node) :: stack)) } map { "@bankAlignment" -> _ },
        (node \ "@{http://www.w3.org/XML/1998/namespace}id").headOption map { x => IPXACT2022scalaxb.DataRecord(x, node, IPXACT2022scalaxb.fromXML[String](x, IPXACT2022scalaxb.ElemName(node) :: stack)) } map { "@{http://www.w3.org/XML/1998/namespace}id" -> _ }
        ).flatten[(String, IPXACT2022scalaxb.DataRecord[Any])]: _*)) })
    
    override def writesAttribute(__obj: IPXACT2022ScalaCases.AddressBankDefinitionType, __scope: scala.xml.NamespaceBinding): scala.xml.MetaData = {
      var attr: scala.xml.MetaData  = scala.xml.Null
      __obj.attributes.toList map {
        case ("@bankAlignment", _) => attr = scala.xml.Attribute(null, "bankAlignment", __obj.bankAlignment.toString, attr)
        case ("@{http://www.w3.org/XML/1998/namespace}id", _) => __obj.xmlid foreach { x => attr = scala.xml.Attribute(__scope.getPrefix("http://www.w3.org/XML/1998/namespace"), "id", x.toString, attr) }
        case (key, x) => attr = scala.xml.Attribute((x.namespace map { __scope.getPrefix(_) }).orNull, x.key.orNull, x.value.toString, attr)
      }
      attr
    }

    def writesChildNodes(__obj: IPXACT2022ScalaCases.AddressBankDefinitionType, __scope: scala.xml.NamespaceBinding): Seq[scala.xml.Node] =
      Seq.concat(IPXACT2022scalaxb.toXML[IPXACT2022ScalaCases.NameGroupSequence](__obj.nameGroupSequence1, None, Some("nameGroupSequence1"), __scope, false),
        __obj.accessHandles map { IPXACT2022scalaxb.toXML[IPXACT2022ScalaCases.AccessHandles2](_, Some("http://www.accellera.org/XMLSchema/IPXACT/1685-2022"), Some("accessHandles"), __scope, false) } getOrElse {Nil},
        IPXACT2022scalaxb.toXML[IPXACT2022ScalaCases.AddressSpecifierSequence](__obj.addressSpecifierSequence3, None, Some("addressSpecifierSequence3"), __scope, false),
        (Some(__obj.addressbankdefinitiontypeoption) map {x => IPXACT2022scalaxb.toXML[IPXACT2022scalaxb.DataRecord[Any]](x, x.namespace, x.key, __scope, false)}).get,
        __obj.vendorExtensions map { IPXACT2022scalaxb.toXML[IPXACT2022ScalaCases.VendorExtensions](_, Some("http://www.accellera.org/XMLSchema/IPXACT/1685-2022"), Some("vendorExtensions"), __scope, false) } getOrElse {Nil})

  }

  trait DefaultIPXACT2022ScalaCases_AccessHandles3Format extends IPXACT2022scalaxb.ElemNameParser[IPXACT2022ScalaCases.AccessHandles3] {
    val targetNamespace: Option[String] = Some("http://www.accellera.org/XMLSchema/IPXACT/1685-2022")
    
    def parser(node: scala.xml.Node, stack: List[IPXACT2022scalaxb.ElemName]): Parser[IPXACT2022ScalaCases.AccessHandles3] =
      phrase(safeRep(((IPXACT2022scalaxb.ElemName(Some("http://www.accellera.org/XMLSchema/IPXACT/1685-2022"), "accessHandle"))) ^^
        { case p1 => IPXACT2022ScalaCases.AccessHandles3Sequence1(IPXACT2022scalaxb.fromXML[IPXACT2022ScalaCases.SimpleAccessHandle](p1, IPXACT2022scalaxb.ElemName(node) :: stack)) }) ^^
      { case p1 =>
      IPXACT2022ScalaCases.AccessHandles3(p1) })
    
    def writesChildNodes(__obj: IPXACT2022ScalaCases.AccessHandles3, __scope: scala.xml.NamespaceBinding): Seq[scala.xml.Node] =
      (__obj.accesshandles3sequence1 flatMap { IPXACT2022scalaxb.toXML[IPXACT2022ScalaCases.AccessHandles3Sequence1](_, None, Some("accesshandles3sequence1"), __scope, false) })
  }

  trait DefaultIPXACT2022ScalaCases_AccessHandles3Sequence1Format extends IPXACT2022scalaxb.XMLFormat[IPXACT2022ScalaCases.AccessHandles3Sequence1] {
    def reads(seq: scala.xml.NodeSeq, stack: List[IPXACT2022scalaxb.ElemName]): Either[String, IPXACT2022ScalaCases.AccessHandles3Sequence1] = Left("don't call me.")
    
    def writes(__obj: IPXACT2022ScalaCases.AccessHandles3Sequence1, __namespace: Option[String], __elementLabel: Option[String],
        __scope: scala.xml.NamespaceBinding, __typeAttribute: Boolean): scala.xml.NodeSeq =
      IPXACT2022scalaxb.toXML[IPXACT2022ScalaCases.SimpleAccessHandle](__obj.accessHandle, Some("http://www.accellera.org/XMLSchema/IPXACT/1685-2022"), Some("accessHandle"), __scope, false)

  }
  trait DefaultIPXACT2022ScalaCases_LocalAddressBankTypeFormat extends IPXACT2022scalaxb.ElemNameParser[IPXACT2022ScalaCases.LocalAddressBankType] with IPXACT2022ScalaCases_NameGroupGroupFormat with IPXACT2022ScalaCases_AddressSpecifierGroupFormat with IPXACT2022ScalaCases_LocalBankBaseGroupFormat {
    val targetNamespace: Option[String] = Some("http://www.accellera.org/XMLSchema/IPXACT/1685-2022")
    
    override def typeName: Option[String] = Some("localAddressBankType")

    def parser(node: scala.xml.Node, stack: List[IPXACT2022scalaxb.ElemName]): Parser[IPXACT2022ScalaCases.LocalAddressBankType] =
      phrase((parseNameGroupGroup(node, IPXACT2022scalaxb.ElemName(node) :: stack)) ~
      opt(IPXACT2022scalaxb.ElemName(Some("http://www.accellera.org/XMLSchema/IPXACT/1685-2022"), "accessHandles")) ~
      (parseAddressSpecifierGroup(node, IPXACT2022scalaxb.ElemName(node) :: stack)) ~
      (parseLocalBankBaseGroup(node, IPXACT2022scalaxb.ElemName(node) :: stack)) ^^
      { case p1 ~ p2 ~ p3 ~ p4 =>
      IPXACT2022ScalaCases.LocalAddressBankType(p1,
        p2.headOption map { IPXACT2022scalaxb.fromXML[IPXACT2022ScalaCases.AccessHandles3](_, IPXACT2022scalaxb.ElemName(node) :: stack) },
        p3,
        p4,
        scala.collection.immutable.ListMap(List(
        (node \ "@bankAlignment").headOption map { x => IPXACT2022scalaxb.DataRecord(x, node, IPXACT2022scalaxb.fromXML[IPXACT2022ScalaCases.BankAlignmentType](x, IPXACT2022scalaxb.ElemName(node) :: stack)) } map { "@bankAlignment" -> _ },
        (node \ "@{http://www.w3.org/XML/1998/namespace}id").headOption map { x => IPXACT2022scalaxb.DataRecord(x, node, IPXACT2022scalaxb.fromXML[String](x, IPXACT2022scalaxb.ElemName(node) :: stack)) } map { "@{http://www.w3.org/XML/1998/namespace}id" -> _ }
        ).flatten[(String, IPXACT2022scalaxb.DataRecord[Any])]: _*)) })
    
    override def writesAttribute(__obj: IPXACT2022ScalaCases.LocalAddressBankType, __scope: scala.xml.NamespaceBinding): scala.xml.MetaData = {
      var attr: scala.xml.MetaData  = scala.xml.Null
      __obj.attributes.toList map {
        case ("@bankAlignment", _) => attr = scala.xml.Attribute(null, "bankAlignment", __obj.bankAlignment.toString, attr)
        case ("@{http://www.w3.org/XML/1998/namespace}id", _) => __obj.xmlid foreach { x => attr = scala.xml.Attribute(__scope.getPrefix("http://www.w3.org/XML/1998/namespace"), "id", x.toString, attr) }
        case (key, x) => attr = scala.xml.Attribute((x.namespace map { __scope.getPrefix(_) }).orNull, x.key.orNull, x.value.toString, attr)
      }
      attr
    }

    def writesChildNodes(__obj: IPXACT2022ScalaCases.LocalAddressBankType, __scope: scala.xml.NamespaceBinding): Seq[scala.xml.Node] =
      Seq.concat(IPXACT2022scalaxb.toXML[IPXACT2022ScalaCases.NameGroupSequence](__obj.nameGroupSequence1, None, Some("nameGroupSequence1"), __scope, false),
        __obj.accessHandles map { IPXACT2022scalaxb.toXML[IPXACT2022ScalaCases.AccessHandles3](_, Some("http://www.accellera.org/XMLSchema/IPXACT/1685-2022"), Some("accessHandles"), __scope, false) } getOrElse {Nil},
        IPXACT2022scalaxb.toXML[IPXACT2022ScalaCases.AddressSpecifierSequence](__obj.addressSpecifierSequence3, None, Some("addressSpecifierSequence3"), __scope, false),
        IPXACT2022scalaxb.toXML[IPXACT2022ScalaCases.LocalBankBaseSequence](__obj.localBankBaseSequence4, None, Some("localBankBaseSequence4"), __scope, false))

  }

  trait DefaultIPXACT2022ScalaCases_AccessHandles4Format extends IPXACT2022scalaxb.ElemNameParser[IPXACT2022ScalaCases.AccessHandles4] {
    val targetNamespace: Option[String] = Some("http://www.accellera.org/XMLSchema/IPXACT/1685-2022")
    
    def parser(node: scala.xml.Node, stack: List[IPXACT2022scalaxb.ElemName]): Parser[IPXACT2022ScalaCases.AccessHandles4] =
      phrase(safeRep(((IPXACT2022scalaxb.ElemName(Some("http://www.accellera.org/XMLSchema/IPXACT/1685-2022"), "accessHandle"))) ^^
        { case p1 => IPXACT2022ScalaCases.AccessHandles4Sequence1(IPXACT2022scalaxb.fromXML[IPXACT2022ScalaCases.SlicedAccessHandle](p1, IPXACT2022scalaxb.ElemName(node) :: stack)) }) ^^
      { case p1 =>
      IPXACT2022ScalaCases.AccessHandles4(p1) })
    
    def writesChildNodes(__obj: IPXACT2022ScalaCases.AccessHandles4, __scope: scala.xml.NamespaceBinding): Seq[scala.xml.Node] =
      (__obj.accesshandles4sequence1 flatMap { IPXACT2022scalaxb.toXML[IPXACT2022ScalaCases.AccessHandles4Sequence1](_, None, Some("accesshandles4sequence1"), __scope, false) })
  }

  trait DefaultIPXACT2022ScalaCases_AccessHandles4Sequence1Format extends IPXACT2022scalaxb.XMLFormat[IPXACT2022ScalaCases.AccessHandles4Sequence1] {
    def reads(seq: scala.xml.NodeSeq, stack: List[IPXACT2022scalaxb.ElemName]): Either[String, IPXACT2022ScalaCases.AccessHandles4Sequence1] = Left("don't call me.")
    
    def writes(__obj: IPXACT2022ScalaCases.AccessHandles4Sequence1, __namespace: Option[String], __elementLabel: Option[String],
        __scope: scala.xml.NamespaceBinding, __typeAttribute: Boolean): scala.xml.NodeSeq =
      IPXACT2022scalaxb.toXML[IPXACT2022ScalaCases.SlicedAccessHandle](__obj.accessHandle, Some("http://www.accellera.org/XMLSchema/IPXACT/1685-2022"), Some("accessHandle"), __scope, false)

  }
  trait DefaultIPXACT2022ScalaCases_AddressBlockDefinitionRefFormat extends IPXACT2022scalaxb.XMLFormat[IPXACT2022ScalaCases.AddressBlockDefinitionRef] with IPXACT2022scalaxb.CanWriteChildNodes[IPXACT2022ScalaCases.AddressBlockDefinitionRef] {
    val targetNamespace: Option[String] = Some("http://www.accellera.org/XMLSchema/IPXACT/1685-2022")
    def reads(seq: scala.xml.NodeSeq, stack: List[IPXACT2022scalaxb.ElemName]): Either[String, IPXACT2022ScalaCases.AddressBlockDefinitionRef] = seq match {
      case node: scala.xml.Node => Right(IPXACT2022ScalaCases.AddressBlockDefinitionRef(IPXACT2022scalaxb.fromXML[String](node, IPXACT2022scalaxb.ElemName(node) :: stack),
        scala.collection.immutable.ListMap(List(
        (node \ "@typeDefinitions").headOption map { x => IPXACT2022scalaxb.DataRecord(x, node, IPXACT2022scalaxb.fromXML[String](x, IPXACT2022scalaxb.ElemName(node) :: stack)) } map { "@typeDefinitions" -> _ }
        ).flatten[(String, IPXACT2022scalaxb.DataRecord[Any])]: _*)))
      case _ => Left("reads failed: seq must be scala.xml.Node")
    }
    
    override def writesAttribute(__obj: IPXACT2022ScalaCases.AddressBlockDefinitionRef, __scope: scala.xml.NamespaceBinding): scala.xml.MetaData = {
      var attr: scala.xml.MetaData  = scala.xml.Null
      __obj.attributes.toList map {
        case ("@typeDefinitions", _) => attr = scala.xml.Attribute(null, "typeDefinitions", __obj.typeDefinitions.toString, attr)
        case (key, x) => attr = scala.xml.Attribute((x.namespace map { __scope.getPrefix(_) }).orNull, x.key.orNull, x.value.toString, attr)
      }
      attr
    }

    def writesChildNodes(__obj: IPXACT2022ScalaCases.AddressBlockDefinitionRef, __scope: scala.xml.NamespaceBinding): Seq[scala.xml.Node] =
      Seq(scala.xml.Text(__obj.value.toString))

  }

  trait DefaultIPXACT2022ScalaCases_AddressBlockTypeFormat extends IPXACT2022scalaxb.ElemNameParser[IPXACT2022ScalaCases.AddressBlockType] with IPXACT2022ScalaCases_NameGroupGroupFormat with IPXACT2022ScalaCases_AddressSpecifierGroupFormat with IPXACT2022ScalaCases_AddressBlockDefinitionGroupGroupFormat {
    val targetNamespace: Option[String] = Some("http://www.accellera.org/XMLSchema/IPXACT/1685-2022")
    
    override def typeName: Option[String] = Some("addressBlockType")

    def parser(node: scala.xml.Node, stack: List[IPXACT2022scalaxb.ElemName]): Parser[IPXACT2022ScalaCases.AddressBlockType] =
      phrase((parseNameGroupGroup(node, IPXACT2022scalaxb.ElemName(node) :: stack)) ~
      opt(IPXACT2022scalaxb.ElemName(Some("http://www.accellera.org/XMLSchema/IPXACT/1685-2022"), "accessHandles")) ~
      opt(IPXACT2022scalaxb.ElemName(Some("http://www.accellera.org/XMLSchema/IPXACT/1685-2022"), "array")) ~
      (parseAddressSpecifierGroup(node, IPXACT2022scalaxb.ElemName(node) :: stack)) ~
      (((IPXACT2022scalaxb.ElemName(Some("http://www.accellera.org/XMLSchema/IPXACT/1685-2022"), "addressBlockDefinitionRef")) ^^
      (x => IPXACT2022scalaxb.DataRecord(x.namespace, Some(x.name), IPXACT2022scalaxb.fromXML[IPXACT2022ScalaCases.AddressBlockDefinitionRef](x, IPXACT2022scalaxb.ElemName(node) :: stack)))) |||
      (parseAddressBlockDefinitionGroupGroup(node, IPXACT2022scalaxb.ElemName(node) :: stack, true))) ~
      opt(IPXACT2022scalaxb.ElemName(Some("http://www.accellera.org/XMLSchema/IPXACT/1685-2022"), "vendorExtensions")) ^^
      { case p1 ~ p2 ~ p3 ~ p4 ~ p5 ~ p6 =>
      IPXACT2022ScalaCases.AddressBlockType(p1,
        p2.headOption map { IPXACT2022scalaxb.fromXML[IPXACT2022ScalaCases.AccessHandles4](_, IPXACT2022scalaxb.ElemName(node) :: stack) },
        p3.headOption map { IPXACT2022scalaxb.fromXML[IPXACT2022ScalaCases.ArrayType4](_, IPXACT2022scalaxb.ElemName(node) :: stack) },
        p4,
        p5,
        p6.headOption map { IPXACT2022scalaxb.fromXML[IPXACT2022ScalaCases.VendorExtensions](_, IPXACT2022scalaxb.ElemName(node) :: stack) },
        scala.collection.immutable.ListMap(List(
        (node \ "@{http://www.w3.org/XML/1998/namespace}id").headOption map { x => IPXACT2022scalaxb.DataRecord(x, node, IPXACT2022scalaxb.fromXML[String](x, IPXACT2022scalaxb.ElemName(node) :: stack)) } map { "@{http://www.w3.org/XML/1998/namespace}id" -> _ },
        (node \ "@misalignmentAllowed").headOption map { x => IPXACT2022scalaxb.DataRecord(x, node, IPXACT2022scalaxb.fromXML[Boolean](x, IPXACT2022scalaxb.ElemName(node) :: stack)) } orElse Some(IPXACT2022scalaxb.DataRecord(None, None, IPXACT2022scalaxb.fromXML[Boolean](scala.xml.Text("true"), IPXACT2022scalaxb.ElemName(node) :: stack))) map { "@misalignmentAllowed" -> _ }
        ).flatten[(String, IPXACT2022scalaxb.DataRecord[Any])]: _*)) })
    
    override def writesAttribute(__obj: IPXACT2022ScalaCases.AddressBlockType, __scope: scala.xml.NamespaceBinding): scala.xml.MetaData = {
      var attr: scala.xml.MetaData  = scala.xml.Null
      __obj.attributes.toList map {
        case ("@{http://www.w3.org/XML/1998/namespace}id", _) => __obj.xmlid foreach { x => attr = scala.xml.Attribute(__scope.getPrefix("http://www.w3.org/XML/1998/namespace"), "id", x.toString, attr) }
        case ("@misalignmentAllowed", _) => if (__obj.misalignmentAllowed.toString != "true") attr = scala.xml.Attribute(null, "misalignmentAllowed", __obj.misalignmentAllowed.toString, attr)
        case (key, x) => attr = scala.xml.Attribute((x.namespace map { __scope.getPrefix(_) }).orNull, x.key.orNull, x.value.toString, attr)
      }
      attr
    }

    def writesChildNodes(__obj: IPXACT2022ScalaCases.AddressBlockType, __scope: scala.xml.NamespaceBinding): Seq[scala.xml.Node] =
      Seq.concat(IPXACT2022scalaxb.toXML[IPXACT2022ScalaCases.NameGroupSequence](__obj.nameGroupSequence1, None, Some("nameGroupSequence1"), __scope, false),
        __obj.accessHandles map { IPXACT2022scalaxb.toXML[IPXACT2022ScalaCases.AccessHandles4](_, Some("http://www.accellera.org/XMLSchema/IPXACT/1685-2022"), Some("accessHandles"), __scope, false) } getOrElse {Nil},
        __obj.array map { IPXACT2022scalaxb.toXML[IPXACT2022ScalaCases.ArrayType4](_, Some("http://www.accellera.org/XMLSchema/IPXACT/1685-2022"), Some("array"), __scope, false) } getOrElse {Nil},
        IPXACT2022scalaxb.toXML[IPXACT2022ScalaCases.AddressSpecifierSequence](__obj.addressSpecifierSequence4, None, Some("addressSpecifierSequence4"), __scope, false),
        (Some(__obj.addressblocktypeoption) map {x => IPXACT2022scalaxb.toXML[IPXACT2022scalaxb.DataRecord[Any]](x, x.namespace, x.key, __scope, false)}).get,
        __obj.vendorExtensions map { IPXACT2022scalaxb.toXML[IPXACT2022ScalaCases.VendorExtensions](_, Some("http://www.accellera.org/XMLSchema/IPXACT/1685-2022"), Some("vendorExtensions"), __scope, false) } getOrElse {Nil})

  }

  trait DefaultIPXACT2022ScalaCases_AddrSpaceRefTypableFormat extends IPXACT2022scalaxb.XMLFormat[IPXACT2022ScalaCases.AddrSpaceRefTypable] {
    def reads(seq: scala.xml.NodeSeq, stack: List[IPXACT2022scalaxb.ElemName]): Either[String, IPXACT2022ScalaCases.AddrSpaceRefTypable] = seq match {
      case node: scala.xml.Node =>     
        IPXACT2022scalaxb.Helper.instanceType(node) match {
          
          case _ => Right(IPXACT2022scalaxb.fromXML[IPXACT2022ScalaCases.AddrSpaceRefType](node, stack))
        }
      case _ => Left("reads failed: seq must be scala.xml.Node")  
    }
    
    def writes(__obj: IPXACT2022ScalaCases.AddrSpaceRefTypable, __namespace: Option[String], __elementLabel: Option[String],
        __scope: scala.xml.NamespaceBinding, __typeAttribute: Boolean): scala.xml.NodeSeq = __obj match {
      case x: IPXACT2022ScalaCases.AddressSpaceRef3 => IPXACT2022scalaxb.toXML[IPXACT2022ScalaCases.AddressSpaceRef3](x, __namespace, __elementLabel, __scope, true)
      case x: IPXACT2022ScalaCases.AddrSpaceRefType => IPXACT2022scalaxb.toXML[IPXACT2022ScalaCases.AddrSpaceRefType](x, __namespace, __elementLabel, __scope, __typeAttribute)
    }
  }
  trait DefaultIPXACT2022ScalaCases_AddrSpaceRefTypeFormat extends IPXACT2022scalaxb.ElemNameParser[IPXACT2022ScalaCases.AddrSpaceRefType] {
    val targetNamespace: Option[String] = Some("http://www.accellera.org/XMLSchema/IPXACT/1685-2022")
    
    override def typeName: Option[String] = Some("addrSpaceRefType")

    def parser(node: scala.xml.Node, stack: List[IPXACT2022scalaxb.ElemName]): Parser[IPXACT2022ScalaCases.AddrSpaceRefType] =
      phrase(opt(IPXACT2022scalaxb.ElemName(Some("http://www.accellera.org/XMLSchema/IPXACT/1685-2022"), "vendorExtensions")) ^^
      { case p1 =>
      IPXACT2022ScalaCases.AddrSpaceRefType(p1.headOption map { IPXACT2022scalaxb.fromXML[IPXACT2022ScalaCases.VendorExtensions](_, IPXACT2022scalaxb.ElemName(node) :: stack) },
        scala.collection.immutable.ListMap(List(
        (node \ "@addressSpaceRef").headOption map { x => IPXACT2022scalaxb.DataRecord(x, node, IPXACT2022scalaxb.fromXML[String](x, IPXACT2022scalaxb.ElemName(node) :: stack)) } map { "@addressSpaceRef" -> _ },
        (node \ "@{http://www.w3.org/XML/1998/namespace}id").headOption map { x => IPXACT2022scalaxb.DataRecord(x, node, IPXACT2022scalaxb.fromXML[String](x, IPXACT2022scalaxb.ElemName(node) :: stack)) } map { "@{http://www.w3.org/XML/1998/namespace}id" -> _ }
        ).flatten[(String, IPXACT2022scalaxb.DataRecord[Any])]: _*)) })
    
    override def writesAttribute(__obj: IPXACT2022ScalaCases.AddrSpaceRefType, __scope: scala.xml.NamespaceBinding): scala.xml.MetaData = {
      var attr: scala.xml.MetaData  = scala.xml.Null
      __obj.attributes.toList map {
        case ("@addressSpaceRef", _) => attr = scala.xml.Attribute(null, "addressSpaceRef", __obj.addressSpaceRef.toString, attr)
        case ("@{http://www.w3.org/XML/1998/namespace}id", _) => __obj.xmlid foreach { x => attr = scala.xml.Attribute(__scope.getPrefix("http://www.w3.org/XML/1998/namespace"), "id", x.toString, attr) }
        case (key, x) => attr = scala.xml.Attribute((x.namespace map { __scope.getPrefix(_) }).orNull, x.key.orNull, x.value.toString, attr)
      }
      attr
    }

    def writesChildNodes(__obj: IPXACT2022ScalaCases.AddrSpaceRefType, __scope: scala.xml.NamespaceBinding): Seq[scala.xml.Node] =
      (__obj.vendorExtensions map { IPXACT2022scalaxb.toXML[IPXACT2022ScalaCases.VendorExtensions](_, Some("http://www.accellera.org/XMLSchema/IPXACT/1685-2022"), Some("vendorExtensions"), __scope, false) } getOrElse {Nil})
  }

  trait DefaultIPXACT2022ScalaCases_ModeRef2Format extends IPXACT2022scalaxb.XMLFormat[IPXACT2022ScalaCases.ModeRef2] with IPXACT2022scalaxb.CanWriteChildNodes[IPXACT2022ScalaCases.ModeRef2] {
    val targetNamespace: Option[String] = Some("http://www.accellera.org/XMLSchema/IPXACT/1685-2022")
    def reads(seq: scala.xml.NodeSeq, stack: List[IPXACT2022scalaxb.ElemName]): Either[String, IPXACT2022ScalaCases.ModeRef2] = seq match {
      case node: scala.xml.Node => Right(IPXACT2022ScalaCases.ModeRef2(IPXACT2022scalaxb.fromXML[String](node, IPXACT2022scalaxb.ElemName(node) :: stack),
        scala.collection.immutable.ListMap(List(
        (node \ "@{http://www.w3.org/XML/1998/namespace}id").headOption map { x => IPXACT2022scalaxb.DataRecord(x, node, IPXACT2022scalaxb.fromXML[String](x, IPXACT2022scalaxb.ElemName(node) :: stack)) } map { "@{http://www.w3.org/XML/1998/namespace}id" -> _ }
        ).flatten[(String, IPXACT2022scalaxb.DataRecord[Any])]: _*)))
      case _ => Left("reads failed: seq must be scala.xml.Node")
    }
    
    override def writesAttribute(__obj: IPXACT2022ScalaCases.ModeRef2, __scope: scala.xml.NamespaceBinding): scala.xml.MetaData = {
      var attr: scala.xml.MetaData  = scala.xml.Null
      __obj.attributes.toList map {
        case ("@{http://www.w3.org/XML/1998/namespace}id", _) => __obj.xmlid foreach { x => attr = scala.xml.Attribute(__scope.getPrefix("http://www.w3.org/XML/1998/namespace"), "id", x.toString, attr) }
        case (key, x) => attr = scala.xml.Attribute((x.namespace map { __scope.getPrefix(_) }).orNull, x.key.orNull, x.value.toString, attr)
      }
      attr
    }

    def writesChildNodes(__obj: IPXACT2022ScalaCases.ModeRef2, __scope: scala.xml.NamespaceBinding): Seq[scala.xml.Node] =
      Seq(scala.xml.Text(__obj.value.toString))

  }

  trait DefaultIPXACT2022ScalaCases_MemoryMapRefTypeFormat extends IPXACT2022scalaxb.ElemNameParser[IPXACT2022ScalaCases.MemoryMapRefType] {
    val targetNamespace: Option[String] = Some("http://www.accellera.org/XMLSchema/IPXACT/1685-2022")
    
    override def typeName: Option[String] = Some("memoryMapRefType")

    def parser(node: scala.xml.Node, stack: List[IPXACT2022scalaxb.ElemName]): Parser[IPXACT2022ScalaCases.MemoryMapRefType] =
      phrase(safeRep(IPXACT2022scalaxb.ElemName(Some("http://www.accellera.org/XMLSchema/IPXACT/1685-2022"), "modeRef")) ^^
      { case p1 =>
      IPXACT2022ScalaCases.MemoryMapRefType(p1 map { IPXACT2022scalaxb.fromXML[IPXACT2022ScalaCases.ModeRef2](_, IPXACT2022scalaxb.ElemName(node) :: stack) },
        scala.collection.immutable.ListMap(List(
        (node \ "@memoryMapRef").headOption map { x => IPXACT2022scalaxb.DataRecord(x, node, IPXACT2022scalaxb.fromXML[String](x, IPXACT2022scalaxb.ElemName(node) :: stack)) } map { "@memoryMapRef" -> _ }
        ).flatten[(String, IPXACT2022scalaxb.DataRecord[Any])]: _*)) })
    
    override def writesAttribute(__obj: IPXACT2022ScalaCases.MemoryMapRefType, __scope: scala.xml.NamespaceBinding): scala.xml.MetaData = {
      var attr: scala.xml.MetaData  = scala.xml.Null
      __obj.attributes.toList map {
        case ("@memoryMapRef", _) => attr = scala.xml.Attribute(null, "memoryMapRef", __obj.memoryMapRef.toString, attr)
        case (key, x) => attr = scala.xml.Attribute((x.namespace map { __scope.getPrefix(_) }).orNull, x.key.orNull, x.value.toString, attr)
      }
      attr
    }

    def writesChildNodes(__obj: IPXACT2022ScalaCases.MemoryMapRefType, __scope: scala.xml.NamespaceBinding): Seq[scala.xml.Node] =
      (__obj.modeRef flatMap { IPXACT2022scalaxb.toXML[IPXACT2022ScalaCases.ModeRef2](_, Some("http://www.accellera.org/XMLSchema/IPXACT/1685-2022"), Some("modeRef"), __scope, false) })
  }

  trait DefaultIPXACT2022ScalaCases_AccessHandles5Format extends IPXACT2022scalaxb.ElemNameParser[IPXACT2022ScalaCases.AccessHandles5] {
    val targetNamespace: Option[String] = Some("http://www.accellera.org/XMLSchema/IPXACT/1685-2022")
    
    def parser(node: scala.xml.Node, stack: List[IPXACT2022scalaxb.ElemName]): Parser[IPXACT2022ScalaCases.AccessHandles5] =
      phrase(safeRep(((IPXACT2022scalaxb.ElemName(Some("http://www.accellera.org/XMLSchema/IPXACT/1685-2022"), "accessHandle"))) ^^
        { case p1 => IPXACT2022ScalaCases.AccessHandles5Sequence1(IPXACT2022scalaxb.fromXML[IPXACT2022ScalaCases.SimpleAccessHandle](p1, IPXACT2022scalaxb.ElemName(node) :: stack)) }) ^^
      { case p1 =>
      IPXACT2022ScalaCases.AccessHandles5(p1) })
    
    def writesChildNodes(__obj: IPXACT2022ScalaCases.AccessHandles5, __scope: scala.xml.NamespaceBinding): Seq[scala.xml.Node] =
      (__obj.accesshandles5sequence1 flatMap { IPXACT2022scalaxb.toXML[IPXACT2022ScalaCases.AccessHandles5Sequence1](_, None, Some("accesshandles5sequence1"), __scope, false) })
  }

  trait DefaultIPXACT2022ScalaCases_AccessHandles5Sequence1Format extends IPXACT2022scalaxb.XMLFormat[IPXACT2022ScalaCases.AccessHandles5Sequence1] {
    def reads(seq: scala.xml.NodeSeq, stack: List[IPXACT2022scalaxb.ElemName]): Either[String, IPXACT2022ScalaCases.AccessHandles5Sequence1] = Left("don't call me.")
    
    def writes(__obj: IPXACT2022ScalaCases.AccessHandles5Sequence1, __namespace: Option[String], __elementLabel: Option[String],
        __scope: scala.xml.NamespaceBinding, __typeAttribute: Boolean): scala.xml.NodeSeq =
      IPXACT2022scalaxb.toXML[IPXACT2022ScalaCases.SimpleAccessHandle](__obj.accessHandle, Some("http://www.accellera.org/XMLSchema/IPXACT/1685-2022"), Some("accessHandle"), __scope, false)

  }
  trait DefaultIPXACT2022ScalaCases_BankDefinitionRef3Format extends IPXACT2022scalaxb.XMLFormat[IPXACT2022ScalaCases.BankDefinitionRef3] with IPXACT2022scalaxb.CanWriteChildNodes[IPXACT2022ScalaCases.BankDefinitionRef3] {
    val targetNamespace: Option[String] = Some("http://www.accellera.org/XMLSchema/IPXACT/1685-2022")
    def reads(seq: scala.xml.NodeSeq, stack: List[IPXACT2022scalaxb.ElemName]): Either[String, IPXACT2022ScalaCases.BankDefinitionRef3] = seq match {
      case node: scala.xml.Node => Right(IPXACT2022ScalaCases.BankDefinitionRef3(IPXACT2022scalaxb.fromXML[String](node, IPXACT2022scalaxb.ElemName(node) :: stack),
        scala.collection.immutable.ListMap(List(
        (node \ "@typeDefinitions").headOption map { x => IPXACT2022scalaxb.DataRecord(x, node, IPXACT2022scalaxb.fromXML[String](x, IPXACT2022scalaxb.ElemName(node) :: stack)) } map { "@typeDefinitions" -> _ }
        ).flatten[(String, IPXACT2022scalaxb.DataRecord[Any])]: _*)))
      case _ => Left("reads failed: seq must be scala.xml.Node")
    }
    
    override def writesAttribute(__obj: IPXACT2022ScalaCases.BankDefinitionRef3, __scope: scala.xml.NamespaceBinding): scala.xml.MetaData = {
      var attr: scala.xml.MetaData  = scala.xml.Null
      __obj.attributes.toList map {
        case ("@typeDefinitions", _) => attr = scala.xml.Attribute(null, "typeDefinitions", __obj.typeDefinitions.toString, attr)
        case (key, x) => attr = scala.xml.Attribute((x.namespace map { __scope.getPrefix(_) }).orNull, x.key.orNull, x.value.toString, attr)
      }
      attr
    }

    def writesChildNodes(__obj: IPXACT2022ScalaCases.BankDefinitionRef3, __scope: scala.xml.NamespaceBinding): Seq[scala.xml.Node] =
      Seq(scala.xml.Text(__obj.value.toString))

  }

  trait DefaultIPXACT2022ScalaCases_BankedBankTypableFormat extends IPXACT2022scalaxb.XMLFormat[IPXACT2022ScalaCases.BankedBankTypable] {
    def reads(seq: scala.xml.NodeSeq, stack: List[IPXACT2022scalaxb.ElemName]): Either[String, IPXACT2022ScalaCases.BankedBankTypable] = seq match {
      case node: scala.xml.Node =>     
        IPXACT2022scalaxb.Helper.instanceType(node) match {
          
          case _ => Right(IPXACT2022scalaxb.fromXML[IPXACT2022ScalaCases.BankedBankType](node, stack))
        }
      case _ => Left("reads failed: seq must be scala.xml.Node")  
    }
    
    def writes(__obj: IPXACT2022ScalaCases.BankedBankTypable, __namespace: Option[String], __elementLabel: Option[String],
        __scope: scala.xml.NamespaceBinding, __typeAttribute: Boolean): scala.xml.NodeSeq = __obj match {
      case x: IPXACT2022ScalaCases.Bank2 => IPXACT2022scalaxb.toXML[IPXACT2022ScalaCases.Bank2](x, __namespace, __elementLabel, __scope, true)
      case x: IPXACT2022ScalaCases.BankedBankType => IPXACT2022scalaxb.toXML[IPXACT2022ScalaCases.BankedBankType](x, __namespace, __elementLabel, __scope, __typeAttribute)
    }
  }
  trait DefaultIPXACT2022ScalaCases_BankedBankTypeFormat extends IPXACT2022scalaxb.ElemNameParser[IPXACT2022ScalaCases.BankedBankType] with IPXACT2022ScalaCases_NameGroupGroupFormat with IPXACT2022ScalaCases_BankBaseGroupFormat {
    val targetNamespace: Option[String] = Some("http://www.accellera.org/XMLSchema/IPXACT/1685-2022")
    
    override def typeName: Option[String] = Some("bankedBankType")

    def parser(node: scala.xml.Node, stack: List[IPXACT2022scalaxb.ElemName]): Parser[IPXACT2022ScalaCases.BankedBankType] =
      phrase((parseNameGroupGroup(node, IPXACT2022scalaxb.ElemName(node) :: stack)) ~
      opt(IPXACT2022scalaxb.ElemName(Some("http://www.accellera.org/XMLSchema/IPXACT/1685-2022"), "accessHandles")) ~
      (((IPXACT2022scalaxb.ElemName(Some("http://www.accellera.org/XMLSchema/IPXACT/1685-2022"), "bankDefinitionRef")) ^^
      (x => IPXACT2022scalaxb.DataRecord(x.namespace, Some(x.name), IPXACT2022scalaxb.fromXML[IPXACT2022ScalaCases.BankDefinitionRef3](x, IPXACT2022scalaxb.ElemName(node) :: stack)))) |||
      (parseBankBaseGroup(node, IPXACT2022scalaxb.ElemName(node) :: stack, true))) ^^
      { case p1 ~ p2 ~ p3 =>
      IPXACT2022ScalaCases.BankedBankType(p1,
        p2.headOption map { IPXACT2022scalaxb.fromXML[IPXACT2022ScalaCases.AccessHandles5](_, IPXACT2022scalaxb.ElemName(node) :: stack) },
        p3,
        scala.collection.immutable.ListMap(List(
        (node \ "@bankAlignment").headOption map { x => IPXACT2022scalaxb.DataRecord(x, node, IPXACT2022scalaxb.fromXML[IPXACT2022ScalaCases.BankAlignmentType](x, IPXACT2022scalaxb.ElemName(node) :: stack)) } map { "@bankAlignment" -> _ },
        (node \ "@{http://www.w3.org/XML/1998/namespace}id").headOption map { x => IPXACT2022scalaxb.DataRecord(x, node, IPXACT2022scalaxb.fromXML[String](x, IPXACT2022scalaxb.ElemName(node) :: stack)) } map { "@{http://www.w3.org/XML/1998/namespace}id" -> _ }
        ).flatten[(String, IPXACT2022scalaxb.DataRecord[Any])]: _*)) })
    
    override def writesAttribute(__obj: IPXACT2022ScalaCases.BankedBankType, __scope: scala.xml.NamespaceBinding): scala.xml.MetaData = {
      var attr: scala.xml.MetaData  = scala.xml.Null
      __obj.attributes.toList map {
        case ("@bankAlignment", _) => attr = scala.xml.Attribute(null, "bankAlignment", __obj.bankAlignment.toString, attr)
        case ("@{http://www.w3.org/XML/1998/namespace}id", _) => __obj.xmlid foreach { x => attr = scala.xml.Attribute(__scope.getPrefix("http://www.w3.org/XML/1998/namespace"), "id", x.toString, attr) }
        case (key, x) => attr = scala.xml.Attribute((x.namespace map { __scope.getPrefix(_) }).orNull, x.key.orNull, x.value.toString, attr)
      }
      attr
    }

    def writesChildNodes(__obj: IPXACT2022ScalaCases.BankedBankType, __scope: scala.xml.NamespaceBinding): Seq[scala.xml.Node] =
      Seq.concat(IPXACT2022scalaxb.toXML[IPXACT2022ScalaCases.NameGroupSequence](__obj.nameGroupSequence1, None, Some("nameGroupSequence1"), __scope, false),
        __obj.accessHandles map { IPXACT2022scalaxb.toXML[IPXACT2022ScalaCases.AccessHandles5](_, Some("http://www.accellera.org/XMLSchema/IPXACT/1685-2022"), Some("accessHandles"), __scope, false) } getOrElse {Nil},
        (Some(__obj.bankedbanktypableoption) map {x => IPXACT2022scalaxb.toXML[IPXACT2022scalaxb.DataRecord[Any]](x, x.namespace, x.key, __scope, false)}).get)

  }

  trait DefaultIPXACT2022ScalaCases_AccessHandles6Format extends IPXACT2022scalaxb.ElemNameParser[IPXACT2022ScalaCases.AccessHandles6] {
    val targetNamespace: Option[String] = Some("http://www.accellera.org/XMLSchema/IPXACT/1685-2022")
    
    def parser(node: scala.xml.Node, stack: List[IPXACT2022scalaxb.ElemName]): Parser[IPXACT2022ScalaCases.AccessHandles6] =
      phrase(safeRep(((IPXACT2022scalaxb.ElemName(Some("http://www.accellera.org/XMLSchema/IPXACT/1685-2022"), "accessHandle"))) ^^
        { case p1 => IPXACT2022ScalaCases.AccessHandles6Sequence1(IPXACT2022scalaxb.fromXML[IPXACT2022ScalaCases.SimpleAccessHandle](p1, IPXACT2022scalaxb.ElemName(node) :: stack)) }) ^^
      { case p1 =>
      IPXACT2022ScalaCases.AccessHandles6(p1) })
    
    def writesChildNodes(__obj: IPXACT2022ScalaCases.AccessHandles6, __scope: scala.xml.NamespaceBinding): Seq[scala.xml.Node] =
      (__obj.accesshandles6sequence1 flatMap { IPXACT2022scalaxb.toXML[IPXACT2022ScalaCases.AccessHandles6Sequence1](_, None, Some("accesshandles6sequence1"), __scope, false) })
  }

  trait DefaultIPXACT2022ScalaCases_AccessHandles6Sequence1Format extends IPXACT2022scalaxb.XMLFormat[IPXACT2022ScalaCases.AccessHandles6Sequence1] {
    def reads(seq: scala.xml.NodeSeq, stack: List[IPXACT2022scalaxb.ElemName]): Either[String, IPXACT2022ScalaCases.AccessHandles6Sequence1] = Left("don't call me.")
    
    def writes(__obj: IPXACT2022ScalaCases.AccessHandles6Sequence1, __namespace: Option[String], __elementLabel: Option[String],
        __scope: scala.xml.NamespaceBinding, __typeAttribute: Boolean): scala.xml.NodeSeq =
      IPXACT2022scalaxb.toXML[IPXACT2022ScalaCases.SimpleAccessHandle](__obj.accessHandle, Some("http://www.accellera.org/XMLSchema/IPXACT/1685-2022"), Some("accessHandle"), __scope, false)

  }
  trait DefaultIPXACT2022ScalaCases_BankDefinitionRef4Format extends IPXACT2022scalaxb.XMLFormat[IPXACT2022ScalaCases.BankDefinitionRef4] with IPXACT2022scalaxb.CanWriteChildNodes[IPXACT2022ScalaCases.BankDefinitionRef4] {
    val targetNamespace: Option[String] = Some("http://www.accellera.org/XMLSchema/IPXACT/1685-2022")
    def reads(seq: scala.xml.NodeSeq, stack: List[IPXACT2022scalaxb.ElemName]): Either[String, IPXACT2022ScalaCases.BankDefinitionRef4] = seq match {
      case node: scala.xml.Node => Right(IPXACT2022ScalaCases.BankDefinitionRef4(IPXACT2022scalaxb.fromXML[String](node, IPXACT2022scalaxb.ElemName(node) :: stack),
        scala.collection.immutable.ListMap(List(
        (node \ "@typeDefinitions").headOption map { x => IPXACT2022scalaxb.DataRecord(x, node, IPXACT2022scalaxb.fromXML[String](x, IPXACT2022scalaxb.ElemName(node) :: stack)) } map { "@typeDefinitions" -> _ }
        ).flatten[(String, IPXACT2022scalaxb.DataRecord[Any])]: _*)))
      case _ => Left("reads failed: seq must be scala.xml.Node")
    }
    
    override def writesAttribute(__obj: IPXACT2022ScalaCases.BankDefinitionRef4, __scope: scala.xml.NamespaceBinding): scala.xml.MetaData = {
      var attr: scala.xml.MetaData  = scala.xml.Null
      __obj.attributes.toList map {
        case ("@typeDefinitions", _) => attr = scala.xml.Attribute(null, "typeDefinitions", __obj.typeDefinitions.toString, attr)
        case (key, x) => attr = scala.xml.Attribute((x.namespace map { __scope.getPrefix(_) }).orNull, x.key.orNull, x.value.toString, attr)
      }
      attr
    }

    def writesChildNodes(__obj: IPXACT2022ScalaCases.BankDefinitionRef4, __scope: scala.xml.NamespaceBinding): Seq[scala.xml.Node] =
      Seq(scala.xml.Text(__obj.value.toString))

  }

  trait DefaultIPXACT2022ScalaCases_BankedDefinitionBankTypableFormat extends IPXACT2022scalaxb.XMLFormat[IPXACT2022ScalaCases.BankedDefinitionBankTypable] {
    def reads(seq: scala.xml.NodeSeq, stack: List[IPXACT2022scalaxb.ElemName]): Either[String, IPXACT2022ScalaCases.BankedDefinitionBankTypable] = seq match {
      case node: scala.xml.Node =>     
        IPXACT2022scalaxb.Helper.instanceType(node) match {
          
          case _ => Right(IPXACT2022scalaxb.fromXML[IPXACT2022ScalaCases.BankedDefinitionBankType](node, stack))
        }
      case _ => Left("reads failed: seq must be scala.xml.Node")  
    }
    
    def writes(__obj: IPXACT2022ScalaCases.BankedDefinitionBankTypable, __namespace: Option[String], __elementLabel: Option[String],
        __scope: scala.xml.NamespaceBinding, __typeAttribute: Boolean): scala.xml.NodeSeq = __obj match {
      case x: IPXACT2022ScalaCases.Bank3 => IPXACT2022scalaxb.toXML[IPXACT2022ScalaCases.Bank3](x, __namespace, __elementLabel, __scope, true)
      case x: IPXACT2022ScalaCases.Bank => IPXACT2022scalaxb.toXML[IPXACT2022ScalaCases.Bank](x, __namespace, __elementLabel, __scope, true)
      case x: IPXACT2022ScalaCases.BankedDefinitionBankType => IPXACT2022scalaxb.toXML[IPXACT2022ScalaCases.BankedDefinitionBankType](x, __namespace, __elementLabel, __scope, __typeAttribute)
    }
  }

  trait DefaultIPXACT2022ScalaCases_BankedDefinitionBankTypeFormat extends IPXACT2022scalaxb.ElemNameParser[IPXACT2022ScalaCases.BankedDefinitionBankType] with IPXACT2022ScalaCases_NameGroupGroupFormat with IPXACT2022ScalaCases_BankDefinitionBaseGroupFormat {
    val targetNamespace: Option[String] = Some("http://www.accellera.org/XMLSchema/IPXACT/1685-2022")
    
    override def typeName: Option[String] = Some("bankedDefinitionBankType")

    def parser(node: scala.xml.Node, stack: List[IPXACT2022scalaxb.ElemName]): Parser[IPXACT2022ScalaCases.BankedDefinitionBankType] =
      phrase((parseNameGroupGroup(node, IPXACT2022scalaxb.ElemName(node) :: stack)) ~
      opt(IPXACT2022scalaxb.ElemName(Some("http://www.accellera.org/XMLSchema/IPXACT/1685-2022"), "accessHandles")) ~
      (((IPXACT2022scalaxb.ElemName(Some("http://www.accellera.org/XMLSchema/IPXACT/1685-2022"), "bankDefinitionRef")) ^^
      (x => IPXACT2022scalaxb.DataRecord(x.namespace, Some(x.name), IPXACT2022scalaxb.fromXML[IPXACT2022ScalaCases.BankDefinitionRef4](x, IPXACT2022scalaxb.ElemName(node) :: stack)))) |||
      (parseBankDefinitionBaseGroup(node, IPXACT2022scalaxb.ElemName(node) :: stack, true))) ^^
      { case p1 ~ p2 ~ p3 =>
      IPXACT2022ScalaCases.BankedDefinitionBankType(p1,
        p2.headOption map { IPXACT2022scalaxb.fromXML[IPXACT2022ScalaCases.AccessHandles6](_, IPXACT2022scalaxb.ElemName(node) :: stack) },
        p3,
        scala.collection.immutable.ListMap(List(
        (node \ "@bankAlignment").headOption map { x => IPXACT2022scalaxb.DataRecord(x, node, IPXACT2022scalaxb.fromXML[IPXACT2022ScalaCases.BankAlignmentType](x, IPXACT2022scalaxb.ElemName(node) :: stack)) } map { "@bankAlignment" -> _ },
        (node \ "@{http://www.w3.org/XML/1998/namespace}id").headOption map { x => IPXACT2022scalaxb.DataRecord(x, node, IPXACT2022scalaxb.fromXML[String](x, IPXACT2022scalaxb.ElemName(node) :: stack)) } map { "@{http://www.w3.org/XML/1998/namespace}id" -> _ }
        ).flatten[(String, IPXACT2022scalaxb.DataRecord[Any])]: _*)) })
    
    override def writesAttribute(__obj: IPXACT2022ScalaCases.BankedDefinitionBankType, __scope: scala.xml.NamespaceBinding): scala.xml.MetaData = {
      var attr: scala.xml.MetaData  = scala.xml.Null
      __obj.attributes.toList map {
        case ("@bankAlignment", _) => attr = scala.xml.Attribute(null, "bankAlignment", __obj.bankAlignment.toString, attr)
        case ("@{http://www.w3.org/XML/1998/namespace}id", _) => __obj.xmlid foreach { x => attr = scala.xml.Attribute(__scope.getPrefix("http://www.w3.org/XML/1998/namespace"), "id", x.toString, attr) }
        case (key, x) => attr = scala.xml.Attribute((x.namespace map { __scope.getPrefix(_) }).orNull, x.key.orNull, x.value.toString, attr)
      }
      attr
    }

    def writesChildNodes(__obj: IPXACT2022ScalaCases.BankedDefinitionBankType, __scope: scala.xml.NamespaceBinding): Seq[scala.xml.Node] =
      Seq.concat(IPXACT2022scalaxb.toXML[IPXACT2022ScalaCases.NameGroupSequence](__obj.nameGroupSequence1, None, Some("nameGroupSequence1"), __scope, false),
        __obj.accessHandles map { IPXACT2022scalaxb.toXML[IPXACT2022ScalaCases.AccessHandles6](_, Some("http://www.accellera.org/XMLSchema/IPXACT/1685-2022"), Some("accessHandles"), __scope, false) } getOrElse {Nil},
        (Some(__obj.bankeddefinitionbanktypableoption) map {x => IPXACT2022scalaxb.toXML[IPXACT2022scalaxb.DataRecord[Any]](x, x.namespace, x.key, __scope, false)}).get)

  }

  trait DefaultIPXACT2022ScalaCases_AccessHandles7Format extends IPXACT2022scalaxb.ElemNameParser[IPXACT2022ScalaCases.AccessHandles7] {
    val targetNamespace: Option[String] = Some("http://www.accellera.org/XMLSchema/IPXACT/1685-2022")
    
    def parser(node: scala.xml.Node, stack: List[IPXACT2022scalaxb.ElemName]): Parser[IPXACT2022ScalaCases.AccessHandles7] =
      phrase(safeRep(((IPXACT2022scalaxb.ElemName(Some("http://www.accellera.org/XMLSchema/IPXACT/1685-2022"), "accessHandle"))) ^^
        { case p1 => IPXACT2022ScalaCases.AccessHandles7Sequence1(IPXACT2022scalaxb.fromXML[IPXACT2022ScalaCases.SimpleAccessHandle](p1, IPXACT2022scalaxb.ElemName(node) :: stack)) }) ^^
      { case p1 =>
      IPXACT2022ScalaCases.AccessHandles7(p1) })
    
    def writesChildNodes(__obj: IPXACT2022ScalaCases.AccessHandles7, __scope: scala.xml.NamespaceBinding): Seq[scala.xml.Node] =
      (__obj.accesshandles7sequence1 flatMap { IPXACT2022scalaxb.toXML[IPXACT2022ScalaCases.AccessHandles7Sequence1](_, None, Some("accesshandles7sequence1"), __scope, false) })
  }

  trait DefaultIPXACT2022ScalaCases_AccessHandles7Sequence1Format extends IPXACT2022scalaxb.XMLFormat[IPXACT2022ScalaCases.AccessHandles7Sequence1] {
    def reads(seq: scala.xml.NodeSeq, stack: List[IPXACT2022scalaxb.ElemName]): Either[String, IPXACT2022ScalaCases.AccessHandles7Sequence1] = Left("don't call me.")
    
    def writes(__obj: IPXACT2022ScalaCases.AccessHandles7Sequence1, __namespace: Option[String], __elementLabel: Option[String],
        __scope: scala.xml.NamespaceBinding, __typeAttribute: Boolean): scala.xml.NodeSeq =
      IPXACT2022scalaxb.toXML[IPXACT2022ScalaCases.SimpleAccessHandle](__obj.accessHandle, Some("http://www.accellera.org/XMLSchema/IPXACT/1685-2022"), Some("accessHandle"), __scope, false)

  }
  trait DefaultIPXACT2022ScalaCases_LocalBankedBankTypeFormat extends IPXACT2022scalaxb.ElemNameParser[IPXACT2022ScalaCases.LocalBankedBankType] with IPXACT2022ScalaCases_NameGroupGroupFormat with IPXACT2022ScalaCases_LocalBankBaseGroupFormat {
    val targetNamespace: Option[String] = Some("http://www.accellera.org/XMLSchema/IPXACT/1685-2022")
    
    override def typeName: Option[String] = Some("localBankedBankType")

    def parser(node: scala.xml.Node, stack: List[IPXACT2022scalaxb.ElemName]): Parser[IPXACT2022ScalaCases.LocalBankedBankType] =
      phrase((parseNameGroupGroup(node, IPXACT2022scalaxb.ElemName(node) :: stack)) ~
      opt(IPXACT2022scalaxb.ElemName(Some("http://www.accellera.org/XMLSchema/IPXACT/1685-2022"), "accessHandles")) ~
      (parseLocalBankBaseGroup(node, IPXACT2022scalaxb.ElemName(node) :: stack)) ^^
      { case p1 ~ p2 ~ p3 =>
      IPXACT2022ScalaCases.LocalBankedBankType(p1,
        p2.headOption map { IPXACT2022scalaxb.fromXML[IPXACT2022ScalaCases.AccessHandles7](_, IPXACT2022scalaxb.ElemName(node) :: stack) },
        p3,
        scala.collection.immutable.ListMap(List(
        (node \ "@bankAlignment").headOption map { x => IPXACT2022scalaxb.DataRecord(x, node, IPXACT2022scalaxb.fromXML[IPXACT2022ScalaCases.BankAlignmentType](x, IPXACT2022scalaxb.ElemName(node) :: stack)) } map { "@bankAlignment" -> _ },
        (node \ "@{http://www.w3.org/XML/1998/namespace}id").headOption map { x => IPXACT2022scalaxb.DataRecord(x, node, IPXACT2022scalaxb.fromXML[String](x, IPXACT2022scalaxb.ElemName(node) :: stack)) } map { "@{http://www.w3.org/XML/1998/namespace}id" -> _ }
        ).flatten[(String, IPXACT2022scalaxb.DataRecord[Any])]: _*)) })
    
    override def writesAttribute(__obj: IPXACT2022ScalaCases.LocalBankedBankType, __scope: scala.xml.NamespaceBinding): scala.xml.MetaData = {
      var attr: scala.xml.MetaData  = scala.xml.Null
      __obj.attributes.toList map {
        case ("@bankAlignment", _) => attr = scala.xml.Attribute(null, "bankAlignment", __obj.bankAlignment.toString, attr)
        case ("@{http://www.w3.org/XML/1998/namespace}id", _) => __obj.xmlid foreach { x => attr = scala.xml.Attribute(__scope.getPrefix("http://www.w3.org/XML/1998/namespace"), "id", x.toString, attr) }
        case (key, x) => attr = scala.xml.Attribute((x.namespace map { __scope.getPrefix(_) }).orNull, x.key.orNull, x.value.toString, attr)
      }
      attr
    }

    def writesChildNodes(__obj: IPXACT2022ScalaCases.LocalBankedBankType, __scope: scala.xml.NamespaceBinding): Seq[scala.xml.Node] =
      Seq.concat(IPXACT2022scalaxb.toXML[IPXACT2022ScalaCases.NameGroupSequence](__obj.nameGroupSequence1, None, Some("nameGroupSequence1"), __scope, false),
        __obj.accessHandles map { IPXACT2022scalaxb.toXML[IPXACT2022ScalaCases.AccessHandles7](_, Some("http://www.accellera.org/XMLSchema/IPXACT/1685-2022"), Some("accessHandles"), __scope, false) } getOrElse {Nil},
        IPXACT2022scalaxb.toXML[IPXACT2022ScalaCases.LocalBankBaseSequence](__obj.localBankBaseSequence3, None, Some("localBankBaseSequence3"), __scope, false))

  }

  trait DefaultIPXACT2022ScalaCases_AccessHandles8Format extends IPXACT2022scalaxb.ElemNameParser[IPXACT2022ScalaCases.AccessHandles8] {
    val targetNamespace: Option[String] = Some("http://www.accellera.org/XMLSchema/IPXACT/1685-2022")
    
    def parser(node: scala.xml.Node, stack: List[IPXACT2022scalaxb.ElemName]): Parser[IPXACT2022ScalaCases.AccessHandles8] =
      phrase(safeRep(((IPXACT2022scalaxb.ElemName(Some("http://www.accellera.org/XMLSchema/IPXACT/1685-2022"), "accessHandle"))) ^^
        { case p1 => IPXACT2022ScalaCases.AccessHandles8Sequence1(IPXACT2022scalaxb.fromXML[IPXACT2022ScalaCases.SlicedAccessHandle](p1, IPXACT2022scalaxb.ElemName(node) :: stack)) }) ^^
      { case p1 =>
      IPXACT2022ScalaCases.AccessHandles8(p1) })
    
    def writesChildNodes(__obj: IPXACT2022ScalaCases.AccessHandles8, __scope: scala.xml.NamespaceBinding): Seq[scala.xml.Node] =
      (__obj.accesshandles8sequence1 flatMap { IPXACT2022scalaxb.toXML[IPXACT2022ScalaCases.AccessHandles8Sequence1](_, None, Some("accesshandles8sequence1"), __scope, false) })
  }

  trait DefaultIPXACT2022ScalaCases_AccessHandles8Sequence1Format extends IPXACT2022scalaxb.XMLFormat[IPXACT2022ScalaCases.AccessHandles8Sequence1] {
    def reads(seq: scala.xml.NodeSeq, stack: List[IPXACT2022scalaxb.ElemName]): Either[String, IPXACT2022ScalaCases.AccessHandles8Sequence1] = Left("don't call me.")
    
    def writes(__obj: IPXACT2022ScalaCases.AccessHandles8Sequence1, __namespace: Option[String], __elementLabel: Option[String],
        __scope: scala.xml.NamespaceBinding, __typeAttribute: Boolean): scala.xml.NodeSeq =
      IPXACT2022scalaxb.toXML[IPXACT2022ScalaCases.SlicedAccessHandle](__obj.accessHandle, Some("http://www.accellera.org/XMLSchema/IPXACT/1685-2022"), Some("accessHandle"), __scope, false)

  }
  trait DefaultIPXACT2022ScalaCases_BankedBlockTypeFormat extends IPXACT2022scalaxb.ElemNameParser[IPXACT2022ScalaCases.BankedBlockType] with IPXACT2022ScalaCases_NameGroupGroupFormat with IPXACT2022ScalaCases_BlockSizeGroupFormat with IPXACT2022ScalaCases_AddressBlockExtensionsGroupFormat {
    val targetNamespace: Option[String] = Some("http://www.accellera.org/XMLSchema/IPXACT/1685-2022")
    
    override def typeName: Option[String] = Some("bankedBlockType")

    def parser(node: scala.xml.Node, stack: List[IPXACT2022scalaxb.ElemName]): Parser[IPXACT2022ScalaCases.BankedBlockType] =
      phrase((parseNameGroupGroup(node, IPXACT2022scalaxb.ElemName(node) :: stack)) ~
      opt(IPXACT2022scalaxb.ElemName(Some("http://www.accellera.org/XMLSchema/IPXACT/1685-2022"), "accessHandles")) ~
      (parseBlockSizeGroup(node, IPXACT2022scalaxb.ElemName(node) :: stack)) ~
      (parseAddressBlockExtensionsGroup(node, IPXACT2022scalaxb.ElemName(node) :: stack)) ~
      opt(IPXACT2022scalaxb.ElemName(Some("http://www.accellera.org/XMLSchema/IPXACT/1685-2022"), "vendorExtensions")) ^^
      { case p1 ~ p2 ~ p3 ~ p4 ~ p5 =>
      IPXACT2022ScalaCases.BankedBlockType(p1,
        p2.headOption map { IPXACT2022scalaxb.fromXML[IPXACT2022ScalaCases.AccessHandles8](_, IPXACT2022scalaxb.ElemName(node) :: stack) },
        p3,
        p4,
        p5.headOption map { IPXACT2022scalaxb.fromXML[IPXACT2022ScalaCases.VendorExtensions](_, IPXACT2022scalaxb.ElemName(node) :: stack) },
        scala.collection.immutable.ListMap(List(
        (node \ "@{http://www.w3.org/XML/1998/namespace}id").headOption map { x => IPXACT2022scalaxb.DataRecord(x, node, IPXACT2022scalaxb.fromXML[String](x, IPXACT2022scalaxb.ElemName(node) :: stack)) } map { "@{http://www.w3.org/XML/1998/namespace}id" -> _ }
        ).flatten[(String, IPXACT2022scalaxb.DataRecord[Any])]: _*)) })
    
    override def writesAttribute(__obj: IPXACT2022ScalaCases.BankedBlockType, __scope: scala.xml.NamespaceBinding): scala.xml.MetaData = {
      var attr: scala.xml.MetaData  = scala.xml.Null
      __obj.attributes.toList map {
        case ("@{http://www.w3.org/XML/1998/namespace}id", _) => __obj.xmlid foreach { x => attr = scala.xml.Attribute(__scope.getPrefix("http://www.w3.org/XML/1998/namespace"), "id", x.toString, attr) }
        case (key, x) => attr = scala.xml.Attribute((x.namespace map { __scope.getPrefix(_) }).orNull, x.key.orNull, x.value.toString, attr)
      }
      attr
    }

    def writesChildNodes(__obj: IPXACT2022ScalaCases.BankedBlockType, __scope: scala.xml.NamespaceBinding): Seq[scala.xml.Node] =
      Seq.concat(IPXACT2022scalaxb.toXML[IPXACT2022ScalaCases.NameGroupSequence](__obj.nameGroupSequence1, None, Some("nameGroupSequence1"), __scope, false),
        __obj.accessHandles map { IPXACT2022scalaxb.toXML[IPXACT2022ScalaCases.AccessHandles8](_, Some("http://www.accellera.org/XMLSchema/IPXACT/1685-2022"), Some("accessHandles"), __scope, false) } getOrElse {Nil},
        IPXACT2022scalaxb.toXML[IPXACT2022ScalaCases.BlockSizeSequence](__obj.blockSizeSequence3, None, Some("blockSizeSequence3"), __scope, false),
        IPXACT2022scalaxb.toXML[IPXACT2022ScalaCases.AddressBlockExtensionsSequence](__obj.addressBlockExtensionsSequence4, None, Some("addressBlockExtensionsSequence4"), __scope, false),
        __obj.vendorExtensions map { IPXACT2022scalaxb.toXML[IPXACT2022ScalaCases.VendorExtensions](_, Some("http://www.accellera.org/XMLSchema/IPXACT/1685-2022"), Some("vendorExtensions"), __scope, false) } getOrElse {Nil})

  }

  trait DefaultIPXACT2022ScalaCases_BankedSubspaceTypeFormat extends IPXACT2022scalaxb.ElemNameParser[IPXACT2022ScalaCases.BankedSubspaceType] with IPXACT2022ScalaCases_NameGroupOptionalGroupFormat {
    val targetNamespace: Option[String] = Some("http://www.accellera.org/XMLSchema/IPXACT/1685-2022")
    
    override def typeName: Option[String] = Some("bankedSubspaceType")

    def parser(node: scala.xml.Node, stack: List[IPXACT2022scalaxb.ElemName]): Parser[IPXACT2022ScalaCases.BankedSubspaceType] =
      phrase((parseNameGroupOptionalGroup(node, IPXACT2022scalaxb.ElemName(node) :: stack)) ~
      opt(IPXACT2022scalaxb.ElemName(Some("http://www.accellera.org/XMLSchema/IPXACT/1685-2022"), "parameters")) ~
      opt(IPXACT2022scalaxb.ElemName(Some("http://www.accellera.org/XMLSchema/IPXACT/1685-2022"), "vendorExtensions")) ^^
      { case p1 ~ p2 ~ p3 =>
      IPXACT2022ScalaCases.BankedSubspaceType(p1,
        p2.headOption map { IPXACT2022scalaxb.fromXML[IPXACT2022ScalaCases.Parameters](_, IPXACT2022scalaxb.ElemName(node) :: stack) },
        p3.headOption map { IPXACT2022scalaxb.fromXML[IPXACT2022ScalaCases.VendorExtensions](_, IPXACT2022scalaxb.ElemName(node) :: stack) },
        scala.collection.immutable.ListMap(List(
        (node \ "@initiatorRef").headOption map { x => IPXACT2022scalaxb.DataRecord(x, node, IPXACT2022scalaxb.fromXML[String](x, IPXACT2022scalaxb.ElemName(node) :: stack)) } map { "@initiatorRef" -> _ },
        (node \ "@{http://www.w3.org/XML/1998/namespace}id").headOption map { x => IPXACT2022scalaxb.DataRecord(x, node, IPXACT2022scalaxb.fromXML[String](x, IPXACT2022scalaxb.ElemName(node) :: stack)) } map { "@{http://www.w3.org/XML/1998/namespace}id" -> _ }
        ).flatten[(String, IPXACT2022scalaxb.DataRecord[Any])]: _*)) })
    
    override def writesAttribute(__obj: IPXACT2022ScalaCases.BankedSubspaceType, __scope: scala.xml.NamespaceBinding): scala.xml.MetaData = {
      var attr: scala.xml.MetaData  = scala.xml.Null
      __obj.attributes.toList map {
        case ("@initiatorRef", _) => attr = scala.xml.Attribute(null, "initiatorRef", __obj.initiatorRef.toString, attr)
        case ("@{http://www.w3.org/XML/1998/namespace}id", _) => __obj.xmlid foreach { x => attr = scala.xml.Attribute(__scope.getPrefix("http://www.w3.org/XML/1998/namespace"), "id", x.toString, attr) }
        case (key, x) => attr = scala.xml.Attribute((x.namespace map { __scope.getPrefix(_) }).orNull, x.key.orNull, x.value.toString, attr)
      }
      attr
    }

    def writesChildNodes(__obj: IPXACT2022ScalaCases.BankedSubspaceType, __scope: scala.xml.NamespaceBinding): Seq[scala.xml.Node] =
      Seq.concat(IPXACT2022scalaxb.toXML[IPXACT2022ScalaCases.NameGroupOptionalSequence](__obj.nameGroupOptionalSequence1, None, Some("nameGroupOptionalSequence1"), __scope, false),
        __obj.parameters map { IPXACT2022scalaxb.toXML[IPXACT2022ScalaCases.Parameters](_, Some("http://www.accellera.org/XMLSchema/IPXACT/1685-2022"), Some("parameters"), __scope, false) } getOrElse {Nil},
        __obj.vendorExtensions map { IPXACT2022scalaxb.toXML[IPXACT2022ScalaCases.VendorExtensions](_, Some("http://www.accellera.org/XMLSchema/IPXACT/1685-2022"), Some("vendorExtensions"), __scope, false) } getOrElse {Nil})

  }

  trait DefaultIPXACT2022ScalaCases_AccessHandles9Format extends IPXACT2022scalaxb.ElemNameParser[IPXACT2022ScalaCases.AccessHandles9] {
    val targetNamespace: Option[String] = Some("http://www.accellera.org/XMLSchema/IPXACT/1685-2022")
    
    def parser(node: scala.xml.Node, stack: List[IPXACT2022scalaxb.ElemName]): Parser[IPXACT2022ScalaCases.AccessHandles9] =
      phrase(safeRep(((IPXACT2022scalaxb.ElemName(Some("http://www.accellera.org/XMLSchema/IPXACT/1685-2022"), "accessHandle"))) ^^
        { case p1 => IPXACT2022ScalaCases.AccessHandles9Sequence1(IPXACT2022scalaxb.fromXML[IPXACT2022ScalaCases.SlicedAccessHandle](p1, IPXACT2022scalaxb.ElemName(node) :: stack)) }) ^^
      { case p1 =>
      IPXACT2022ScalaCases.AccessHandles9(p1) })
    
    def writesChildNodes(__obj: IPXACT2022ScalaCases.AccessHandles9, __scope: scala.xml.NamespaceBinding): Seq[scala.xml.Node] =
      (__obj.accesshandles9sequence1 flatMap { IPXACT2022scalaxb.toXML[IPXACT2022ScalaCases.AccessHandles9Sequence1](_, None, Some("accesshandles9sequence1"), __scope, false) })
  }

  trait DefaultIPXACT2022ScalaCases_AccessHandles9Sequence1Format extends IPXACT2022scalaxb.XMLFormat[IPXACT2022ScalaCases.AccessHandles9Sequence1] {
    def reads(seq: scala.xml.NodeSeq, stack: List[IPXACT2022scalaxb.ElemName]): Either[String, IPXACT2022ScalaCases.AccessHandles9Sequence1] = Left("don't call me.")
    
    def writes(__obj: IPXACT2022ScalaCases.AccessHandles9Sequence1, __namespace: Option[String], __elementLabel: Option[String],
        __scope: scala.xml.NamespaceBinding, __typeAttribute: Boolean): scala.xml.NodeSeq =
      IPXACT2022scalaxb.toXML[IPXACT2022ScalaCases.SlicedAccessHandle](__obj.accessHandle, Some("http://www.accellera.org/XMLSchema/IPXACT/1685-2022"), Some("accessHandle"), __scope, false)

  }
  trait DefaultIPXACT2022ScalaCases_ArrayType3Format extends IPXACT2022scalaxb.ElemNameParser[IPXACT2022ScalaCases.ArrayType3] {
    val targetNamespace: Option[String] = Some("http://www.accellera.org/XMLSchema/IPXACT/1685-2022")
    
    def parser(node: scala.xml.Node, stack: List[IPXACT2022scalaxb.ElemName]): Parser[IPXACT2022ScalaCases.ArrayType3] =
      phrase(safeRep(IPXACT2022scalaxb.ElemName(Some("http://www.accellera.org/XMLSchema/IPXACT/1685-2022"), "dim")) ~
      opt(IPXACT2022scalaxb.ElemName(Some("http://www.accellera.org/XMLSchema/IPXACT/1685-2022"), "bitStride")) ^^
      { case p1 ~ p2 =>
      IPXACT2022ScalaCases.ArrayType3(p1 map { IPXACT2022scalaxb.fromXML[IPXACT2022ScalaCases.Dim](_, IPXACT2022scalaxb.ElemName(node) :: stack) },
        p2.headOption map { IPXACT2022scalaxb.fromXML[IPXACT2022ScalaCases.BitStride](_, IPXACT2022scalaxb.ElemName(node) :: stack) }) })
    
    def writesChildNodes(__obj: IPXACT2022ScalaCases.ArrayType3, __scope: scala.xml.NamespaceBinding): Seq[scala.xml.Node] =
      Seq.concat(__obj.dim flatMap { IPXACT2022scalaxb.toXML[IPXACT2022ScalaCases.Dim](_, Some("http://www.accellera.org/XMLSchema/IPXACT/1685-2022"), Some("dim"), __scope, false) },
        __obj.bitStride map { IPXACT2022scalaxb.toXML[IPXACT2022ScalaCases.BitStride](_, Some("http://www.accellera.org/XMLSchema/IPXACT/1685-2022"), Some("bitStride"), __scope, false) } getOrElse {Nil})

  }

  trait DefaultIPXACT2022ScalaCases_FieldDefinitionRefFormat extends IPXACT2022scalaxb.XMLFormat[IPXACT2022ScalaCases.FieldDefinitionRef] with IPXACT2022scalaxb.CanWriteChildNodes[IPXACT2022ScalaCases.FieldDefinitionRef] {
    val targetNamespace: Option[String] = Some("http://www.accellera.org/XMLSchema/IPXACT/1685-2022")
    def reads(seq: scala.xml.NodeSeq, stack: List[IPXACT2022scalaxb.ElemName]): Either[String, IPXACT2022ScalaCases.FieldDefinitionRef] = seq match {
      case node: scala.xml.Node => Right(IPXACT2022ScalaCases.FieldDefinitionRef(IPXACT2022scalaxb.fromXML[String](node, IPXACT2022scalaxb.ElemName(node) :: stack),
        scala.collection.immutable.ListMap(List(
        (node \ "@typeDefinitions").headOption map { x => IPXACT2022scalaxb.DataRecord(x, node, IPXACT2022scalaxb.fromXML[String](x, IPXACT2022scalaxb.ElemName(node) :: stack)) } map { "@typeDefinitions" -> _ }
        ).flatten[(String, IPXACT2022scalaxb.DataRecord[Any])]: _*)))
      case _ => Left("reads failed: seq must be scala.xml.Node")
    }
    
    override def writesAttribute(__obj: IPXACT2022ScalaCases.FieldDefinitionRef, __scope: scala.xml.NamespaceBinding): scala.xml.MetaData = {
      var attr: scala.xml.MetaData  = scala.xml.Null
      __obj.attributes.toList map {
        case ("@typeDefinitions", _) => attr = scala.xml.Attribute(null, "typeDefinitions", __obj.typeDefinitions.toString, attr)
        case (key, x) => attr = scala.xml.Attribute((x.namespace map { __scope.getPrefix(_) }).orNull, x.key.orNull, x.value.toString, attr)
      }
      attr
    }

    def writesChildNodes(__obj: IPXACT2022ScalaCases.FieldDefinitionRef, __scope: scala.xml.NamespaceBinding): Seq[scala.xml.Node] =
      Seq(scala.xml.Text(__obj.value.toString))

  }

  trait DefaultIPXACT2022ScalaCases_FieldTypeFormat extends IPXACT2022scalaxb.ElemNameParser[IPXACT2022ScalaCases.FieldType] with IPXACT2022ScalaCases_NameGroupGroupFormat with IPXACT2022ScalaCases_FieldDefinitionGroupGroupFormat {
    val targetNamespace: Option[String] = Some("http://www.accellera.org/XMLSchema/IPXACT/1685-2022")
    
    override def typeName: Option[String] = Some("fieldType")

    def parser(node: scala.xml.Node, stack: List[IPXACT2022scalaxb.ElemName]): Parser[IPXACT2022ScalaCases.FieldType] =
      phrase((parseNameGroupGroup(node, IPXACT2022scalaxb.ElemName(node) :: stack)) ~
      opt(IPXACT2022scalaxb.ElemName(Some("http://www.accellera.org/XMLSchema/IPXACT/1685-2022"), "accessHandles")) ~
      opt(IPXACT2022scalaxb.ElemName(Some("http://www.accellera.org/XMLSchema/IPXACT/1685-2022"), "array")) ~
      (IPXACT2022scalaxb.ElemName(Some("http://www.accellera.org/XMLSchema/IPXACT/1685-2022"), "bitOffset")) ~
      (((IPXACT2022scalaxb.ElemName(Some("http://www.accellera.org/XMLSchema/IPXACT/1685-2022"), "fieldDefinitionRef")) ^^
      (x => IPXACT2022scalaxb.DataRecord(x.namespace, Some(x.name), IPXACT2022scalaxb.fromXML[IPXACT2022ScalaCases.FieldDefinitionRef](x, IPXACT2022scalaxb.ElemName(node) :: stack)))) |||
      (parseFieldDefinitionGroupGroup(node, IPXACT2022scalaxb.ElemName(node) :: stack, true))) ~
      opt(IPXACT2022scalaxb.ElemName(Some("http://www.accellera.org/XMLSchema/IPXACT/1685-2022"), "parameters")) ~
      opt(IPXACT2022scalaxb.ElemName(Some("http://www.accellera.org/XMLSchema/IPXACT/1685-2022"), "vendorExtensions")) ^^
      { case p1 ~ p2 ~ p3 ~ p4 ~ p5 ~ p6 ~ p7 =>
      IPXACT2022ScalaCases.FieldType(p1,
        p2.headOption map { IPXACT2022scalaxb.fromXML[IPXACT2022ScalaCases.AccessHandles9](_, IPXACT2022scalaxb.ElemName(node) :: stack) },
        p3.headOption map { IPXACT2022scalaxb.fromXML[IPXACT2022ScalaCases.ArrayType3](_, IPXACT2022scalaxb.ElemName(node) :: stack) },
        IPXACT2022scalaxb.fromXML[IPXACT2022ScalaCases.UnsignedIntExpressionable](p4, IPXACT2022scalaxb.ElemName(node) :: stack),
        p5,
        p6.headOption map { IPXACT2022scalaxb.fromXML[IPXACT2022ScalaCases.Parameters](_, IPXACT2022scalaxb.ElemName(node) :: stack) },
        p7.headOption map { IPXACT2022scalaxb.fromXML[IPXACT2022ScalaCases.VendorExtensions](_, IPXACT2022scalaxb.ElemName(node) :: stack) },
        scala.collection.immutable.ListMap(List(
        (node \ "@{http://www.w3.org/XML/1998/namespace}id").headOption map { x => IPXACT2022scalaxb.DataRecord(x, node, IPXACT2022scalaxb.fromXML[String](x, IPXACT2022scalaxb.ElemName(node) :: stack)) } map { "@{http://www.w3.org/XML/1998/namespace}id" -> _ }
        ).flatten[(String, IPXACT2022scalaxb.DataRecord[Any])]: _*)) })
    
    override def writesAttribute(__obj: IPXACT2022ScalaCases.FieldType, __scope: scala.xml.NamespaceBinding): scala.xml.MetaData = {
      var attr: scala.xml.MetaData  = scala.xml.Null
      __obj.attributes.toList map {
        case ("@{http://www.w3.org/XML/1998/namespace}id", _) => __obj.xmlid foreach { x => attr = scala.xml.Attribute(__scope.getPrefix("http://www.w3.org/XML/1998/namespace"), "id", x.toString, attr) }
        case (key, x) => attr = scala.xml.Attribute((x.namespace map { __scope.getPrefix(_) }).orNull, x.key.orNull, x.value.toString, attr)
      }
      attr
    }

    def writesChildNodes(__obj: IPXACT2022ScalaCases.FieldType, __scope: scala.xml.NamespaceBinding): Seq[scala.xml.Node] =
      Seq.concat(IPXACT2022scalaxb.toXML[IPXACT2022ScalaCases.NameGroupSequence](__obj.nameGroupSequence1, None, Some("nameGroupSequence1"), __scope, false),
        __obj.accessHandles map { IPXACT2022scalaxb.toXML[IPXACT2022ScalaCases.AccessHandles9](_, Some("http://www.accellera.org/XMLSchema/IPXACT/1685-2022"), Some("accessHandles"), __scope, false) } getOrElse {Nil},
        __obj.array map { IPXACT2022scalaxb.toXML[IPXACT2022ScalaCases.ArrayType3](_, Some("http://www.accellera.org/XMLSchema/IPXACT/1685-2022"), Some("array"), __scope, false) } getOrElse {Nil},
        IPXACT2022scalaxb.toXML[IPXACT2022ScalaCases.UnsignedIntExpressionable](__obj.bitOffset, Some("http://www.accellera.org/XMLSchema/IPXACT/1685-2022"), Some("bitOffset"), __scope, false),
        (Some(__obj.fieldtypeoption) map {x => IPXACT2022scalaxb.toXML[IPXACT2022scalaxb.DataRecord[Any]](x, x.namespace, x.key, __scope, false)}).get,
        __obj.parameters map { IPXACT2022scalaxb.toXML[IPXACT2022ScalaCases.Parameters](_, Some("http://www.accellera.org/XMLSchema/IPXACT/1685-2022"), Some("parameters"), __scope, false) } getOrElse {Nil},
        __obj.vendorExtensions map { IPXACT2022scalaxb.toXML[IPXACT2022ScalaCases.VendorExtensions](_, Some("http://www.accellera.org/XMLSchema/IPXACT/1685-2022"), Some("vendorExtensions"), __scope, false) } getOrElse {Nil})

  }

  trait DefaultIPXACT2022ScalaCases_MemoryMapDefinitionRefFormat extends IPXACT2022scalaxb.XMLFormat[IPXACT2022ScalaCases.MemoryMapDefinitionRef] with IPXACT2022scalaxb.CanWriteChildNodes[IPXACT2022ScalaCases.MemoryMapDefinitionRef] {
    val targetNamespace: Option[String] = Some("http://www.accellera.org/XMLSchema/IPXACT/1685-2022")
    def reads(seq: scala.xml.NodeSeq, stack: List[IPXACT2022scalaxb.ElemName]): Either[String, IPXACT2022ScalaCases.MemoryMapDefinitionRef] = seq match {
      case node: scala.xml.Node => Right(IPXACT2022ScalaCases.MemoryMapDefinitionRef(IPXACT2022scalaxb.fromXML[String](node, IPXACT2022scalaxb.ElemName(node) :: stack),
        scala.collection.immutable.ListMap(List(
        (node \ "@typeDefinitions").headOption map { x => IPXACT2022scalaxb.DataRecord(x, node, IPXACT2022scalaxb.fromXML[String](x, IPXACT2022scalaxb.ElemName(node) :: stack)) } map { "@typeDefinitions" -> _ }
        ).flatten[(String, IPXACT2022scalaxb.DataRecord[Any])]: _*)))
      case _ => Left("reads failed: seq must be scala.xml.Node")
    }
    
    override def writesAttribute(__obj: IPXACT2022ScalaCases.MemoryMapDefinitionRef, __scope: scala.xml.NamespaceBinding): scala.xml.MetaData = {
      var attr: scala.xml.MetaData  = scala.xml.Null
      __obj.attributes.toList map {
        case ("@typeDefinitions", _) => attr = scala.xml.Attribute(null, "typeDefinitions", __obj.typeDefinitions.toString, attr)
        case (key, x) => attr = scala.xml.Attribute((x.namespace map { __scope.getPrefix(_) }).orNull, x.key.orNull, x.value.toString, attr)
      }
      attr
    }

    def writesChildNodes(__obj: IPXACT2022ScalaCases.MemoryMapDefinitionRef, __scope: scala.xml.NamespaceBinding): Seq[scala.xml.Node] =
      Seq(scala.xml.Text(__obj.value.toString))

  }

  trait DefaultIPXACT2022ScalaCases_MemoryMapTypeFormat extends IPXACT2022scalaxb.ElemNameParser[IPXACT2022ScalaCases.MemoryMapType] with IPXACT2022ScalaCases_NameGroupGroupFormat with IPXACT2022ScalaCases_MemoryMapGroupGroupFormat {
    val targetNamespace: Option[String] = Some("http://www.accellera.org/XMLSchema/IPXACT/1685-2022")
    
    override def typeName: Option[String] = Some("memoryMapType")

    def parser(node: scala.xml.Node, stack: List[IPXACT2022scalaxb.ElemName]): Parser[IPXACT2022ScalaCases.MemoryMapType] =
      phrase((parseNameGroupGroup(node, IPXACT2022scalaxb.ElemName(node) :: stack)) ~
      opt(((IPXACT2022scalaxb.ElemName(Some("http://www.accellera.org/XMLSchema/IPXACT/1685-2022"), "memoryMapDefinitionRef")) ^^
      (x => IPXACT2022scalaxb.DataRecord(x.namespace, Some(x.name), IPXACT2022scalaxb.fromXML[IPXACT2022ScalaCases.MemoryMapDefinitionRef](x, IPXACT2022scalaxb.ElemName(node) :: stack)))) |||
      (parseMemoryMapGroupGroup(node, IPXACT2022scalaxb.ElemName(node) :: stack, true))) ~
      opt(IPXACT2022scalaxb.ElemName(Some("http://www.accellera.org/XMLSchema/IPXACT/1685-2022"), "vendorExtensions")) ^^
      { case p1 ~ p2 ~ p3 =>
      IPXACT2022ScalaCases.MemoryMapType(p1,
        p2,
        p3.headOption map { IPXACT2022scalaxb.fromXML[IPXACT2022ScalaCases.VendorExtensions](_, IPXACT2022scalaxb.ElemName(node) :: stack) },
        scala.collection.immutable.ListMap(List(
        (node \ "@{http://www.w3.org/XML/1998/namespace}id").headOption map { x => IPXACT2022scalaxb.DataRecord(x, node, IPXACT2022scalaxb.fromXML[String](x, IPXACT2022scalaxb.ElemName(node) :: stack)) } map { "@{http://www.w3.org/XML/1998/namespace}id" -> _ }
        ).flatten[(String, IPXACT2022scalaxb.DataRecord[Any])]: _*)) })
    
    override def writesAttribute(__obj: IPXACT2022ScalaCases.MemoryMapType, __scope: scala.xml.NamespaceBinding): scala.xml.MetaData = {
      var attr: scala.xml.MetaData  = scala.xml.Null
      __obj.attributes.toList map {
        case ("@{http://www.w3.org/XML/1998/namespace}id", _) => __obj.xmlid foreach { x => attr = scala.xml.Attribute(__scope.getPrefix("http://www.w3.org/XML/1998/namespace"), "id", x.toString, attr) }
        case (key, x) => attr = scala.xml.Attribute((x.namespace map { __scope.getPrefix(_) }).orNull, x.key.orNull, x.value.toString, attr)
      }
      attr
    }

    def writesChildNodes(__obj: IPXACT2022ScalaCases.MemoryMapType, __scope: scala.xml.NamespaceBinding): Seq[scala.xml.Node] =
      Seq.concat(IPXACT2022scalaxb.toXML[IPXACT2022ScalaCases.NameGroupSequence](__obj.nameGroupSequence1, None, Some("nameGroupSequence1"), __scope, false),
        __obj.memorymaptypeoption map { x => IPXACT2022scalaxb.toXML[IPXACT2022scalaxb.DataRecord[Any]](x, x.namespace, x.key, __scope, false) } getOrElse {Nil},
        __obj.vendorExtensions map { IPXACT2022scalaxb.toXML[IPXACT2022ScalaCases.VendorExtensions](_, Some("http://www.accellera.org/XMLSchema/IPXACT/1685-2022"), Some("vendorExtensions"), __scope, false) } getOrElse {Nil})

  }

  trait DefaultIPXACT2022ScalaCases_RemapDefinitionRefFormat extends IPXACT2022scalaxb.XMLFormat[IPXACT2022ScalaCases.RemapDefinitionRef] with IPXACT2022scalaxb.CanWriteChildNodes[IPXACT2022ScalaCases.RemapDefinitionRef] {
    val targetNamespace: Option[String] = Some("http://www.accellera.org/XMLSchema/IPXACT/1685-2022")
    def reads(seq: scala.xml.NodeSeq, stack: List[IPXACT2022scalaxb.ElemName]): Either[String, IPXACT2022ScalaCases.RemapDefinitionRef] = seq match {
      case node: scala.xml.Node => Right(IPXACT2022ScalaCases.RemapDefinitionRef(IPXACT2022scalaxb.fromXML[String](node, IPXACT2022scalaxb.ElemName(node) :: stack),
        scala.collection.immutable.ListMap(List(
        (node \ "@typeDefinitions").headOption map { x => IPXACT2022scalaxb.DataRecord(x, node, IPXACT2022scalaxb.fromXML[String](x, IPXACT2022scalaxb.ElemName(node) :: stack)) } map { "@typeDefinitions" -> _ }
        ).flatten[(String, IPXACT2022scalaxb.DataRecord[Any])]: _*)))
      case _ => Left("reads failed: seq must be scala.xml.Node")
    }
    
    override def writesAttribute(__obj: IPXACT2022ScalaCases.RemapDefinitionRef, __scope: scala.xml.NamespaceBinding): scala.xml.MetaData = {
      var attr: scala.xml.MetaData  = scala.xml.Null
      __obj.attributes.toList map {
        case ("@typeDefinitions", _) => attr = scala.xml.Attribute(null, "typeDefinitions", __obj.typeDefinitions.toString, attr)
        case (key, x) => attr = scala.xml.Attribute((x.namespace map { __scope.getPrefix(_) }).orNull, x.key.orNull, x.value.toString, attr)
      }
      attr
    }

    def writesChildNodes(__obj: IPXACT2022ScalaCases.RemapDefinitionRef, __scope: scala.xml.NamespaceBinding): Seq[scala.xml.Node] =
      Seq(scala.xml.Text(__obj.value.toString))

  }

  trait DefaultIPXACT2022ScalaCases_MemoryRemapTypeFormat extends IPXACT2022scalaxb.ElemNameParser[IPXACT2022ScalaCases.MemoryRemapType] with IPXACT2022ScalaCases_NameGroupGroupFormat with IPXACT2022ScalaCases_MemoryMapGroupFormat {
    val targetNamespace: Option[String] = Some("http://www.accellera.org/XMLSchema/IPXACT/1685-2022")
    
    override def typeName: Option[String] = Some("memoryRemapType")

    def parser(node: scala.xml.Node, stack: List[IPXACT2022scalaxb.ElemName]): Parser[IPXACT2022ScalaCases.MemoryRemapType] =
      phrase((parseNameGroupGroup(node, IPXACT2022scalaxb.ElemName(node) :: stack)) ~
      safeRep(IPXACT2022scalaxb.ElemName(Some("http://www.accellera.org/XMLSchema/IPXACT/1685-2022"), "modeRef")) ~
      safeRep(((IPXACT2022scalaxb.ElemName(Some("http://www.accellera.org/XMLSchema/IPXACT/1685-2022"), "remapDefinitionRef")) ^^
      (x => IPXACT2022scalaxb.DataRecord(x.namespace, Some(x.name), IPXACT2022scalaxb.fromXML[IPXACT2022ScalaCases.RemapDefinitionRef](x, IPXACT2022scalaxb.ElemName(node) :: stack)))) |||
      (parseMemoryMapGroup(node, IPXACT2022scalaxb.ElemName(node) :: stack, true))) ~
      opt(IPXACT2022scalaxb.ElemName(Some("http://www.accellera.org/XMLSchema/IPXACT/1685-2022"), "vendorExtensions")) ^^
      { case p1 ~ p2 ~ p3 ~ p4 =>
      IPXACT2022ScalaCases.MemoryRemapType(p1,
        p2 map { IPXACT2022scalaxb.fromXML[IPXACT2022ScalaCases.ModeRef3](_, IPXACT2022scalaxb.ElemName(node) :: stack) },
        p3,
        p4.headOption map { IPXACT2022scalaxb.fromXML[IPXACT2022ScalaCases.VendorExtensions](_, IPXACT2022scalaxb.ElemName(node) :: stack) },
        scala.collection.immutable.ListMap(List(
        (node \ "@{http://www.w3.org/XML/1998/namespace}id").headOption map { x => IPXACT2022scalaxb.DataRecord(x, node, IPXACT2022scalaxb.fromXML[String](x, IPXACT2022scalaxb.ElemName(node) :: stack)) } map { "@{http://www.w3.org/XML/1998/namespace}id" -> _ }
        ).flatten[(String, IPXACT2022scalaxb.DataRecord[Any])]: _*)) })
    
    override def writesAttribute(__obj: IPXACT2022ScalaCases.MemoryRemapType, __scope: scala.xml.NamespaceBinding): scala.xml.MetaData = {
      var attr: scala.xml.MetaData  = scala.xml.Null
      __obj.attributes.toList map {
        case ("@{http://www.w3.org/XML/1998/namespace}id", _) => __obj.xmlid foreach { x => attr = scala.xml.Attribute(__scope.getPrefix("http://www.w3.org/XML/1998/namespace"), "id", x.toString, attr) }
        case (key, x) => attr = scala.xml.Attribute((x.namespace map { __scope.getPrefix(_) }).orNull, x.key.orNull, x.value.toString, attr)
      }
      attr
    }

    def writesChildNodes(__obj: IPXACT2022ScalaCases.MemoryRemapType, __scope: scala.xml.NamespaceBinding): Seq[scala.xml.Node] =
      Seq.concat(IPXACT2022scalaxb.toXML[IPXACT2022ScalaCases.NameGroupSequence](__obj.nameGroupSequence1, None, Some("nameGroupSequence1"), __scope, false),
        __obj.modeRef flatMap { IPXACT2022scalaxb.toXML[IPXACT2022ScalaCases.ModeRef3](_, Some("http://www.accellera.org/XMLSchema/IPXACT/1685-2022"), Some("modeRef"), __scope, false) },
        __obj.memoryremaptypeoption flatMap { x => IPXACT2022scalaxb.toXML[IPXACT2022scalaxb.DataRecord[Any]](x, x.namespace, x.key, __scope, false) },
        __obj.vendorExtensions map { IPXACT2022scalaxb.toXML[IPXACT2022ScalaCases.VendorExtensions](_, Some("http://www.accellera.org/XMLSchema/IPXACT/1685-2022"), Some("vendorExtensions"), __scope, false) } getOrElse {Nil})

  }

  trait DefaultIPXACT2022ScalaCases_RemapDefinitionRef2Format extends IPXACT2022scalaxb.XMLFormat[IPXACT2022ScalaCases.RemapDefinitionRef2] with IPXACT2022scalaxb.CanWriteChildNodes[IPXACT2022ScalaCases.RemapDefinitionRef2] {
    val targetNamespace: Option[String] = Some("http://www.accellera.org/XMLSchema/IPXACT/1685-2022")
    def reads(seq: scala.xml.NodeSeq, stack: List[IPXACT2022scalaxb.ElemName]): Either[String, IPXACT2022ScalaCases.RemapDefinitionRef2] = seq match {
      case node: scala.xml.Node => Right(IPXACT2022ScalaCases.RemapDefinitionRef2(IPXACT2022scalaxb.fromXML[String](node, IPXACT2022scalaxb.ElemName(node) :: stack),
        scala.collection.immutable.ListMap(List(
        (node \ "@typeDefinitions").headOption map { x => IPXACT2022scalaxb.DataRecord(x, node, IPXACT2022scalaxb.fromXML[String](x, IPXACT2022scalaxb.ElemName(node) :: stack)) } map { "@typeDefinitions" -> _ }
        ).flatten[(String, IPXACT2022scalaxb.DataRecord[Any])]: _*)))
      case _ => Left("reads failed: seq must be scala.xml.Node")
    }
    
    override def writesAttribute(__obj: IPXACT2022ScalaCases.RemapDefinitionRef2, __scope: scala.xml.NamespaceBinding): scala.xml.MetaData = {
      var attr: scala.xml.MetaData  = scala.xml.Null
      __obj.attributes.toList map {
        case ("@typeDefinitions", _) => attr = scala.xml.Attribute(null, "typeDefinitions", __obj.typeDefinitions.toString, attr)
        case (key, x) => attr = scala.xml.Attribute((x.namespace map { __scope.getPrefix(_) }).orNull, x.key.orNull, x.value.toString, attr)
      }
      attr
    }

    def writesChildNodes(__obj: IPXACT2022ScalaCases.RemapDefinitionRef2, __scope: scala.xml.NamespaceBinding): Seq[scala.xml.Node] =
      Seq(scala.xml.Text(__obj.value.toString))

  }

  trait DefaultIPXACT2022ScalaCases_BankFormat extends IPXACT2022scalaxb.ElemNameParser[IPXACT2022ScalaCases.Bank] with IPXACT2022ScalaCases_NameGroupGroupFormat with IPXACT2022ScalaCases_BankDefinitionBaseGroupFormat {
    val targetNamespace: Option[String] = Some("http://www.accellera.org/XMLSchema/IPXACT/1685-2022")
    
    def parser(node: scala.xml.Node, stack: List[IPXACT2022scalaxb.ElemName]): Parser[IPXACT2022ScalaCases.Bank] =
      phrase((parseNameGroupGroup(node, IPXACT2022scalaxb.ElemName(node) :: stack)) ~
      opt(IPXACT2022scalaxb.ElemName(Some("http://www.accellera.org/XMLSchema/IPXACT/1685-2022"), "accessHandles")) ~
      (((IPXACT2022scalaxb.ElemName(Some("http://www.accellera.org/XMLSchema/IPXACT/1685-2022"), "bankDefinitionRef")) ^^
      (x => IPXACT2022scalaxb.DataRecord(x.namespace, Some(x.name), IPXACT2022scalaxb.fromXML[IPXACT2022ScalaCases.BankDefinitionRef4](x, IPXACT2022scalaxb.ElemName(node) :: stack)))) |||
      (parseBankDefinitionBaseGroup(node, IPXACT2022scalaxb.ElemName(node) :: stack, true))) ~
      opt(IPXACT2022scalaxb.ElemName(Some("http://www.accellera.org/XMLSchema/IPXACT/1685-2022"), "vendorExtensions")) ^^
      { case p1 ~ p2 ~ p3 ~ p4 =>
      IPXACT2022ScalaCases.Bank(p1,
        p2.headOption map { IPXACT2022scalaxb.fromXML[IPXACT2022ScalaCases.AccessHandles6](_, IPXACT2022scalaxb.ElemName(node) :: stack) },
        p3,
        p4.headOption map { IPXACT2022scalaxb.fromXML[IPXACT2022ScalaCases.VendorExtensions](_, IPXACT2022scalaxb.ElemName(node) :: stack) },
        scala.collection.immutable.ListMap(List(
        (node \ "@bankAlignment").headOption map { x => IPXACT2022scalaxb.DataRecord(x, node, IPXACT2022scalaxb.fromXML[IPXACT2022ScalaCases.BankAlignmentType](x, IPXACT2022scalaxb.ElemName(node) :: stack)) } map { "@bankAlignment" -> _ },
        (node \ "@{http://www.w3.org/XML/1998/namespace}id").headOption map { x => IPXACT2022scalaxb.DataRecord(x, node, IPXACT2022scalaxb.fromXML[String](x, IPXACT2022scalaxb.ElemName(node) :: stack)) } map { "@{http://www.w3.org/XML/1998/namespace}id" -> _ }
        ).flatten[(String, IPXACT2022scalaxb.DataRecord[Any])]: _*)) })
    
    override def writesAttribute(__obj: IPXACT2022ScalaCases.Bank, __scope: scala.xml.NamespaceBinding): scala.xml.MetaData = {
      var attr: scala.xml.MetaData  = scala.xml.Null
      __obj.attributes.toList map {
        case ("@bankAlignment", _) => attr = scala.xml.Attribute(null, "bankAlignment", __obj.bankAlignment.toString, attr)
        case ("@{http://www.w3.org/XML/1998/namespace}id", _) => __obj.xmlid foreach { x => attr = scala.xml.Attribute(__scope.getPrefix("http://www.w3.org/XML/1998/namespace"), "id", x.toString, attr) }
        case (key, x) => attr = scala.xml.Attribute((x.namespace map { __scope.getPrefix(_) }).orNull, x.key.orNull, x.value.toString, attr)
      }
      attr
    }

    def writesChildNodes(__obj: IPXACT2022ScalaCases.Bank, __scope: scala.xml.NamespaceBinding): Seq[scala.xml.Node] =
      Seq.concat(IPXACT2022scalaxb.toXML[IPXACT2022ScalaCases.NameGroupSequence](__obj.nameGroupSequence1, None, Some("nameGroupSequence1"), __scope, false),
        __obj.accessHandles map { IPXACT2022scalaxb.toXML[IPXACT2022ScalaCases.AccessHandles6](_, Some("http://www.accellera.org/XMLSchema/IPXACT/1685-2022"), Some("accessHandles"), __scope, false) } getOrElse {Nil},
        (Some(__obj.bankeddefinitionbanktypableoption) map {x => IPXACT2022scalaxb.toXML[IPXACT2022scalaxb.DataRecord[Any]](x, x.namespace, x.key, __scope, false)}).get,
        __obj.vendorExtensions map { IPXACT2022scalaxb.toXML[IPXACT2022ScalaCases.VendorExtensions](_, Some("http://www.accellera.org/XMLSchema/IPXACT/1685-2022"), Some("vendorExtensions"), __scope, false) } getOrElse {Nil})

  }

  trait DefaultIPXACT2022ScalaCases_MemoryRemapDefinitionTypeFormat extends IPXACT2022scalaxb.ElemNameParser[IPXACT2022ScalaCases.MemoryRemapDefinitionType] with IPXACT2022ScalaCases_NameGroupGroupFormat {
    val targetNamespace: Option[String] = Some("http://www.accellera.org/XMLSchema/IPXACT/1685-2022")
    
    override def typeName: Option[String] = Some("memoryRemapDefinitionType")

    def parser(node: scala.xml.Node, stack: List[IPXACT2022scalaxb.ElemName]): Parser[IPXACT2022ScalaCases.MemoryRemapDefinitionType] =
      phrase((parseNameGroupGroup(node, IPXACT2022scalaxb.ElemName(node) :: stack)) ~
      safeRep(IPXACT2022scalaxb.ElemName(Some("http://www.accellera.org/XMLSchema/IPXACT/1685-2022"), "modeRef")) ~
      safeRep(((IPXACT2022scalaxb.ElemName(Some("http://www.accellera.org/XMLSchema/IPXACT/1685-2022"), "remapDefinitionRef")) ^^
      (x => IPXACT2022scalaxb.DataRecord(x.namespace, Some(x.name), IPXACT2022scalaxb.fromXML[IPXACT2022ScalaCases.RemapDefinitionRef2](x, IPXACT2022scalaxb.ElemName(node) :: stack)))) |||
      (((IPXACT2022scalaxb.ElemName(Some("http://www.accellera.org/XMLSchema/IPXACT/1685-2022"), "addressBlock")) ^^
      (x => IPXACT2022scalaxb.DataRecord(x.namespace, Some(x.name), IPXACT2022scalaxb.fromXML[IPXACT2022ScalaCases.AddressBlockType](x, IPXACT2022scalaxb.ElemName(node) :: stack)))) |
      ((IPXACT2022scalaxb.ElemName(Some("http://www.accellera.org/XMLSchema/IPXACT/1685-2022"), "bank")) ^^
      (x => IPXACT2022scalaxb.DataRecord(x.namespace, Some(x.name), IPXACT2022scalaxb.fromXML[IPXACT2022ScalaCases.Bank](x, IPXACT2022scalaxb.ElemName(node) :: stack)))))) ~
      opt(IPXACT2022scalaxb.ElemName(Some("http://www.accellera.org/XMLSchema/IPXACT/1685-2022"), "vendorExtensions")) ^^
      { case p1 ~ p2 ~ p3 ~ p4 =>
      IPXACT2022ScalaCases.MemoryRemapDefinitionType(p1,
        p2 map { IPXACT2022scalaxb.fromXML[IPXACT2022ScalaCases.ModeRef3](_, IPXACT2022scalaxb.ElemName(node) :: stack) },
        p3,
        p4.headOption map { IPXACT2022scalaxb.fromXML[IPXACT2022ScalaCases.VendorExtensions](_, IPXACT2022scalaxb.ElemName(node) :: stack) },
        scala.collection.immutable.ListMap(List(
        (node \ "@{http://www.w3.org/XML/1998/namespace}id").headOption map { x => IPXACT2022scalaxb.DataRecord(x, node, IPXACT2022scalaxb.fromXML[String](x, IPXACT2022scalaxb.ElemName(node) :: stack)) } map { "@{http://www.w3.org/XML/1998/namespace}id" -> _ }
        ).flatten[(String, IPXACT2022scalaxb.DataRecord[Any])]: _*)) })
    
    override def writesAttribute(__obj: IPXACT2022ScalaCases.MemoryRemapDefinitionType, __scope: scala.xml.NamespaceBinding): scala.xml.MetaData = {
      var attr: scala.xml.MetaData  = scala.xml.Null
      __obj.attributes.toList map {
        case ("@{http://www.w3.org/XML/1998/namespace}id", _) => __obj.xmlid foreach { x => attr = scala.xml.Attribute(__scope.getPrefix("http://www.w3.org/XML/1998/namespace"), "id", x.toString, attr) }
        case (key, x) => attr = scala.xml.Attribute((x.namespace map { __scope.getPrefix(_) }).orNull, x.key.orNull, x.value.toString, attr)
      }
      attr
    }

    def writesChildNodes(__obj: IPXACT2022ScalaCases.MemoryRemapDefinitionType, __scope: scala.xml.NamespaceBinding): Seq[scala.xml.Node] =
      Seq.concat(IPXACT2022scalaxb.toXML[IPXACT2022ScalaCases.NameGroupSequence](__obj.nameGroupSequence1, None, Some("nameGroupSequence1"), __scope, false),
        __obj.modeRef flatMap { IPXACT2022scalaxb.toXML[IPXACT2022ScalaCases.ModeRef3](_, Some("http://www.accellera.org/XMLSchema/IPXACT/1685-2022"), Some("modeRef"), __scope, false) },
        __obj.memoryremapdefinitiontypeoption flatMap { x => IPXACT2022scalaxb.toXML[IPXACT2022scalaxb.DataRecord[IPXACT2022ScalaCases.MemoryRemapDefinitionTypeOption]](x, x.namespace, x.key, __scope, false) },
        __obj.vendorExtensions map { IPXACT2022scalaxb.toXML[IPXACT2022ScalaCases.VendorExtensions](_, Some("http://www.accellera.org/XMLSchema/IPXACT/1685-2022"), Some("vendorExtensions"), __scope, false) } getOrElse {Nil})

  }

  trait DefaultIPXACT2022ScalaCases_LocalMemoryMapTypeFormat extends IPXACT2022scalaxb.ElemNameParser[IPXACT2022ScalaCases.LocalMemoryMapType] with IPXACT2022ScalaCases_NameGroupGroupFormat {
    val targetNamespace: Option[String] = Some("http://www.accellera.org/XMLSchema/IPXACT/1685-2022")
    
    override def typeName: Option[String] = Some("localMemoryMapType")

    def parser(node: scala.xml.Node, stack: List[IPXACT2022scalaxb.ElemName]): Parser[IPXACT2022ScalaCases.LocalMemoryMapType] =
      phrase((parseNameGroupGroup(node, IPXACT2022scalaxb.ElemName(node) :: stack)) ~
      safeRep(((IPXACT2022scalaxb.ElemName(Some("http://www.accellera.org/XMLSchema/IPXACT/1685-2022"), "addressBlock")) ^^
      (x => IPXACT2022scalaxb.DataRecord(x.namespace, Some(x.name), IPXACT2022scalaxb.fromXML[IPXACT2022ScalaCases.AddressBlockType](x, IPXACT2022scalaxb.ElemName(node) :: stack)))) |
      ((IPXACT2022scalaxb.ElemName(Some("http://www.accellera.org/XMLSchema/IPXACT/1685-2022"), "bank")) ^^
      (x => IPXACT2022scalaxb.DataRecord(x.namespace, Some(x.name), IPXACT2022scalaxb.fromXML[IPXACT2022ScalaCases.LocalAddressBankType](x, IPXACT2022scalaxb.ElemName(node) :: stack))))) ~
      opt(IPXACT2022scalaxb.ElemName(Some("http://www.accellera.org/XMLSchema/IPXACT/1685-2022"), "vendorExtensions")) ^^
      { case p1 ~ p2 ~ p3 =>
      IPXACT2022ScalaCases.LocalMemoryMapType(p1,
        p2,
        p3.headOption map { IPXACT2022scalaxb.fromXML[IPXACT2022ScalaCases.VendorExtensions](_, IPXACT2022scalaxb.ElemName(node) :: stack) },
        scala.collection.immutable.ListMap(List(
        (node \ "@{http://www.w3.org/XML/1998/namespace}id").headOption map { x => IPXACT2022scalaxb.DataRecord(x, node, IPXACT2022scalaxb.fromXML[String](x, IPXACT2022scalaxb.ElemName(node) :: stack)) } map { "@{http://www.w3.org/XML/1998/namespace}id" -> _ }
        ).flatten[(String, IPXACT2022scalaxb.DataRecord[Any])]: _*)) })
    
    override def writesAttribute(__obj: IPXACT2022ScalaCases.LocalMemoryMapType, __scope: scala.xml.NamespaceBinding): scala.xml.MetaData = {
      var attr: scala.xml.MetaData  = scala.xml.Null
      __obj.attributes.toList map {
        case ("@{http://www.w3.org/XML/1998/namespace}id", _) => __obj.xmlid foreach { x => attr = scala.xml.Attribute(__scope.getPrefix("http://www.w3.org/XML/1998/namespace"), "id", x.toString, attr) }
        case (key, x) => attr = scala.xml.Attribute((x.namespace map { __scope.getPrefix(_) }).orNull, x.key.orNull, x.value.toString, attr)
      }
      attr
    }

    def writesChildNodes(__obj: IPXACT2022ScalaCases.LocalMemoryMapType, __scope: scala.xml.NamespaceBinding): Seq[scala.xml.Node] =
      Seq.concat(IPXACT2022scalaxb.toXML[IPXACT2022ScalaCases.NameGroupSequence](__obj.nameGroupSequence1, None, Some("nameGroupSequence1"), __scope, false),
        __obj.localmemorymaptypeoption flatMap { x => IPXACT2022scalaxb.toXML[IPXACT2022scalaxb.DataRecord[IPXACT2022ScalaCases.LocalMemoryMapTypeOption]](x, x.namespace, x.key, __scope, false) },
        __obj.vendorExtensions map { IPXACT2022scalaxb.toXML[IPXACT2022ScalaCases.VendorExtensions](_, Some("http://www.accellera.org/XMLSchema/IPXACT/1685-2022"), Some("vendorExtensions"), __scope, false) } getOrElse {Nil})

  }

  trait DefaultIPXACT2022ScalaCases_SubspaceRefTypeFormat extends IPXACT2022scalaxb.ElemNameParser[IPXACT2022ScalaCases.SubspaceRefType] with IPXACT2022ScalaCases_NameGroupGroupFormat {
    val targetNamespace: Option[String] = Some("http://www.accellera.org/XMLSchema/IPXACT/1685-2022")
    
    override def typeName: Option[String] = Some("subspaceRefType")

    def parser(node: scala.xml.Node, stack: List[IPXACT2022scalaxb.ElemName]): Parser[IPXACT2022ScalaCases.SubspaceRefType] =
      phrase((parseNameGroupGroup(node, IPXACT2022scalaxb.ElemName(node) :: stack)) ~
      (IPXACT2022scalaxb.ElemName(Some("http://www.accellera.org/XMLSchema/IPXACT/1685-2022"), "baseAddress")) ~
      opt(IPXACT2022scalaxb.ElemName(Some("http://www.accellera.org/XMLSchema/IPXACT/1685-2022"), "parameters")) ~
      opt(IPXACT2022scalaxb.ElemName(Some("http://www.accellera.org/XMLSchema/IPXACT/1685-2022"), "vendorExtensions")) ^^
      { case p1 ~ p2 ~ p3 ~ p4 =>
      IPXACT2022ScalaCases.SubspaceRefType(p1,
        IPXACT2022scalaxb.fromXML[IPXACT2022ScalaCases.SignedLongintExpression](p2, IPXACT2022scalaxb.ElemName(node) :: stack),
        p3.headOption map { IPXACT2022scalaxb.fromXML[IPXACT2022ScalaCases.Parameters](_, IPXACT2022scalaxb.ElemName(node) :: stack) },
        p4.headOption map { IPXACT2022scalaxb.fromXML[IPXACT2022ScalaCases.VendorExtensions](_, IPXACT2022scalaxb.ElemName(node) :: stack) },
        scala.collection.immutable.ListMap(List(
        (node \ "@initiatorRef").headOption map { x => IPXACT2022scalaxb.DataRecord(x, node, IPXACT2022scalaxb.fromXML[String](x, IPXACT2022scalaxb.ElemName(node) :: stack)) } map { "@initiatorRef" -> _ },
        (node \ "@segmentRef").headOption map { x => IPXACT2022scalaxb.DataRecord(x, node, IPXACT2022scalaxb.fromXML[String](x, IPXACT2022scalaxb.ElemName(node) :: stack)) } map { "@segmentRef" -> _ },
        (node \ "@{http://www.w3.org/XML/1998/namespace}id").headOption map { x => IPXACT2022scalaxb.DataRecord(x, node, IPXACT2022scalaxb.fromXML[String](x, IPXACT2022scalaxb.ElemName(node) :: stack)) } map { "@{http://www.w3.org/XML/1998/namespace}id" -> _ }
        ).flatten[(String, IPXACT2022scalaxb.DataRecord[Any])]: _*)) })
    
    override def writesAttribute(__obj: IPXACT2022ScalaCases.SubspaceRefType, __scope: scala.xml.NamespaceBinding): scala.xml.MetaData = {
      var attr: scala.xml.MetaData  = scala.xml.Null
      __obj.attributes.toList map {
        case ("@initiatorRef", _) => attr = scala.xml.Attribute(null, "initiatorRef", __obj.initiatorRef.toString, attr)
        case ("@segmentRef", _) => __obj.segmentRef foreach { x => attr = scala.xml.Attribute(null, "segmentRef", x.toString, attr) }
        case ("@{http://www.w3.org/XML/1998/namespace}id", _) => __obj.xmlid foreach { x => attr = scala.xml.Attribute(__scope.getPrefix("http://www.w3.org/XML/1998/namespace"), "id", x.toString, attr) }
        case (key, x) => attr = scala.xml.Attribute((x.namespace map { __scope.getPrefix(_) }).orNull, x.key.orNull, x.value.toString, attr)
      }
      attr
    }

    def writesChildNodes(__obj: IPXACT2022ScalaCases.SubspaceRefType, __scope: scala.xml.NamespaceBinding): Seq[scala.xml.Node] =
      Seq.concat(IPXACT2022scalaxb.toXML[IPXACT2022ScalaCases.NameGroupSequence](__obj.nameGroupSequence1, None, Some("nameGroupSequence1"), __scope, false),
        IPXACT2022scalaxb.toXML[IPXACT2022ScalaCases.SignedLongintExpression](__obj.baseAddress, Some("http://www.accellera.org/XMLSchema/IPXACT/1685-2022"), Some("baseAddress"), __scope, false),
        __obj.parameters map { IPXACT2022scalaxb.toXML[IPXACT2022ScalaCases.Parameters](_, Some("http://www.accellera.org/XMLSchema/IPXACT/1685-2022"), Some("parameters"), __scope, false) } getOrElse {Nil},
        __obj.vendorExtensions map { IPXACT2022scalaxb.toXML[IPXACT2022ScalaCases.VendorExtensions](_, Some("http://www.accellera.org/XMLSchema/IPXACT/1685-2022"), Some("vendorExtensions"), __scope, false) } getOrElse {Nil})

  }

  trait DefaultIPXACT2022ScalaCases_FieldAccessPolicyDefinitionRefFormat extends IPXACT2022scalaxb.XMLFormat[IPXACT2022ScalaCases.FieldAccessPolicyDefinitionRef] with IPXACT2022scalaxb.CanWriteChildNodes[IPXACT2022ScalaCases.FieldAccessPolicyDefinitionRef] {
    val targetNamespace: Option[String] = Some("http://www.accellera.org/XMLSchema/IPXACT/1685-2022")
    def reads(seq: scala.xml.NodeSeq, stack: List[IPXACT2022scalaxb.ElemName]): Either[String, IPXACT2022ScalaCases.FieldAccessPolicyDefinitionRef] = seq match {
      case node: scala.xml.Node => Right(IPXACT2022ScalaCases.FieldAccessPolicyDefinitionRef(IPXACT2022scalaxb.fromXML[String](node, IPXACT2022scalaxb.ElemName(node) :: stack),
        scala.collection.immutable.ListMap(List(
        (node \ "@typeDefinitions").headOption map { x => IPXACT2022scalaxb.DataRecord(x, node, IPXACT2022scalaxb.fromXML[String](x, IPXACT2022scalaxb.ElemName(node) :: stack)) } map { "@typeDefinitions" -> _ }
        ).flatten[(String, IPXACT2022scalaxb.DataRecord[Any])]: _*)))
      case _ => Left("reads failed: seq must be scala.xml.Node")
    }
    
    override def writesAttribute(__obj: IPXACT2022ScalaCases.FieldAccessPolicyDefinitionRef, __scope: scala.xml.NamespaceBinding): scala.xml.MetaData = {
      var attr: scala.xml.MetaData  = scala.xml.Null
      __obj.attributes.toList map {
        case ("@typeDefinitions", _) => attr = scala.xml.Attribute(null, "typeDefinitions", __obj.typeDefinitions.toString, attr)
        case (key, x) => attr = scala.xml.Attribute((x.namespace map { __scope.getPrefix(_) }).orNull, x.key.orNull, x.value.toString, attr)
      }
      attr
    }

    def writesChildNodes(__obj: IPXACT2022ScalaCases.FieldAccessPolicyDefinitionRef, __scope: scala.xml.NamespaceBinding): Seq[scala.xml.Node] =
      Seq(scala.xml.Text(__obj.value.toString))

  }

  trait DefaultIPXACT2022ScalaCases_SegmentFormat extends IPXACT2022scalaxb.ElemNameParser[IPXACT2022ScalaCases.Segment] with IPXACT2022ScalaCases_NameGroupGroupFormat {
    val targetNamespace: Option[String] = Some("http://www.accellera.org/XMLSchema/IPXACT/1685-2022")
    
    def parser(node: scala.xml.Node, stack: List[IPXACT2022scalaxb.ElemName]): Parser[IPXACT2022ScalaCases.Segment] =
      phrase((parseNameGroupGroup(node, IPXACT2022scalaxb.ElemName(node) :: stack)) ~
      (IPXACT2022scalaxb.ElemName(Some("http://www.accellera.org/XMLSchema/IPXACT/1685-2022"), "addressOffset")) ~
      (IPXACT2022scalaxb.ElemName(Some("http://www.accellera.org/XMLSchema/IPXACT/1685-2022"), "range")) ~
      opt(IPXACT2022scalaxb.ElemName(Some("http://www.accellera.org/XMLSchema/IPXACT/1685-2022"), "vendorExtensions")) ^^
      { case p1 ~ p2 ~ p3 ~ p4 =>
      IPXACT2022ScalaCases.Segment(p1,
        IPXACT2022scalaxb.fromXML[IPXACT2022ScalaCases.UnsignedLongintExpressionable](p2, IPXACT2022scalaxb.ElemName(node) :: stack),
        IPXACT2022scalaxb.fromXML[IPXACT2022ScalaCases.UnsignedPositiveLongintExpressionable](p3, IPXACT2022scalaxb.ElemName(node) :: stack),
        p4.headOption map { IPXACT2022scalaxb.fromXML[IPXACT2022ScalaCases.VendorExtensions](_, IPXACT2022scalaxb.ElemName(node) :: stack) },
        scala.collection.immutable.ListMap(List(
        (node \ "@{http://www.w3.org/XML/1998/namespace}id").headOption map { x => IPXACT2022scalaxb.DataRecord(x, node, IPXACT2022scalaxb.fromXML[String](x, IPXACT2022scalaxb.ElemName(node) :: stack)) } map { "@{http://www.w3.org/XML/1998/namespace}id" -> _ }
        ).flatten[(String, IPXACT2022scalaxb.DataRecord[Any])]: _*)) })
    
    override def writesAttribute(__obj: IPXACT2022ScalaCases.Segment, __scope: scala.xml.NamespaceBinding): scala.xml.MetaData = {
      var attr: scala.xml.MetaData  = scala.xml.Null
      __obj.attributes.toList map {
        case ("@{http://www.w3.org/XML/1998/namespace}id", _) => __obj.xmlid foreach { x => attr = scala.xml.Attribute(__scope.getPrefix("http://www.w3.org/XML/1998/namespace"), "id", x.toString, attr) }
        case (key, x) => attr = scala.xml.Attribute((x.namespace map { __scope.getPrefix(_) }).orNull, x.key.orNull, x.value.toString, attr)
      }
      attr
    }

    def writesChildNodes(__obj: IPXACT2022ScalaCases.Segment, __scope: scala.xml.NamespaceBinding): Seq[scala.xml.Node] =
      Seq.concat(IPXACT2022scalaxb.toXML[IPXACT2022ScalaCases.NameGroupSequence](__obj.nameGroupSequence1, None, Some("nameGroupSequence1"), __scope, false),
        IPXACT2022scalaxb.toXML[IPXACT2022ScalaCases.UnsignedLongintExpressionable](__obj.addressOffset, Some("http://www.accellera.org/XMLSchema/IPXACT/1685-2022"), Some("addressOffset"), __scope, false),
        IPXACT2022scalaxb.toXML[IPXACT2022ScalaCases.UnsignedPositiveLongintExpressionable](__obj.range, Some("http://www.accellera.org/XMLSchema/IPXACT/1685-2022"), Some("range"), __scope, false),
        __obj.vendorExtensions map { IPXACT2022scalaxb.toXML[IPXACT2022ScalaCases.VendorExtensions](_, Some("http://www.accellera.org/XMLSchema/IPXACT/1685-2022"), Some("vendorExtensions"), __scope, false) } getOrElse {Nil})

  }

  trait DefaultIPXACT2022ScalaCases_SegmentsFormat extends IPXACT2022scalaxb.ElemNameParser[IPXACT2022ScalaCases.Segments] {
    val targetNamespace: Option[String] = Some("http://www.accellera.org/XMLSchema/IPXACT/1685-2022")
    
    def parser(node: scala.xml.Node, stack: List[IPXACT2022scalaxb.ElemName]): Parser[IPXACT2022ScalaCases.Segments] =
      phrase(safeRep(IPXACT2022scalaxb.ElemName(Some("http://www.accellera.org/XMLSchema/IPXACT/1685-2022"), "segment")) ^^
      { case p1 =>
      IPXACT2022ScalaCases.Segments(p1 map { IPXACT2022scalaxb.fromXML[IPXACT2022ScalaCases.Segment](_, IPXACT2022scalaxb.ElemName(node) :: stack) }) })
    
    def writesChildNodes(__obj: IPXACT2022ScalaCases.Segments, __scope: scala.xml.NamespaceBinding): Seq[scala.xml.Node] =
      (__obj.segment flatMap { IPXACT2022scalaxb.toXML[IPXACT2022ScalaCases.Segment](_, Some("http://www.accellera.org/XMLSchema/IPXACT/1685-2022"), Some("segment"), __scope, false) })
  }
  trait DefaultIPXACT2022ScalaCases_AddressSpaceFormat extends IPXACT2022scalaxb.ElemNameParser[IPXACT2022ScalaCases.AddressSpace] with IPXACT2022ScalaCases_NameGroupGroupFormat with IPXACT2022ScalaCases_BlockSizeGroupFormat {
    val targetNamespace: Option[String] = Some("http://www.accellera.org/XMLSchema/IPXACT/1685-2022")
    
    def parser(node: scala.xml.Node, stack: List[IPXACT2022scalaxb.ElemName]): Parser[IPXACT2022ScalaCases.AddressSpace] =
      phrase((parseNameGroupGroup(node, IPXACT2022scalaxb.ElemName(node) :: stack)) ~
      (parseBlockSizeGroup(node, IPXACT2022scalaxb.ElemName(node) :: stack)) ~
      opt(IPXACT2022scalaxb.ElemName(Some("http://www.accellera.org/XMLSchema/IPXACT/1685-2022"), "segments")) ~
      opt(IPXACT2022scalaxb.ElemName(Some("http://www.accellera.org/XMLSchema/IPXACT/1685-2022"), "addressUnitBits")) ~
      opt(IPXACT2022scalaxb.ElemName(Some("http://www.accellera.org/XMLSchema/IPXACT/1685-2022"), "localMemoryMap")) ~
      opt(IPXACT2022scalaxb.ElemName(Some("http://www.accellera.org/XMLSchema/IPXACT/1685-2022"), "parameters")) ~
      opt(IPXACT2022scalaxb.ElemName(Some("http://www.accellera.org/XMLSchema/IPXACT/1685-2022"), "vendorExtensions")) ^^
      { case p1 ~ p2 ~ p3 ~ p4 ~ p5 ~ p6 ~ p7 =>
      IPXACT2022ScalaCases.AddressSpace(p1,
        p2,
        p3.headOption map { IPXACT2022scalaxb.fromXML[IPXACT2022ScalaCases.Segments](_, IPXACT2022scalaxb.ElemName(node) :: stack) },
        p4.headOption map { IPXACT2022scalaxb.fromXML[IPXACT2022ScalaCases.UnsignedPositiveLongintExpressionable](_, IPXACT2022scalaxb.ElemName(node) :: stack) },
        p5.headOption map { IPXACT2022scalaxb.fromXML[IPXACT2022ScalaCases.LocalMemoryMapType](_, IPXACT2022scalaxb.ElemName(node) :: stack) },
        p6.headOption map { IPXACT2022scalaxb.fromXML[IPXACT2022ScalaCases.Parameters](_, IPXACT2022scalaxb.ElemName(node) :: stack) },
        p7.headOption map { IPXACT2022scalaxb.fromXML[IPXACT2022ScalaCases.VendorExtensions](_, IPXACT2022scalaxb.ElemName(node) :: stack) },
        scala.collection.immutable.ListMap(List(
        (node \ "@{http://www.w3.org/XML/1998/namespace}id").headOption map { x => IPXACT2022scalaxb.DataRecord(x, node, IPXACT2022scalaxb.fromXML[String](x, IPXACT2022scalaxb.ElemName(node) :: stack)) } map { "@{http://www.w3.org/XML/1998/namespace}id" -> _ }
        ).flatten[(String, IPXACT2022scalaxb.DataRecord[Any])]: _*)) })
    
    override def writesAttribute(__obj: IPXACT2022ScalaCases.AddressSpace, __scope: scala.xml.NamespaceBinding): scala.xml.MetaData = {
      var attr: scala.xml.MetaData  = scala.xml.Null
      __obj.attributes.toList map {
        case ("@{http://www.w3.org/XML/1998/namespace}id", _) => __obj.xmlid foreach { x => attr = scala.xml.Attribute(__scope.getPrefix("http://www.w3.org/XML/1998/namespace"), "id", x.toString, attr) }
        case (key, x) => attr = scala.xml.Attribute((x.namespace map { __scope.getPrefix(_) }).orNull, x.key.orNull, x.value.toString, attr)
      }
      attr
    }

    def writesChildNodes(__obj: IPXACT2022ScalaCases.AddressSpace, __scope: scala.xml.NamespaceBinding): Seq[scala.xml.Node] =
      Seq.concat(IPXACT2022scalaxb.toXML[IPXACT2022ScalaCases.NameGroupSequence](__obj.nameGroupSequence1, None, Some("nameGroupSequence1"), __scope, false),
        IPXACT2022scalaxb.toXML[IPXACT2022ScalaCases.BlockSizeSequence](__obj.blockSizeSequence2, None, Some("blockSizeSequence2"), __scope, false),
        __obj.segments map { IPXACT2022scalaxb.toXML[IPXACT2022ScalaCases.Segments](_, Some("http://www.accellera.org/XMLSchema/IPXACT/1685-2022"), Some("segments"), __scope, false) } getOrElse {Nil},
        __obj.addressUnitBits map { IPXACT2022scalaxb.toXML[IPXACT2022ScalaCases.UnsignedPositiveLongintExpressionable](_, Some("http://www.accellera.org/XMLSchema/IPXACT/1685-2022"), Some("addressUnitBits"), __scope, false) } getOrElse {Nil},
        __obj.localMemoryMap map { IPXACT2022scalaxb.toXML[IPXACT2022ScalaCases.LocalMemoryMapType](_, Some("http://www.accellera.org/XMLSchema/IPXACT/1685-2022"), Some("localMemoryMap"), __scope, false) } getOrElse {Nil},
        __obj.parameters map { IPXACT2022scalaxb.toXML[IPXACT2022ScalaCases.Parameters](_, Some("http://www.accellera.org/XMLSchema/IPXACT/1685-2022"), Some("parameters"), __scope, false) } getOrElse {Nil},
        __obj.vendorExtensions map { IPXACT2022scalaxb.toXML[IPXACT2022ScalaCases.VendorExtensions](_, Some("http://www.accellera.org/XMLSchema/IPXACT/1685-2022"), Some("vendorExtensions"), __scope, false) } getOrElse {Nil})

  }

  trait DefaultIPXACT2022ScalaCases_AddressSpacesFormat extends IPXACT2022scalaxb.ElemNameParser[IPXACT2022ScalaCases.AddressSpaces] {
    val targetNamespace: Option[String] = Some("http://www.accellera.org/XMLSchema/IPXACT/1685-2022")
    
    def parser(node: scala.xml.Node, stack: List[IPXACT2022scalaxb.ElemName]): Parser[IPXACT2022ScalaCases.AddressSpaces] =
      phrase(safeRep(IPXACT2022scalaxb.ElemName(Some("http://www.accellera.org/XMLSchema/IPXACT/1685-2022"), "addressSpace")) ^^
      { case p1 =>
      IPXACT2022ScalaCases.AddressSpaces(p1 map { IPXACT2022scalaxb.fromXML[IPXACT2022ScalaCases.AddressSpace](_, IPXACT2022scalaxb.ElemName(node) :: stack) }) })
    
    def writesChildNodes(__obj: IPXACT2022ScalaCases.AddressSpaces, __scope: scala.xml.NamespaceBinding): Seq[scala.xml.Node] =
      (__obj.addressSpace flatMap { IPXACT2022scalaxb.toXML[IPXACT2022ScalaCases.AddressSpace](_, Some("http://www.accellera.org/XMLSchema/IPXACT/1685-2022"), Some("addressSpace"), __scope, false) })
  }
  trait DefaultIPXACT2022ScalaCases_MemoryMapsFormat extends IPXACT2022scalaxb.ElemNameParser[IPXACT2022ScalaCases.MemoryMaps] {
    val targetNamespace: Option[String] = Some("http://www.accellera.org/XMLSchema/IPXACT/1685-2022")
    
    def parser(node: scala.xml.Node, stack: List[IPXACT2022scalaxb.ElemName]): Parser[IPXACT2022ScalaCases.MemoryMaps] =
      phrase(safeRep(IPXACT2022scalaxb.ElemName(Some("http://www.accellera.org/XMLSchema/IPXACT/1685-2022"), "memoryMap")) ^^
      { case p1 =>
      IPXACT2022ScalaCases.MemoryMaps(p1 map { IPXACT2022scalaxb.fromXML[IPXACT2022ScalaCases.MemoryMapType](_, IPXACT2022scalaxb.ElemName(node) :: stack) }) })
    
    def writesChildNodes(__obj: IPXACT2022ScalaCases.MemoryMaps, __scope: scala.xml.NamespaceBinding): Seq[scala.xml.Node] =
      (__obj.memoryMap flatMap { IPXACT2022scalaxb.toXML[IPXACT2022ScalaCases.MemoryMapType](_, Some("http://www.accellera.org/XMLSchema/IPXACT/1685-2022"), Some("memoryMap"), __scope, false) })
  }
  trait DefaultIPXACT2022ScalaCases_Bank2Format extends IPXACT2022scalaxb.ElemNameParser[IPXACT2022ScalaCases.Bank2] with IPXACT2022ScalaCases_NameGroupGroupFormat with IPXACT2022ScalaCases_BankBaseGroupFormat {
    val targetNamespace: Option[String] = Some("http://www.accellera.org/XMLSchema/IPXACT/1685-2022")
    
    def parser(node: scala.xml.Node, stack: List[IPXACT2022scalaxb.ElemName]): Parser[IPXACT2022ScalaCases.Bank2] =
      phrase((parseNameGroupGroup(node, IPXACT2022scalaxb.ElemName(node) :: stack)) ~
      opt(IPXACT2022scalaxb.ElemName(Some("http://www.accellera.org/XMLSchema/IPXACT/1685-2022"), "accessHandles")) ~
      (((IPXACT2022scalaxb.ElemName(Some("http://www.accellera.org/XMLSchema/IPXACT/1685-2022"), "bankDefinitionRef")) ^^
      (x => IPXACT2022scalaxb.DataRecord(x.namespace, Some(x.name), IPXACT2022scalaxb.fromXML[IPXACT2022ScalaCases.BankDefinitionRef3](x, IPXACT2022scalaxb.ElemName(node) :: stack)))) |||
      (parseBankBaseGroup(node, IPXACT2022scalaxb.ElemName(node) :: stack, true))) ~
      opt(IPXACT2022scalaxb.ElemName(Some("http://www.accellera.org/XMLSchema/IPXACT/1685-2022"), "vendorExtensions")) ^^
      { case p1 ~ p2 ~ p3 ~ p4 =>
      IPXACT2022ScalaCases.Bank2(p1,
        p2.headOption map { IPXACT2022scalaxb.fromXML[IPXACT2022ScalaCases.AccessHandles5](_, IPXACT2022scalaxb.ElemName(node) :: stack) },
        p3,
        p4.headOption map { IPXACT2022scalaxb.fromXML[IPXACT2022ScalaCases.VendorExtensions](_, IPXACT2022scalaxb.ElemName(node) :: stack) },
        scala.collection.immutable.ListMap(List(
        (node \ "@bankAlignment").headOption map { x => IPXACT2022scalaxb.DataRecord(x, node, IPXACT2022scalaxb.fromXML[IPXACT2022ScalaCases.BankAlignmentType](x, IPXACT2022scalaxb.ElemName(node) :: stack)) } map { "@bankAlignment" -> _ },
        (node \ "@{http://www.w3.org/XML/1998/namespace}id").headOption map { x => IPXACT2022scalaxb.DataRecord(x, node, IPXACT2022scalaxb.fromXML[String](x, IPXACT2022scalaxb.ElemName(node) :: stack)) } map { "@{http://www.w3.org/XML/1998/namespace}id" -> _ }
        ).flatten[(String, IPXACT2022scalaxb.DataRecord[Any])]: _*)) })
    
    override def writesAttribute(__obj: IPXACT2022ScalaCases.Bank2, __scope: scala.xml.NamespaceBinding): scala.xml.MetaData = {
      var attr: scala.xml.MetaData  = scala.xml.Null
      __obj.attributes.toList map {
        case ("@bankAlignment", _) => attr = scala.xml.Attribute(null, "bankAlignment", __obj.bankAlignment.toString, attr)
        case ("@{http://www.w3.org/XML/1998/namespace}id", _) => __obj.xmlid foreach { x => attr = scala.xml.Attribute(__scope.getPrefix("http://www.w3.org/XML/1998/namespace"), "id", x.toString, attr) }
        case (key, x) => attr = scala.xml.Attribute((x.namespace map { __scope.getPrefix(_) }).orNull, x.key.orNull, x.value.toString, attr)
      }
      attr
    }

    def writesChildNodes(__obj: IPXACT2022ScalaCases.Bank2, __scope: scala.xml.NamespaceBinding): Seq[scala.xml.Node] =
      Seq.concat(IPXACT2022scalaxb.toXML[IPXACT2022ScalaCases.NameGroupSequence](__obj.nameGroupSequence1, None, Some("nameGroupSequence1"), __scope, false),
        __obj.accessHandles map { IPXACT2022scalaxb.toXML[IPXACT2022ScalaCases.AccessHandles5](_, Some("http://www.accellera.org/XMLSchema/IPXACT/1685-2022"), Some("accessHandles"), __scope, false) } getOrElse {Nil},
        (Some(__obj.bankedbanktypableoption) map {x => IPXACT2022scalaxb.toXML[IPXACT2022scalaxb.DataRecord[Any]](x, x.namespace, x.key, __scope, false)}).get,
        __obj.vendorExtensions map { IPXACT2022scalaxb.toXML[IPXACT2022ScalaCases.VendorExtensions](_, Some("http://www.accellera.org/XMLSchema/IPXACT/1685-2022"), Some("vendorExtensions"), __scope, false) } getOrElse {Nil})

  }

  trait DefaultIPXACT2022ScalaCases_Bank3Format extends IPXACT2022scalaxb.ElemNameParser[IPXACT2022ScalaCases.Bank3] with IPXACT2022ScalaCases_NameGroupGroupFormat with IPXACT2022ScalaCases_BankDefinitionBaseGroupFormat {
    val targetNamespace: Option[String] = Some("http://www.accellera.org/XMLSchema/IPXACT/1685-2022")
    
    def parser(node: scala.xml.Node, stack: List[IPXACT2022scalaxb.ElemName]): Parser[IPXACT2022ScalaCases.Bank3] =
      phrase((parseNameGroupGroup(node, IPXACT2022scalaxb.ElemName(node) :: stack)) ~
      opt(IPXACT2022scalaxb.ElemName(Some("http://www.accellera.org/XMLSchema/IPXACT/1685-2022"), "accessHandles")) ~
      (((IPXACT2022scalaxb.ElemName(Some("http://www.accellera.org/XMLSchema/IPXACT/1685-2022"), "bankDefinitionRef")) ^^
      (x => IPXACT2022scalaxb.DataRecord(x.namespace, Some(x.name), IPXACT2022scalaxb.fromXML[IPXACT2022ScalaCases.BankDefinitionRef4](x, IPXACT2022scalaxb.ElemName(node) :: stack)))) |||
      (parseBankDefinitionBaseGroup(node, IPXACT2022scalaxb.ElemName(node) :: stack, true))) ~
      opt(IPXACT2022scalaxb.ElemName(Some("http://www.accellera.org/XMLSchema/IPXACT/1685-2022"), "vendorExtensions")) ^^
      { case p1 ~ p2 ~ p3 ~ p4 =>
      IPXACT2022ScalaCases.Bank3(p1,
        p2.headOption map { IPXACT2022scalaxb.fromXML[IPXACT2022ScalaCases.AccessHandles6](_, IPXACT2022scalaxb.ElemName(node) :: stack) },
        p3,
        p4.headOption map { IPXACT2022scalaxb.fromXML[IPXACT2022ScalaCases.VendorExtensions](_, IPXACT2022scalaxb.ElemName(node) :: stack) },
        scala.collection.immutable.ListMap(List(
        (node \ "@bankAlignment").headOption map { x => IPXACT2022scalaxb.DataRecord(x, node, IPXACT2022scalaxb.fromXML[IPXACT2022ScalaCases.BankAlignmentType](x, IPXACT2022scalaxb.ElemName(node) :: stack)) } map { "@bankAlignment" -> _ },
        (node \ "@{http://www.w3.org/XML/1998/namespace}id").headOption map { x => IPXACT2022scalaxb.DataRecord(x, node, IPXACT2022scalaxb.fromXML[String](x, IPXACT2022scalaxb.ElemName(node) :: stack)) } map { "@{http://www.w3.org/XML/1998/namespace}id" -> _ }
        ).flatten[(String, IPXACT2022scalaxb.DataRecord[Any])]: _*)) })
    
    override def writesAttribute(__obj: IPXACT2022ScalaCases.Bank3, __scope: scala.xml.NamespaceBinding): scala.xml.MetaData = {
      var attr: scala.xml.MetaData  = scala.xml.Null
      __obj.attributes.toList map {
        case ("@bankAlignment", _) => attr = scala.xml.Attribute(null, "bankAlignment", __obj.bankAlignment.toString, attr)
        case ("@{http://www.w3.org/XML/1998/namespace}id", _) => __obj.xmlid foreach { x => attr = scala.xml.Attribute(__scope.getPrefix("http://www.w3.org/XML/1998/namespace"), "id", x.toString, attr) }
        case (key, x) => attr = scala.xml.Attribute((x.namespace map { __scope.getPrefix(_) }).orNull, x.key.orNull, x.value.toString, attr)
      }
      attr
    }

    def writesChildNodes(__obj: IPXACT2022ScalaCases.Bank3, __scope: scala.xml.NamespaceBinding): Seq[scala.xml.Node] =
      Seq.concat(IPXACT2022scalaxb.toXML[IPXACT2022ScalaCases.NameGroupSequence](__obj.nameGroupSequence1, None, Some("nameGroupSequence1"), __scope, false),
        __obj.accessHandles map { IPXACT2022scalaxb.toXML[IPXACT2022ScalaCases.AccessHandles6](_, Some("http://www.accellera.org/XMLSchema/IPXACT/1685-2022"), Some("accessHandles"), __scope, false) } getOrElse {Nil},
        (Some(__obj.bankeddefinitionbanktypableoption) map {x => IPXACT2022scalaxb.toXML[IPXACT2022scalaxb.DataRecord[Any]](x, x.namespace, x.key, __scope, false)}).get,
        __obj.vendorExtensions map { IPXACT2022scalaxb.toXML[IPXACT2022ScalaCases.VendorExtensions](_, Some("http://www.accellera.org/XMLSchema/IPXACT/1685-2022"), Some("vendorExtensions"), __scope, false) } getOrElse {Nil})

  }

  trait DefaultIPXACT2022ScalaCases_DimFormat extends IPXACT2022scalaxb.XMLFormat[IPXACT2022ScalaCases.Dim] with IPXACT2022scalaxb.CanWriteChildNodes[IPXACT2022ScalaCases.Dim] {
    val targetNamespace: Option[String] = Some("http://www.accellera.org/XMLSchema/IPXACT/1685-2022")
    def reads(seq: scala.xml.NodeSeq, stack: List[IPXACT2022scalaxb.ElemName]): Either[String, IPXACT2022ScalaCases.Dim] = seq match {
      case node: scala.xml.Node => Right(IPXACT2022ScalaCases.Dim(IPXACT2022scalaxb.fromXML[String](node, IPXACT2022scalaxb.ElemName(node) :: stack),
        scala.collection.immutable.ListMap(List(
        (node \ "@minimum").headOption map { x => IPXACT2022scalaxb.DataRecord(x, node, IPXACT2022scalaxb.fromXML[Int](x, IPXACT2022scalaxb.ElemName(node) :: stack)) } map { "@minimum" -> _ },
        (node \ "@maximum").headOption map { x => IPXACT2022scalaxb.DataRecord(x, node, IPXACT2022scalaxb.fromXML[Int](x, IPXACT2022scalaxb.ElemName(node) :: stack)) } map { "@maximum" -> _ },
        (node \ "@{http://www.w3.org/XML/1998/namespace}id").headOption map { x => IPXACT2022scalaxb.DataRecord(x, node, IPXACT2022scalaxb.fromXML[String](x, IPXACT2022scalaxb.ElemName(node) :: stack)) } map { "@{http://www.w3.org/XML/1998/namespace}id" -> _ },
        (node \ "@indexVar").headOption map { x => IPXACT2022scalaxb.DataRecord(x, node, IPXACT2022scalaxb.fromXML[String](x, IPXACT2022scalaxb.ElemName(node) :: stack)) } map { "@indexVar" -> _ }
        ).flatten[(String, IPXACT2022scalaxb.DataRecord[Any])] ::: (node match {
          case elem: scala.xml.Elem =>
            elem.attributes.toList flatMap {
              case scala.xml.UnprefixedAttribute(key, value, _) if key == "minimum" => Nil
              case scala.xml.UnprefixedAttribute(key, value, _) if key == "maximum" => Nil
              case scala.xml.PrefixedAttribute(pre, key, value, _) if pre == elem.scope.getPrefix("http://www.w3.org/XML/1998/namespace") &&
                key == "id" => Nil
              case scala.xml.UnprefixedAttribute(key, value, _) if key == "indexVar" => Nil
              case scala.xml.UnprefixedAttribute(key, value, _) =>
                List(("@" + key, IPXACT2022scalaxb.DataRecord(None, Some(key), value.text)))
              case scala.xml.PrefixedAttribute(pre, key, value, _) =>
                val ns = elem.scope.getURI(pre)
                List(("@{" + ns + "}" + key, IPXACT2022scalaxb.DataRecord(Option[String](ns), Some(key), value.text)))
              case _ => Nil
            }
          case _ => Nil
        }): _*)))
      case _ => Left("reads failed: seq must be scala.xml.Node")
    }
    
    override def writesAttribute(__obj: IPXACT2022ScalaCases.Dim, __scope: scala.xml.NamespaceBinding): scala.xml.MetaData = {
      var attr: scala.xml.MetaData  = scala.xml.Null
      __obj.attributes.toList map {
        case ("@minimum", _) => __obj.minimum foreach { x => attr = scala.xml.Attribute(null, "minimum", x.toString, attr) }
        case ("@maximum", _) => __obj.maximum foreach { x => attr = scala.xml.Attribute(null, "maximum", x.toString, attr) }
        case ("@{http://www.w3.org/XML/1998/namespace}id", _) => __obj.xmlid foreach { x => attr = scala.xml.Attribute(__scope.getPrefix("http://www.w3.org/XML/1998/namespace"), "id", x.toString, attr) }
        case ("@indexVar", _) => __obj.indexVar foreach { x => attr = scala.xml.Attribute(null, "indexVar", x.toString, attr) }
        case (key, x) => attr = scala.xml.Attribute((x.namespace map { __scope.getPrefix(_) }).orNull, x.key.orNull, x.value.toString, attr)
      }
      attr
    }

    def writesChildNodes(__obj: IPXACT2022ScalaCases.Dim, __scope: scala.xml.NamespaceBinding): Seq[scala.xml.Node] =
      Seq(scala.xml.Text(__obj.value.toString))

  }

  trait DefaultIPXACT2022ScalaCases_StrideFormat extends IPXACT2022scalaxb.XMLFormat[IPXACT2022ScalaCases.Stride] with IPXACT2022scalaxb.CanWriteChildNodes[IPXACT2022ScalaCases.Stride] {
    val targetNamespace: Option[String] = Some("http://www.accellera.org/XMLSchema/IPXACT/1685-2022")
    def reads(seq: scala.xml.NodeSeq, stack: List[IPXACT2022scalaxb.ElemName]): Either[String, IPXACT2022ScalaCases.Stride] = seq match {
      case node: scala.xml.Node => Right(IPXACT2022ScalaCases.Stride(IPXACT2022scalaxb.fromXML[String](node, IPXACT2022scalaxb.ElemName(node) :: stack),
        scala.collection.immutable.ListMap(List(
        (node \ "@minimum").headOption map { x => IPXACT2022scalaxb.DataRecord(x, node, IPXACT2022scalaxb.fromXML[Int](x, IPXACT2022scalaxb.ElemName(node) :: stack)) } map { "@minimum" -> _ },
        (node \ "@maximum").headOption map { x => IPXACT2022scalaxb.DataRecord(x, node, IPXACT2022scalaxb.fromXML[Int](x, IPXACT2022scalaxb.ElemName(node) :: stack)) } map { "@maximum" -> _ },
        (node \ "@{http://www.w3.org/XML/1998/namespace}id").headOption map { x => IPXACT2022scalaxb.DataRecord(x, node, IPXACT2022scalaxb.fromXML[String](x, IPXACT2022scalaxb.ElemName(node) :: stack)) } map { "@{http://www.w3.org/XML/1998/namespace}id" -> _ }
        ).flatten[(String, IPXACT2022scalaxb.DataRecord[Any])] ::: (node match {
          case elem: scala.xml.Elem =>
            elem.attributes.toList flatMap {
              case scala.xml.UnprefixedAttribute(key, value, _) if key == "minimum" => Nil
              case scala.xml.UnprefixedAttribute(key, value, _) if key == "maximum" => Nil
              case scala.xml.PrefixedAttribute(pre, key, value, _) if pre == elem.scope.getPrefix("http://www.w3.org/XML/1998/namespace") &&
                key == "id" => Nil
              case scala.xml.UnprefixedAttribute(key, value, _) =>
                List(("@" + key, IPXACT2022scalaxb.DataRecord(None, Some(key), value.text)))
              case scala.xml.PrefixedAttribute(pre, key, value, _) =>
                val ns = elem.scope.getURI(pre)
                List(("@{" + ns + "}" + key, IPXACT2022scalaxb.DataRecord(Option[String](ns), Some(key), value.text)))
              case _ => Nil
            }
          case _ => Nil
        }): _*)))
      case _ => Left("reads failed: seq must be scala.xml.Node")
    }
    
    override def writesAttribute(__obj: IPXACT2022ScalaCases.Stride, __scope: scala.xml.NamespaceBinding): scala.xml.MetaData = {
      var attr: scala.xml.MetaData  = scala.xml.Null
      __obj.attributes.toList map {
        case ("@minimum", _) => __obj.minimum foreach { x => attr = scala.xml.Attribute(null, "minimum", x.toString, attr) }
        case ("@maximum", _) => __obj.maximum foreach { x => attr = scala.xml.Attribute(null, "maximum", x.toString, attr) }
        case ("@{http://www.w3.org/XML/1998/namespace}id", _) => __obj.xmlid foreach { x => attr = scala.xml.Attribute(__scope.getPrefix("http://www.w3.org/XML/1998/namespace"), "id", x.toString, attr) }
        case (key, x) => attr = scala.xml.Attribute((x.namespace map { __scope.getPrefix(_) }).orNull, x.key.orNull, x.value.toString, attr)
      }
      attr
    }

    def writesChildNodes(__obj: IPXACT2022ScalaCases.Stride, __scope: scala.xml.NamespaceBinding): Seq[scala.xml.Node] =
      Seq(scala.xml.Text(__obj.value.toString))

  }

  trait DefaultIPXACT2022ScalaCases_BitStrideFormat extends IPXACT2022scalaxb.XMLFormat[IPXACT2022ScalaCases.BitStride] with IPXACT2022scalaxb.CanWriteChildNodes[IPXACT2022ScalaCases.BitStride] {
    val targetNamespace: Option[String] = Some("http://www.accellera.org/XMLSchema/IPXACT/1685-2022")
    def reads(seq: scala.xml.NodeSeq, stack: List[IPXACT2022scalaxb.ElemName]): Either[String, IPXACT2022ScalaCases.BitStride] = seq match {
      case node: scala.xml.Node => Right(IPXACT2022ScalaCases.BitStride(IPXACT2022scalaxb.fromXML[String](node, IPXACT2022scalaxb.ElemName(node) :: stack),
        scala.collection.immutable.ListMap(List(
        (node \ "@minimum").headOption map { x => IPXACT2022scalaxb.DataRecord(x, node, IPXACT2022scalaxb.fromXML[Int](x, IPXACT2022scalaxb.ElemName(node) :: stack)) } map { "@minimum" -> _ },
        (node \ "@maximum").headOption map { x => IPXACT2022scalaxb.DataRecord(x, node, IPXACT2022scalaxb.fromXML[Int](x, IPXACT2022scalaxb.ElemName(node) :: stack)) } map { "@maximum" -> _ },
        (node \ "@{http://www.w3.org/XML/1998/namespace}id").headOption map { x => IPXACT2022scalaxb.DataRecord(x, node, IPXACT2022scalaxb.fromXML[String](x, IPXACT2022scalaxb.ElemName(node) :: stack)) } map { "@{http://www.w3.org/XML/1998/namespace}id" -> _ }
        ).flatten[(String, IPXACT2022scalaxb.DataRecord[Any])] ::: (node match {
          case elem: scala.xml.Elem =>
            elem.attributes.toList flatMap {
              case scala.xml.UnprefixedAttribute(key, value, _) if key == "minimum" => Nil
              case scala.xml.UnprefixedAttribute(key, value, _) if key == "maximum" => Nil
              case scala.xml.PrefixedAttribute(pre, key, value, _) if pre == elem.scope.getPrefix("http://www.w3.org/XML/1998/namespace") &&
                key == "id" => Nil
              case scala.xml.UnprefixedAttribute(key, value, _) =>
                List(("@" + key, IPXACT2022scalaxb.DataRecord(None, Some(key), value.text)))
              case scala.xml.PrefixedAttribute(pre, key, value, _) =>
                val ns = elem.scope.getURI(pre)
                List(("@{" + ns + "}" + key, IPXACT2022scalaxb.DataRecord(Option[String](ns), Some(key), value.text)))
              case _ => Nil
            }
          case _ => Nil
        }): _*)))
      case _ => Left("reads failed: seq must be scala.xml.Node")
    }
    
    override def writesAttribute(__obj: IPXACT2022ScalaCases.BitStride, __scope: scala.xml.NamespaceBinding): scala.xml.MetaData = {
      var attr: scala.xml.MetaData  = scala.xml.Null
      __obj.attributes.toList map {
        case ("@minimum", _) => __obj.minimum foreach { x => attr = scala.xml.Attribute(null, "minimum", x.toString, attr) }
        case ("@maximum", _) => __obj.maximum foreach { x => attr = scala.xml.Attribute(null, "maximum", x.toString, attr) }
        case ("@{http://www.w3.org/XML/1998/namespace}id", _) => __obj.xmlid foreach { x => attr = scala.xml.Attribute(__scope.getPrefix("http://www.w3.org/XML/1998/namespace"), "id", x.toString, attr) }
        case (key, x) => attr = scala.xml.Attribute((x.namespace map { __scope.getPrefix(_) }).orNull, x.key.orNull, x.value.toString, attr)
      }
      attr
    }

    def writesChildNodes(__obj: IPXACT2022ScalaCases.BitStride, __scope: scala.xml.NamespaceBinding): Seq[scala.xml.Node] =
      Seq(scala.xml.Text(__obj.value.toString))

  }

  trait DefaultIPXACT2022ScalaCases_AccessHandles10Format extends IPXACT2022scalaxb.ElemNameParser[IPXACT2022ScalaCases.AccessHandles10] {
    val targetNamespace: Option[String] = Some("http://www.accellera.org/XMLSchema/IPXACT/1685-2022")
    
    def parser(node: scala.xml.Node, stack: List[IPXACT2022scalaxb.ElemName]): Parser[IPXACT2022ScalaCases.AccessHandles10] =
      phrase(safeRep(((IPXACT2022scalaxb.ElemName(Some("http://www.accellera.org/XMLSchema/IPXACT/1685-2022"), "accessHandle"))) ^^
        { case p1 => IPXACT2022ScalaCases.AccessHandles10Sequence1(IPXACT2022scalaxb.fromXML[IPXACT2022ScalaCases.SimpleAccessHandle](p1, IPXACT2022scalaxb.ElemName(node) :: stack)) }) ^^
      { case p1 =>
      IPXACT2022ScalaCases.AccessHandles10(p1) })
    
    def writesChildNodes(__obj: IPXACT2022ScalaCases.AccessHandles10, __scope: scala.xml.NamespaceBinding): Seq[scala.xml.Node] =
      (__obj.accesshandles10sequence1 flatMap { IPXACT2022scalaxb.toXML[IPXACT2022ScalaCases.AccessHandles10Sequence1](_, None, Some("accesshandles10sequence1"), __scope, false) })
  }

  trait DefaultIPXACT2022ScalaCases_AccessHandles10Sequence1Format extends IPXACT2022scalaxb.XMLFormat[IPXACT2022ScalaCases.AccessHandles10Sequence1] {
    def reads(seq: scala.xml.NodeSeq, stack: List[IPXACT2022scalaxb.ElemName]): Either[String, IPXACT2022ScalaCases.AccessHandles10Sequence1] = Left("don't call me.")
    
    def writes(__obj: IPXACT2022ScalaCases.AccessHandles10Sequence1, __namespace: Option[String], __elementLabel: Option[String],
        __scope: scala.xml.NamespaceBinding, __typeAttribute: Boolean): scala.xml.NodeSeq =
      IPXACT2022scalaxb.toXML[IPXACT2022ScalaCases.SimpleAccessHandle](__obj.accessHandle, Some("http://www.accellera.org/XMLSchema/IPXACT/1685-2022"), Some("accessHandle"), __scope, false)

  }
  trait DefaultIPXACT2022ScalaCases_RegisterDefinitionRefFormat extends IPXACT2022scalaxb.XMLFormat[IPXACT2022ScalaCases.RegisterDefinitionRef] with IPXACT2022scalaxb.CanWriteChildNodes[IPXACT2022ScalaCases.RegisterDefinitionRef] {
    val targetNamespace: Option[String] = Some("http://www.accellera.org/XMLSchema/IPXACT/1685-2022")
    def reads(seq: scala.xml.NodeSeq, stack: List[IPXACT2022scalaxb.ElemName]): Either[String, IPXACT2022ScalaCases.RegisterDefinitionRef] = seq match {
      case node: scala.xml.Node => Right(IPXACT2022ScalaCases.RegisterDefinitionRef(IPXACT2022scalaxb.fromXML[String](node, IPXACT2022scalaxb.ElemName(node) :: stack),
        scala.collection.immutable.ListMap(List(
        (node \ "@typeDefinitions").headOption map { x => IPXACT2022scalaxb.DataRecord(x, node, IPXACT2022scalaxb.fromXML[String](x, IPXACT2022scalaxb.ElemName(node) :: stack)) } map { "@typeDefinitions" -> _ }
        ).flatten[(String, IPXACT2022scalaxb.DataRecord[Any])]: _*)))
      case _ => Left("reads failed: seq must be scala.xml.Node")
    }
    
    override def writesAttribute(__obj: IPXACT2022ScalaCases.RegisterDefinitionRef, __scope: scala.xml.NamespaceBinding): scala.xml.MetaData = {
      var attr: scala.xml.MetaData  = scala.xml.Null
      __obj.attributes.toList map {
        case ("@typeDefinitions", _) => attr = scala.xml.Attribute(null, "typeDefinitions", __obj.typeDefinitions.toString, attr)
        case (key, x) => attr = scala.xml.Attribute((x.namespace map { __scope.getPrefix(_) }).orNull, x.key.orNull, x.value.toString, attr)
      }
      attr
    }

    def writesChildNodes(__obj: IPXACT2022ScalaCases.RegisterDefinitionRef, __scope: scala.xml.NamespaceBinding): Seq[scala.xml.Node] =
      Seq(scala.xml.Text(__obj.value.toString))

  }

  trait DefaultIPXACT2022ScalaCases_RegisterFormat extends IPXACT2022scalaxb.ElemNameParser[IPXACT2022ScalaCases.Register] with IPXACT2022ScalaCases_NameGroupGroupFormat with IPXACT2022ScalaCases_RegisterDefinitionGroupGroupFormat {
    val targetNamespace: Option[String] = Some("http://www.accellera.org/XMLSchema/IPXACT/1685-2022")
    
    def parser(node: scala.xml.Node, stack: List[IPXACT2022scalaxb.ElemName]): Parser[IPXACT2022ScalaCases.Register] =
      phrase((parseNameGroupGroup(node, IPXACT2022scalaxb.ElemName(node) :: stack)) ~
      opt(IPXACT2022scalaxb.ElemName(Some("http://www.accellera.org/XMLSchema/IPXACT/1685-2022"), "accessHandles")) ~
      opt(IPXACT2022scalaxb.ElemName(Some("http://www.accellera.org/XMLSchema/IPXACT/1685-2022"), "array")) ~
      (IPXACT2022scalaxb.ElemName(Some("http://www.accellera.org/XMLSchema/IPXACT/1685-2022"), "addressOffset")) ~
      (((IPXACT2022scalaxb.ElemName(Some("http://www.accellera.org/XMLSchema/IPXACT/1685-2022"), "registerDefinitionRef")) ^^
      (x => IPXACT2022scalaxb.DataRecord(x.namespace, Some(x.name), IPXACT2022scalaxb.fromXML[IPXACT2022ScalaCases.RegisterDefinitionRef](x, IPXACT2022scalaxb.ElemName(node) :: stack)))) |||
      (parseRegisterDefinitionGroupGroup(node, IPXACT2022scalaxb.ElemName(node) :: stack, true))) ~
      opt(IPXACT2022scalaxb.ElemName(Some("http://www.accellera.org/XMLSchema/IPXACT/1685-2022"), "alternateRegisters")) ~
      opt(IPXACT2022scalaxb.ElemName(Some("http://www.accellera.org/XMLSchema/IPXACT/1685-2022"), "parameters")) ~
      opt(IPXACT2022scalaxb.ElemName(Some("http://www.accellera.org/XMLSchema/IPXACT/1685-2022"), "vendorExtensions")) ^^
      { case p1 ~ p2 ~ p3 ~ p4 ~ p5 ~ p6 ~ p7 ~ p8 =>
      IPXACT2022ScalaCases.Register(p1,
        p2.headOption map { IPXACT2022scalaxb.fromXML[IPXACT2022ScalaCases.AccessHandles10](_, IPXACT2022scalaxb.ElemName(node) :: stack) },
        p3.headOption map { IPXACT2022scalaxb.fromXML[IPXACT2022ScalaCases.ArrayType4](_, IPXACT2022scalaxb.ElemName(node) :: stack) },
        IPXACT2022scalaxb.fromXML[IPXACT2022ScalaCases.UnsignedLongintExpressionable](p4, IPXACT2022scalaxb.ElemName(node) :: stack),
        p5,
        p6.headOption map { IPXACT2022scalaxb.fromXML[IPXACT2022ScalaCases.AlternateRegisters](_, IPXACT2022scalaxb.ElemName(node) :: stack) },
        p7.headOption map { IPXACT2022scalaxb.fromXML[IPXACT2022ScalaCases.Parameters](_, IPXACT2022scalaxb.ElemName(node) :: stack) },
        p8.headOption map { IPXACT2022scalaxb.fromXML[IPXACT2022ScalaCases.VendorExtensions](_, IPXACT2022scalaxb.ElemName(node) :: stack) },
        scala.collection.immutable.ListMap(List(
        (node \ "@{http://www.w3.org/XML/1998/namespace}id").headOption map { x => IPXACT2022scalaxb.DataRecord(x, node, IPXACT2022scalaxb.fromXML[String](x, IPXACT2022scalaxb.ElemName(node) :: stack)) } map { "@{http://www.w3.org/XML/1998/namespace}id" -> _ }
        ).flatten[(String, IPXACT2022scalaxb.DataRecord[Any])]: _*)) })
    
    override def writesAttribute(__obj: IPXACT2022ScalaCases.Register, __scope: scala.xml.NamespaceBinding): scala.xml.MetaData = {
      var attr: scala.xml.MetaData  = scala.xml.Null
      __obj.attributes.toList map {
        case ("@{http://www.w3.org/XML/1998/namespace}id", _) => __obj.xmlid foreach { x => attr = scala.xml.Attribute(__scope.getPrefix("http://www.w3.org/XML/1998/namespace"), "id", x.toString, attr) }
        case (key, x) => attr = scala.xml.Attribute((x.namespace map { __scope.getPrefix(_) }).orNull, x.key.orNull, x.value.toString, attr)
      }
      attr
    }

    def writesChildNodes(__obj: IPXACT2022ScalaCases.Register, __scope: scala.xml.NamespaceBinding): Seq[scala.xml.Node] =
      Seq.concat(IPXACT2022scalaxb.toXML[IPXACT2022ScalaCases.NameGroupSequence](__obj.nameGroupSequence1, None, Some("nameGroupSequence1"), __scope, false),
        __obj.accessHandles map { IPXACT2022scalaxb.toXML[IPXACT2022ScalaCases.AccessHandles10](_, Some("http://www.accellera.org/XMLSchema/IPXACT/1685-2022"), Some("accessHandles"), __scope, false) } getOrElse {Nil},
        __obj.array map { IPXACT2022scalaxb.toXML[IPXACT2022ScalaCases.ArrayType4](_, Some("http://www.accellera.org/XMLSchema/IPXACT/1685-2022"), Some("array"), __scope, false) } getOrElse {Nil},
        IPXACT2022scalaxb.toXML[IPXACT2022ScalaCases.UnsignedLongintExpressionable](__obj.addressOffset, Some("http://www.accellera.org/XMLSchema/IPXACT/1685-2022"), Some("addressOffset"), __scope, false),
        (Some(__obj.registeroption) map {x => IPXACT2022scalaxb.toXML[IPXACT2022scalaxb.DataRecord[Any]](x, x.namespace, x.key, __scope, false)}).get,
        __obj.alternateRegisters map { IPXACT2022scalaxb.toXML[IPXACT2022ScalaCases.AlternateRegisters](_, Some("http://www.accellera.org/XMLSchema/IPXACT/1685-2022"), Some("alternateRegisters"), __scope, false) } getOrElse {Nil},
        __obj.parameters map { IPXACT2022scalaxb.toXML[IPXACT2022ScalaCases.Parameters](_, Some("http://www.accellera.org/XMLSchema/IPXACT/1685-2022"), Some("parameters"), __scope, false) } getOrElse {Nil},
        __obj.vendorExtensions map { IPXACT2022scalaxb.toXML[IPXACT2022ScalaCases.VendorExtensions](_, Some("http://www.accellera.org/XMLSchema/IPXACT/1685-2022"), Some("vendorExtensions"), __scope, false) } getOrElse {Nil})

  }

  trait DefaultIPXACT2022ScalaCases_AccessHandles11Format extends IPXACT2022scalaxb.ElemNameParser[IPXACT2022ScalaCases.AccessHandles11] {
    val targetNamespace: Option[String] = Some("http://www.accellera.org/XMLSchema/IPXACT/1685-2022")
    
    def parser(node: scala.xml.Node, stack: List[IPXACT2022scalaxb.ElemName]): Parser[IPXACT2022ScalaCases.AccessHandles11] =
      phrase(safeRep(((IPXACT2022scalaxb.ElemName(Some("http://www.accellera.org/XMLSchema/IPXACT/1685-2022"), "accessHandle"))) ^^
        { case p1 => IPXACT2022ScalaCases.AccessHandles11Sequence1(IPXACT2022scalaxb.fromXML[IPXACT2022ScalaCases.SimpleAccessHandle](p1, IPXACT2022scalaxb.ElemName(node) :: stack)) }) ^^
      { case p1 =>
      IPXACT2022ScalaCases.AccessHandles11(p1) })
    
    def writesChildNodes(__obj: IPXACT2022ScalaCases.AccessHandles11, __scope: scala.xml.NamespaceBinding): Seq[scala.xml.Node] =
      (__obj.accesshandles11sequence1 flatMap { IPXACT2022scalaxb.toXML[IPXACT2022ScalaCases.AccessHandles11Sequence1](_, None, Some("accesshandles11sequence1"), __scope, false) })
  }

  trait DefaultIPXACT2022ScalaCases_AccessHandles11Sequence1Format extends IPXACT2022scalaxb.XMLFormat[IPXACT2022ScalaCases.AccessHandles11Sequence1] {
    def reads(seq: scala.xml.NodeSeq, stack: List[IPXACT2022scalaxb.ElemName]): Either[String, IPXACT2022ScalaCases.AccessHandles11Sequence1] = Left("don't call me.")
    
    def writes(__obj: IPXACT2022ScalaCases.AccessHandles11Sequence1, __namespace: Option[String], __elementLabel: Option[String],
        __scope: scala.xml.NamespaceBinding, __typeAttribute: Boolean): scala.xml.NodeSeq =
      IPXACT2022scalaxb.toXML[IPXACT2022ScalaCases.SimpleAccessHandle](__obj.accessHandle, Some("http://www.accellera.org/XMLSchema/IPXACT/1685-2022"), Some("accessHandle"), __scope, false)

  }
  trait DefaultIPXACT2022ScalaCases_AlternateRegisterFormat extends IPXACT2022scalaxb.ElemNameParser[IPXACT2022ScalaCases.AlternateRegister] with IPXACT2022ScalaCases_NameGroupGroupFormat with IPXACT2022ScalaCases_AlternateRegisterDefinitionGroupGroupFormat {
    val targetNamespace: Option[String] = Some("http://www.accellera.org/XMLSchema/IPXACT/1685-2022")
    
    def parser(node: scala.xml.Node, stack: List[IPXACT2022scalaxb.ElemName]): Parser[IPXACT2022ScalaCases.AlternateRegister] =
      phrase((parseNameGroupGroup(node, IPXACT2022scalaxb.ElemName(node) :: stack)) ~
      opt(IPXACT2022scalaxb.ElemName(Some("http://www.accellera.org/XMLSchema/IPXACT/1685-2022"), "accessHandles")) ~
      safeRep(IPXACT2022scalaxb.ElemName(Some("http://www.accellera.org/XMLSchema/IPXACT/1685-2022"), "modeRef")) ~
      (parseAlternateRegisterDefinitionGroupGroup(node, IPXACT2022scalaxb.ElemName(node) :: stack)) ~
      opt(IPXACT2022scalaxb.ElemName(Some("http://www.accellera.org/XMLSchema/IPXACT/1685-2022"), "parameters")) ~
      opt(IPXACT2022scalaxb.ElemName(Some("http://www.accellera.org/XMLSchema/IPXACT/1685-2022"), "vendorExtensions")) ^^
      { case p1 ~ p2 ~ p3 ~ p4 ~ p5 ~ p6 =>
      IPXACT2022ScalaCases.AlternateRegister(p1,
        p2.headOption map { IPXACT2022scalaxb.fromXML[IPXACT2022ScalaCases.AccessHandles11](_, IPXACT2022scalaxb.ElemName(node) :: stack) },
        p3 map { IPXACT2022scalaxb.fromXML[IPXACT2022ScalaCases.ModeRef3](_, IPXACT2022scalaxb.ElemName(node) :: stack) },
        p4,
        p5.headOption map { IPXACT2022scalaxb.fromXML[IPXACT2022ScalaCases.Parameters](_, IPXACT2022scalaxb.ElemName(node) :: stack) },
        p6.headOption map { IPXACT2022scalaxb.fromXML[IPXACT2022ScalaCases.VendorExtensions](_, IPXACT2022scalaxb.ElemName(node) :: stack) },
        scala.collection.immutable.ListMap(List(
        (node \ "@{http://www.w3.org/XML/1998/namespace}id").headOption map { x => IPXACT2022scalaxb.DataRecord(x, node, IPXACT2022scalaxb.fromXML[String](x, IPXACT2022scalaxb.ElemName(node) :: stack)) } map { "@{http://www.w3.org/XML/1998/namespace}id" -> _ }
        ).flatten[(String, IPXACT2022scalaxb.DataRecord[Any])]: _*)) })
    
    override def writesAttribute(__obj: IPXACT2022ScalaCases.AlternateRegister, __scope: scala.xml.NamespaceBinding): scala.xml.MetaData = {
      var attr: scala.xml.MetaData  = scala.xml.Null
      __obj.attributes.toList map {
        case ("@{http://www.w3.org/XML/1998/namespace}id", _) => __obj.xmlid foreach { x => attr = scala.xml.Attribute(__scope.getPrefix("http://www.w3.org/XML/1998/namespace"), "id", x.toString, attr) }
        case (key, x) => attr = scala.xml.Attribute((x.namespace map { __scope.getPrefix(_) }).orNull, x.key.orNull, x.value.toString, attr)
      }
      attr
    }

    def writesChildNodes(__obj: IPXACT2022ScalaCases.AlternateRegister, __scope: scala.xml.NamespaceBinding): Seq[scala.xml.Node] =
      Seq.concat(IPXACT2022scalaxb.toXML[IPXACT2022ScalaCases.NameGroupSequence](__obj.nameGroupSequence1, None, Some("nameGroupSequence1"), __scope, false),
        __obj.accessHandles map { IPXACT2022scalaxb.toXML[IPXACT2022ScalaCases.AccessHandles11](_, Some("http://www.accellera.org/XMLSchema/IPXACT/1685-2022"), Some("accessHandles"), __scope, false) } getOrElse {Nil},
        __obj.modeRef flatMap { IPXACT2022scalaxb.toXML[IPXACT2022ScalaCases.ModeRef3](_, Some("http://www.accellera.org/XMLSchema/IPXACT/1685-2022"), Some("modeRef"), __scope, false) },
        IPXACT2022scalaxb.toXML[IPXACT2022ScalaCases.AlternateRegisterDefinitionGroupSequence](__obj.alternateRegisterDefinitionGroupSequence4, None, Some("alternateRegisterDefinitionGroupSequence4"), __scope, false),
        __obj.parameters map { IPXACT2022scalaxb.toXML[IPXACT2022ScalaCases.Parameters](_, Some("http://www.accellera.org/XMLSchema/IPXACT/1685-2022"), Some("parameters"), __scope, false) } getOrElse {Nil},
        __obj.vendorExtensions map { IPXACT2022scalaxb.toXML[IPXACT2022ScalaCases.VendorExtensions](_, Some("http://www.accellera.org/XMLSchema/IPXACT/1685-2022"), Some("vendorExtensions"), __scope, false) } getOrElse {Nil})

  }

  trait DefaultIPXACT2022ScalaCases_AlternateRegistersFormat extends IPXACT2022scalaxb.ElemNameParser[IPXACT2022ScalaCases.AlternateRegisters] {
    val targetNamespace: Option[String] = Some("http://www.accellera.org/XMLSchema/IPXACT/1685-2022")
    
    def parser(node: scala.xml.Node, stack: List[IPXACT2022scalaxb.ElemName]): Parser[IPXACT2022ScalaCases.AlternateRegisters] =
      phrase(safeRep(IPXACT2022scalaxb.ElemName(Some("http://www.accellera.org/XMLSchema/IPXACT/1685-2022"), "alternateRegister")) ^^
      { case p1 =>
      IPXACT2022ScalaCases.AlternateRegisters(p1 map { IPXACT2022scalaxb.fromXML[IPXACT2022ScalaCases.AlternateRegister](_, IPXACT2022scalaxb.ElemName(node) :: stack) }) })
    
    def writesChildNodes(__obj: IPXACT2022ScalaCases.AlternateRegisters, __scope: scala.xml.NamespaceBinding): Seq[scala.xml.Node] =
      (__obj.alternateRegister flatMap { IPXACT2022scalaxb.toXML[IPXACT2022ScalaCases.AlternateRegister](_, Some("http://www.accellera.org/XMLSchema/IPXACT/1685-2022"), Some("alternateRegister"), __scope, false) })
  }
  trait DefaultIPXACT2022ScalaCases_EnumerationDefinitionRefFormat extends IPXACT2022scalaxb.XMLFormat[IPXACT2022ScalaCases.EnumerationDefinitionRef] with IPXACT2022scalaxb.CanWriteChildNodes[IPXACT2022ScalaCases.EnumerationDefinitionRef] {
    val targetNamespace: Option[String] = Some("http://www.accellera.org/XMLSchema/IPXACT/1685-2022")
    def reads(seq: scala.xml.NodeSeq, stack: List[IPXACT2022scalaxb.ElemName]): Either[String, IPXACT2022ScalaCases.EnumerationDefinitionRef] = seq match {
      case node: scala.xml.Node => Right(IPXACT2022ScalaCases.EnumerationDefinitionRef(IPXACT2022scalaxb.fromXML[String](node, IPXACT2022scalaxb.ElemName(node) :: stack),
        scala.collection.immutable.ListMap(List(
        (node \ "@typeDefinitions").headOption map { x => IPXACT2022scalaxb.DataRecord(x, node, IPXACT2022scalaxb.fromXML[String](x, IPXACT2022scalaxb.ElemName(node) :: stack)) } map { "@typeDefinitions" -> _ }
        ).flatten[(String, IPXACT2022scalaxb.DataRecord[Any])]: _*)))
      case _ => Left("reads failed: seq must be scala.xml.Node")
    }
    
    override def writesAttribute(__obj: IPXACT2022ScalaCases.EnumerationDefinitionRef, __scope: scala.xml.NamespaceBinding): scala.xml.MetaData = {
      var attr: scala.xml.MetaData  = scala.xml.Null
      __obj.attributes.toList map {
        case ("@typeDefinitions", _) => attr = scala.xml.Attribute(null, "typeDefinitions", __obj.typeDefinitions.toString, attr)
        case (key, x) => attr = scala.xml.Attribute((x.namespace map { __scope.getPrefix(_) }).orNull, x.key.orNull, x.value.toString, attr)
      }
      attr
    }

    def writesChildNodes(__obj: IPXACT2022ScalaCases.EnumerationDefinitionRef, __scope: scala.xml.NamespaceBinding): Seq[scala.xml.Node] =
      Seq(scala.xml.Text(__obj.value.toString))

  }

  trait DefaultIPXACT2022ScalaCases_EnumeratedValuesFormat extends IPXACT2022scalaxb.ElemNameParser[IPXACT2022ScalaCases.EnumeratedValues] {
    val targetNamespace: Option[String] = Some("http://www.accellera.org/XMLSchema/IPXACT/1685-2022")
    
    def parser(node: scala.xml.Node, stack: List[IPXACT2022scalaxb.ElemName]): Parser[IPXACT2022ScalaCases.EnumeratedValues] =
      phrase(safeRep(((IPXACT2022scalaxb.ElemName(Some("http://www.accellera.org/XMLSchema/IPXACT/1685-2022"), "enumerationDefinitionRef")) ^^
      (x => IPXACT2022scalaxb.DataRecord(x.namespace, Some(x.name), IPXACT2022scalaxb.fromXML[IPXACT2022ScalaCases.EnumerationDefinitionRef](x, IPXACT2022scalaxb.ElemName(node) :: stack)))) |
      ((IPXACT2022scalaxb.ElemName(Some("http://www.accellera.org/XMLSchema/IPXACT/1685-2022"), "enumeratedValue")) ^^
      (x => IPXACT2022scalaxb.DataRecord(x.namespace, Some(x.name), IPXACT2022scalaxb.fromXML[IPXACT2022ScalaCases.EnumeratedValueType](x, IPXACT2022scalaxb.ElemName(node) :: stack))))) ^^
      { case p1 =>
      IPXACT2022ScalaCases.EnumeratedValues(p1) })
    
    def writesChildNodes(__obj: IPXACT2022ScalaCases.EnumeratedValues, __scope: scala.xml.NamespaceBinding): Seq[scala.xml.Node] =
      (__obj.enumeratedvaluesoption flatMap { x => IPXACT2022scalaxb.toXML[IPXACT2022scalaxb.DataRecord[IPXACT2022ScalaCases.EnumeratedValuesOption]](x, x.namespace, x.key, __scope, false) })
  }

  def buildIPXACT2022ScalaCases_UsageFormat = new DefaultIPXACT2022ScalaCases_UsageFormat {}
  trait DefaultIPXACT2022ScalaCases_UsageFormat extends IPXACT2022scalaxb.XMLFormat[IPXACT2022ScalaCases.Usage] {
    val targetNamespace: Option[String] = Some("http://www.accellera.org/XMLSchema/IPXACT/1685-2022")
    
    def fromString(value: String, scope: scala.xml.NamespaceBinding): IPXACT2022ScalaCases.Usage =
        (fromString0(value, scope)).apply(IPXACT2022scalaxb.fromXML[String](scala.xml.Text(value)))

    private def fromString0(value: String, scope: scala.xml.NamespaceBinding): PartialFunction[Any, IPXACT2022ScalaCases.Usage] = {
      case x: String if x == IPXACT2022scalaxb.fromXML[String](scala.xml.Text("read")) => IPXACT2022ScalaCases.Read
      case x: String if x == IPXACT2022scalaxb.fromXML[String](scala.xml.Text("write")) => IPXACT2022ScalaCases.Write
      case x: String if x == IPXACT2022scalaxb.fromXML[String](scala.xml.Text("read-write")) => IPXACT2022ScalaCases.Readu45writeValue

    }



    def reads(seq: scala.xml.NodeSeq, stack: List[IPXACT2022scalaxb.ElemName]): Either[String, IPXACT2022ScalaCases.Usage] = seq match {
      case elem: scala.xml.Elem => Right(fromString(elem.text, elem.scope))
      case _ => Right(fromString(seq.text, scala.xml.TopScope))
    }
    
    def writes(__obj: IPXACT2022ScalaCases.Usage, __namespace: Option[String], __elementLabel: Option[String],
        __scope: scala.xml.NamespaceBinding, __typeAttribute: Boolean): scala.xml.NodeSeq =
      scala.xml.Elem(IPXACT2022scalaxb.Helper.getPrefix(__namespace, __scope).orNull,
        __elementLabel getOrElse { sys.error("missing element label.") },
        scala.xml.Null, __scope, true, scala.xml.Text(__obj.toString))
  }
  trait DefaultIPXACT2022ScalaCases_EnumeratedValueTypeFormat extends IPXACT2022scalaxb.ElemNameParser[IPXACT2022ScalaCases.EnumeratedValueType] with IPXACT2022ScalaCases_NameGroupGroupFormat {
    val targetNamespace: Option[String] = Some("http://www.accellera.org/XMLSchema/IPXACT/1685-2022")
    
    override def typeName: Option[String] = Some("enumeratedValueType")

    def parser(node: scala.xml.Node, stack: List[IPXACT2022scalaxb.ElemName]): Parser[IPXACT2022ScalaCases.EnumeratedValueType] =
      phrase((parseNameGroupGroup(node, IPXACT2022scalaxb.ElemName(node) :: stack)) ~
      (IPXACT2022scalaxb.ElemName(Some("http://www.accellera.org/XMLSchema/IPXACT/1685-2022"), "value")) ~
      opt(IPXACT2022scalaxb.ElemName(Some("http://www.accellera.org/XMLSchema/IPXACT/1685-2022"), "vendorExtensions")) ^^
      { case p1 ~ p2 ~ p3 =>
      IPXACT2022ScalaCases.EnumeratedValueType(p1,
        IPXACT2022scalaxb.fromXML[IPXACT2022ScalaCases.UnsignedBitVectorExpressionable](p2, IPXACT2022scalaxb.ElemName(node) :: stack),
        p3.headOption map { IPXACT2022scalaxb.fromXML[IPXACT2022ScalaCases.VendorExtensions](_, IPXACT2022scalaxb.ElemName(node) :: stack) },
        scala.collection.immutable.ListMap(List(
        (node \ "@usage").headOption map { x => IPXACT2022scalaxb.DataRecord(x, node, IPXACT2022scalaxb.fromXML[IPXACT2022ScalaCases.Usage](x, IPXACT2022scalaxb.ElemName(node) :: stack)) } orElse Some(IPXACT2022scalaxb.DataRecord(None, None, IPXACT2022scalaxb.fromXML[IPXACT2022ScalaCases.Usage](scala.xml.Text("read-write"), IPXACT2022scalaxb.ElemName(node) :: stack))) map { "@usage" -> _ },
        (node \ "@{http://www.w3.org/XML/1998/namespace}id").headOption map { x => IPXACT2022scalaxb.DataRecord(x, node, IPXACT2022scalaxb.fromXML[String](x, IPXACT2022scalaxb.ElemName(node) :: stack)) } map { "@{http://www.w3.org/XML/1998/namespace}id" -> _ }
        ).flatten[(String, IPXACT2022scalaxb.DataRecord[Any])]: _*)) })
    
    override def writesAttribute(__obj: IPXACT2022ScalaCases.EnumeratedValueType, __scope: scala.xml.NamespaceBinding): scala.xml.MetaData = {
      var attr: scala.xml.MetaData  = scala.xml.Null
      __obj.attributes.toList map {
        case ("@usage", _) => if (__obj.usage.toString != "read-write") attr = scala.xml.Attribute(null, "usage", __obj.usage.toString, attr)
        case ("@{http://www.w3.org/XML/1998/namespace}id", _) => __obj.xmlid foreach { x => attr = scala.xml.Attribute(__scope.getPrefix("http://www.w3.org/XML/1998/namespace"), "id", x.toString, attr) }
        case (key, x) => attr = scala.xml.Attribute((x.namespace map { __scope.getPrefix(_) }).orNull, x.key.orNull, x.value.toString, attr)
      }
      attr
    }

    def writesChildNodes(__obj: IPXACT2022ScalaCases.EnumeratedValueType, __scope: scala.xml.NamespaceBinding): Seq[scala.xml.Node] =
      Seq.concat(IPXACT2022scalaxb.toXML[IPXACT2022ScalaCases.NameGroupSequence](__obj.nameGroupSequence1, None, Some("nameGroupSequence1"), __scope, false),
        IPXACT2022scalaxb.toXML[IPXACT2022ScalaCases.UnsignedBitVectorExpressionable](__obj.value, Some("http://www.accellera.org/XMLSchema/IPXACT/1685-2022"), Some("value"), __scope, false),
        __obj.vendorExtensions map { IPXACT2022scalaxb.toXML[IPXACT2022ScalaCases.VendorExtensions](_, Some("http://www.accellera.org/XMLSchema/IPXACT/1685-2022"), Some("vendorExtensions"), __scope, false) } getOrElse {Nil})

  }

  def buildIPXACT2022ScalaCases_ModifiedWriteValueTypeFormat = new DefaultIPXACT2022ScalaCases_ModifiedWriteValueTypeFormat {}
  trait DefaultIPXACT2022ScalaCases_ModifiedWriteValueTypeFormat extends IPXACT2022scalaxb.XMLFormat[IPXACT2022ScalaCases.ModifiedWriteValueType] {
    val targetNamespace: Option[String] = Some("http://www.accellera.org/XMLSchema/IPXACT/1685-2022")
    
    def fromString(value: String, scope: scala.xml.NamespaceBinding): IPXACT2022ScalaCases.ModifiedWriteValueType =
        (fromString0(value, scope)).apply(IPXACT2022scalaxb.fromXML[String](scala.xml.Text(value)))

    private def fromString0(value: String, scope: scala.xml.NamespaceBinding): PartialFunction[Any, IPXACT2022ScalaCases.ModifiedWriteValueType] = {
      case x: String if x == IPXACT2022scalaxb.fromXML[String](scala.xml.Text("oneToClear")) => IPXACT2022ScalaCases.OneToClear
      case x: String if x == IPXACT2022scalaxb.fromXML[String](scala.xml.Text("oneToSet")) => IPXACT2022ScalaCases.OneToSet
      case x: String if x == IPXACT2022scalaxb.fromXML[String](scala.xml.Text("oneToToggle")) => IPXACT2022ScalaCases.OneToToggle
      case x: String if x == IPXACT2022scalaxb.fromXML[String](scala.xml.Text("zeroToClear")) => IPXACT2022ScalaCases.ZeroToClear
      case x: String if x == IPXACT2022scalaxb.fromXML[String](scala.xml.Text("zeroToSet")) => IPXACT2022ScalaCases.ZeroToSet
      case x: String if x == IPXACT2022scalaxb.fromXML[String](scala.xml.Text("zeroToToggle")) => IPXACT2022ScalaCases.ZeroToToggle
      case x: String if x == IPXACT2022scalaxb.fromXML[String](scala.xml.Text("clear")) => IPXACT2022ScalaCases.Clear
      case x: String if x == IPXACT2022scalaxb.fromXML[String](scala.xml.Text("set")) => IPXACT2022ScalaCases.SetType
      case x: String if x == IPXACT2022scalaxb.fromXML[String](scala.xml.Text("modify")) => IPXACT2022ScalaCases.Modify

    }



    def reads(seq: scala.xml.NodeSeq, stack: List[IPXACT2022scalaxb.ElemName]): Either[String, IPXACT2022ScalaCases.ModifiedWriteValueType] = seq match {
      case elem: scala.xml.Elem => Right(fromString(elem.text, elem.scope))
      case _ => Right(fromString(seq.text, scala.xml.TopScope))
    }
    
    def writes(__obj: IPXACT2022ScalaCases.ModifiedWriteValueType, __namespace: Option[String], __elementLabel: Option[String],
        __scope: scala.xml.NamespaceBinding, __typeAttribute: Boolean): scala.xml.NodeSeq =
      scala.xml.Elem(IPXACT2022scalaxb.Helper.getPrefix(__namespace, __scope).orNull,
        __elementLabel getOrElse { sys.error("missing element label.") },
        scala.xml.Null, __scope, true, scala.xml.Text(__obj.toString))
  }
  def buildIPXACT2022ScalaCases_ReadActionTypeFormat = new DefaultIPXACT2022ScalaCases_ReadActionTypeFormat {}
  trait DefaultIPXACT2022ScalaCases_ReadActionTypeFormat extends IPXACT2022scalaxb.XMLFormat[IPXACT2022ScalaCases.ReadActionType] {
    val targetNamespace: Option[String] = Some("http://www.accellera.org/XMLSchema/IPXACT/1685-2022")
    
    def fromString(value: String, scope: scala.xml.NamespaceBinding): IPXACT2022ScalaCases.ReadActionType =
        (fromString0(value, scope)).apply(IPXACT2022scalaxb.fromXML[String](scala.xml.Text(value)))

    private def fromString0(value: String, scope: scala.xml.NamespaceBinding): PartialFunction[Any, IPXACT2022ScalaCases.ReadActionType] = {
      case x: String if x == IPXACT2022scalaxb.fromXML[String](scala.xml.Text("clear")) => IPXACT2022ScalaCases.ClearValue
      case x: String if x == IPXACT2022scalaxb.fromXML[String](scala.xml.Text("set")) => IPXACT2022ScalaCases.SetTypeValue
      case x: String if x == IPXACT2022scalaxb.fromXML[String](scala.xml.Text("modify")) => IPXACT2022ScalaCases.ModifyValue

    }



    def reads(seq: scala.xml.NodeSeq, stack: List[IPXACT2022scalaxb.ElemName]): Either[String, IPXACT2022ScalaCases.ReadActionType] = seq match {
      case elem: scala.xml.Elem => Right(fromString(elem.text, elem.scope))
      case _ => Right(fromString(seq.text, scala.xml.TopScope))
    }
    
    def writes(__obj: IPXACT2022ScalaCases.ReadActionType, __namespace: Option[String], __elementLabel: Option[String],
        __scope: scala.xml.NamespaceBinding, __typeAttribute: Boolean): scala.xml.NodeSeq =
      scala.xml.Elem(IPXACT2022scalaxb.Helper.getPrefix(__namespace, __scope).orNull,
        __elementLabel getOrElse { sys.error("missing element label.") },
        scala.xml.Null, __scope, true, scala.xml.Text(__obj.toString))
  }
  trait DefaultIPXACT2022ScalaCases_AccessRestrictionTypeFormat extends IPXACT2022scalaxb.ElemNameParser[IPXACT2022ScalaCases.AccessRestrictionType] {
    val targetNamespace: Option[String] = Some("http://www.accellera.org/XMLSchema/IPXACT/1685-2022")
    
    override def typeName: Option[String] = Some("accessRestrictionType")

    def parser(node: scala.xml.Node, stack: List[IPXACT2022scalaxb.ElemName]): Parser[IPXACT2022ScalaCases.AccessRestrictionType] =
      phrase(safeRep(IPXACT2022scalaxb.ElemName(Some("http://www.accellera.org/XMLSchema/IPXACT/1685-2022"), "modeRef")) ~
      opt(IPXACT2022scalaxb.ElemName(Some("http://www.accellera.org/XMLSchema/IPXACT/1685-2022"), "readAccessMask")) ~
      opt(IPXACT2022scalaxb.ElemName(Some("http://www.accellera.org/XMLSchema/IPXACT/1685-2022"), "writeAccessMask")) ^^
      { case p1 ~ p2 ~ p3 =>
      IPXACT2022ScalaCases.AccessRestrictionType(p1 map { IPXACT2022scalaxb.fromXML[IPXACT2022ScalaCases.ModeRef3](_, IPXACT2022scalaxb.ElemName(node) :: stack) },
        p2.headOption map { IPXACT2022scalaxb.fromXML[IPXACT2022ScalaCases.UnsignedBitVectorExpressionable](_, IPXACT2022scalaxb.ElemName(node) :: stack) },
        p3.headOption map { IPXACT2022scalaxb.fromXML[IPXACT2022ScalaCases.UnsignedBitVectorExpressionable](_, IPXACT2022scalaxb.ElemName(node) :: stack) },
        scala.collection.immutable.ListMap(List(
        (node \ "@{http://www.w3.org/XML/1998/namespace}id").headOption map { x => IPXACT2022scalaxb.DataRecord(x, node, IPXACT2022scalaxb.fromXML[String](x, IPXACT2022scalaxb.ElemName(node) :: stack)) } map { "@{http://www.w3.org/XML/1998/namespace}id" -> _ }
        ).flatten[(String, IPXACT2022scalaxb.DataRecord[Any])]: _*)) })
    
    override def writesAttribute(__obj: IPXACT2022ScalaCases.AccessRestrictionType, __scope: scala.xml.NamespaceBinding): scala.xml.MetaData = {
      var attr: scala.xml.MetaData  = scala.xml.Null
      __obj.attributes.toList map {
        case ("@{http://www.w3.org/XML/1998/namespace}id", _) => __obj.xmlid foreach { x => attr = scala.xml.Attribute(__scope.getPrefix("http://www.w3.org/XML/1998/namespace"), "id", x.toString, attr) }
        case (key, x) => attr = scala.xml.Attribute((x.namespace map { __scope.getPrefix(_) }).orNull, x.key.orNull, x.value.toString, attr)
      }
      attr
    }

    def writesChildNodes(__obj: IPXACT2022ScalaCases.AccessRestrictionType, __scope: scala.xml.NamespaceBinding): Seq[scala.xml.Node] =
      Seq.concat(__obj.modeRef flatMap { IPXACT2022scalaxb.toXML[IPXACT2022ScalaCases.ModeRef3](_, Some("http://www.accellera.org/XMLSchema/IPXACT/1685-2022"), Some("modeRef"), __scope, false) },
        __obj.readAccessMask map { IPXACT2022scalaxb.toXML[IPXACT2022ScalaCases.UnsignedBitVectorExpressionable](_, Some("http://www.accellera.org/XMLSchema/IPXACT/1685-2022"), Some("readAccessMask"), __scope, false) } getOrElse {Nil},
        __obj.writeAccessMask map { IPXACT2022scalaxb.toXML[IPXACT2022ScalaCases.UnsignedBitVectorExpressionable](_, Some("http://www.accellera.org/XMLSchema/IPXACT/1685-2022"), Some("writeAccessMask"), __scope, false) } getOrElse {Nil})

  }

  trait DefaultIPXACT2022ScalaCases_AccessRestrictionsTypeFormat extends IPXACT2022scalaxb.ElemNameParser[IPXACT2022ScalaCases.AccessRestrictionsType] {
    val targetNamespace: Option[String] = Some("http://www.accellera.org/XMLSchema/IPXACT/1685-2022")
    
    override def typeName: Option[String] = Some("accessRestrictionsType")

    def parser(node: scala.xml.Node, stack: List[IPXACT2022scalaxb.ElemName]): Parser[IPXACT2022ScalaCases.AccessRestrictionsType] =
      phrase(safeRep(IPXACT2022scalaxb.ElemName(Some("http://www.accellera.org/XMLSchema/IPXACT/1685-2022"), "accessRestriction")) ^^
      { case p1 =>
      IPXACT2022ScalaCases.AccessRestrictionsType(p1 map { IPXACT2022scalaxb.fromXML[IPXACT2022ScalaCases.AccessRestrictionType](_, IPXACT2022scalaxb.ElemName(node) :: stack) }) })
    
    def writesChildNodes(__obj: IPXACT2022ScalaCases.AccessRestrictionsType, __scope: scala.xml.NamespaceBinding): Seq[scala.xml.Node] =
      (__obj.accessRestriction flatMap { IPXACT2022scalaxb.toXML[IPXACT2022ScalaCases.AccessRestrictionType](_, Some("http://www.accellera.org/XMLSchema/IPXACT/1685-2022"), Some("accessRestriction"), __scope, false) })
  }

  trait DefaultIPXACT2022ScalaCases_FieldAccessPropertiesTypableFormat extends IPXACT2022scalaxb.XMLFormat[IPXACT2022ScalaCases.FieldAccessPropertiesTypable] {
    def reads(seq: scala.xml.NodeSeq, stack: List[IPXACT2022scalaxb.ElemName]): Either[String, IPXACT2022ScalaCases.FieldAccessPropertiesTypable] = seq match {
      case node: scala.xml.Node =>     
        IPXACT2022scalaxb.Helper.instanceType(node) match {
          
          case _ => Right(IPXACT2022scalaxb.fromXML[IPXACT2022ScalaCases.FieldAccessPropertiesType](node, stack))
        }
      case _ => Left("reads failed: seq must be scala.xml.Node")  
    }
    
    def writes(__obj: IPXACT2022ScalaCases.FieldAccessPropertiesTypable, __namespace: Option[String], __elementLabel: Option[String],
        __scope: scala.xml.NamespaceBinding, __typeAttribute: Boolean): scala.xml.NodeSeq = __obj match {
      case x: IPXACT2022ScalaCases.FieldAccessPolicies => IPXACT2022scalaxb.toXML[IPXACT2022ScalaCases.FieldAccessPolicies](x, __namespace, __elementLabel, __scope, true)
      case x: IPXACT2022ScalaCases.FieldAccessPropertiesType => IPXACT2022scalaxb.toXML[IPXACT2022ScalaCases.FieldAccessPropertiesType](x, __namespace, __elementLabel, __scope, __typeAttribute)
    }
  }
  trait DefaultIPXACT2022ScalaCases_FieldAccessPropertiesTypeFormat extends IPXACT2022scalaxb.XMLFormat[IPXACT2022ScalaCases.FieldAccessPropertiesType] with IPXACT2022scalaxb.CanWriteChildNodes[IPXACT2022ScalaCases.FieldAccessPropertiesType] {
    val targetNamespace: Option[String] = Some("http://www.accellera.org/XMLSchema/IPXACT/1685-2022")
    def reads(seq: scala.xml.NodeSeq, stack: List[IPXACT2022scalaxb.ElemName]): Either[String, IPXACT2022ScalaCases.FieldAccessPropertiesType] = seq match {
      case node: scala.xml.Node => Right(IPXACT2022ScalaCases.FieldAccessPropertiesType(scala.collection.immutable.ListMap(List(
        (node \ "@{http://www.w3.org/XML/1998/namespace}id").headOption map { x => IPXACT2022scalaxb.DataRecord(x, node, IPXACT2022scalaxb.fromXML[String](x, IPXACT2022scalaxb.ElemName(node) :: stack)) } map { "@{http://www.w3.org/XML/1998/namespace}id" -> _ }
        ).flatten[(String, IPXACT2022scalaxb.DataRecord[Any])]: _*)))
      case _ => Left("reads failed: seq must be scala.xml.Node")
    }
    
    override def writesAttribute(__obj: IPXACT2022ScalaCases.FieldAccessPropertiesType, __scope: scala.xml.NamespaceBinding): scala.xml.MetaData = {
      var attr: scala.xml.MetaData  = scala.xml.Null
      __obj.attributes.toList map {
        case ("@{http://www.w3.org/XML/1998/namespace}id", _) => __obj.xmlid foreach { x => attr = scala.xml.Attribute(__scope.getPrefix("http://www.w3.org/XML/1998/namespace"), "id", x.toString, attr) }
        case (key, x) => attr = scala.xml.Attribute((x.namespace map { __scope.getPrefix(_) }).orNull, x.key.orNull, x.value.toString, attr)
      }
      attr
    }

    def writesChildNodes(__obj: IPXACT2022ScalaCases.FieldAccessPropertiesType, __scope: scala.xml.NamespaceBinding): Seq[scala.xml.Node] =
      Nil

  }

  trait DefaultIPXACT2022ScalaCases_AccessPropertiesTypeFormat extends IPXACT2022scalaxb.XMLFormat[IPXACT2022ScalaCases.AccessPropertiesType] with IPXACT2022scalaxb.CanWriteChildNodes[IPXACT2022ScalaCases.AccessPropertiesType] {
    val targetNamespace: Option[String] = Some("http://www.accellera.org/XMLSchema/IPXACT/1685-2022")
    def reads(seq: scala.xml.NodeSeq, stack: List[IPXACT2022scalaxb.ElemName]): Either[String, IPXACT2022ScalaCases.AccessPropertiesType] = seq match {
      case node: scala.xml.Node => Right(IPXACT2022ScalaCases.AccessPropertiesType(scala.collection.immutable.ListMap(List(
        (node \ "@accessEntryTypeRef").headOption map { x => IPXACT2022scalaxb.DataRecord(x, node, IPXACT2022scalaxb.fromXML[String](x, IPXACT2022scalaxb.ElemName(node) :: stack)) } map { "@accessEntryTypeRef" -> _ },
        (node \ "@{http://www.w3.org/XML/1998/namespace}id").headOption map { x => IPXACT2022scalaxb.DataRecord(x, node, IPXACT2022scalaxb.fromXML[String](x, IPXACT2022scalaxb.ElemName(node) :: stack)) } map { "@{http://www.w3.org/XML/1998/namespace}id" -> _ }
        ).flatten[(String, IPXACT2022scalaxb.DataRecord[Any])]: _*)))
      case _ => Left("reads failed: seq must be scala.xml.Node")
    }
    
    override def writesAttribute(__obj: IPXACT2022ScalaCases.AccessPropertiesType, __scope: scala.xml.NamespaceBinding): scala.xml.MetaData = {
      var attr: scala.xml.MetaData  = scala.xml.Null
      __obj.attributes.toList map {
        case ("@accessEntryTypeRef", _) => __obj.accessEntryTypeRef foreach { x => attr = scala.xml.Attribute(null, "accessEntryTypeRef", x.toString, attr) }
        case ("@{http://www.w3.org/XML/1998/namespace}id", _) => __obj.xmlid foreach { x => attr = scala.xml.Attribute(__scope.getPrefix("http://www.w3.org/XML/1998/namespace"), "id", x.toString, attr) }
        case (key, x) => attr = scala.xml.Attribute((x.namespace map { __scope.getPrefix(_) }).orNull, x.key.orNull, x.value.toString, attr)
      }
      attr
    }

    def writesChildNodes(__obj: IPXACT2022ScalaCases.AccessPropertiesType, __scope: scala.xml.NamespaceBinding): Seq[scala.xml.Node] =
      Nil

  }

  trait DefaultIPXACT2022ScalaCases_BroadcastToFormat extends IPXACT2022scalaxb.ElemNameParser[IPXACT2022ScalaCases.BroadcastTo] with IPXACT2022ScalaCases_FieldReferenceGroupGroupFormat {
    val targetNamespace: Option[String] = Some("http://www.accellera.org/XMLSchema/IPXACT/1685-2022")
    
    def parser(node: scala.xml.Node, stack: List[IPXACT2022scalaxb.ElemName]): Parser[IPXACT2022ScalaCases.BroadcastTo] =
      phrase((parseFieldReferenceGroupGroup(node, IPXACT2022scalaxb.ElemName(node) :: stack)) ^^
      { case p1 =>
      IPXACT2022ScalaCases.BroadcastTo(p1,
        scala.collection.immutable.ListMap(List(
        (node \ "@{http://www.w3.org/XML/1998/namespace}id").headOption map { x => IPXACT2022scalaxb.DataRecord(x, node, IPXACT2022scalaxb.fromXML[String](x, IPXACT2022scalaxb.ElemName(node) :: stack)) } map { "@{http://www.w3.org/XML/1998/namespace}id" -> _ }
        ).flatten[(String, IPXACT2022scalaxb.DataRecord[Any])]: _*)) })
    
    override def writesAttribute(__obj: IPXACT2022ScalaCases.BroadcastTo, __scope: scala.xml.NamespaceBinding): scala.xml.MetaData = {
      var attr: scala.xml.MetaData  = scala.xml.Null
      __obj.attributes.toList map {
        case ("@{http://www.w3.org/XML/1998/namespace}id", _) => __obj.xmlid foreach { x => attr = scala.xml.Attribute(__scope.getPrefix("http://www.w3.org/XML/1998/namespace"), "id", x.toString, attr) }
        case (key, x) => attr = scala.xml.Attribute((x.namespace map { __scope.getPrefix(_) }).orNull, x.key.orNull, x.value.toString, attr)
      }
      attr
    }

    def writesChildNodes(__obj: IPXACT2022ScalaCases.BroadcastTo, __scope: scala.xml.NamespaceBinding): Seq[scala.xml.Node] =
      (IPXACT2022scalaxb.toXML[IPXACT2022ScalaCases.FieldReferenceGroupSequence](__obj.fieldReferenceGroupSequence1, None, Some("fieldReferenceGroupSequence1"), __scope, false))
  }

  trait DefaultIPXACT2022ScalaCases_BroadcastsFormat extends IPXACT2022scalaxb.ElemNameParser[IPXACT2022ScalaCases.Broadcasts] {
    val targetNamespace: Option[String] = Some("http://www.accellera.org/XMLSchema/IPXACT/1685-2022")
    
    def parser(node: scala.xml.Node, stack: List[IPXACT2022scalaxb.ElemName]): Parser[IPXACT2022ScalaCases.Broadcasts] =
      phrase(safeRep(IPXACT2022scalaxb.ElemName(Some("http://www.accellera.org/XMLSchema/IPXACT/1685-2022"), "broadcastTo")) ^^
      { case p1 =>
      IPXACT2022ScalaCases.Broadcasts(p1 map { IPXACT2022scalaxb.fromXML[IPXACT2022ScalaCases.BroadcastTo](_, IPXACT2022scalaxb.ElemName(node) :: stack) }) })
    
    def writesChildNodes(__obj: IPXACT2022ScalaCases.Broadcasts, __scope: scala.xml.NamespaceBinding): Seq[scala.xml.Node] =
      (__obj.broadcastTo flatMap { IPXACT2022scalaxb.toXML[IPXACT2022ScalaCases.BroadcastTo](_, Some("http://www.accellera.org/XMLSchema/IPXACT/1685-2022"), Some("broadcastTo"), __scope, false) })
  }
  def buildIPXACT2022ScalaCases_TestConstraintFormat = new DefaultIPXACT2022ScalaCases_TestConstraintFormat {}
  trait DefaultIPXACT2022ScalaCases_TestConstraintFormat extends IPXACT2022scalaxb.XMLFormat[IPXACT2022ScalaCases.TestConstraint] {
    val targetNamespace: Option[String] = Some("http://www.accellera.org/XMLSchema/IPXACT/1685-2022")
    
    def fromString(value: String, scope: scala.xml.NamespaceBinding): IPXACT2022ScalaCases.TestConstraint =
        (fromString0(value, scope)).apply(IPXACT2022scalaxb.fromXML[String](scala.xml.Text(value)))

    private def fromString0(value: String, scope: scala.xml.NamespaceBinding): PartialFunction[Any, IPXACT2022ScalaCases.TestConstraint] = {
      case x: String if x == IPXACT2022scalaxb.fromXML[String](scala.xml.Text("unconstrained")) => IPXACT2022ScalaCases.Unconstrained
      case x: String if x == IPXACT2022scalaxb.fromXML[String](scala.xml.Text("restore")) => IPXACT2022ScalaCases.Restore
      case x: String if x == IPXACT2022scalaxb.fromXML[String](scala.xml.Text("writeAsRead")) => IPXACT2022ScalaCases.WriteAsRead
      case x: String if x == IPXACT2022scalaxb.fromXML[String](scala.xml.Text("readOnly")) => IPXACT2022ScalaCases.ReadOnly

    }



    def reads(seq: scala.xml.NodeSeq, stack: List[IPXACT2022scalaxb.ElemName]): Either[String, IPXACT2022ScalaCases.TestConstraint] = seq match {
      case elem: scala.xml.Elem => Right(fromString(elem.text, elem.scope))
      case _ => Right(fromString(seq.text, scala.xml.TopScope))
    }
    
    def writes(__obj: IPXACT2022ScalaCases.TestConstraint, __namespace: Option[String], __elementLabel: Option[String],
        __scope: scala.xml.NamespaceBinding, __typeAttribute: Boolean): scala.xml.NodeSeq =
      scala.xml.Elem(IPXACT2022scalaxb.Helper.getPrefix(__namespace, __scope).orNull,
        __elementLabel getOrElse { sys.error("missing element label.") },
        scala.xml.Null, __scope, true, scala.xml.Text(__obj.toString))
  }
  trait DefaultIPXACT2022ScalaCases_TestableFormat extends IPXACT2022scalaxb.XMLFormat[IPXACT2022ScalaCases.Testable] with IPXACT2022scalaxb.CanWriteChildNodes[IPXACT2022ScalaCases.Testable] {
    val targetNamespace: Option[String] = Some("http://www.accellera.org/XMLSchema/IPXACT/1685-2022")
    def reads(seq: scala.xml.NodeSeq, stack: List[IPXACT2022scalaxb.ElemName]): Either[String, IPXACT2022ScalaCases.Testable] = seq match {
      case node: scala.xml.Node => Right(IPXACT2022ScalaCases.Testable(IPXACT2022scalaxb.fromXML[Boolean](node, IPXACT2022scalaxb.ElemName(node) :: stack),
        scala.collection.immutable.ListMap(List(
        (node \ "@testConstraint").headOption map { x => IPXACT2022scalaxb.DataRecord(x, node, IPXACT2022scalaxb.fromXML[IPXACT2022ScalaCases.TestConstraint](x, IPXACT2022scalaxb.ElemName(node) :: stack)) } orElse Some(IPXACT2022scalaxb.DataRecord(None, None, IPXACT2022scalaxb.fromXML[IPXACT2022ScalaCases.TestConstraint](scala.xml.Text("unconstrained"), IPXACT2022scalaxb.ElemName(node) :: stack))) map { "@testConstraint" -> _ }
        ).flatten[(String, IPXACT2022scalaxb.DataRecord[Any])]: _*)))
      case _ => Left("reads failed: seq must be scala.xml.Node")
    }
    
    override def writesAttribute(__obj: IPXACT2022ScalaCases.Testable, __scope: scala.xml.NamespaceBinding): scala.xml.MetaData = {
      var attr: scala.xml.MetaData  = scala.xml.Null
      __obj.attributes.toList map {
        case ("@testConstraint", _) => if (__obj.testConstraint.toString != "unconstrained") attr = scala.xml.Attribute(null, "testConstraint", __obj.testConstraint.toString, attr)
        case (key, x) => attr = scala.xml.Attribute((x.namespace map { __scope.getPrefix(_) }).orNull, x.key.orNull, x.value.toString, attr)
      }
      attr
    }

    def writesChildNodes(__obj: IPXACT2022ScalaCases.Testable, __scope: scala.xml.NamespaceBinding): Seq[scala.xml.Node] =
      Seq(scala.xml.Text(__obj.value.toString))

  }

  trait DefaultIPXACT2022ScalaCases_FieldAccessPolicyFormat extends IPXACT2022scalaxb.ElemNameParser[IPXACT2022ScalaCases.FieldAccessPolicy] {
    val targetNamespace: Option[String] = Some("http://www.accellera.org/XMLSchema/IPXACT/1685-2022")
    
    def parser(node: scala.xml.Node, stack: List[IPXACT2022scalaxb.ElemName]): Parser[IPXACT2022ScalaCases.FieldAccessPolicy] =
      phrase(safeRep(IPXACT2022scalaxb.ElemName(Some("http://www.accellera.org/XMLSchema/IPXACT/1685-2022"), "modeRef")) ~
      opt(((IPXACT2022scalaxb.ElemName(Some("http://www.accellera.org/XMLSchema/IPXACT/1685-2022"), "fieldAccessPolicyDefinitionRef")) ^^
      (x => IPXACT2022scalaxb.DataRecord(x.namespace, Some(x.name), IPXACT2022scalaxb.fromXML[IPXACT2022ScalaCases.FieldAccessPolicyDefinitionRef](x, IPXACT2022scalaxb.ElemName(node) :: stack)))) |||
      ((opt(IPXACT2022scalaxb.ElemName(Some("http://www.accellera.org/XMLSchema/IPXACT/1685-2022"), "access")) ~
      opt(IPXACT2022scalaxb.ElemName(Some("http://www.accellera.org/XMLSchema/IPXACT/1685-2022"), "modifiedWriteValue")) ~
      opt(IPXACT2022scalaxb.ElemName(Some("http://www.accellera.org/XMLSchema/IPXACT/1685-2022"), "writeValueConstraint")) ~
      opt(IPXACT2022scalaxb.ElemName(Some("http://www.accellera.org/XMLSchema/IPXACT/1685-2022"), "readAction")) ~
      opt(IPXACT2022scalaxb.ElemName(Some("http://www.accellera.org/XMLSchema/IPXACT/1685-2022"), "readResponse"))) ^^
        { case p1 ~ p2 ~ p3 ~ p4 ~ p5 => IPXACT2022scalaxb.DataRecord(IPXACT2022ScalaCases.FieldAccessPolicySequence1(p1.headOption map { IPXACT2022scalaxb.fromXML[IPXACT2022ScalaCases.AccessType](_, IPXACT2022scalaxb.ElemName(node) :: stack) },
        p2.headOption map { IPXACT2022scalaxb.fromXML[IPXACT2022ScalaCases.ModifiedWriteValue](_, IPXACT2022scalaxb.ElemName(node) :: stack) },
        p3.headOption map { IPXACT2022scalaxb.fromXML[IPXACT2022ScalaCases.WriteValueConstraintType](_, IPXACT2022scalaxb.ElemName(node) :: stack) },
        p4.headOption map { IPXACT2022scalaxb.fromXML[IPXACT2022ScalaCases.ReadAction](_, IPXACT2022scalaxb.ElemName(node) :: stack) },
        p5.headOption map { IPXACT2022scalaxb.fromXML[IPXACT2022ScalaCases.UnsignedBitVectorExpressionable](_, IPXACT2022scalaxb.ElemName(node) :: stack) })) })) ~
      opt(IPXACT2022scalaxb.ElemName(Some("http://www.accellera.org/XMLSchema/IPXACT/1685-2022"), "broadcasts")) ~
      opt(IPXACT2022scalaxb.ElemName(Some("http://www.accellera.org/XMLSchema/IPXACT/1685-2022"), "accessRestrictions")) ~
      opt(IPXACT2022scalaxb.ElemName(Some("http://www.accellera.org/XMLSchema/IPXACT/1685-2022"), "testable")) ~
      opt(IPXACT2022scalaxb.ElemName(Some("http://www.accellera.org/XMLSchema/IPXACT/1685-2022"), "reserved")) ~
      opt(IPXACT2022scalaxb.ElemName(Some("http://www.accellera.org/XMLSchema/IPXACT/1685-2022"), "vendorExtensions")) ^^
      { case p1 ~ p2 ~ p3 ~ p4 ~ p5 ~ p6 ~ p7 =>
      IPXACT2022ScalaCases.FieldAccessPolicy(p1 map { IPXACT2022scalaxb.fromXML[IPXACT2022ScalaCases.ModeRef3](_, IPXACT2022scalaxb.ElemName(node) :: stack) },
        p2,
        p3.headOption map { IPXACT2022scalaxb.fromXML[IPXACT2022ScalaCases.Broadcasts](_, IPXACT2022scalaxb.ElemName(node) :: stack) },
        p4.headOption map { IPXACT2022scalaxb.fromXML[IPXACT2022ScalaCases.AccessRestrictionsType](_, IPXACT2022scalaxb.ElemName(node) :: stack) },
        p5.headOption map { IPXACT2022scalaxb.fromXML[IPXACT2022ScalaCases.Testable](_, IPXACT2022scalaxb.ElemName(node) :: stack) },
        p6.headOption map { IPXACT2022scalaxb.fromXML[IPXACT2022ScalaCases.UnsignedBitExpression](_, IPXACT2022scalaxb.ElemName(node) :: stack) },
        p7.headOption map { IPXACT2022scalaxb.fromXML[IPXACT2022ScalaCases.VendorExtensions](_, IPXACT2022scalaxb.ElemName(node) :: stack) },
        scala.collection.immutable.ListMap(List(
        (node \ "@{http://www.w3.org/XML/1998/namespace}id").headOption map { x => IPXACT2022scalaxb.DataRecord(x, node, IPXACT2022scalaxb.fromXML[String](x, IPXACT2022scalaxb.ElemName(node) :: stack)) } map { "@{http://www.w3.org/XML/1998/namespace}id" -> _ }
        ).flatten[(String, IPXACT2022scalaxb.DataRecord[Any])]: _*)) })
    
    override def writesAttribute(__obj: IPXACT2022ScalaCases.FieldAccessPolicy, __scope: scala.xml.NamespaceBinding): scala.xml.MetaData = {
      var attr: scala.xml.MetaData  = scala.xml.Null
      __obj.attributes.toList map {
        case ("@{http://www.w3.org/XML/1998/namespace}id", _) => __obj.xmlid foreach { x => attr = scala.xml.Attribute(__scope.getPrefix("http://www.w3.org/XML/1998/namespace"), "id", x.toString, attr) }
        case (key, x) => attr = scala.xml.Attribute((x.namespace map { __scope.getPrefix(_) }).orNull, x.key.orNull, x.value.toString, attr)
      }
      attr
    }

    def writesChildNodes(__obj: IPXACT2022ScalaCases.FieldAccessPolicy, __scope: scala.xml.NamespaceBinding): Seq[scala.xml.Node] =
      Seq.concat(__obj.modeRef flatMap { IPXACT2022scalaxb.toXML[IPXACT2022ScalaCases.ModeRef3](_, Some("http://www.accellera.org/XMLSchema/IPXACT/1685-2022"), Some("modeRef"), __scope, false) },
        __obj.fieldaccesspolicyoption map { x => IPXACT2022scalaxb.toXML[IPXACT2022scalaxb.DataRecord[IPXACT2022ScalaCases.FieldAccessPolicyOption]](x, x.namespace, x.key, __scope, false) } getOrElse {Nil},
        __obj.broadcasts map { IPXACT2022scalaxb.toXML[IPXACT2022ScalaCases.Broadcasts](_, Some("http://www.accellera.org/XMLSchema/IPXACT/1685-2022"), Some("broadcasts"), __scope, false) } getOrElse {Nil},
        __obj.accessRestrictions map { IPXACT2022scalaxb.toXML[IPXACT2022ScalaCases.AccessRestrictionsType](_, Some("http://www.accellera.org/XMLSchema/IPXACT/1685-2022"), Some("accessRestrictions"), __scope, false) } getOrElse {Nil},
        __obj.testable map { IPXACT2022scalaxb.toXML[IPXACT2022ScalaCases.Testable](_, Some("http://www.accellera.org/XMLSchema/IPXACT/1685-2022"), Some("testable"), __scope, false) } getOrElse {Nil},
        __obj.reserved map { IPXACT2022scalaxb.toXML[IPXACT2022ScalaCases.UnsignedBitExpression](_, Some("http://www.accellera.org/XMLSchema/IPXACT/1685-2022"), Some("reserved"), __scope, false) } getOrElse {Nil},
        __obj.vendorExtensions map { IPXACT2022scalaxb.toXML[IPXACT2022ScalaCases.VendorExtensions](_, Some("http://www.accellera.org/XMLSchema/IPXACT/1685-2022"), Some("vendorExtensions"), __scope, false) } getOrElse {Nil})

  }

  trait DefaultIPXACT2022ScalaCases_FieldAccessPolicySequence1Format extends IPXACT2022scalaxb.XMLFormat[IPXACT2022ScalaCases.FieldAccessPolicySequence1] {
    def reads(seq: scala.xml.NodeSeq, stack: List[IPXACT2022scalaxb.ElemName]): Either[String, IPXACT2022ScalaCases.FieldAccessPolicySequence1] = Left("don't call me.")
    
    def writes(__obj: IPXACT2022ScalaCases.FieldAccessPolicySequence1, __namespace: Option[String], __elementLabel: Option[String],
        __scope: scala.xml.NamespaceBinding, __typeAttribute: Boolean): scala.xml.NodeSeq =
      Seq.concat(__obj.access map { IPXACT2022scalaxb.toXML[IPXACT2022ScalaCases.AccessType](_, Some("http://www.accellera.org/XMLSchema/IPXACT/1685-2022"), Some("access"), __scope, false) } getOrElse {Nil},
        __obj.modifiedWriteValue map { IPXACT2022scalaxb.toXML[IPXACT2022ScalaCases.ModifiedWriteValue](_, Some("http://www.accellera.org/XMLSchema/IPXACT/1685-2022"), Some("modifiedWriteValue"), __scope, false) } getOrElse {Nil},
        __obj.writeValueConstraint map { IPXACT2022scalaxb.toXML[IPXACT2022ScalaCases.WriteValueConstraintType](_, Some("http://www.accellera.org/XMLSchema/IPXACT/1685-2022"), Some("writeValueConstraint"), __scope, false) } getOrElse {Nil},
        __obj.readAction map { IPXACT2022scalaxb.toXML[IPXACT2022ScalaCases.ReadAction](_, Some("http://www.accellera.org/XMLSchema/IPXACT/1685-2022"), Some("readAction"), __scope, false) } getOrElse {Nil},
        __obj.readResponse map { IPXACT2022scalaxb.toXML[IPXACT2022ScalaCases.UnsignedBitVectorExpressionable](_, Some("http://www.accellera.org/XMLSchema/IPXACT/1685-2022"), Some("readResponse"), __scope, false) } getOrElse {Nil})


  }

  trait DefaultIPXACT2022ScalaCases_FieldAccessPoliciesFormat extends IPXACT2022scalaxb.ElemNameParser[IPXACT2022ScalaCases.FieldAccessPolicies] {
    val targetNamespace: Option[String] = Some("http://www.accellera.org/XMLSchema/IPXACT/1685-2022")
    
    def parser(node: scala.xml.Node, stack: List[IPXACT2022scalaxb.ElemName]): Parser[IPXACT2022ScalaCases.FieldAccessPolicies] =
      phrase(safeRep(IPXACT2022scalaxb.ElemName(Some("http://www.accellera.org/XMLSchema/IPXACT/1685-2022"), "fieldAccessPolicy")) ^^
      { case p1 =>
      IPXACT2022ScalaCases.FieldAccessPolicies(p1 map { IPXACT2022scalaxb.fromXML[IPXACT2022ScalaCases.FieldAccessPolicy](_, IPXACT2022scalaxb.ElemName(node) :: stack) },
        scala.collection.immutable.ListMap(List(
        (node \ "@{http://www.w3.org/XML/1998/namespace}id").headOption map { x => IPXACT2022scalaxb.DataRecord(x, node, IPXACT2022scalaxb.fromXML[String](x, IPXACT2022scalaxb.ElemName(node) :: stack)) } map { "@{http://www.w3.org/XML/1998/namespace}id" -> _ }
        ).flatten[(String, IPXACT2022scalaxb.DataRecord[Any])]: _*)) })
    
    override def writesAttribute(__obj: IPXACT2022ScalaCases.FieldAccessPolicies, __scope: scala.xml.NamespaceBinding): scala.xml.MetaData = {
      var attr: scala.xml.MetaData  = scala.xml.Null
      __obj.attributes.toList map {
        case ("@{http://www.w3.org/XML/1998/namespace}id", _) => __obj.xmlid foreach { x => attr = scala.xml.Attribute(__scope.getPrefix("http://www.w3.org/XML/1998/namespace"), "id", x.toString, attr) }
        case (key, x) => attr = scala.xml.Attribute((x.namespace map { __scope.getPrefix(_) }).orNull, x.key.orNull, x.value.toString, attr)
      }
      attr
    }

    def writesChildNodes(__obj: IPXACT2022ScalaCases.FieldAccessPolicies, __scope: scala.xml.NamespaceBinding): Seq[scala.xml.Node] =
      (__obj.fieldAccessPolicy flatMap { IPXACT2022scalaxb.toXML[IPXACT2022ScalaCases.FieldAccessPolicy](_, Some("http://www.accellera.org/XMLSchema/IPXACT/1685-2022"), Some("fieldAccessPolicy"), __scope, false) })
  }

  trait DefaultIPXACT2022ScalaCases_WriteValueConstraintTypeFormat extends IPXACT2022scalaxb.ElemNameParser[IPXACT2022ScalaCases.WriteValueConstraintType] {
    val targetNamespace: Option[String] = Some("http://www.accellera.org/XMLSchema/IPXACT/1685-2022")
    
    override def typeName: Option[String] = Some("writeValueConstraintType")

    def parser(node: scala.xml.Node, stack: List[IPXACT2022scalaxb.ElemName]): Parser[IPXACT2022ScalaCases.WriteValueConstraintType] =
      phrase((((IPXACT2022scalaxb.ElemName(Some("http://www.accellera.org/XMLSchema/IPXACT/1685-2022"), "writeAsRead")) ^^
      (x => IPXACT2022scalaxb.DataRecord(x.namespace, Some(x.name), IPXACT2022scalaxb.fromXML[Boolean](x, IPXACT2022scalaxb.ElemName(node) :: stack)))) |||
      ((IPXACT2022scalaxb.ElemName(Some("http://www.accellera.org/XMLSchema/IPXACT/1685-2022"), "useEnumeratedValues")) ^^
      (x => IPXACT2022scalaxb.DataRecord(x.namespace, Some(x.name), IPXACT2022scalaxb.fromXML[Boolean](x, IPXACT2022scalaxb.ElemName(node) :: stack)))) |||
      (((IPXACT2022scalaxb.ElemName(Some("http://www.accellera.org/XMLSchema/IPXACT/1685-2022"), "minimum")) ~
      (IPXACT2022scalaxb.ElemName(Some("http://www.accellera.org/XMLSchema/IPXACT/1685-2022"), "maximum"))) ^^
        { case p1 ~ p2 => IPXACT2022scalaxb.DataRecord(IPXACT2022ScalaCases.WriteValueConstraintTypeSequence1(IPXACT2022scalaxb.fromXML[IPXACT2022ScalaCases.UnsignedBitVectorExpressionable](p1, IPXACT2022scalaxb.ElemName(node) :: stack),
        IPXACT2022scalaxb.fromXML[IPXACT2022ScalaCases.UnsignedBitVectorExpressionable](p2, IPXACT2022scalaxb.ElemName(node) :: stack))) })) ^^
      { case p1 =>
      IPXACT2022ScalaCases.WriteValueConstraintType(p1) })
    
    def writesChildNodes(__obj: IPXACT2022ScalaCases.WriteValueConstraintType, __scope: scala.xml.NamespaceBinding): Seq[scala.xml.Node] =
      ((Some(__obj.writevalueconstrainttypeoption) map {x => IPXACT2022scalaxb.toXML[IPXACT2022scalaxb.DataRecord[Any]](x, x.namespace, x.key, __scope, false)}).get)
  }

  trait DefaultIPXACT2022ScalaCases_WriteValueConstraintTypeSequence1Format extends IPXACT2022scalaxb.XMLFormat[IPXACT2022ScalaCases.WriteValueConstraintTypeSequence1] {
    def reads(seq: scala.xml.NodeSeq, stack: List[IPXACT2022scalaxb.ElemName]): Either[String, IPXACT2022ScalaCases.WriteValueConstraintTypeSequence1] = Left("don't call me.")
    
    def writes(__obj: IPXACT2022ScalaCases.WriteValueConstraintTypeSequence1, __namespace: Option[String], __elementLabel: Option[String],
        __scope: scala.xml.NamespaceBinding, __typeAttribute: Boolean): scala.xml.NodeSeq =
      Seq.concat(IPXACT2022scalaxb.toXML[IPXACT2022ScalaCases.UnsignedBitVectorExpressionable](__obj.minimum, Some("http://www.accellera.org/XMLSchema/IPXACT/1685-2022"), Some("minimum"), __scope, false),
        IPXACT2022scalaxb.toXML[IPXACT2022ScalaCases.UnsignedBitVectorExpressionable](__obj.maximum, Some("http://www.accellera.org/XMLSchema/IPXACT/1685-2022"), Some("maximum"), __scope, false))


  }

  trait DefaultIPXACT2022ScalaCases_AccessHandles12Format extends IPXACT2022scalaxb.ElemNameParser[IPXACT2022ScalaCases.AccessHandles12] {
    val targetNamespace: Option[String] = Some("http://www.accellera.org/XMLSchema/IPXACT/1685-2022")
    
    def parser(node: scala.xml.Node, stack: List[IPXACT2022scalaxb.ElemName]): Parser[IPXACT2022ScalaCases.AccessHandles12] =
      phrase(safeRep(((IPXACT2022scalaxb.ElemName(Some("http://www.accellera.org/XMLSchema/IPXACT/1685-2022"), "accessHandle"))) ^^
        { case p1 => IPXACT2022ScalaCases.AccessHandles12Sequence1(IPXACT2022scalaxb.fromXML[IPXACT2022ScalaCases.SimpleAccessHandle](p1, IPXACT2022scalaxb.ElemName(node) :: stack)) }) ^^
      { case p1 =>
      IPXACT2022ScalaCases.AccessHandles12(p1) })
    
    def writesChildNodes(__obj: IPXACT2022ScalaCases.AccessHandles12, __scope: scala.xml.NamespaceBinding): Seq[scala.xml.Node] =
      (__obj.accesshandles12sequence1 flatMap { IPXACT2022scalaxb.toXML[IPXACT2022ScalaCases.AccessHandles12Sequence1](_, None, Some("accesshandles12sequence1"), __scope, false) })
  }

  trait DefaultIPXACT2022ScalaCases_AccessHandles12Sequence1Format extends IPXACT2022scalaxb.XMLFormat[IPXACT2022ScalaCases.AccessHandles12Sequence1] {
    def reads(seq: scala.xml.NodeSeq, stack: List[IPXACT2022scalaxb.ElemName]): Either[String, IPXACT2022ScalaCases.AccessHandles12Sequence1] = Left("don't call me.")
    
    def writes(__obj: IPXACT2022ScalaCases.AccessHandles12Sequence1, __namespace: Option[String], __elementLabel: Option[String],
        __scope: scala.xml.NamespaceBinding, __typeAttribute: Boolean): scala.xml.NodeSeq =
      IPXACT2022scalaxb.toXML[IPXACT2022ScalaCases.SimpleAccessHandle](__obj.accessHandle, Some("http://www.accellera.org/XMLSchema/IPXACT/1685-2022"), Some("accessHandle"), __scope, false)

  }
  trait DefaultIPXACT2022ScalaCases_RegisterFileDefinitionRefFormat extends IPXACT2022scalaxb.XMLFormat[IPXACT2022ScalaCases.RegisterFileDefinitionRef] with IPXACT2022scalaxb.CanWriteChildNodes[IPXACT2022ScalaCases.RegisterFileDefinitionRef] {
    val targetNamespace: Option[String] = Some("http://www.accellera.org/XMLSchema/IPXACT/1685-2022")
    def reads(seq: scala.xml.NodeSeq, stack: List[IPXACT2022scalaxb.ElemName]): Either[String, IPXACT2022ScalaCases.RegisterFileDefinitionRef] = seq match {
      case node: scala.xml.Node => Right(IPXACT2022ScalaCases.RegisterFileDefinitionRef(IPXACT2022scalaxb.fromXML[String](node, IPXACT2022scalaxb.ElemName(node) :: stack),
        scala.collection.immutable.ListMap(List(
        (node \ "@typeDefinitions").headOption map { x => IPXACT2022scalaxb.DataRecord(x, node, IPXACT2022scalaxb.fromXML[String](x, IPXACT2022scalaxb.ElemName(node) :: stack)) } map { "@typeDefinitions" -> _ }
        ).flatten[(String, IPXACT2022scalaxb.DataRecord[Any])]: _*)))
      case _ => Left("reads failed: seq must be scala.xml.Node")
    }
    
    override def writesAttribute(__obj: IPXACT2022ScalaCases.RegisterFileDefinitionRef, __scope: scala.xml.NamespaceBinding): scala.xml.MetaData = {
      var attr: scala.xml.MetaData  = scala.xml.Null
      __obj.attributes.toList map {
        case ("@typeDefinitions", _) => attr = scala.xml.Attribute(null, "typeDefinitions", __obj.typeDefinitions.toString, attr)
        case (key, x) => attr = scala.xml.Attribute((x.namespace map { __scope.getPrefix(_) }).orNull, x.key.orNull, x.value.toString, attr)
      }
      attr
    }

    def writesChildNodes(__obj: IPXACT2022ScalaCases.RegisterFileDefinitionRef, __scope: scala.xml.NamespaceBinding): Seq[scala.xml.Node] =
      Seq(scala.xml.Text(__obj.value.toString))

  }

  trait DefaultIPXACT2022ScalaCases_RegisterFileFormat extends IPXACT2022scalaxb.ElemNameParser[IPXACT2022ScalaCases.RegisterFile] with IPXACT2022ScalaCases_NameGroupGroupFormat with IPXACT2022ScalaCases_RegisterFileDefinitionGroupGroupFormat {
    val targetNamespace: Option[String] = Some("http://www.accellera.org/XMLSchema/IPXACT/1685-2022")
    
    def parser(node: scala.xml.Node, stack: List[IPXACT2022scalaxb.ElemName]): Parser[IPXACT2022ScalaCases.RegisterFile] =
      phrase((parseNameGroupGroup(node, IPXACT2022scalaxb.ElemName(node) :: stack)) ~
      opt(IPXACT2022scalaxb.ElemName(Some("http://www.accellera.org/XMLSchema/IPXACT/1685-2022"), "accessHandles")) ~
      opt(IPXACT2022scalaxb.ElemName(Some("http://www.accellera.org/XMLSchema/IPXACT/1685-2022"), "array")) ~
      (IPXACT2022scalaxb.ElemName(Some("http://www.accellera.org/XMLSchema/IPXACT/1685-2022"), "addressOffset")) ~
      (((IPXACT2022scalaxb.ElemName(Some("http://www.accellera.org/XMLSchema/IPXACT/1685-2022"), "registerFileDefinitionRef")) ^^
      (x => IPXACT2022scalaxb.DataRecord(x.namespace, Some(x.name), IPXACT2022scalaxb.fromXML[IPXACT2022ScalaCases.RegisterFileDefinitionRef](x, IPXACT2022scalaxb.ElemName(node) :: stack)))) |||
      (parseRegisterFileDefinitionGroupGroup(node, IPXACT2022scalaxb.ElemName(node) :: stack, true))) ~
      opt(IPXACT2022scalaxb.ElemName(Some("http://www.accellera.org/XMLSchema/IPXACT/1685-2022"), "parameters")) ~
      opt(IPXACT2022scalaxb.ElemName(Some("http://www.accellera.org/XMLSchema/IPXACT/1685-2022"), "vendorExtensions")) ^^
      { case p1 ~ p2 ~ p3 ~ p4 ~ p5 ~ p6 ~ p7 =>
      IPXACT2022ScalaCases.RegisterFile(p1,
        p2.headOption map { IPXACT2022scalaxb.fromXML[IPXACT2022ScalaCases.AccessHandles12](_, IPXACT2022scalaxb.ElemName(node) :: stack) },
        p3.headOption map { IPXACT2022scalaxb.fromXML[IPXACT2022ScalaCases.ArrayType4](_, IPXACT2022scalaxb.ElemName(node) :: stack) },
        IPXACT2022scalaxb.fromXML[IPXACT2022ScalaCases.UnsignedLongintExpressionable](p4, IPXACT2022scalaxb.ElemName(node) :: stack),
        p5,
        p6.headOption map { IPXACT2022scalaxb.fromXML[IPXACT2022ScalaCases.Parameters](_, IPXACT2022scalaxb.ElemName(node) :: stack) },
        p7.headOption map { IPXACT2022scalaxb.fromXML[IPXACT2022ScalaCases.VendorExtensions](_, IPXACT2022scalaxb.ElemName(node) :: stack) },
        scala.collection.immutable.ListMap(List(
        (node \ "@{http://www.w3.org/XML/1998/namespace}id").headOption map { x => IPXACT2022scalaxb.DataRecord(x, node, IPXACT2022scalaxb.fromXML[String](x, IPXACT2022scalaxb.ElemName(node) :: stack)) } map { "@{http://www.w3.org/XML/1998/namespace}id" -> _ }
        ).flatten[(String, IPXACT2022scalaxb.DataRecord[Any])]: _*)) })
    
    override def writesAttribute(__obj: IPXACT2022ScalaCases.RegisterFile, __scope: scala.xml.NamespaceBinding): scala.xml.MetaData = {
      var attr: scala.xml.MetaData  = scala.xml.Null
      __obj.attributes.toList map {
        case ("@{http://www.w3.org/XML/1998/namespace}id", _) => __obj.xmlid foreach { x => attr = scala.xml.Attribute(__scope.getPrefix("http://www.w3.org/XML/1998/namespace"), "id", x.toString, attr) }
        case (key, x) => attr = scala.xml.Attribute((x.namespace map { __scope.getPrefix(_) }).orNull, x.key.orNull, x.value.toString, attr)
      }
      attr
    }

    def writesChildNodes(__obj: IPXACT2022ScalaCases.RegisterFile, __scope: scala.xml.NamespaceBinding): Seq[scala.xml.Node] =
      Seq.concat(IPXACT2022scalaxb.toXML[IPXACT2022ScalaCases.NameGroupSequence](__obj.nameGroupSequence1, None, Some("nameGroupSequence1"), __scope, false),
        __obj.accessHandles map { IPXACT2022scalaxb.toXML[IPXACT2022ScalaCases.AccessHandles12](_, Some("http://www.accellera.org/XMLSchema/IPXACT/1685-2022"), Some("accessHandles"), __scope, false) } getOrElse {Nil},
        __obj.array map { IPXACT2022scalaxb.toXML[IPXACT2022ScalaCases.ArrayType4](_, Some("http://www.accellera.org/XMLSchema/IPXACT/1685-2022"), Some("array"), __scope, false) } getOrElse {Nil},
        IPXACT2022scalaxb.toXML[IPXACT2022ScalaCases.UnsignedLongintExpressionable](__obj.addressOffset, Some("http://www.accellera.org/XMLSchema/IPXACT/1685-2022"), Some("addressOffset"), __scope, false),
        (Some(__obj.registerfileoption) map {x => IPXACT2022scalaxb.toXML[IPXACT2022scalaxb.DataRecord[Any]](x, x.namespace, x.key, __scope, false)}).get,
        __obj.parameters map { IPXACT2022scalaxb.toXML[IPXACT2022ScalaCases.Parameters](_, Some("http://www.accellera.org/XMLSchema/IPXACT/1685-2022"), Some("parameters"), __scope, false) } getOrElse {Nil},
        __obj.vendorExtensions map { IPXACT2022scalaxb.toXML[IPXACT2022ScalaCases.VendorExtensions](_, Some("http://www.accellera.org/XMLSchema/IPXACT/1685-2022"), Some("vendorExtensions"), __scope, false) } getOrElse {Nil})

  }

  trait DefaultIPXACT2022ScalaCases_ResetsFormat extends IPXACT2022scalaxb.ElemNameParser[IPXACT2022ScalaCases.Resets] {
    val targetNamespace: Option[String] = Some("http://www.accellera.org/XMLSchema/IPXACT/1685-2022")
    
    def parser(node: scala.xml.Node, stack: List[IPXACT2022scalaxb.ElemName]): Parser[IPXACT2022ScalaCases.Resets] =
      phrase(safeRep(IPXACT2022scalaxb.ElemName(Some("http://www.accellera.org/XMLSchema/IPXACT/1685-2022"), "reset")) ^^
      { case p1 =>
      IPXACT2022ScalaCases.Resets(p1 map { IPXACT2022scalaxb.fromXML[IPXACT2022ScalaCases.Reset](_, IPXACT2022scalaxb.ElemName(node) :: stack) }) })
    
    def writesChildNodes(__obj: IPXACT2022ScalaCases.Resets, __scope: scala.xml.NamespaceBinding): Seq[scala.xml.Node] =
      (__obj.reset flatMap { IPXACT2022scalaxb.toXML[IPXACT2022ScalaCases.Reset](_, Some("http://www.accellera.org/XMLSchema/IPXACT/1685-2022"), Some("reset"), __scope, false) })
  }
  trait DefaultIPXACT2022ScalaCases_AliasOfFormat extends IPXACT2022scalaxb.ElemNameParser[IPXACT2022ScalaCases.AliasOf] with IPXACT2022ScalaCases_FieldReferenceGroupGroupFormat {
    val targetNamespace: Option[String] = Some("http://www.accellera.org/XMLSchema/IPXACT/1685-2022")
    
    def parser(node: scala.xml.Node, stack: List[IPXACT2022scalaxb.ElemName]): Parser[IPXACT2022ScalaCases.AliasOf] =
      phrase((parseFieldReferenceGroupGroup(node, IPXACT2022scalaxb.ElemName(node) :: stack)) ^^
      { case p1 =>
      IPXACT2022ScalaCases.AliasOf(p1) })
    
    def writesChildNodes(__obj: IPXACT2022ScalaCases.AliasOf, __scope: scala.xml.NamespaceBinding): Seq[scala.xml.Node] =
      (IPXACT2022scalaxb.toXML[IPXACT2022ScalaCases.FieldReferenceGroupSequence](__obj.fieldReferenceGroupSequence1, None, Some("fieldReferenceGroupSequence1"), __scope, false))
  }
  trait DefaultIPXACT2022ScalaCases_ResetFormat extends IPXACT2022scalaxb.ElemNameParser[IPXACT2022ScalaCases.Reset] {
    val targetNamespace: Option[String] = Some("http://www.accellera.org/XMLSchema/IPXACT/1685-2022")
    
    def parser(node: scala.xml.Node, stack: List[IPXACT2022scalaxb.ElemName]): Parser[IPXACT2022ScalaCases.Reset] =
      phrase((IPXACT2022scalaxb.ElemName(Some("http://www.accellera.org/XMLSchema/IPXACT/1685-2022"), "value")) ~
      opt(IPXACT2022scalaxb.ElemName(Some("http://www.accellera.org/XMLSchema/IPXACT/1685-2022"), "mask")) ^^
      { case p1 ~ p2 =>
      IPXACT2022ScalaCases.Reset(IPXACT2022scalaxb.fromXML[IPXACT2022ScalaCases.UnsignedBitVectorExpressionable](p1, IPXACT2022scalaxb.ElemName(node) :: stack),
        p2.headOption map { IPXACT2022scalaxb.fromXML[IPXACT2022ScalaCases.UnsignedBitVectorExpressionable](_, IPXACT2022scalaxb.ElemName(node) :: stack) },
        scala.collection.immutable.ListMap(List(
        (node \ "@resetTypeRef").headOption map { x => IPXACT2022scalaxb.DataRecord(x, node, IPXACT2022scalaxb.fromXML[String](x, IPXACT2022scalaxb.ElemName(node) :: stack)) } map { "@resetTypeRef" -> _ },
        (node \ "@{http://www.w3.org/XML/1998/namespace}id").headOption map { x => IPXACT2022scalaxb.DataRecord(x, node, IPXACT2022scalaxb.fromXML[String](x, IPXACT2022scalaxb.ElemName(node) :: stack)) } map { "@{http://www.w3.org/XML/1998/namespace}id" -> _ }
        ).flatten[(String, IPXACT2022scalaxb.DataRecord[Any])]: _*)) })
    
    override def writesAttribute(__obj: IPXACT2022ScalaCases.Reset, __scope: scala.xml.NamespaceBinding): scala.xml.MetaData = {
      var attr: scala.xml.MetaData  = scala.xml.Null
      __obj.attributes.toList map {
        case ("@resetTypeRef", _) => __obj.resetTypeRef foreach { x => attr = scala.xml.Attribute(null, "resetTypeRef", x.toString, attr) }
        case ("@{http://www.w3.org/XML/1998/namespace}id", _) => __obj.xmlid foreach { x => attr = scala.xml.Attribute(__scope.getPrefix("http://www.w3.org/XML/1998/namespace"), "id", x.toString, attr) }
        case (key, x) => attr = scala.xml.Attribute((x.namespace map { __scope.getPrefix(_) }).orNull, x.key.orNull, x.value.toString, attr)
      }
      attr
    }

    def writesChildNodes(__obj: IPXACT2022ScalaCases.Reset, __scope: scala.xml.NamespaceBinding): Seq[scala.xml.Node] =
      Seq.concat(IPXACT2022scalaxb.toXML[IPXACT2022ScalaCases.UnsignedBitVectorExpressionable](__obj.value, Some("http://www.accellera.org/XMLSchema/IPXACT/1685-2022"), Some("value"), __scope, false),
        __obj.mask map { IPXACT2022scalaxb.toXML[IPXACT2022ScalaCases.UnsignedBitVectorExpressionable](_, Some("http://www.accellera.org/XMLSchema/IPXACT/1685-2022"), Some("mask"), __scope, false) } getOrElse {Nil})

  }

  trait DefaultIPXACT2022ScalaCases_ExternalTypeDefinitionsFormat extends IPXACT2022scalaxb.ElemNameParser[IPXACT2022ScalaCases.ExternalTypeDefinitions] with IPXACT2022ScalaCases_NameGroupGroupFormat {
    val targetNamespace: Option[String] = Some("http://www.accellera.org/XMLSchema/IPXACT/1685-2022")
    
    def parser(node: scala.xml.Node, stack: List[IPXACT2022scalaxb.ElemName]): Parser[IPXACT2022ScalaCases.ExternalTypeDefinitions] =
      phrase((parseNameGroupGroup(node, IPXACT2022scalaxb.ElemName(node) :: stack)) ~
      (IPXACT2022scalaxb.ElemName(Some("http://www.accellera.org/XMLSchema/IPXACT/1685-2022"), "typeDefinitionsRef")) ~
      opt(IPXACT2022scalaxb.ElemName(Some("http://www.accellera.org/XMLSchema/IPXACT/1685-2022"), "viewLinks")) ~
      opt(IPXACT2022scalaxb.ElemName(Some("http://www.accellera.org/XMLSchema/IPXACT/1685-2022"), "modeLinks")) ~
      opt(IPXACT2022scalaxb.ElemName(Some("http://www.accellera.org/XMLSchema/IPXACT/1685-2022"), "resetTypeLinks")) ~
      opt(IPXACT2022scalaxb.ElemName(Some("http://www.accellera.org/XMLSchema/IPXACT/1685-2022"), "vendorExtensions")) ^^
      { case p1 ~ p2 ~ p3 ~ p4 ~ p5 ~ p6 =>
      IPXACT2022ScalaCases.ExternalTypeDefinitions(p1,
        IPXACT2022scalaxb.fromXML[IPXACT2022ScalaCases.ConfigurableLibraryRefType](p2, IPXACT2022scalaxb.ElemName(node) :: stack),
        p3.headOption map { IPXACT2022scalaxb.fromXML[IPXACT2022ScalaCases.ViewLinks](_, IPXACT2022scalaxb.ElemName(node) :: stack) },
        p4.headOption map { IPXACT2022scalaxb.fromXML[IPXACT2022ScalaCases.ModeLinks](_, IPXACT2022scalaxb.ElemName(node) :: stack) },
        p5.headOption map { IPXACT2022scalaxb.fromXML[IPXACT2022ScalaCases.ResetTypeLinks](_, IPXACT2022scalaxb.ElemName(node) :: stack) },
        p6.headOption map { IPXACT2022scalaxb.fromXML[IPXACT2022ScalaCases.VendorExtensions](_, IPXACT2022scalaxb.ElemName(node) :: stack) },
        scala.collection.immutable.ListMap(List(
        (node \ "@{http://www.w3.org/XML/1998/namespace}id").headOption map { x => IPXACT2022scalaxb.DataRecord(x, node, IPXACT2022scalaxb.fromXML[String](x, IPXACT2022scalaxb.ElemName(node) :: stack)) } map { "@{http://www.w3.org/XML/1998/namespace}id" -> _ }
        ).flatten[(String, IPXACT2022scalaxb.DataRecord[Any])]: _*)) })
    
    override def writesAttribute(__obj: IPXACT2022ScalaCases.ExternalTypeDefinitions, __scope: scala.xml.NamespaceBinding): scala.xml.MetaData = {
      var attr: scala.xml.MetaData  = scala.xml.Null
      __obj.attributes.toList map {
        case ("@{http://www.w3.org/XML/1998/namespace}id", _) => __obj.xmlid foreach { x => attr = scala.xml.Attribute(__scope.getPrefix("http://www.w3.org/XML/1998/namespace"), "id", x.toString, attr) }
        case (key, x) => attr = scala.xml.Attribute((x.namespace map { __scope.getPrefix(_) }).orNull, x.key.orNull, x.value.toString, attr)
      }
      attr
    }

    def writesChildNodes(__obj: IPXACT2022ScalaCases.ExternalTypeDefinitions, __scope: scala.xml.NamespaceBinding): Seq[scala.xml.Node] =
      Seq.concat(IPXACT2022scalaxb.toXML[IPXACT2022ScalaCases.NameGroupSequence](__obj.nameGroupSequence1, None, Some("nameGroupSequence1"), __scope, false),
        IPXACT2022scalaxb.toXML[IPXACT2022ScalaCases.ConfigurableLibraryRefType](__obj.typeDefinitionsRef, Some("http://www.accellera.org/XMLSchema/IPXACT/1685-2022"), Some("typeDefinitionsRef"), __scope, false),
        __obj.viewLinks map { IPXACT2022scalaxb.toXML[IPXACT2022ScalaCases.ViewLinks](_, Some("http://www.accellera.org/XMLSchema/IPXACT/1685-2022"), Some("viewLinks"), __scope, false) } getOrElse {Nil},
        __obj.modeLinks map { IPXACT2022scalaxb.toXML[IPXACT2022ScalaCases.ModeLinks](_, Some("http://www.accellera.org/XMLSchema/IPXACT/1685-2022"), Some("modeLinks"), __scope, false) } getOrElse {Nil},
        __obj.resetTypeLinks map { IPXACT2022scalaxb.toXML[IPXACT2022ScalaCases.ResetTypeLinks](_, Some("http://www.accellera.org/XMLSchema/IPXACT/1685-2022"), Some("resetTypeLinks"), __scope, false) } getOrElse {Nil},
        __obj.vendorExtensions map { IPXACT2022scalaxb.toXML[IPXACT2022ScalaCases.VendorExtensions](_, Some("http://www.accellera.org/XMLSchema/IPXACT/1685-2022"), Some("vendorExtensions"), __scope, false) } getOrElse {Nil})

  }

  trait DefaultIPXACT2022ScalaCases_EnumerationDefinitionFormat extends IPXACT2022scalaxb.ElemNameParser[IPXACT2022ScalaCases.EnumerationDefinition] with IPXACT2022ScalaCases_NameGroupGroupFormat {
    val targetNamespace: Option[String] = Some("http://www.accellera.org/XMLSchema/IPXACT/1685-2022")
    
    def parser(node: scala.xml.Node, stack: List[IPXACT2022scalaxb.ElemName]): Parser[IPXACT2022ScalaCases.EnumerationDefinition] =
      phrase((parseNameGroupGroup(node, IPXACT2022scalaxb.ElemName(node) :: stack)) ~
      (IPXACT2022scalaxb.ElemName(Some("http://www.accellera.org/XMLSchema/IPXACT/1685-2022"), "width")) ~
      safeRep(IPXACT2022scalaxb.ElemName(Some("http://www.accellera.org/XMLSchema/IPXACT/1685-2022"), "enumeratedValue")) ~
      opt(IPXACT2022scalaxb.ElemName(Some("http://www.accellera.org/XMLSchema/IPXACT/1685-2022"), "vendorExtensions")) ^^
      { case p1 ~ p2 ~ p3 ~ p4 =>
      IPXACT2022ScalaCases.EnumerationDefinition(p1,
        IPXACT2022scalaxb.fromXML[IPXACT2022ScalaCases.UnsignedPositiveIntExpressionable](p2, IPXACT2022scalaxb.ElemName(node) :: stack),
        p3 map { IPXACT2022scalaxb.fromXML[IPXACT2022ScalaCases.EnumeratedValueType](_, IPXACT2022scalaxb.ElemName(node) :: stack) },
        p4.headOption map { IPXACT2022scalaxb.fromXML[IPXACT2022ScalaCases.VendorExtensions](_, IPXACT2022scalaxb.ElemName(node) :: stack) },
        scala.collection.immutable.ListMap(List(
        (node \ "@{http://www.w3.org/XML/1998/namespace}id").headOption map { x => IPXACT2022scalaxb.DataRecord(x, node, IPXACT2022scalaxb.fromXML[String](x, IPXACT2022scalaxb.ElemName(node) :: stack)) } map { "@{http://www.w3.org/XML/1998/namespace}id" -> _ }
        ).flatten[(String, IPXACT2022scalaxb.DataRecord[Any])]: _*)) })
    
    override def writesAttribute(__obj: IPXACT2022ScalaCases.EnumerationDefinition, __scope: scala.xml.NamespaceBinding): scala.xml.MetaData = {
      var attr: scala.xml.MetaData  = scala.xml.Null
      __obj.attributes.toList map {
        case ("@{http://www.w3.org/XML/1998/namespace}id", _) => __obj.xmlid foreach { x => attr = scala.xml.Attribute(__scope.getPrefix("http://www.w3.org/XML/1998/namespace"), "id", x.toString, attr) }
        case (key, x) => attr = scala.xml.Attribute((x.namespace map { __scope.getPrefix(_) }).orNull, x.key.orNull, x.value.toString, attr)
      }
      attr
    }

    def writesChildNodes(__obj: IPXACT2022ScalaCases.EnumerationDefinition, __scope: scala.xml.NamespaceBinding): Seq[scala.xml.Node] =
      Seq.concat(IPXACT2022scalaxb.toXML[IPXACT2022ScalaCases.NameGroupSequence](__obj.nameGroupSequence1, None, Some("nameGroupSequence1"), __scope, false),
        IPXACT2022scalaxb.toXML[IPXACT2022ScalaCases.UnsignedPositiveIntExpressionable](__obj.width, Some("http://www.accellera.org/XMLSchema/IPXACT/1685-2022"), Some("width"), __scope, false),
        __obj.enumeratedValue flatMap { IPXACT2022scalaxb.toXML[IPXACT2022ScalaCases.EnumeratedValueType](_, Some("http://www.accellera.org/XMLSchema/IPXACT/1685-2022"), Some("enumeratedValue"), __scope, false) },
        __obj.vendorExtensions map { IPXACT2022scalaxb.toXML[IPXACT2022ScalaCases.VendorExtensions](_, Some("http://www.accellera.org/XMLSchema/IPXACT/1685-2022"), Some("vendorExtensions"), __scope, false) } getOrElse {Nil})

  }

  trait DefaultIPXACT2022ScalaCases_EnumerationDefinitionsFormat extends IPXACT2022scalaxb.ElemNameParser[IPXACT2022ScalaCases.EnumerationDefinitions] {
    val targetNamespace: Option[String] = Some("http://www.accellera.org/XMLSchema/IPXACT/1685-2022")
    
    def parser(node: scala.xml.Node, stack: List[IPXACT2022scalaxb.ElemName]): Parser[IPXACT2022ScalaCases.EnumerationDefinitions] =
      phrase(safeRep(IPXACT2022scalaxb.ElemName(Some("http://www.accellera.org/XMLSchema/IPXACT/1685-2022"), "enumerationDefinition")) ^^
      { case p1 =>
      IPXACT2022ScalaCases.EnumerationDefinitions(p1 map { IPXACT2022scalaxb.fromXML[IPXACT2022ScalaCases.EnumerationDefinition](_, IPXACT2022scalaxb.ElemName(node) :: stack) }) })
    
    def writesChildNodes(__obj: IPXACT2022ScalaCases.EnumerationDefinitions, __scope: scala.xml.NamespaceBinding): Seq[scala.xml.Node] =
      (__obj.enumerationDefinition flatMap { IPXACT2022scalaxb.toXML[IPXACT2022ScalaCases.EnumerationDefinition](_, Some("http://www.accellera.org/XMLSchema/IPXACT/1685-2022"), Some("enumerationDefinition"), __scope, false) })
  }
  trait DefaultIPXACT2022ScalaCases_FieldAccessPolicyDefinitionFormat extends IPXACT2022scalaxb.ElemNameParser[IPXACT2022ScalaCases.FieldAccessPolicyDefinition] with IPXACT2022ScalaCases_NameGroupGroupFormat {
    val targetNamespace: Option[String] = Some("http://www.accellera.org/XMLSchema/IPXACT/1685-2022")
    
    def parser(node: scala.xml.Node, stack: List[IPXACT2022scalaxb.ElemName]): Parser[IPXACT2022ScalaCases.FieldAccessPolicyDefinition] =
      phrase((parseNameGroupGroup(node, IPXACT2022scalaxb.ElemName(node) :: stack)) ~
      opt(IPXACT2022scalaxb.ElemName(Some("http://www.accellera.org/XMLSchema/IPXACT/1685-2022"), "access")) ~
      opt(IPXACT2022scalaxb.ElemName(Some("http://www.accellera.org/XMLSchema/IPXACT/1685-2022"), "modifiedWriteValue")) ~
      opt(IPXACT2022scalaxb.ElemName(Some("http://www.accellera.org/XMLSchema/IPXACT/1685-2022"), "writeValueConstraint")) ~
      opt(IPXACT2022scalaxb.ElemName(Some("http://www.accellera.org/XMLSchema/IPXACT/1685-2022"), "readAction")) ~
      opt(IPXACT2022scalaxb.ElemName(Some("http://www.accellera.org/XMLSchema/IPXACT/1685-2022"), "readResponse")) ~
      opt(IPXACT2022scalaxb.ElemName(Some("http://www.accellera.org/XMLSchema/IPXACT/1685-2022"), "vendorExtensions")) ^^
      { case p1 ~ p2 ~ p3 ~ p4 ~ p5 ~ p6 ~ p7 =>
      IPXACT2022ScalaCases.FieldAccessPolicyDefinition(p1,
        p2.headOption map { IPXACT2022scalaxb.fromXML[IPXACT2022ScalaCases.AccessType](_, IPXACT2022scalaxb.ElemName(node) :: stack) },
        p3.headOption map { IPXACT2022scalaxb.fromXML[IPXACT2022ScalaCases.ModifiedWriteValue](_, IPXACT2022scalaxb.ElemName(node) :: stack) },
        p4.headOption map { IPXACT2022scalaxb.fromXML[IPXACT2022ScalaCases.WriteValueConstraintType](_, IPXACT2022scalaxb.ElemName(node) :: stack) },
        p5.headOption map { IPXACT2022scalaxb.fromXML[IPXACT2022ScalaCases.ReadAction](_, IPXACT2022scalaxb.ElemName(node) :: stack) },
        p6.headOption map { IPXACT2022scalaxb.fromXML[IPXACT2022ScalaCases.UnsignedBitVectorExpressionable](_, IPXACT2022scalaxb.ElemName(node) :: stack) },
        p7.headOption map { IPXACT2022scalaxb.fromXML[IPXACT2022ScalaCases.VendorExtensions](_, IPXACT2022scalaxb.ElemName(node) :: stack) },
        scala.collection.immutable.ListMap(List(
        (node \ "@{http://www.w3.org/XML/1998/namespace}id").headOption map { x => IPXACT2022scalaxb.DataRecord(x, node, IPXACT2022scalaxb.fromXML[String](x, IPXACT2022scalaxb.ElemName(node) :: stack)) } map { "@{http://www.w3.org/XML/1998/namespace}id" -> _ }
        ).flatten[(String, IPXACT2022scalaxb.DataRecord[Any])]: _*)) })
    
    override def writesAttribute(__obj: IPXACT2022ScalaCases.FieldAccessPolicyDefinition, __scope: scala.xml.NamespaceBinding): scala.xml.MetaData = {
      var attr: scala.xml.MetaData  = scala.xml.Null
      __obj.attributes.toList map {
        case ("@{http://www.w3.org/XML/1998/namespace}id", _) => __obj.xmlid foreach { x => attr = scala.xml.Attribute(__scope.getPrefix("http://www.w3.org/XML/1998/namespace"), "id", x.toString, attr) }
        case (key, x) => attr = scala.xml.Attribute((x.namespace map { __scope.getPrefix(_) }).orNull, x.key.orNull, x.value.toString, attr)
      }
      attr
    }

    def writesChildNodes(__obj: IPXACT2022ScalaCases.FieldAccessPolicyDefinition, __scope: scala.xml.NamespaceBinding): Seq[scala.xml.Node] =
      Seq.concat(IPXACT2022scalaxb.toXML[IPXACT2022ScalaCases.NameGroupSequence](__obj.nameGroupSequence1, None, Some("nameGroupSequence1"), __scope, false),
        __obj.access map { IPXACT2022scalaxb.toXML[IPXACT2022ScalaCases.AccessType](_, Some("http://www.accellera.org/XMLSchema/IPXACT/1685-2022"), Some("access"), __scope, false) } getOrElse {Nil},
        __obj.modifiedWriteValue map { IPXACT2022scalaxb.toXML[IPXACT2022ScalaCases.ModifiedWriteValue](_, Some("http://www.accellera.org/XMLSchema/IPXACT/1685-2022"), Some("modifiedWriteValue"), __scope, false) } getOrElse {Nil},
        __obj.writeValueConstraint map { IPXACT2022scalaxb.toXML[IPXACT2022ScalaCases.WriteValueConstraintType](_, Some("http://www.accellera.org/XMLSchema/IPXACT/1685-2022"), Some("writeValueConstraint"), __scope, false) } getOrElse {Nil},
        __obj.readAction map { IPXACT2022scalaxb.toXML[IPXACT2022ScalaCases.ReadAction](_, Some("http://www.accellera.org/XMLSchema/IPXACT/1685-2022"), Some("readAction"), __scope, false) } getOrElse {Nil},
        __obj.readResponse map { IPXACT2022scalaxb.toXML[IPXACT2022ScalaCases.UnsignedBitVectorExpressionable](_, Some("http://www.accellera.org/XMLSchema/IPXACT/1685-2022"), Some("readResponse"), __scope, false) } getOrElse {Nil},
        __obj.vendorExtensions map { IPXACT2022scalaxb.toXML[IPXACT2022ScalaCases.VendorExtensions](_, Some("http://www.accellera.org/XMLSchema/IPXACT/1685-2022"), Some("vendorExtensions"), __scope, false) } getOrElse {Nil})

  }

  trait DefaultIPXACT2022ScalaCases_FieldAccessPolicyDefinitionsFormat extends IPXACT2022scalaxb.ElemNameParser[IPXACT2022ScalaCases.FieldAccessPolicyDefinitions] {
    val targetNamespace: Option[String] = Some("http://www.accellera.org/XMLSchema/IPXACT/1685-2022")
    
    def parser(node: scala.xml.Node, stack: List[IPXACT2022scalaxb.ElemName]): Parser[IPXACT2022ScalaCases.FieldAccessPolicyDefinitions] =
      phrase(safeRep(IPXACT2022scalaxb.ElemName(Some("http://www.accellera.org/XMLSchema/IPXACT/1685-2022"), "fieldAccessPolicyDefinition")) ^^
      { case p1 =>
      IPXACT2022ScalaCases.FieldAccessPolicyDefinitions(p1 map { IPXACT2022scalaxb.fromXML[IPXACT2022ScalaCases.FieldAccessPolicyDefinition](_, IPXACT2022scalaxb.ElemName(node) :: stack) }) })
    
    def writesChildNodes(__obj: IPXACT2022ScalaCases.FieldAccessPolicyDefinitions, __scope: scala.xml.NamespaceBinding): Seq[scala.xml.Node] =
      (__obj.fieldAccessPolicyDefinition flatMap { IPXACT2022scalaxb.toXML[IPXACT2022ScalaCases.FieldAccessPolicyDefinition](_, Some("http://www.accellera.org/XMLSchema/IPXACT/1685-2022"), Some("fieldAccessPolicyDefinition"), __scope, false) })
  }
  trait DefaultIPXACT2022ScalaCases_Resets2Format extends IPXACT2022scalaxb.ElemNameParser[IPXACT2022ScalaCases.Resets2] {
    val targetNamespace: Option[String] = Some("http://www.accellera.org/XMLSchema/IPXACT/1685-2022")
    
    def parser(node: scala.xml.Node, stack: List[IPXACT2022scalaxb.ElemName]): Parser[IPXACT2022ScalaCases.Resets2] =
      phrase(safeRep(IPXACT2022scalaxb.ElemName(Some("http://www.accellera.org/XMLSchema/IPXACT/1685-2022"), "reset")) ^^
      { case p1 =>
      IPXACT2022ScalaCases.Resets2(p1 map { IPXACT2022scalaxb.fromXML[IPXACT2022ScalaCases.Reset](_, IPXACT2022scalaxb.ElemName(node) :: stack) }) })
    
    def writesChildNodes(__obj: IPXACT2022ScalaCases.Resets2, __scope: scala.xml.NamespaceBinding): Seq[scala.xml.Node] =
      (__obj.reset flatMap { IPXACT2022scalaxb.toXML[IPXACT2022ScalaCases.Reset](_, Some("http://www.accellera.org/XMLSchema/IPXACT/1685-2022"), Some("reset"), __scope, false) })
  }
  trait DefaultIPXACT2022ScalaCases_FieldDefinitionFormat extends IPXACT2022scalaxb.ElemNameParser[IPXACT2022ScalaCases.FieldDefinition] with IPXACT2022ScalaCases_NameGroupGroupFormat with IPXACT2022ScalaCases_FieldDataGroupFormat {
    val targetNamespace: Option[String] = Some("http://www.accellera.org/XMLSchema/IPXACT/1685-2022")
    
    def parser(node: scala.xml.Node, stack: List[IPXACT2022scalaxb.ElemName]): Parser[IPXACT2022ScalaCases.FieldDefinition] =
      phrase((parseNameGroupGroup(node, IPXACT2022scalaxb.ElemName(node) :: stack)) ~
      opt(IPXACT2022scalaxb.ElemName(Some("http://www.accellera.org/XMLSchema/IPXACT/1685-2022"), "typeIdentifier")) ~
      (IPXACT2022scalaxb.ElemName(Some("http://www.accellera.org/XMLSchema/IPXACT/1685-2022"), "bitWidth")) ~
      opt(IPXACT2022scalaxb.ElemName(Some("http://www.accellera.org/XMLSchema/IPXACT/1685-2022"), "volatile")) ~
      opt(IPXACT2022scalaxb.ElemName(Some("http://www.accellera.org/XMLSchema/IPXACT/1685-2022"), "resets")) ~
      (parseFieldDataGroup(node, IPXACT2022scalaxb.ElemName(node) :: stack)) ~
      opt(IPXACT2022scalaxb.ElemName(Some("http://www.accellera.org/XMLSchema/IPXACT/1685-2022"), "vendorExtensions")) ^^
      { case p1 ~ p2 ~ p3 ~ p4 ~ p5 ~ p6 ~ p7 =>
      IPXACT2022ScalaCases.FieldDefinition(p1,
        p2.headOption map { IPXACT2022scalaxb.fromXML[String](_, IPXACT2022scalaxb.ElemName(node) :: stack) },
        IPXACT2022scalaxb.fromXML[IPXACT2022ScalaCases.UnsignedPositiveIntExpressionable](p3, IPXACT2022scalaxb.ElemName(node) :: stack),
        p4.headOption map { IPXACT2022scalaxb.fromXML[Boolean](_, IPXACT2022scalaxb.ElemName(node) :: stack) },
        p5.headOption map { IPXACT2022scalaxb.fromXML[IPXACT2022ScalaCases.Resets2](_, IPXACT2022scalaxb.ElemName(node) :: stack) },
        p6,
        p7.headOption map { IPXACT2022scalaxb.fromXML[IPXACT2022ScalaCases.VendorExtensions](_, IPXACT2022scalaxb.ElemName(node) :: stack) },
        scala.collection.immutable.ListMap(List(
        (node \ "@{http://www.w3.org/XML/1998/namespace}id").headOption map { x => IPXACT2022scalaxb.DataRecord(x, node, IPXACT2022scalaxb.fromXML[String](x, IPXACT2022scalaxb.ElemName(node) :: stack)) } map { "@{http://www.w3.org/XML/1998/namespace}id" -> _ }
        ).flatten[(String, IPXACT2022scalaxb.DataRecord[Any])]: _*)) })
    
    override def writesAttribute(__obj: IPXACT2022ScalaCases.FieldDefinition, __scope: scala.xml.NamespaceBinding): scala.xml.MetaData = {
      var attr: scala.xml.MetaData  = scala.xml.Null
      __obj.attributes.toList map {
        case ("@{http://www.w3.org/XML/1998/namespace}id", _) => __obj.xmlid foreach { x => attr = scala.xml.Attribute(__scope.getPrefix("http://www.w3.org/XML/1998/namespace"), "id", x.toString, attr) }
        case (key, x) => attr = scala.xml.Attribute((x.namespace map { __scope.getPrefix(_) }).orNull, x.key.orNull, x.value.toString, attr)
      }
      attr
    }

    def writesChildNodes(__obj: IPXACT2022ScalaCases.FieldDefinition, __scope: scala.xml.NamespaceBinding): Seq[scala.xml.Node] =
      Seq.concat(IPXACT2022scalaxb.toXML[IPXACT2022ScalaCases.NameGroupSequence](__obj.nameGroupSequence1, None, Some("nameGroupSequence1"), __scope, false),
        __obj.typeIdentifier map { IPXACT2022scalaxb.toXML[String](_, Some("http://www.accellera.org/XMLSchema/IPXACT/1685-2022"), Some("typeIdentifier"), __scope, false) } getOrElse {Nil},
        IPXACT2022scalaxb.toXML[IPXACT2022ScalaCases.UnsignedPositiveIntExpressionable](__obj.bitWidth, Some("http://www.accellera.org/XMLSchema/IPXACT/1685-2022"), Some("bitWidth"), __scope, false),
        __obj.volatile map { IPXACT2022scalaxb.toXML[Boolean](_, Some("http://www.accellera.org/XMLSchema/IPXACT/1685-2022"), Some("volatile"), __scope, false) } getOrElse {Nil},
        __obj.resets map { IPXACT2022scalaxb.toXML[IPXACT2022ScalaCases.Resets2](_, Some("http://www.accellera.org/XMLSchema/IPXACT/1685-2022"), Some("resets"), __scope, false) } getOrElse {Nil},
        IPXACT2022scalaxb.toXML[IPXACT2022ScalaCases.FieldDataSequence](__obj.fieldDataSequence6, None, Some("fieldDataSequence6"), __scope, false),
        __obj.vendorExtensions map { IPXACT2022scalaxb.toXML[IPXACT2022ScalaCases.VendorExtensions](_, Some("http://www.accellera.org/XMLSchema/IPXACT/1685-2022"), Some("vendorExtensions"), __scope, false) } getOrElse {Nil})

  }

  trait DefaultIPXACT2022ScalaCases_FieldDefinitionsFormat extends IPXACT2022scalaxb.ElemNameParser[IPXACT2022ScalaCases.FieldDefinitions] {
    val targetNamespace: Option[String] = Some("http://www.accellera.org/XMLSchema/IPXACT/1685-2022")
    
    def parser(node: scala.xml.Node, stack: List[IPXACT2022scalaxb.ElemName]): Parser[IPXACT2022ScalaCases.FieldDefinitions] =
      phrase(safeRep(IPXACT2022scalaxb.ElemName(Some("http://www.accellera.org/XMLSchema/IPXACT/1685-2022"), "fieldDefinition")) ^^
      { case p1 =>
      IPXACT2022ScalaCases.FieldDefinitions(p1 map { IPXACT2022scalaxb.fromXML[IPXACT2022ScalaCases.FieldDefinition](_, IPXACT2022scalaxb.ElemName(node) :: stack) }) })
    
    def writesChildNodes(__obj: IPXACT2022ScalaCases.FieldDefinitions, __scope: scala.xml.NamespaceBinding): Seq[scala.xml.Node] =
      (__obj.fieldDefinition flatMap { IPXACT2022scalaxb.toXML[IPXACT2022ScalaCases.FieldDefinition](_, Some("http://www.accellera.org/XMLSchema/IPXACT/1685-2022"), Some("fieldDefinition"), __scope, false) })
  }
  trait DefaultIPXACT2022ScalaCases_RegisterDefinitionFormat extends IPXACT2022scalaxb.ElemNameParser[IPXACT2022ScalaCases.RegisterDefinition] with IPXACT2022ScalaCases_NameGroupGroupFormat with IPXACT2022ScalaCases_RegisterDefinitionGroupGroupFormat {
    val targetNamespace: Option[String] = Some("http://www.accellera.org/XMLSchema/IPXACT/1685-2022")
    
    def parser(node: scala.xml.Node, stack: List[IPXACT2022scalaxb.ElemName]): Parser[IPXACT2022ScalaCases.RegisterDefinition] =
      phrase((parseNameGroupGroup(node, IPXACT2022scalaxb.ElemName(node) :: stack)) ~
      (parseRegisterDefinitionGroupGroup(node, IPXACT2022scalaxb.ElemName(node) :: stack)) ~
      opt(IPXACT2022scalaxb.ElemName(Some("http://www.accellera.org/XMLSchema/IPXACT/1685-2022"), "vendorExtensions")) ^^
      { case p1 ~ p2 ~ p3 =>
      IPXACT2022ScalaCases.RegisterDefinition(p1,
        p2,
        p3.headOption map { IPXACT2022scalaxb.fromXML[IPXACT2022ScalaCases.VendorExtensions](_, IPXACT2022scalaxb.ElemName(node) :: stack) },
        scala.collection.immutable.ListMap(List(
        (node \ "@{http://www.w3.org/XML/1998/namespace}id").headOption map { x => IPXACT2022scalaxb.DataRecord(x, node, IPXACT2022scalaxb.fromXML[String](x, IPXACT2022scalaxb.ElemName(node) :: stack)) } map { "@{http://www.w3.org/XML/1998/namespace}id" -> _ }
        ).flatten[(String, IPXACT2022scalaxb.DataRecord[Any])]: _*)) })
    
    override def writesAttribute(__obj: IPXACT2022ScalaCases.RegisterDefinition, __scope: scala.xml.NamespaceBinding): scala.xml.MetaData = {
      var attr: scala.xml.MetaData  = scala.xml.Null
      __obj.attributes.toList map {
        case ("@{http://www.w3.org/XML/1998/namespace}id", _) => __obj.xmlid foreach { x => attr = scala.xml.Attribute(__scope.getPrefix("http://www.w3.org/XML/1998/namespace"), "id", x.toString, attr) }
        case (key, x) => attr = scala.xml.Attribute((x.namespace map { __scope.getPrefix(_) }).orNull, x.key.orNull, x.value.toString, attr)
      }
      attr
    }

    def writesChildNodes(__obj: IPXACT2022ScalaCases.RegisterDefinition, __scope: scala.xml.NamespaceBinding): Seq[scala.xml.Node] =
      Seq.concat(IPXACT2022scalaxb.toXML[IPXACT2022ScalaCases.NameGroupSequence](__obj.nameGroupSequence1, None, Some("nameGroupSequence1"), __scope, false),
        IPXACT2022scalaxb.toXML[IPXACT2022ScalaCases.RegisterDefinitionGroupSequence](__obj.registerDefinitionGroupSequence2, None, Some("registerDefinitionGroupSequence2"), __scope, false),
        __obj.vendorExtensions map { IPXACT2022scalaxb.toXML[IPXACT2022ScalaCases.VendorExtensions](_, Some("http://www.accellera.org/XMLSchema/IPXACT/1685-2022"), Some("vendorExtensions"), __scope, false) } getOrElse {Nil})

  }

  trait DefaultIPXACT2022ScalaCases_RegisterDefinitionsFormat extends IPXACT2022scalaxb.ElemNameParser[IPXACT2022ScalaCases.RegisterDefinitions] {
    val targetNamespace: Option[String] = Some("http://www.accellera.org/XMLSchema/IPXACT/1685-2022")
    
    def parser(node: scala.xml.Node, stack: List[IPXACT2022scalaxb.ElemName]): Parser[IPXACT2022ScalaCases.RegisterDefinitions] =
      phrase(safeRep(IPXACT2022scalaxb.ElemName(Some("http://www.accellera.org/XMLSchema/IPXACT/1685-2022"), "registerDefinition")) ^^
      { case p1 =>
      IPXACT2022ScalaCases.RegisterDefinitions(p1 map { IPXACT2022scalaxb.fromXML[IPXACT2022ScalaCases.RegisterDefinition](_, IPXACT2022scalaxb.ElemName(node) :: stack) }) })
    
    def writesChildNodes(__obj: IPXACT2022ScalaCases.RegisterDefinitions, __scope: scala.xml.NamespaceBinding): Seq[scala.xml.Node] =
      (__obj.registerDefinition flatMap { IPXACT2022scalaxb.toXML[IPXACT2022ScalaCases.RegisterDefinition](_, Some("http://www.accellera.org/XMLSchema/IPXACT/1685-2022"), Some("registerDefinition"), __scope, false) })
  }
  trait DefaultIPXACT2022ScalaCases_RegisterFileDefinitionFormat extends IPXACT2022scalaxb.ElemNameParser[IPXACT2022ScalaCases.RegisterFileDefinition] with IPXACT2022ScalaCases_NameGroupGroupFormat with IPXACT2022ScalaCases_RegisterFileDefinitionGroupGroupFormat {
    val targetNamespace: Option[String] = Some("http://www.accellera.org/XMLSchema/IPXACT/1685-2022")
    
    def parser(node: scala.xml.Node, stack: List[IPXACT2022scalaxb.ElemName]): Parser[IPXACT2022ScalaCases.RegisterFileDefinition] =
      phrase((parseNameGroupGroup(node, IPXACT2022scalaxb.ElemName(node) :: stack)) ~
      (parseRegisterFileDefinitionGroupGroup(node, IPXACT2022scalaxb.ElemName(node) :: stack)) ~
      opt(IPXACT2022scalaxb.ElemName(Some("http://www.accellera.org/XMLSchema/IPXACT/1685-2022"), "addressUnitBits")) ~
      opt(IPXACT2022scalaxb.ElemName(Some("http://www.accellera.org/XMLSchema/IPXACT/1685-2022"), "vendorExtensions")) ^^
      { case p1 ~ p2 ~ p3 ~ p4 =>
      IPXACT2022ScalaCases.RegisterFileDefinition(p1,
        p2,
        p3.headOption map { IPXACT2022scalaxb.fromXML[IPXACT2022ScalaCases.UnsignedPositiveLongintExpressionable](_, IPXACT2022scalaxb.ElemName(node) :: stack) },
        p4.headOption map { IPXACT2022scalaxb.fromXML[IPXACT2022ScalaCases.VendorExtensions](_, IPXACT2022scalaxb.ElemName(node) :: stack) },
        scala.collection.immutable.ListMap(List(
        (node \ "@{http://www.w3.org/XML/1998/namespace}id").headOption map { x => IPXACT2022scalaxb.DataRecord(x, node, IPXACT2022scalaxb.fromXML[String](x, IPXACT2022scalaxb.ElemName(node) :: stack)) } map { "@{http://www.w3.org/XML/1998/namespace}id" -> _ }
        ).flatten[(String, IPXACT2022scalaxb.DataRecord[Any])]: _*)) })
    
    override def writesAttribute(__obj: IPXACT2022ScalaCases.RegisterFileDefinition, __scope: scala.xml.NamespaceBinding): scala.xml.MetaData = {
      var attr: scala.xml.MetaData  = scala.xml.Null
      __obj.attributes.toList map {
        case ("@{http://www.w3.org/XML/1998/namespace}id", _) => __obj.xmlid foreach { x => attr = scala.xml.Attribute(__scope.getPrefix("http://www.w3.org/XML/1998/namespace"), "id", x.toString, attr) }
        case (key, x) => attr = scala.xml.Attribute((x.namespace map { __scope.getPrefix(_) }).orNull, x.key.orNull, x.value.toString, attr)
      }
      attr
    }

    def writesChildNodes(__obj: IPXACT2022ScalaCases.RegisterFileDefinition, __scope: scala.xml.NamespaceBinding): Seq[scala.xml.Node] =
      Seq.concat(IPXACT2022scalaxb.toXML[IPXACT2022ScalaCases.NameGroupSequence](__obj.nameGroupSequence1, None, Some("nameGroupSequence1"), __scope, false),
        IPXACT2022scalaxb.toXML[IPXACT2022ScalaCases.RegisterFileDefinitionGroupSequence](__obj.registerFileDefinitionGroupSequence2, None, Some("registerFileDefinitionGroupSequence2"), __scope, false),
        __obj.addressUnitBits map { IPXACT2022scalaxb.toXML[IPXACT2022ScalaCases.UnsignedPositiveLongintExpressionable](_, Some("http://www.accellera.org/XMLSchema/IPXACT/1685-2022"), Some("addressUnitBits"), __scope, false) } getOrElse {Nil},
        __obj.vendorExtensions map { IPXACT2022scalaxb.toXML[IPXACT2022ScalaCases.VendorExtensions](_, Some("http://www.accellera.org/XMLSchema/IPXACT/1685-2022"), Some("vendorExtensions"), __scope, false) } getOrElse {Nil})

  }

  trait DefaultIPXACT2022ScalaCases_RegisterFileDefinitionsFormat extends IPXACT2022scalaxb.ElemNameParser[IPXACT2022ScalaCases.RegisterFileDefinitions] {
    val targetNamespace: Option[String] = Some("http://www.accellera.org/XMLSchema/IPXACT/1685-2022")
    
    def parser(node: scala.xml.Node, stack: List[IPXACT2022scalaxb.ElemName]): Parser[IPXACT2022ScalaCases.RegisterFileDefinitions] =
      phrase(safeRep(IPXACT2022scalaxb.ElemName(Some("http://www.accellera.org/XMLSchema/IPXACT/1685-2022"), "registerFileDefinition")) ^^
      { case p1 =>
      IPXACT2022ScalaCases.RegisterFileDefinitions(p1 map { IPXACT2022scalaxb.fromXML[IPXACT2022ScalaCases.RegisterFileDefinition](_, IPXACT2022scalaxb.ElemName(node) :: stack) }) })
    
    def writesChildNodes(__obj: IPXACT2022ScalaCases.RegisterFileDefinitions, __scope: scala.xml.NamespaceBinding): Seq[scala.xml.Node] =
      (__obj.registerFileDefinition flatMap { IPXACT2022scalaxb.toXML[IPXACT2022ScalaCases.RegisterFileDefinition](_, Some("http://www.accellera.org/XMLSchema/IPXACT/1685-2022"), Some("registerFileDefinition"), __scope, false) })
  }
  trait DefaultIPXACT2022ScalaCases_AddressBlockDefinitionFormat extends IPXACT2022scalaxb.ElemNameParser[IPXACT2022ScalaCases.AddressBlockDefinition] with IPXACT2022ScalaCases_NameGroupGroupFormat with IPXACT2022ScalaCases_AddressBlockDefinitionGroupGroupFormat {
    val targetNamespace: Option[String] = Some("http://www.accellera.org/XMLSchema/IPXACT/1685-2022")
    
    def parser(node: scala.xml.Node, stack: List[IPXACT2022scalaxb.ElemName]): Parser[IPXACT2022ScalaCases.AddressBlockDefinition] =
      phrase((parseNameGroupGroup(node, IPXACT2022scalaxb.ElemName(node) :: stack)) ~
      (parseAddressBlockDefinitionGroupGroup(node, IPXACT2022scalaxb.ElemName(node) :: stack)) ~
      opt(IPXACT2022scalaxb.ElemName(Some("http://www.accellera.org/XMLSchema/IPXACT/1685-2022"), "addressUnitBits")) ~
      opt(IPXACT2022scalaxb.ElemName(Some("http://www.accellera.org/XMLSchema/IPXACT/1685-2022"), "vendorExtensions")) ^^
      { case p1 ~ p2 ~ p3 ~ p4 =>
      IPXACT2022ScalaCases.AddressBlockDefinition(p1,
        p2,
        p3.headOption map { IPXACT2022scalaxb.fromXML[IPXACT2022ScalaCases.UnsignedPositiveLongintExpressionable](_, IPXACT2022scalaxb.ElemName(node) :: stack) },
        p4.headOption map { IPXACT2022scalaxb.fromXML[IPXACT2022ScalaCases.VendorExtensions](_, IPXACT2022scalaxb.ElemName(node) :: stack) },
        scala.collection.immutable.ListMap(List(
        (node \ "@{http://www.w3.org/XML/1998/namespace}id").headOption map { x => IPXACT2022scalaxb.DataRecord(x, node, IPXACT2022scalaxb.fromXML[String](x, IPXACT2022scalaxb.ElemName(node) :: stack)) } map { "@{http://www.w3.org/XML/1998/namespace}id" -> _ }
        ).flatten[(String, IPXACT2022scalaxb.DataRecord[Any])]: _*)) })
    
    override def writesAttribute(__obj: IPXACT2022ScalaCases.AddressBlockDefinition, __scope: scala.xml.NamespaceBinding): scala.xml.MetaData = {
      var attr: scala.xml.MetaData  = scala.xml.Null
      __obj.attributes.toList map {
        case ("@{http://www.w3.org/XML/1998/namespace}id", _) => __obj.xmlid foreach { x => attr = scala.xml.Attribute(__scope.getPrefix("http://www.w3.org/XML/1998/namespace"), "id", x.toString, attr) }
        case (key, x) => attr = scala.xml.Attribute((x.namespace map { __scope.getPrefix(_) }).orNull, x.key.orNull, x.value.toString, attr)
      }
      attr
    }

    def writesChildNodes(__obj: IPXACT2022ScalaCases.AddressBlockDefinition, __scope: scala.xml.NamespaceBinding): Seq[scala.xml.Node] =
      Seq.concat(IPXACT2022scalaxb.toXML[IPXACT2022ScalaCases.NameGroupSequence](__obj.nameGroupSequence1, None, Some("nameGroupSequence1"), __scope, false),
        IPXACT2022scalaxb.toXML[IPXACT2022ScalaCases.AddressBlockDefinitionGroupSequence](__obj.addressBlockDefinitionGroupSequence2, None, Some("addressBlockDefinitionGroupSequence2"), __scope, false),
        __obj.addressUnitBits map { IPXACT2022scalaxb.toXML[IPXACT2022ScalaCases.UnsignedPositiveLongintExpressionable](_, Some("http://www.accellera.org/XMLSchema/IPXACT/1685-2022"), Some("addressUnitBits"), __scope, false) } getOrElse {Nil},
        __obj.vendorExtensions map { IPXACT2022scalaxb.toXML[IPXACT2022ScalaCases.VendorExtensions](_, Some("http://www.accellera.org/XMLSchema/IPXACT/1685-2022"), Some("vendorExtensions"), __scope, false) } getOrElse {Nil})

  }

  trait DefaultIPXACT2022ScalaCases_AddressBlockDefinitionsFormat extends IPXACT2022scalaxb.ElemNameParser[IPXACT2022ScalaCases.AddressBlockDefinitions] {
    val targetNamespace: Option[String] = Some("http://www.accellera.org/XMLSchema/IPXACT/1685-2022")
    
    def parser(node: scala.xml.Node, stack: List[IPXACT2022scalaxb.ElemName]): Parser[IPXACT2022ScalaCases.AddressBlockDefinitions] =
      phrase(safeRep(IPXACT2022scalaxb.ElemName(Some("http://www.accellera.org/XMLSchema/IPXACT/1685-2022"), "addressBlockDefinition")) ^^
      { case p1 =>
      IPXACT2022ScalaCases.AddressBlockDefinitions(p1 map { IPXACT2022scalaxb.fromXML[IPXACT2022ScalaCases.AddressBlockDefinition](_, IPXACT2022scalaxb.ElemName(node) :: stack) }) })
    
    def writesChildNodes(__obj: IPXACT2022ScalaCases.AddressBlockDefinitions, __scope: scala.xml.NamespaceBinding): Seq[scala.xml.Node] =
      (__obj.addressBlockDefinition flatMap { IPXACT2022scalaxb.toXML[IPXACT2022ScalaCases.AddressBlockDefinition](_, Some("http://www.accellera.org/XMLSchema/IPXACT/1685-2022"), Some("addressBlockDefinition"), __scope, false) })
  }
  trait DefaultIPXACT2022ScalaCases_BankDefinitionFormat extends IPXACT2022scalaxb.ElemNameParser[IPXACT2022ScalaCases.BankDefinition] with IPXACT2022ScalaCases_NameGroupGroupFormat with IPXACT2022ScalaCases_BankDefinitionBaseGroupFormat {
    val targetNamespace: Option[String] = Some("http://www.accellera.org/XMLSchema/IPXACT/1685-2022")
    
    def parser(node: scala.xml.Node, stack: List[IPXACT2022scalaxb.ElemName]): Parser[IPXACT2022ScalaCases.BankDefinition] =
      phrase((parseNameGroupGroup(node, IPXACT2022scalaxb.ElemName(node) :: stack)) ~
      (parseBankDefinitionBaseGroup(node, IPXACT2022scalaxb.ElemName(node) :: stack)) ~
      opt(IPXACT2022scalaxb.ElemName(Some("http://www.accellera.org/XMLSchema/IPXACT/1685-2022"), "addressUnitBits")) ~
      opt(IPXACT2022scalaxb.ElemName(Some("http://www.accellera.org/XMLSchema/IPXACT/1685-2022"), "vendorExtensions")) ^^
      { case p1 ~ p2 ~ p3 ~ p4 =>
      IPXACT2022ScalaCases.BankDefinition(p1,
        p2,
        p3.headOption map { IPXACT2022scalaxb.fromXML[IPXACT2022ScalaCases.UnsignedPositiveLongintExpressionable](_, IPXACT2022scalaxb.ElemName(node) :: stack) },
        p4.headOption map { IPXACT2022scalaxb.fromXML[IPXACT2022ScalaCases.VendorExtensions](_, IPXACT2022scalaxb.ElemName(node) :: stack) },
        scala.collection.immutable.ListMap(List(
        (node \ "@{http://www.w3.org/XML/1998/namespace}id").headOption map { x => IPXACT2022scalaxb.DataRecord(x, node, IPXACT2022scalaxb.fromXML[String](x, IPXACT2022scalaxb.ElemName(node) :: stack)) } map { "@{http://www.w3.org/XML/1998/namespace}id" -> _ }
        ).flatten[(String, IPXACT2022scalaxb.DataRecord[Any])]: _*)) })
    
    override def writesAttribute(__obj: IPXACT2022ScalaCases.BankDefinition, __scope: scala.xml.NamespaceBinding): scala.xml.MetaData = {
      var attr: scala.xml.MetaData  = scala.xml.Null
      __obj.attributes.toList map {
        case ("@{http://www.w3.org/XML/1998/namespace}id", _) => __obj.xmlid foreach { x => attr = scala.xml.Attribute(__scope.getPrefix("http://www.w3.org/XML/1998/namespace"), "id", x.toString, attr) }
        case (key, x) => attr = scala.xml.Attribute((x.namespace map { __scope.getPrefix(_) }).orNull, x.key.orNull, x.value.toString, attr)
      }
      attr
    }

    def writesChildNodes(__obj: IPXACT2022ScalaCases.BankDefinition, __scope: scala.xml.NamespaceBinding): Seq[scala.xml.Node] =
      Seq.concat(IPXACT2022scalaxb.toXML[IPXACT2022ScalaCases.NameGroupSequence](__obj.nameGroupSequence1, None, Some("nameGroupSequence1"), __scope, false),
        IPXACT2022scalaxb.toXML[IPXACT2022ScalaCases.BankDefinitionBaseSequence](__obj.bankDefinitionBaseSequence2, None, Some("bankDefinitionBaseSequence2"), __scope, false),
        __obj.addressUnitBits map { IPXACT2022scalaxb.toXML[IPXACT2022ScalaCases.UnsignedPositiveLongintExpressionable](_, Some("http://www.accellera.org/XMLSchema/IPXACT/1685-2022"), Some("addressUnitBits"), __scope, false) } getOrElse {Nil},
        __obj.vendorExtensions map { IPXACT2022scalaxb.toXML[IPXACT2022ScalaCases.VendorExtensions](_, Some("http://www.accellera.org/XMLSchema/IPXACT/1685-2022"), Some("vendorExtensions"), __scope, false) } getOrElse {Nil})

  }

  trait DefaultIPXACT2022ScalaCases_BankDefinitionsFormat extends IPXACT2022scalaxb.ElemNameParser[IPXACT2022ScalaCases.BankDefinitions] {
    val targetNamespace: Option[String] = Some("http://www.accellera.org/XMLSchema/IPXACT/1685-2022")
    
    def parser(node: scala.xml.Node, stack: List[IPXACT2022scalaxb.ElemName]): Parser[IPXACT2022ScalaCases.BankDefinitions] =
      phrase(safeRep(IPXACT2022scalaxb.ElemName(Some("http://www.accellera.org/XMLSchema/IPXACT/1685-2022"), "bankDefinition")) ^^
      { case p1 =>
      IPXACT2022ScalaCases.BankDefinitions(p1 map { IPXACT2022scalaxb.fromXML[IPXACT2022ScalaCases.BankDefinition](_, IPXACT2022scalaxb.ElemName(node) :: stack) }) })
    
    def writesChildNodes(__obj: IPXACT2022ScalaCases.BankDefinitions, __scope: scala.xml.NamespaceBinding): Seq[scala.xml.Node] =
      (__obj.bankDefinition flatMap { IPXACT2022scalaxb.toXML[IPXACT2022ScalaCases.BankDefinition](_, Some("http://www.accellera.org/XMLSchema/IPXACT/1685-2022"), Some("bankDefinition"), __scope, false) })
  }
  trait DefaultIPXACT2022ScalaCases_MemoryMapDefinitionFormat extends IPXACT2022scalaxb.ElemNameParser[IPXACT2022ScalaCases.MemoryMapDefinition] with IPXACT2022ScalaCases_NameGroupGroupFormat with IPXACT2022ScalaCases_MemoryMapDefinitionTypeGroupGroupFormat {
    val targetNamespace: Option[String] = Some("http://www.accellera.org/XMLSchema/IPXACT/1685-2022")
    
    def parser(node: scala.xml.Node, stack: List[IPXACT2022scalaxb.ElemName]): Parser[IPXACT2022ScalaCases.MemoryMapDefinition] =
      phrase((parseNameGroupGroup(node, IPXACT2022scalaxb.ElemName(node) :: stack)) ~
      opt(parseMemoryMapDefinitionTypeGroupGroup(node, IPXACT2022scalaxb.ElemName(node) :: stack)) ~
      opt(IPXACT2022scalaxb.ElemName(Some("http://www.accellera.org/XMLSchema/IPXACT/1685-2022"), "vendorExtensions")) ^^
      { case p1 ~ p2 ~ p3 =>
      IPXACT2022ScalaCases.MemoryMapDefinition(p1,
        p2,
        p3.headOption map { IPXACT2022scalaxb.fromXML[IPXACT2022ScalaCases.VendorExtensions](_, IPXACT2022scalaxb.ElemName(node) :: stack) },
        scala.collection.immutable.ListMap(List(
        (node \ "@{http://www.w3.org/XML/1998/namespace}id").headOption map { x => IPXACT2022scalaxb.DataRecord(x, node, IPXACT2022scalaxb.fromXML[String](x, IPXACT2022scalaxb.ElemName(node) :: stack)) } map { "@{http://www.w3.org/XML/1998/namespace}id" -> _ }
        ).flatten[(String, IPXACT2022scalaxb.DataRecord[Any])]: _*)) })
    
    override def writesAttribute(__obj: IPXACT2022ScalaCases.MemoryMapDefinition, __scope: scala.xml.NamespaceBinding): scala.xml.MetaData = {
      var attr: scala.xml.MetaData  = scala.xml.Null
      __obj.attributes.toList map {
        case ("@{http://www.w3.org/XML/1998/namespace}id", _) => __obj.xmlid foreach { x => attr = scala.xml.Attribute(__scope.getPrefix("http://www.w3.org/XML/1998/namespace"), "id", x.toString, attr) }
        case (key, x) => attr = scala.xml.Attribute((x.namespace map { __scope.getPrefix(_) }).orNull, x.key.orNull, x.value.toString, attr)
      }
      attr
    }

    def writesChildNodes(__obj: IPXACT2022ScalaCases.MemoryMapDefinition, __scope: scala.xml.NamespaceBinding): Seq[scala.xml.Node] =
      Seq.concat(IPXACT2022scalaxb.toXML[IPXACT2022ScalaCases.NameGroupSequence](__obj.nameGroupSequence1, None, Some("nameGroupSequence1"), __scope, false),
        __obj.memoryMapDefinitionTypeGroupSequence2 map { IPXACT2022scalaxb.toXML[IPXACT2022ScalaCases.MemoryMapDefinitionTypeGroupSequence](_, None, Some("memoryMapDefinitionTypeGroupSequence2"), __scope, false) } getOrElse {Nil},
        __obj.vendorExtensions map { IPXACT2022scalaxb.toXML[IPXACT2022ScalaCases.VendorExtensions](_, Some("http://www.accellera.org/XMLSchema/IPXACT/1685-2022"), Some("vendorExtensions"), __scope, false) } getOrElse {Nil})

  }

  trait DefaultIPXACT2022ScalaCases_MemoryMapDefinitionsFormat extends IPXACT2022scalaxb.ElemNameParser[IPXACT2022ScalaCases.MemoryMapDefinitions] {
    val targetNamespace: Option[String] = Some("http://www.accellera.org/XMLSchema/IPXACT/1685-2022")
    
    def parser(node: scala.xml.Node, stack: List[IPXACT2022scalaxb.ElemName]): Parser[IPXACT2022ScalaCases.MemoryMapDefinitions] =
      phrase(safeRep(IPXACT2022scalaxb.ElemName(Some("http://www.accellera.org/XMLSchema/IPXACT/1685-2022"), "memoryMapDefinition")) ^^
      { case p1 =>
      IPXACT2022ScalaCases.MemoryMapDefinitions(p1 map { IPXACT2022scalaxb.fromXML[IPXACT2022ScalaCases.MemoryMapDefinition](_, IPXACT2022scalaxb.ElemName(node) :: stack) }) })
    
    def writesChildNodes(__obj: IPXACT2022ScalaCases.MemoryMapDefinitions, __scope: scala.xml.NamespaceBinding): Seq[scala.xml.Node] =
      (__obj.memoryMapDefinition flatMap { IPXACT2022scalaxb.toXML[IPXACT2022ScalaCases.MemoryMapDefinition](_, Some("http://www.accellera.org/XMLSchema/IPXACT/1685-2022"), Some("memoryMapDefinition"), __scope, false) })
  }
  trait DefaultIPXACT2022ScalaCases_MemoryRemapDefinitionFormat extends IPXACT2022scalaxb.ElemNameParser[IPXACT2022ScalaCases.MemoryRemapDefinition] with IPXACT2022ScalaCases_NameGroupGroupFormat {
    val targetNamespace: Option[String] = Some("http://www.accellera.org/XMLSchema/IPXACT/1685-2022")
    
    def parser(node: scala.xml.Node, stack: List[IPXACT2022scalaxb.ElemName]): Parser[IPXACT2022ScalaCases.MemoryRemapDefinition] =
      phrase((parseNameGroupGroup(node, IPXACT2022scalaxb.ElemName(node) :: stack)) ~
      safeRep(((IPXACT2022scalaxb.ElemName(Some("http://www.accellera.org/XMLSchema/IPXACT/1685-2022"), "addressBlock")) ^^
      (x => IPXACT2022scalaxb.DataRecord(x.namespace, Some(x.name), IPXACT2022scalaxb.fromXML[IPXACT2022ScalaCases.AddressBlockType](x, IPXACT2022scalaxb.ElemName(node) :: stack)))) |
      ((IPXACT2022scalaxb.ElemName(Some("http://www.accellera.org/XMLSchema/IPXACT/1685-2022"), "bank")) ^^
      (x => IPXACT2022scalaxb.DataRecord(x.namespace, Some(x.name), IPXACT2022scalaxb.fromXML[IPXACT2022ScalaCases.AddressBankDefinitionType](x, IPXACT2022scalaxb.ElemName(node) :: stack))))) ~
      opt(IPXACT2022scalaxb.ElemName(Some("http://www.accellera.org/XMLSchema/IPXACT/1685-2022"), "addressUnitBits")) ~
      opt(IPXACT2022scalaxb.ElemName(Some("http://www.accellera.org/XMLSchema/IPXACT/1685-2022"), "vendorExtensions")) ^^
      { case p1 ~ p2 ~ p3 ~ p4 =>
      IPXACT2022ScalaCases.MemoryRemapDefinition(p1,
        p2,
        p3.headOption map { IPXACT2022scalaxb.fromXML[IPXACT2022ScalaCases.UnsignedPositiveLongintExpressionable](_, IPXACT2022scalaxb.ElemName(node) :: stack) },
        p4.headOption map { IPXACT2022scalaxb.fromXML[IPXACT2022ScalaCases.VendorExtensions](_, IPXACT2022scalaxb.ElemName(node) :: stack) },
        scala.collection.immutable.ListMap(List(
        (node \ "@{http://www.w3.org/XML/1998/namespace}id").headOption map { x => IPXACT2022scalaxb.DataRecord(x, node, IPXACT2022scalaxb.fromXML[String](x, IPXACT2022scalaxb.ElemName(node) :: stack)) } map { "@{http://www.w3.org/XML/1998/namespace}id" -> _ }
        ).flatten[(String, IPXACT2022scalaxb.DataRecord[Any])]: _*)) })
    
    override def writesAttribute(__obj: IPXACT2022ScalaCases.MemoryRemapDefinition, __scope: scala.xml.NamespaceBinding): scala.xml.MetaData = {
      var attr: scala.xml.MetaData  = scala.xml.Null
      __obj.attributes.toList map {
        case ("@{http://www.w3.org/XML/1998/namespace}id", _) => __obj.xmlid foreach { x => attr = scala.xml.Attribute(__scope.getPrefix("http://www.w3.org/XML/1998/namespace"), "id", x.toString, attr) }
        case (key, x) => attr = scala.xml.Attribute((x.namespace map { __scope.getPrefix(_) }).orNull, x.key.orNull, x.value.toString, attr)
      }
      attr
    }

    def writesChildNodes(__obj: IPXACT2022ScalaCases.MemoryRemapDefinition, __scope: scala.xml.NamespaceBinding): Seq[scala.xml.Node] =
      Seq.concat(IPXACT2022scalaxb.toXML[IPXACT2022ScalaCases.NameGroupSequence](__obj.nameGroupSequence1, None, Some("nameGroupSequence1"), __scope, false),
        __obj.memoryremapdefinitionoption flatMap { x => IPXACT2022scalaxb.toXML[IPXACT2022scalaxb.DataRecord[IPXACT2022ScalaCases.MemoryRemapDefinitionOption]](x, x.namespace, x.key, __scope, false) },
        __obj.addressUnitBits map { IPXACT2022scalaxb.toXML[IPXACT2022ScalaCases.UnsignedPositiveLongintExpressionable](_, Some("http://www.accellera.org/XMLSchema/IPXACT/1685-2022"), Some("addressUnitBits"), __scope, false) } getOrElse {Nil},
        __obj.vendorExtensions map { IPXACT2022scalaxb.toXML[IPXACT2022ScalaCases.VendorExtensions](_, Some("http://www.accellera.org/XMLSchema/IPXACT/1685-2022"), Some("vendorExtensions"), __scope, false) } getOrElse {Nil})

  }

  trait DefaultIPXACT2022ScalaCases_MemoryRemapDefinitionsFormat extends IPXACT2022scalaxb.ElemNameParser[IPXACT2022ScalaCases.MemoryRemapDefinitions] {
    val targetNamespace: Option[String] = Some("http://www.accellera.org/XMLSchema/IPXACT/1685-2022")
    
    def parser(node: scala.xml.Node, stack: List[IPXACT2022scalaxb.ElemName]): Parser[IPXACT2022ScalaCases.MemoryRemapDefinitions] =
      phrase(safeRep(IPXACT2022scalaxb.ElemName(Some("http://www.accellera.org/XMLSchema/IPXACT/1685-2022"), "memoryRemapDefinition")) ^^
      { case p1 =>
      IPXACT2022ScalaCases.MemoryRemapDefinitions(p1 map { IPXACT2022scalaxb.fromXML[IPXACT2022ScalaCases.MemoryRemapDefinition](_, IPXACT2022scalaxb.ElemName(node) :: stack) }) })
    
    def writesChildNodes(__obj: IPXACT2022ScalaCases.MemoryRemapDefinitions, __scope: scala.xml.NamespaceBinding): Seq[scala.xml.Node] =
      (__obj.memoryRemapDefinition flatMap { IPXACT2022scalaxb.toXML[IPXACT2022ScalaCases.MemoryRemapDefinition](_, Some("http://www.accellera.org/XMLSchema/IPXACT/1685-2022"), Some("memoryRemapDefinition"), __scope, false) })
  }
  trait DefaultIPXACT2022ScalaCases_ModeRef3Format extends IPXACT2022scalaxb.XMLFormat[IPXACT2022ScalaCases.ModeRef3] with IPXACT2022scalaxb.CanWriteChildNodes[IPXACT2022ScalaCases.ModeRef3] {
    val targetNamespace: Option[String] = Some("http://www.accellera.org/XMLSchema/IPXACT/1685-2022")
    def reads(seq: scala.xml.NodeSeq, stack: List[IPXACT2022scalaxb.ElemName]): Either[String, IPXACT2022ScalaCases.ModeRef3] = seq match {
      case node: scala.xml.Node => Right(IPXACT2022ScalaCases.ModeRef3(IPXACT2022scalaxb.fromXML[String](node, IPXACT2022scalaxb.ElemName(node) :: stack),
        scala.collection.immutable.ListMap(List(
        (node \ "@priority").headOption map { x => IPXACT2022scalaxb.DataRecord(x, node, IPXACT2022scalaxb.fromXML[BigInt](x, IPXACT2022scalaxb.ElemName(node) :: stack)) } map { "@priority" -> _ },
        (node \ "@{http://www.w3.org/XML/1998/namespace}id").headOption map { x => IPXACT2022scalaxb.DataRecord(x, node, IPXACT2022scalaxb.fromXML[String](x, IPXACT2022scalaxb.ElemName(node) :: stack)) } map { "@{http://www.w3.org/XML/1998/namespace}id" -> _ }
        ).flatten[(String, IPXACT2022scalaxb.DataRecord[Any])]: _*)))
      case _ => Left("reads failed: seq must be scala.xml.Node")
    }
    
    override def writesAttribute(__obj: IPXACT2022ScalaCases.ModeRef3, __scope: scala.xml.NamespaceBinding): scala.xml.MetaData = {
      var attr: scala.xml.MetaData  = scala.xml.Null
      __obj.attributes.toList map {
        case ("@priority", _) => attr = scala.xml.Attribute(null, "priority", __obj.priority.toString, attr)
        case ("@{http://www.w3.org/XML/1998/namespace}id", _) => __obj.xmlid foreach { x => attr = scala.xml.Attribute(__scope.getPrefix("http://www.w3.org/XML/1998/namespace"), "id", x.toString, attr) }
        case (key, x) => attr = scala.xml.Attribute((x.namespace map { __scope.getPrefix(_) }).orNull, x.key.orNull, x.value.toString, attr)
      }
      attr
    }

    def writesChildNodes(__obj: IPXACT2022ScalaCases.ModeRef3, __scope: scala.xml.NamespaceBinding): Seq[scala.xml.Node] =
      Seq(scala.xml.Text(__obj.value.toString))

  }

  trait DefaultIPXACT2022ScalaCases_ArrayType4Format extends IPXACT2022scalaxb.ElemNameParser[IPXACT2022ScalaCases.ArrayType4] {
    val targetNamespace: Option[String] = Some("http://www.accellera.org/XMLSchema/IPXACT/1685-2022")
    
    def parser(node: scala.xml.Node, stack: List[IPXACT2022scalaxb.ElemName]): Parser[IPXACT2022ScalaCases.ArrayType4] =
      phrase(safeRep(IPXACT2022scalaxb.ElemName(Some("http://www.accellera.org/XMLSchema/IPXACT/1685-2022"), "dim")) ~
      opt(IPXACT2022scalaxb.ElemName(Some("http://www.accellera.org/XMLSchema/IPXACT/1685-2022"), "stride")) ^^
      { case p1 ~ p2 =>
      IPXACT2022ScalaCases.ArrayType4(p1 map { IPXACT2022scalaxb.fromXML[IPXACT2022ScalaCases.Dim](_, IPXACT2022scalaxb.ElemName(node) :: stack) },
        p2.headOption map { IPXACT2022scalaxb.fromXML[IPXACT2022ScalaCases.Stride](_, IPXACT2022scalaxb.ElemName(node) :: stack) }) })
    
    def writesChildNodes(__obj: IPXACT2022ScalaCases.ArrayType4, __scope: scala.xml.NamespaceBinding): Seq[scala.xml.Node] =
      Seq.concat(__obj.dim flatMap { IPXACT2022scalaxb.toXML[IPXACT2022ScalaCases.Dim](_, Some("http://www.accellera.org/XMLSchema/IPXACT/1685-2022"), Some("dim"), __scope, false) },
        __obj.stride map { IPXACT2022scalaxb.toXML[IPXACT2022ScalaCases.Stride](_, Some("http://www.accellera.org/XMLSchema/IPXACT/1685-2022"), Some("stride"), __scope, false) } getOrElse {Nil})

  }

  trait DefaultIPXACT2022ScalaCases_ModifiedWriteValueFormat extends IPXACT2022scalaxb.XMLFormat[IPXACT2022ScalaCases.ModifiedWriteValue] with IPXACT2022scalaxb.CanWriteChildNodes[IPXACT2022ScalaCases.ModifiedWriteValue] {
    val targetNamespace: Option[String] = Some("http://www.accellera.org/XMLSchema/IPXACT/1685-2022")
    def reads(seq: scala.xml.NodeSeq, stack: List[IPXACT2022scalaxb.ElemName]): Either[String, IPXACT2022ScalaCases.ModifiedWriteValue] = seq match {
      case node: scala.xml.Node => Right(IPXACT2022ScalaCases.ModifiedWriteValue(IPXACT2022scalaxb.fromXML[IPXACT2022ScalaCases.ModifiedWriteValueType](node, IPXACT2022scalaxb.ElemName(node) :: stack),
        scala.collection.immutable.ListMap(List(
        (node \ "@modify").headOption map { x => IPXACT2022scalaxb.DataRecord(x, node, IPXACT2022scalaxb.fromXML[String](x, IPXACT2022scalaxb.ElemName(node) :: stack)) } map { "@modify" -> _ }
        ).flatten[(String, IPXACT2022scalaxb.DataRecord[Any])]: _*)))
      case _ => Left("reads failed: seq must be scala.xml.Node")
    }
    
    override def writesAttribute(__obj: IPXACT2022ScalaCases.ModifiedWriteValue, __scope: scala.xml.NamespaceBinding): scala.xml.MetaData = {
      var attr: scala.xml.MetaData  = scala.xml.Null
      __obj.attributes.toList map {
        case ("@modify", _) => __obj.modify foreach { x => attr = scala.xml.Attribute(null, "modify", x.toString, attr) }
        case (key, x) => attr = scala.xml.Attribute((x.namespace map { __scope.getPrefix(_) }).orNull, x.key.orNull, x.value.toString, attr)
      }
      attr
    }

    def writesChildNodes(__obj: IPXACT2022ScalaCases.ModifiedWriteValue, __scope: scala.xml.NamespaceBinding): Seq[scala.xml.Node] =
      Seq(scala.xml.Text(__obj.value.toString))

  }

  trait DefaultIPXACT2022ScalaCases_ReadActionFormat extends IPXACT2022scalaxb.XMLFormat[IPXACT2022ScalaCases.ReadAction] with IPXACT2022scalaxb.CanWriteChildNodes[IPXACT2022ScalaCases.ReadAction] {
    val targetNamespace: Option[String] = Some("http://www.accellera.org/XMLSchema/IPXACT/1685-2022")
    def reads(seq: scala.xml.NodeSeq, stack: List[IPXACT2022scalaxb.ElemName]): Either[String, IPXACT2022ScalaCases.ReadAction] = seq match {
      case node: scala.xml.Node => Right(IPXACT2022ScalaCases.ReadAction(IPXACT2022scalaxb.fromXML[IPXACT2022ScalaCases.ReadActionType](node, IPXACT2022scalaxb.ElemName(node) :: stack),
        scala.collection.immutable.ListMap(List(
        (node \ "@modify").headOption map { x => IPXACT2022scalaxb.DataRecord(x, node, IPXACT2022scalaxb.fromXML[String](x, IPXACT2022scalaxb.ElemName(node) :: stack)) } map { "@modify" -> _ }
        ).flatten[(String, IPXACT2022scalaxb.DataRecord[Any])]: _*)))
      case _ => Left("reads failed: seq must be scala.xml.Node")
    }
    
    override def writesAttribute(__obj: IPXACT2022ScalaCases.ReadAction, __scope: scala.xml.NamespaceBinding): scala.xml.MetaData = {
      var attr: scala.xml.MetaData  = scala.xml.Null
      __obj.attributes.toList map {
        case ("@modify", _) => __obj.modify foreach { x => attr = scala.xml.Attribute(null, "modify", x.toString, attr) }
        case (key, x) => attr = scala.xml.Attribute((x.namespace map { __scope.getPrefix(_) }).orNull, x.key.orNull, x.value.toString, attr)
      }
      attr
    }

    def writesChildNodes(__obj: IPXACT2022ScalaCases.ReadAction, __scope: scala.xml.NamespaceBinding): Seq[scala.xml.Node] =
      Seq(scala.xml.Text(__obj.value.toString))

  }

  trait DefaultIPXACT2022ScalaCases_AccessPolicyFormat extends IPXACT2022scalaxb.ElemNameParser[IPXACT2022ScalaCases.AccessPolicy] {
    val targetNamespace: Option[String] = Some("http://www.accellera.org/XMLSchema/IPXACT/1685-2022")
    
    def parser(node: scala.xml.Node, stack: List[IPXACT2022scalaxb.ElemName]): Parser[IPXACT2022ScalaCases.AccessPolicy] =
      phrase(safeRep(IPXACT2022scalaxb.ElemName(Some("http://www.accellera.org/XMLSchema/IPXACT/1685-2022"), "modeRef")) ~
      opt(IPXACT2022scalaxb.ElemName(Some("http://www.accellera.org/XMLSchema/IPXACT/1685-2022"), "access")) ~
      opt(IPXACT2022scalaxb.ElemName(Some("http://www.accellera.org/XMLSchema/IPXACT/1685-2022"), "vendorExtensions")) ^^
      { case p1 ~ p2 ~ p3 =>
      IPXACT2022ScalaCases.AccessPolicy(p1 map { IPXACT2022scalaxb.fromXML[IPXACT2022ScalaCases.ModeRef3](_, IPXACT2022scalaxb.ElemName(node) :: stack) },
        p2.headOption map { IPXACT2022scalaxb.fromXML[IPXACT2022ScalaCases.AccessType](_, IPXACT2022scalaxb.ElemName(node) :: stack) },
        p3.headOption map { IPXACT2022scalaxb.fromXML[IPXACT2022ScalaCases.VendorExtensions](_, IPXACT2022scalaxb.ElemName(node) :: stack) },
        scala.collection.immutable.ListMap(List(
        (node \ "@{http://www.w3.org/XML/1998/namespace}id").headOption map { x => IPXACT2022scalaxb.DataRecord(x, node, IPXACT2022scalaxb.fromXML[String](x, IPXACT2022scalaxb.ElemName(node) :: stack)) } map { "@{http://www.w3.org/XML/1998/namespace}id" -> _ }
        ).flatten[(String, IPXACT2022scalaxb.DataRecord[Any])]: _*)) })
    
    override def writesAttribute(__obj: IPXACT2022ScalaCases.AccessPolicy, __scope: scala.xml.NamespaceBinding): scala.xml.MetaData = {
      var attr: scala.xml.MetaData  = scala.xml.Null
      __obj.attributes.toList map {
        case ("@{http://www.w3.org/XML/1998/namespace}id", _) => __obj.xmlid foreach { x => attr = scala.xml.Attribute(__scope.getPrefix("http://www.w3.org/XML/1998/namespace"), "id", x.toString, attr) }
        case (key, x) => attr = scala.xml.Attribute((x.namespace map { __scope.getPrefix(_) }).orNull, x.key.orNull, x.value.toString, attr)
      }
      attr
    }

    def writesChildNodes(__obj: IPXACT2022ScalaCases.AccessPolicy, __scope: scala.xml.NamespaceBinding): Seq[scala.xml.Node] =
      Seq.concat(__obj.modeRef flatMap { IPXACT2022scalaxb.toXML[IPXACT2022ScalaCases.ModeRef3](_, Some("http://www.accellera.org/XMLSchema/IPXACT/1685-2022"), Some("modeRef"), __scope, false) },
        __obj.access map { IPXACT2022scalaxb.toXML[IPXACT2022ScalaCases.AccessType](_, Some("http://www.accellera.org/XMLSchema/IPXACT/1685-2022"), Some("access"), __scope, false) } getOrElse {Nil},
        __obj.vendorExtensions map { IPXACT2022scalaxb.toXML[IPXACT2022ScalaCases.VendorExtensions](_, Some("http://www.accellera.org/XMLSchema/IPXACT/1685-2022"), Some("vendorExtensions"), __scope, false) } getOrElse {Nil})

  }

  trait DefaultIPXACT2022ScalaCases_AccessPoliciesFormat extends IPXACT2022scalaxb.ElemNameParser[IPXACT2022ScalaCases.AccessPolicies] {
    val targetNamespace: Option[String] = Some("http://www.accellera.org/XMLSchema/IPXACT/1685-2022")
    
    def parser(node: scala.xml.Node, stack: List[IPXACT2022scalaxb.ElemName]): Parser[IPXACT2022ScalaCases.AccessPolicies] =
      phrase(safeRep(IPXACT2022scalaxb.ElemName(Some("http://www.accellera.org/XMLSchema/IPXACT/1685-2022"), "accessPolicy")) ^^
      { case p1 =>
      IPXACT2022ScalaCases.AccessPolicies(p1 map { IPXACT2022scalaxb.fromXML[IPXACT2022ScalaCases.AccessPolicy](_, IPXACT2022scalaxb.ElemName(node) :: stack) }) })
    
    def writesChildNodes(__obj: IPXACT2022ScalaCases.AccessPolicies, __scope: scala.xml.NamespaceBinding): Seq[scala.xml.Node] =
      (__obj.accessPolicy flatMap { IPXACT2022scalaxb.toXML[IPXACT2022ScalaCases.AccessPolicy](_, Some("http://www.accellera.org/XMLSchema/IPXACT/1685-2022"), Some("accessPolicy"), __scope, false) })
  }

/** Alternate register definition specific information
*/
  trait IPXACT2022ScalaCases_AlternateRegisterDefinitionGroupGroupFormat extends IPXACT2022scalaxb.AnyElemNameParser {
    def parseAlternateRegisterDefinitionGroupGroup(node: scala.xml.Node, stack: List[IPXACT2022scalaxb.ElemName]): Parser[IPXACT2022ScalaCases.AlternateRegisterDefinitionGroupSequence] =
      ((opt(IPXACT2022scalaxb.ElemName(Some("http://www.accellera.org/XMLSchema/IPXACT/1685-2022"), "typeIdentifier")) ~
      opt(IPXACT2022scalaxb.ElemName(Some("http://www.accellera.org/XMLSchema/IPXACT/1685-2022"), "volatile")) ~
      opt(IPXACT2022scalaxb.ElemName(Some("http://www.accellera.org/XMLSchema/IPXACT/1685-2022"), "accessPolicies")) ~
      safeRep(((IPXACT2022scalaxb.ElemName(Some("http://www.accellera.org/XMLSchema/IPXACT/1685-2022"), "field"))) ^^
        { case p1 => IPXACT2022ScalaCases.AlternateRegisterDefinitionGroupSequence2(IPXACT2022scalaxb.fromXML[IPXACT2022ScalaCases.FieldType](p1, IPXACT2022scalaxb.ElemName(node) :: stack)) })) ^^
        { case p1 ~ p2 ~ p3 ~ p4 => IPXACT2022ScalaCases.AlternateRegisterDefinitionGroupSequence(p1.headOption map { IPXACT2022scalaxb.fromXML[String](_, IPXACT2022scalaxb.ElemName(node) :: stack) },
        p2.headOption map { IPXACT2022scalaxb.fromXML[Boolean](_, IPXACT2022scalaxb.ElemName(node) :: stack) },
        p3.headOption map { IPXACT2022scalaxb.fromXML[IPXACT2022ScalaCases.AccessPolicies](_, IPXACT2022scalaxb.ElemName(node) :: stack) },
        p4) })
  
    def parseAlternateRegisterDefinitionGroupGroup(node: scala.xml.Node, stack: List[IPXACT2022scalaxb.ElemName], wrap: Boolean): Parser[IPXACT2022scalaxb.DataRecord[Any]] =
      ((opt(IPXACT2022scalaxb.ElemName(Some("http://www.accellera.org/XMLSchema/IPXACT/1685-2022"), "typeIdentifier")) ~
      opt(IPXACT2022scalaxb.ElemName(Some("http://www.accellera.org/XMLSchema/IPXACT/1685-2022"), "volatile")) ~
      opt(IPXACT2022scalaxb.ElemName(Some("http://www.accellera.org/XMLSchema/IPXACT/1685-2022"), "accessPolicies")) ~
      safeRep(((IPXACT2022scalaxb.ElemName(Some("http://www.accellera.org/XMLSchema/IPXACT/1685-2022"), "field"))) ^^
        { case p1 => IPXACT2022ScalaCases.AlternateRegisterDefinitionGroupSequence2(IPXACT2022scalaxb.fromXML[IPXACT2022ScalaCases.FieldType](p1, IPXACT2022scalaxb.ElemName(node) :: stack)) })) ^^
        { case p1 ~ p2 ~ p3 ~ p4 => IPXACT2022scalaxb.DataRecord(IPXACT2022ScalaCases.AlternateRegisterDefinitionGroupSequence(p1.headOption map { IPXACT2022scalaxb.fromXML[String](_, IPXACT2022scalaxb.ElemName(node) :: stack) },
        p2.headOption map { IPXACT2022scalaxb.fromXML[Boolean](_, IPXACT2022scalaxb.ElemName(node) :: stack) },
        p3.headOption map { IPXACT2022scalaxb.fromXML[IPXACT2022ScalaCases.AccessPolicies](_, IPXACT2022scalaxb.ElemName(node) :: stack) },
        p4)) })
    
    def parsemixedAlternateRegisterDefinitionGroupGroup(node: scala.xml.Node, stack: List[IPXACT2022scalaxb.ElemName]): Parser[Seq[IPXACT2022scalaxb.DataRecord[Any]]] =
      (((opt(IPXACT2022scalaxb.ElemName(Some("http://www.accellera.org/XMLSchema/IPXACT/1685-2022"), "typeIdentifier")) ^^
      (_ map { x => IPXACT2022scalaxb.DataRecord(x.namespace, Some(x.name), IPXACT2022scalaxb.fromXML[String](x, IPXACT2022scalaxb.ElemName(node) :: stack)) })) ~
      optTextRecord ~ 
      (opt(IPXACT2022scalaxb.ElemName(Some("http://www.accellera.org/XMLSchema/IPXACT/1685-2022"), "volatile")) ^^
      (_ map { x => IPXACT2022scalaxb.DataRecord(x.namespace, Some(x.name), IPXACT2022scalaxb.fromXML[Boolean](x, IPXACT2022scalaxb.ElemName(node) :: stack)) })) ~
      optTextRecord ~ 
      (opt(IPXACT2022scalaxb.ElemName(Some("http://www.accellera.org/XMLSchema/IPXACT/1685-2022"), "accessPolicies")) ^^
      (_ map { x => IPXACT2022scalaxb.DataRecord(x.namespace, Some(x.name), IPXACT2022scalaxb.fromXML[IPXACT2022ScalaCases.AccessPolicies](x, IPXACT2022scalaxb.ElemName(node) :: stack)) })) ~
      optTextRecord ~ 
      safeRep((((IPXACT2022scalaxb.ElemName(Some("http://www.accellera.org/XMLSchema/IPXACT/1685-2022"), "field")) ^^
      (x => IPXACT2022scalaxb.DataRecord(x.namespace, Some(x.name), IPXACT2022scalaxb.fromXML[IPXACT2022ScalaCases.FieldType](x, IPXACT2022scalaxb.ElemName(node) :: stack)))) ~
      optTextRecord) ^^ 
        { case p1 ~ p2 => Seq.concat(Seq(p1),
        p2.toList) }) ~ 
      optTextRecord) ^^ 
        { case p1 ~ p2 ~ p3 ~ p4 ~ p5 ~ p6 ~ p7 ~ p8 => Seq.concat(p1.toList,
        p2.toList,
        p3.toList,
        p4.toList,
        p5.toList,
        p6.toList,
        p7.flatten,
        p8.toList) })
  }

  trait DefaultIPXACT2022ScalaCases_AlternateRegisterDefinitionGroupSequenceFormat extends IPXACT2022scalaxb.XMLFormat[IPXACT2022ScalaCases.AlternateRegisterDefinitionGroupSequence] {
    def reads(seq: scala.xml.NodeSeq, stack: List[IPXACT2022scalaxb.ElemName]): Either[String, IPXACT2022ScalaCases.AlternateRegisterDefinitionGroupSequence] = Left("don't call me.")
    
    def writes(__obj: IPXACT2022ScalaCases.AlternateRegisterDefinitionGroupSequence, __namespace: Option[String], __elementLabel: Option[String],
        __scope: scala.xml.NamespaceBinding, __typeAttribute: Boolean): scala.xml.NodeSeq =
      Seq.concat(__obj.typeIdentifier map { IPXACT2022scalaxb.toXML[String](_, Some("http://www.accellera.org/XMLSchema/IPXACT/1685-2022"), Some("typeIdentifier"), __scope, false) } getOrElse {Nil},
        __obj.volatile map { IPXACT2022scalaxb.toXML[Boolean](_, Some("http://www.accellera.org/XMLSchema/IPXACT/1685-2022"), Some("volatile"), __scope, false) } getOrElse {Nil},
        __obj.accessPolicies map { IPXACT2022scalaxb.toXML[IPXACT2022ScalaCases.AccessPolicies](_, Some("http://www.accellera.org/XMLSchema/IPXACT/1685-2022"), Some("accessPolicies"), __scope, false) } getOrElse {Nil},
        __obj.alternateregisterdefinitiongroupsequence2 flatMap { IPXACT2022scalaxb.toXML[IPXACT2022ScalaCases.AlternateRegisterDefinitionGroupSequence2](_, None, Some("alternateregisterdefinitiongroupsequence2"), __scope, false) })


  }

  trait DefaultIPXACT2022ScalaCases_AlternateRegisterDefinitionGroupSequence2Format extends IPXACT2022scalaxb.XMLFormat[IPXACT2022ScalaCases.AlternateRegisterDefinitionGroupSequence2] {
    def reads(seq: scala.xml.NodeSeq, stack: List[IPXACT2022scalaxb.ElemName]): Either[String, IPXACT2022ScalaCases.AlternateRegisterDefinitionGroupSequence2] = Left("don't call me.")
    
    def writes(__obj: IPXACT2022ScalaCases.AlternateRegisterDefinitionGroupSequence2, __namespace: Option[String], __elementLabel: Option[String],
        __scope: scala.xml.NamespaceBinding, __typeAttribute: Boolean): scala.xml.NodeSeq =
      IPXACT2022scalaxb.toXML[IPXACT2022ScalaCases.FieldType](__obj.field, Some("http://www.accellera.org/XMLSchema/IPXACT/1685-2022"), Some("field"), __scope, false)

  }

/** Address block definition specific information
*/
  trait IPXACT2022ScalaCases_AddressBlockDefinitionGroupGroupFormat extends IPXACT2022ScalaCases_BlockSizeGroupFormat with IPXACT2022ScalaCases_MemoryBlockDataGroupFormat with IPXACT2022ScalaCases_RegisterDataGroupFormat {
    def parseAddressBlockDefinitionGroupGroup(node: scala.xml.Node, stack: List[IPXACT2022scalaxb.ElemName]): Parser[IPXACT2022ScalaCases.AddressBlockDefinitionGroupSequence] =
      ((opt(IPXACT2022scalaxb.ElemName(Some("http://www.accellera.org/XMLSchema/IPXACT/1685-2022"), "typeIdentifier")) ~
      (parseBlockSizeGroup(node, IPXACT2022scalaxb.ElemName(node) :: stack)) ~
      (parseMemoryBlockDataGroup(node, IPXACT2022scalaxb.ElemName(node) :: stack)) ~
      safeRep(parseRegisterDataGroup(node, IPXACT2022scalaxb.ElemName(node) :: stack))) ^^
        { case p1 ~ p2 ~ p3 ~ p4 => IPXACT2022ScalaCases.AddressBlockDefinitionGroupSequence(p1.headOption map { IPXACT2022scalaxb.fromXML[String](_, IPXACT2022scalaxb.ElemName(node) :: stack) },
        p2,
        p3,
        p4) })
  
    def parseAddressBlockDefinitionGroupGroup(node: scala.xml.Node, stack: List[IPXACT2022scalaxb.ElemName], wrap: Boolean): Parser[IPXACT2022scalaxb.DataRecord[Any]] =
      ((opt(IPXACT2022scalaxb.ElemName(Some("http://www.accellera.org/XMLSchema/IPXACT/1685-2022"), "typeIdentifier")) ~
      (parseBlockSizeGroup(node, IPXACT2022scalaxb.ElemName(node) :: stack)) ~
      (parseMemoryBlockDataGroup(node, IPXACT2022scalaxb.ElemName(node) :: stack)) ~
      safeRep(parseRegisterDataGroup(node, IPXACT2022scalaxb.ElemName(node) :: stack))) ^^
        { case p1 ~ p2 ~ p3 ~ p4 => IPXACT2022scalaxb.DataRecord(IPXACT2022ScalaCases.AddressBlockDefinitionGroupSequence(p1.headOption map { IPXACT2022scalaxb.fromXML[String](_, IPXACT2022scalaxb.ElemName(node) :: stack) },
        p2,
        p3,
        p4)) })
    
    def parsemixedAddressBlockDefinitionGroupGroup(node: scala.xml.Node, stack: List[IPXACT2022scalaxb.ElemName]): Parser[Seq[IPXACT2022scalaxb.DataRecord[Any]]] =
      (((opt(IPXACT2022scalaxb.ElemName(Some("http://www.accellera.org/XMLSchema/IPXACT/1685-2022"), "typeIdentifier")) ^^
      (_ map { x => IPXACT2022scalaxb.DataRecord(x.namespace, Some(x.name), IPXACT2022scalaxb.fromXML[String](x, IPXACT2022scalaxb.ElemName(node) :: stack)) })) ~
      optTextRecord ~ 
      (parsemixedBlockSizeGroup(node, IPXACT2022scalaxb.ElemName(node) :: stack)) ~
      optTextRecord ~ 
      (parsemixedMemoryBlockDataGroup(node, IPXACT2022scalaxb.ElemName(node) :: stack)) ~
      optTextRecord ~ 
      safeRep(parsemixedRegisterDataGroup(node, IPXACT2022scalaxb.ElemName(node) :: stack)) ~
      optTextRecord) ^^ 
        { case p1 ~ p2 ~ p3 ~ p4 ~ p5 ~ p6 ~ p7 ~ p8 => Seq.concat(p1.toList,
        p2.toList,
        p3,
        p4.toList,
        p5,
        p6.toList,
        p7.flatten,
        p8.toList) })
  }

  trait DefaultIPXACT2022ScalaCases_AddressBlockDefinitionGroupSequenceFormat extends IPXACT2022scalaxb.XMLFormat[IPXACT2022ScalaCases.AddressBlockDefinitionGroupSequence] {
    def reads(seq: scala.xml.NodeSeq, stack: List[IPXACT2022scalaxb.ElemName]): Either[String, IPXACT2022ScalaCases.AddressBlockDefinitionGroupSequence] = Left("don't call me.")
    
    def writes(__obj: IPXACT2022ScalaCases.AddressBlockDefinitionGroupSequence, __namespace: Option[String], __elementLabel: Option[String],
        __scope: scala.xml.NamespaceBinding, __typeAttribute: Boolean): scala.xml.NodeSeq =
      Seq.concat(__obj.typeIdentifier map { IPXACT2022scalaxb.toXML[String](_, Some("http://www.accellera.org/XMLSchema/IPXACT/1685-2022"), Some("typeIdentifier"), __scope, false) } getOrElse {Nil},
        IPXACT2022scalaxb.toXML[IPXACT2022ScalaCases.BlockSizeSequence](__obj.blockSizeSequence2, None, Some("blockSizeSequence2"), __scope, false),
        IPXACT2022scalaxb.toXML[IPXACT2022ScalaCases.MemoryBlockDataSequence](__obj.memoryBlockDataSequence3, None, Some("memoryBlockDataSequence3"), __scope, false),
        __obj.registerDataOption4 flatMap { x => IPXACT2022scalaxb.toXML[IPXACT2022scalaxb.DataRecord[IPXACT2022ScalaCases.RegisterDataOption]](x, x.namespace, x.key, __scope, false) })


  }


/** Field definition specific information
*/
  trait IPXACT2022ScalaCases_FieldDefinitionGroupGroupFormat extends IPXACT2022ScalaCases_FieldDataGroupFormat {
    def parseFieldDefinitionGroupGroup(node: scala.xml.Node, stack: List[IPXACT2022scalaxb.ElemName]): Parser[IPXACT2022ScalaCases.FieldDefinitionGroupSequence] =
      ((opt(IPXACT2022scalaxb.ElemName(Some("http://www.accellera.org/XMLSchema/IPXACT/1685-2022"), "typeIdentifier")) ~
      ((((IPXACT2022scalaxb.ElemName(Some("http://www.accellera.org/XMLSchema/IPXACT/1685-2022"), "bitWidth")) ~
      opt(IPXACT2022scalaxb.ElemName(Some("http://www.accellera.org/XMLSchema/IPXACT/1685-2022"), "volatile")) ~
      opt(IPXACT2022scalaxb.ElemName(Some("http://www.accellera.org/XMLSchema/IPXACT/1685-2022"), "resets"))) ^^
        { case p1 ~ p2 ~ p3 => IPXACT2022scalaxb.DataRecord(IPXACT2022ScalaCases.FieldDefinitionGroupSequence2(IPXACT2022scalaxb.fromXML[IPXACT2022ScalaCases.UnsignedPositiveIntExpressionable](p1, IPXACT2022scalaxb.ElemName(node) :: stack),
        p2.headOption map { IPXACT2022scalaxb.fromXML[Boolean](_, IPXACT2022scalaxb.ElemName(node) :: stack) },
        p3.headOption map { IPXACT2022scalaxb.fromXML[IPXACT2022ScalaCases.Resets](_, IPXACT2022scalaxb.ElemName(node) :: stack) })) }) |||
      ((IPXACT2022scalaxb.ElemName(Some("http://www.accellera.org/XMLSchema/IPXACT/1685-2022"), "aliasOf")) ^^
      (x => IPXACT2022scalaxb.DataRecord(x.namespace, Some(x.name), IPXACT2022scalaxb.fromXML[IPXACT2022ScalaCases.AliasOf](x, IPXACT2022scalaxb.ElemName(node) :: stack))))) ~
      (parseFieldDataGroup(node, IPXACT2022scalaxb.ElemName(node) :: stack))) ^^
        { case p1 ~ p2 ~ p3 => IPXACT2022ScalaCases.FieldDefinitionGroupSequence(p1.headOption map { IPXACT2022scalaxb.fromXML[String](_, IPXACT2022scalaxb.ElemName(node) :: stack) },
        p2,
        p3) })
  
    def parseFieldDefinitionGroupGroup(node: scala.xml.Node, stack: List[IPXACT2022scalaxb.ElemName], wrap: Boolean): Parser[IPXACT2022scalaxb.DataRecord[Any]] =
      ((opt(IPXACT2022scalaxb.ElemName(Some("http://www.accellera.org/XMLSchema/IPXACT/1685-2022"), "typeIdentifier")) ~
      ((((IPXACT2022scalaxb.ElemName(Some("http://www.accellera.org/XMLSchema/IPXACT/1685-2022"), "bitWidth")) ~
      opt(IPXACT2022scalaxb.ElemName(Some("http://www.accellera.org/XMLSchema/IPXACT/1685-2022"), "volatile")) ~
      opt(IPXACT2022scalaxb.ElemName(Some("http://www.accellera.org/XMLSchema/IPXACT/1685-2022"), "resets"))) ^^
        { case p1 ~ p2 ~ p3 => IPXACT2022scalaxb.DataRecord(IPXACT2022ScalaCases.FieldDefinitionGroupSequence2(IPXACT2022scalaxb.fromXML[IPXACT2022ScalaCases.UnsignedPositiveIntExpressionable](p1, IPXACT2022scalaxb.ElemName(node) :: stack),
        p2.headOption map { IPXACT2022scalaxb.fromXML[Boolean](_, IPXACT2022scalaxb.ElemName(node) :: stack) },
        p3.headOption map { IPXACT2022scalaxb.fromXML[IPXACT2022ScalaCases.Resets](_, IPXACT2022scalaxb.ElemName(node) :: stack) })) }) |||
      ((IPXACT2022scalaxb.ElemName(Some("http://www.accellera.org/XMLSchema/IPXACT/1685-2022"), "aliasOf")) ^^
      (x => IPXACT2022scalaxb.DataRecord(x.namespace, Some(x.name), IPXACT2022scalaxb.fromXML[IPXACT2022ScalaCases.AliasOf](x, IPXACT2022scalaxb.ElemName(node) :: stack))))) ~
      (parseFieldDataGroup(node, IPXACT2022scalaxb.ElemName(node) :: stack))) ^^
        { case p1 ~ p2 ~ p3 => IPXACT2022scalaxb.DataRecord(IPXACT2022ScalaCases.FieldDefinitionGroupSequence(p1.headOption map { IPXACT2022scalaxb.fromXML[String](_, IPXACT2022scalaxb.ElemName(node) :: stack) },
        p2,
        p3)) })
    
    def parsemixedFieldDefinitionGroupGroup(node: scala.xml.Node, stack: List[IPXACT2022scalaxb.ElemName]): Parser[Seq[IPXACT2022scalaxb.DataRecord[Any]]] =
      (((opt(IPXACT2022scalaxb.ElemName(Some("http://www.accellera.org/XMLSchema/IPXACT/1685-2022"), "typeIdentifier")) ^^
      (_ map { x => IPXACT2022scalaxb.DataRecord(x.namespace, Some(x.name), IPXACT2022scalaxb.fromXML[String](x, IPXACT2022scalaxb.ElemName(node) :: stack)) })) ~
      optTextRecord ~ 
      (((((IPXACT2022scalaxb.ElemName(Some("http://www.accellera.org/XMLSchema/IPXACT/1685-2022"), "bitWidth")) ^^
      (x => IPXACT2022scalaxb.DataRecord(x.namespace, Some(x.name), IPXACT2022scalaxb.fromXML[IPXACT2022ScalaCases.UnsignedPositiveIntExpressionable](x, IPXACT2022scalaxb.ElemName(node) :: stack)))) ~
      optTextRecord ~ 
      (opt(IPXACT2022scalaxb.ElemName(Some("http://www.accellera.org/XMLSchema/IPXACT/1685-2022"), "volatile")) ^^
      (_ map { x => IPXACT2022scalaxb.DataRecord(x.namespace, Some(x.name), IPXACT2022scalaxb.fromXML[Boolean](x, IPXACT2022scalaxb.ElemName(node) :: stack)) })) ~
      optTextRecord ~ 
      (opt(IPXACT2022scalaxb.ElemName(Some("http://www.accellera.org/XMLSchema/IPXACT/1685-2022"), "resets")) ^^
      (_ map { x => IPXACT2022scalaxb.DataRecord(x.namespace, Some(x.name), IPXACT2022scalaxb.fromXML[IPXACT2022ScalaCases.Resets](x, IPXACT2022scalaxb.ElemName(node) :: stack)) })) ~
      optTextRecord) ^^ 
        { case p1 ~ p2 ~ p3 ~ p4 ~ p5 ~ p6 => Seq.concat(Seq(p1),
        p2.toList,
        p3.toList,
        p4.toList,
        p5.toList,
        p6.toList) }) ||| 
      ((((IPXACT2022scalaxb.ElemName(Some("http://www.accellera.org/XMLSchema/IPXACT/1685-2022"), "aliasOf")) ^^
      (x => IPXACT2022scalaxb.DataRecord(x.namespace, Some(x.name), IPXACT2022scalaxb.fromXML[IPXACT2022ScalaCases.AliasOf](x, IPXACT2022scalaxb.ElemName(node) :: stack)))) ~
      optTextRecord) ^^ 
        { case p1 ~ p2 => Seq.concat(Seq(p1),
        p2.toList) })) ~ 
      optTextRecord ~ 
      (parsemixedFieldDataGroup(node, IPXACT2022scalaxb.ElemName(node) :: stack)) ~
      optTextRecord) ^^ 
        { case p1 ~ p2 ~ p3 ~ p4 ~ p5 ~ p6 => Seq.concat(p1.toList,
        p2.toList,
        p3,
        p4.toList,
        p5,
        p6.toList) })
  }

  trait DefaultIPXACT2022ScalaCases_FieldDefinitionGroupSequence2Format extends IPXACT2022scalaxb.XMLFormat[IPXACT2022ScalaCases.FieldDefinitionGroupSequence2] {
    def reads(seq: scala.xml.NodeSeq, stack: List[IPXACT2022scalaxb.ElemName]): Either[String, IPXACT2022ScalaCases.FieldDefinitionGroupSequence2] = Left("don't call me.")
    
    def writes(__obj: IPXACT2022ScalaCases.FieldDefinitionGroupSequence2, __namespace: Option[String], __elementLabel: Option[String],
        __scope: scala.xml.NamespaceBinding, __typeAttribute: Boolean): scala.xml.NodeSeq =
      Seq.concat(IPXACT2022scalaxb.toXML[IPXACT2022ScalaCases.UnsignedPositiveIntExpressionable](__obj.bitWidth, Some("http://www.accellera.org/XMLSchema/IPXACT/1685-2022"), Some("bitWidth"), __scope, false),
        __obj.volatile map { IPXACT2022scalaxb.toXML[Boolean](_, Some("http://www.accellera.org/XMLSchema/IPXACT/1685-2022"), Some("volatile"), __scope, false) } getOrElse {Nil},
        __obj.resets map { IPXACT2022scalaxb.toXML[IPXACT2022ScalaCases.Resets](_, Some("http://www.accellera.org/XMLSchema/IPXACT/1685-2022"), Some("resets"), __scope, false) } getOrElse {Nil})


  }

  trait DefaultIPXACT2022ScalaCases_FieldDefinitionGroupSequenceFormat extends IPXACT2022scalaxb.XMLFormat[IPXACT2022ScalaCases.FieldDefinitionGroupSequence] {
    def reads(seq: scala.xml.NodeSeq, stack: List[IPXACT2022scalaxb.ElemName]): Either[String, IPXACT2022ScalaCases.FieldDefinitionGroupSequence] = Left("don't call me.")
    
    def writes(__obj: IPXACT2022ScalaCases.FieldDefinitionGroupSequence, __namespace: Option[String], __elementLabel: Option[String],
        __scope: scala.xml.NamespaceBinding, __typeAttribute: Boolean): scala.xml.NodeSeq =
      Seq.concat(__obj.typeIdentifier map { IPXACT2022scalaxb.toXML[String](_, Some("http://www.accellera.org/XMLSchema/IPXACT/1685-2022"), Some("typeIdentifier"), __scope, false) } getOrElse {Nil},
        (Some(__obj.fielddefinitiongroupoption1) map {x => IPXACT2022scalaxb.toXML[IPXACT2022scalaxb.DataRecord[IPXACT2022ScalaCases.FieldDefinitionGroupOption1]](x, x.namespace, x.key, __scope, false)}).get,
        IPXACT2022scalaxb.toXML[IPXACT2022ScalaCases.FieldDataSequence](__obj.fieldDataSequence3, None, Some("fieldDataSequence3"), __scope, false))


  }


/** This group of optional elements describes the memory mapped registers of an address block
*/
  trait IPXACT2022ScalaCases_RegisterDataGroupFormat extends IPXACT2022scalaxb.AnyElemNameParser {
    def parseRegisterDataGroup(node: scala.xml.Node, stack: List[IPXACT2022scalaxb.ElemName]): Parser[IPXACT2022scalaxb.DataRecord[IPXACT2022ScalaCases.RegisterDataOption]] =
      (((IPXACT2022scalaxb.ElemName(Some("http://www.accellera.org/XMLSchema/IPXACT/1685-2022"), "register")) ^^
      (x => IPXACT2022scalaxb.DataRecord(x.namespace, Some(x.name), IPXACT2022scalaxb.fromXML[IPXACT2022ScalaCases.Register](x, IPXACT2022scalaxb.ElemName(node) :: stack)))) |
      ((IPXACT2022scalaxb.ElemName(Some("http://www.accellera.org/XMLSchema/IPXACT/1685-2022"), "registerFile")) ^^
      (x => IPXACT2022scalaxb.DataRecord(x.namespace, Some(x.name), IPXACT2022scalaxb.fromXML[IPXACT2022ScalaCases.RegisterFile](x, IPXACT2022scalaxb.ElemName(node) :: stack)))))
  
    def parseRegisterDataGroup(node: scala.xml.Node, stack: List[IPXACT2022scalaxb.ElemName], wrap: Boolean): Parser[IPXACT2022scalaxb.DataRecord[IPXACT2022ScalaCases.RegisterDataOption]] =
      (((IPXACT2022scalaxb.ElemName(Some("http://www.accellera.org/XMLSchema/IPXACT/1685-2022"), "register")) ^^
      (x => IPXACT2022scalaxb.DataRecord(x.namespace, Some(x.name), IPXACT2022scalaxb.fromXML[IPXACT2022ScalaCases.Register](x, IPXACT2022scalaxb.ElemName(node) :: stack)))) |
      ((IPXACT2022scalaxb.ElemName(Some("http://www.accellera.org/XMLSchema/IPXACT/1685-2022"), "registerFile")) ^^
      (x => IPXACT2022scalaxb.DataRecord(x.namespace, Some(x.name), IPXACT2022scalaxb.fromXML[IPXACT2022ScalaCases.RegisterFile](x, IPXACT2022scalaxb.ElemName(node) :: stack)))))
    
    def parsemixedRegisterDataGroup(node: scala.xml.Node, stack: List[IPXACT2022scalaxb.ElemName]): Parser[Seq[IPXACT2022scalaxb.DataRecord[Any]]] =
      (((((IPXACT2022scalaxb.ElemName(Some("http://www.accellera.org/XMLSchema/IPXACT/1685-2022"), "register")) ^^
      (x => IPXACT2022scalaxb.DataRecord(x.namespace, Some(x.name), IPXACT2022scalaxb.fromXML[IPXACT2022ScalaCases.Register](x, IPXACT2022scalaxb.ElemName(node) :: stack)))) ~
      optTextRecord) ^^ 
        { case p1 ~ p2 => Seq.concat(Seq(p1),
        p2.toList) }) ||| 
      ((((IPXACT2022scalaxb.ElemName(Some("http://www.accellera.org/XMLSchema/IPXACT/1685-2022"), "registerFile")) ^^
      (x => IPXACT2022scalaxb.DataRecord(x.namespace, Some(x.name), IPXACT2022scalaxb.fromXML[IPXACT2022ScalaCases.RegisterFile](x, IPXACT2022scalaxb.ElemName(node) :: stack)))) ~
      optTextRecord) ^^ 
        { case p1 ~ p2 => Seq.concat(Seq(p1),
        p2.toList) }))
  }


/** This group of elements describes the number of addressable units and the width of a row of an address block in a memory map.

Note that this is a group, not an element.  It does not appear in the XML, but its contents may.
*/
  trait IPXACT2022ScalaCases_BlockSizeGroupFormat extends IPXACT2022scalaxb.AnyElemNameParser {
    def parseBlockSizeGroup(node: scala.xml.Node, stack: List[IPXACT2022scalaxb.ElemName]): Parser[IPXACT2022ScalaCases.BlockSizeSequence] =
      (((IPXACT2022scalaxb.ElemName(Some("http://www.accellera.org/XMLSchema/IPXACT/1685-2022"), "range")) ~
      (IPXACT2022scalaxb.ElemName(Some("http://www.accellera.org/XMLSchema/IPXACT/1685-2022"), "width"))) ^^
        { case p1 ~ p2 => IPXACT2022ScalaCases.BlockSizeSequence(IPXACT2022scalaxb.fromXML[IPXACT2022ScalaCases.UnsignedPositiveLongintExpressionable](p1, IPXACT2022scalaxb.ElemName(node) :: stack),
        IPXACT2022scalaxb.fromXML[IPXACT2022ScalaCases.UnsignedPositiveIntExpressionable](p2, IPXACT2022scalaxb.ElemName(node) :: stack)) })
  
    def parseBlockSizeGroup(node: scala.xml.Node, stack: List[IPXACT2022scalaxb.ElemName], wrap: Boolean): Parser[IPXACT2022scalaxb.DataRecord[Any]] =
      (((IPXACT2022scalaxb.ElemName(Some("http://www.accellera.org/XMLSchema/IPXACT/1685-2022"), "range")) ~
      (IPXACT2022scalaxb.ElemName(Some("http://www.accellera.org/XMLSchema/IPXACT/1685-2022"), "width"))) ^^
        { case p1 ~ p2 => IPXACT2022scalaxb.DataRecord(IPXACT2022ScalaCases.BlockSizeSequence(IPXACT2022scalaxb.fromXML[IPXACT2022ScalaCases.UnsignedPositiveLongintExpressionable](p1, IPXACT2022scalaxb.ElemName(node) :: stack),
        IPXACT2022scalaxb.fromXML[IPXACT2022ScalaCases.UnsignedPositiveIntExpressionable](p2, IPXACT2022scalaxb.ElemName(node) :: stack))) })
    
    def parsemixedBlockSizeGroup(node: scala.xml.Node, stack: List[IPXACT2022scalaxb.ElemName]): Parser[Seq[IPXACT2022scalaxb.DataRecord[Any]]] =
      ((((IPXACT2022scalaxb.ElemName(Some("http://www.accellera.org/XMLSchema/IPXACT/1685-2022"), "range")) ^^
      (x => IPXACT2022scalaxb.DataRecord(x.namespace, Some(x.name), IPXACT2022scalaxb.fromXML[IPXACT2022ScalaCases.UnsignedPositiveLongintExpressionable](x, IPXACT2022scalaxb.ElemName(node) :: stack)))) ~
      optTextRecord ~ 
      ((IPXACT2022scalaxb.ElemName(Some("http://www.accellera.org/XMLSchema/IPXACT/1685-2022"), "width")) ^^
      (x => IPXACT2022scalaxb.DataRecord(x.namespace, Some(x.name), IPXACT2022scalaxb.fromXML[IPXACT2022ScalaCases.UnsignedPositiveIntExpressionable](x, IPXACT2022scalaxb.ElemName(node) :: stack)))) ~
      optTextRecord) ^^ 
        { case p1 ~ p2 ~ p3 ~ p4 => Seq.concat(Seq(p1),
        p2.toList,
        Seq(p3),
        p4.toList) })
  }

  trait DefaultIPXACT2022ScalaCases_BlockSizeSequenceFormat extends IPXACT2022scalaxb.XMLFormat[IPXACT2022ScalaCases.BlockSizeSequence] {
    def reads(seq: scala.xml.NodeSeq, stack: List[IPXACT2022scalaxb.ElemName]): Either[String, IPXACT2022ScalaCases.BlockSizeSequence] = Left("don't call me.")
    
    def writes(__obj: IPXACT2022ScalaCases.BlockSizeSequence, __namespace: Option[String], __elementLabel: Option[String],
        __scope: scala.xml.NamespaceBinding, __typeAttribute: Boolean): scala.xml.NodeSeq =
      Seq.concat(IPXACT2022scalaxb.toXML[IPXACT2022ScalaCases.UnsignedPositiveLongintExpressionable](__obj.range, Some("http://www.accellera.org/XMLSchema/IPXACT/1685-2022"), Some("range"), __scope, false),
        IPXACT2022scalaxb.toXML[IPXACT2022ScalaCases.UnsignedPositiveIntExpressionable](__obj.width, Some("http://www.accellera.org/XMLSchema/IPXACT/1685-2022"), Some("width"), __scope, false))


  }


/** This group of elements is common to top level bank definitions and banked bank definitions.
*/
  trait IPXACT2022ScalaCases_BankDefinitionBaseGroupFormat extends IPXACT2022ScalaCases_MemoryBlockDataGroupFormat {
    def parseBankDefinitionBaseGroup(node: scala.xml.Node, stack: List[IPXACT2022scalaxb.ElemName]): Parser[IPXACT2022ScalaCases.BankDefinitionBaseSequence] =
      ((safeRep(((IPXACT2022scalaxb.ElemName(Some("http://www.accellera.org/XMLSchema/IPXACT/1685-2022"), "addressBlock")) ^^
      (x => IPXACT2022scalaxb.DataRecord(x.namespace, Some(x.name), IPXACT2022scalaxb.fromXML[IPXACT2022ScalaCases.BankedBlockType](x, IPXACT2022scalaxb.ElemName(node) :: stack)))) |
      ((IPXACT2022scalaxb.ElemName(Some("http://www.accellera.org/XMLSchema/IPXACT/1685-2022"), "bank")) ^^
      (x => IPXACT2022scalaxb.DataRecord(x.namespace, Some(x.name), IPXACT2022scalaxb.fromXML[IPXACT2022ScalaCases.Bank3](x, IPXACT2022scalaxb.ElemName(node) :: stack))))) ~
      (parseMemoryBlockDataGroup(node, IPXACT2022scalaxb.ElemName(node) :: stack))) ^^
        { case p1 ~ p2 => IPXACT2022ScalaCases.BankDefinitionBaseSequence(p1,
        p2) })
  
    def parseBankDefinitionBaseGroup(node: scala.xml.Node, stack: List[IPXACT2022scalaxb.ElemName], wrap: Boolean): Parser[IPXACT2022scalaxb.DataRecord[Any]] =
      ((safeRep(((IPXACT2022scalaxb.ElemName(Some("http://www.accellera.org/XMLSchema/IPXACT/1685-2022"), "addressBlock")) ^^
      (x => IPXACT2022scalaxb.DataRecord(x.namespace, Some(x.name), IPXACT2022scalaxb.fromXML[IPXACT2022ScalaCases.BankedBlockType](x, IPXACT2022scalaxb.ElemName(node) :: stack)))) |
      ((IPXACT2022scalaxb.ElemName(Some("http://www.accellera.org/XMLSchema/IPXACT/1685-2022"), "bank")) ^^
      (x => IPXACT2022scalaxb.DataRecord(x.namespace, Some(x.name), IPXACT2022scalaxb.fromXML[IPXACT2022ScalaCases.Bank3](x, IPXACT2022scalaxb.ElemName(node) :: stack))))) ~
      (parseMemoryBlockDataGroup(node, IPXACT2022scalaxb.ElemName(node) :: stack))) ^^
        { case p1 ~ p2 => IPXACT2022scalaxb.DataRecord(IPXACT2022ScalaCases.BankDefinitionBaseSequence(p1,
        p2)) })
    
    def parsemixedBankDefinitionBaseGroup(node: scala.xml.Node, stack: List[IPXACT2022scalaxb.ElemName]): Parser[Seq[IPXACT2022scalaxb.DataRecord[Any]]] =
      ((safeRep(((((IPXACT2022scalaxb.ElemName(Some("http://www.accellera.org/XMLSchema/IPXACT/1685-2022"), "addressBlock")) ^^
      (x => IPXACT2022scalaxb.DataRecord(x.namespace, Some(x.name), IPXACT2022scalaxb.fromXML[IPXACT2022ScalaCases.BankedBlockType](x, IPXACT2022scalaxb.ElemName(node) :: stack)))) ~
      optTextRecord) ^^ 
        { case p1 ~ p2 => Seq.concat(Seq(p1),
        p2.toList) }) ||| 
      ((((IPXACT2022scalaxb.ElemName(Some("http://www.accellera.org/XMLSchema/IPXACT/1685-2022"), "bank")) ^^
      (x => IPXACT2022scalaxb.DataRecord(x.namespace, Some(x.name), IPXACT2022scalaxb.fromXML[IPXACT2022ScalaCases.Bank3](x, IPXACT2022scalaxb.ElemName(node) :: stack)))) ~
      optTextRecord) ^^ 
        { case p1 ~ p2 => Seq.concat(Seq(p1),
        p2.toList) })) ~ 
      optTextRecord ~ 
      (parsemixedMemoryBlockDataGroup(node, IPXACT2022scalaxb.ElemName(node) :: stack)) ~
      optTextRecord) ^^ 
        { case p1 ~ p2 ~ p3 ~ p4 => Seq.concat(p1.flatten,
        p2.toList,
        p3,
        p4.toList) })
  }

  trait DefaultIPXACT2022ScalaCases_BankDefinitionBaseSequenceFormat extends IPXACT2022scalaxb.XMLFormat[IPXACT2022ScalaCases.BankDefinitionBaseSequence] {
    def reads(seq: scala.xml.NodeSeq, stack: List[IPXACT2022scalaxb.ElemName]): Either[String, IPXACT2022ScalaCases.BankDefinitionBaseSequence] = Left("don't call me.")
    
    def writes(__obj: IPXACT2022ScalaCases.BankDefinitionBaseSequence, __namespace: Option[String], __elementLabel: Option[String],
        __scope: scala.xml.NamespaceBinding, __typeAttribute: Boolean): scala.xml.NodeSeq =
      Seq.concat(__obj.bankdefinitionbaseoption1 flatMap { x => IPXACT2022scalaxb.toXML[IPXACT2022scalaxb.DataRecord[IPXACT2022ScalaCases.BankDefinitionBaseOption1]](x, x.namespace, x.key, __scope, false) },
        IPXACT2022scalaxb.toXML[IPXACT2022ScalaCases.MemoryBlockDataSequence](__obj.memoryBlockDataSequence2, None, Some("memoryBlockDataSequence2"), __scope, false))


  }


/** This group of elements describes an absolute or relative address of an address block in a memory map.

Note that this is a group, not an element.  It does not appear in the XML, but its contents may.
*/
  trait IPXACT2022ScalaCases_AddressSpecifierGroupFormat extends IPXACT2022scalaxb.AnyElemNameParser {
    def parseAddressSpecifierGroup(node: scala.xml.Node, stack: List[IPXACT2022scalaxb.ElemName]): Parser[IPXACT2022ScalaCases.AddressSpecifierSequence] =
      (((IPXACT2022scalaxb.ElemName(Some("http://www.accellera.org/XMLSchema/IPXACT/1685-2022"), "baseAddress"))) ^^
        { case p1 => IPXACT2022ScalaCases.AddressSpecifierSequence(IPXACT2022scalaxb.fromXML[IPXACT2022ScalaCases.UnsignedLongintExpressionable](p1, IPXACT2022scalaxb.ElemName(node) :: stack)) })
  
    def parseAddressSpecifierGroup(node: scala.xml.Node, stack: List[IPXACT2022scalaxb.ElemName], wrap: Boolean): Parser[IPXACT2022scalaxb.DataRecord[Any]] =
      (((IPXACT2022scalaxb.ElemName(Some("http://www.accellera.org/XMLSchema/IPXACT/1685-2022"), "baseAddress"))) ^^
        { case p1 => IPXACT2022scalaxb.DataRecord(IPXACT2022ScalaCases.AddressSpecifierSequence(IPXACT2022scalaxb.fromXML[IPXACT2022ScalaCases.UnsignedLongintExpressionable](p1, IPXACT2022scalaxb.ElemName(node) :: stack))) })
    
    def parsemixedAddressSpecifierGroup(node: scala.xml.Node, stack: List[IPXACT2022scalaxb.ElemName]): Parser[Seq[IPXACT2022scalaxb.DataRecord[Any]]] =
      ((((IPXACT2022scalaxb.ElemName(Some("http://www.accellera.org/XMLSchema/IPXACT/1685-2022"), "baseAddress")) ^^
      (x => IPXACT2022scalaxb.DataRecord(x.namespace, Some(x.name), IPXACT2022scalaxb.fromXML[IPXACT2022ScalaCases.UnsignedLongintExpressionable](x, IPXACT2022scalaxb.ElemName(node) :: stack)))) ~
      optTextRecord) ^^ 
        { case p1 ~ p2 => Seq.concat(Seq(p1),
        p2.toList) })
  }

  trait DefaultIPXACT2022ScalaCases_AddressSpecifierSequenceFormat extends IPXACT2022scalaxb.XMLFormat[IPXACT2022ScalaCases.AddressSpecifierSequence] {
    def reads(seq: scala.xml.NodeSeq, stack: List[IPXACT2022scalaxb.ElemName]): Either[String, IPXACT2022ScalaCases.AddressSpecifierSequence] = Left("don't call me.")
    
    def writes(__obj: IPXACT2022ScalaCases.AddressSpecifierSequence, __namespace: Option[String], __elementLabel: Option[String],
        __scope: scala.xml.NamespaceBinding, __typeAttribute: Boolean): scala.xml.NodeSeq =
      IPXACT2022scalaxb.toXML[IPXACT2022ScalaCases.UnsignedLongintExpressionable](__obj.baseAddress, Some("http://www.accellera.org/XMLSchema/IPXACT/1685-2022"), Some("baseAddress"), __scope, false)

  }

  trait IPXACT2022ScalaCases_MemoryMapGroupGroupFormat extends IPXACT2022ScalaCases_MemoryMapGroupFormat {
    def parseMemoryMapGroupGroup(node: scala.xml.Node, stack: List[IPXACT2022scalaxb.ElemName]): Parser[IPXACT2022ScalaCases.MemoryMapGroupSequence] =
      ((safeRep(parseMemoryMapGroup(node, IPXACT2022scalaxb.ElemName(node) :: stack)) ~
      safeRep(IPXACT2022scalaxb.ElemName(Some("http://www.accellera.org/XMLSchema/IPXACT/1685-2022"), "memoryRemap")) ~
      opt(IPXACT2022scalaxb.ElemName(Some("http://www.accellera.org/XMLSchema/IPXACT/1685-2022"), "addressUnitBits")) ~
      opt(IPXACT2022scalaxb.ElemName(Some("http://www.accellera.org/XMLSchema/IPXACT/1685-2022"), "shared"))) ^^
        { case p1 ~ p2 ~ p3 ~ p4 => IPXACT2022ScalaCases.MemoryMapGroupSequence(p1,
        p2 map { IPXACT2022scalaxb.fromXML[IPXACT2022ScalaCases.MemoryRemapType](_, IPXACT2022scalaxb.ElemName(node) :: stack) },
        p3.headOption map { IPXACT2022scalaxb.fromXML[IPXACT2022ScalaCases.UnsignedPositiveLongintExpressionable](_, IPXACT2022scalaxb.ElemName(node) :: stack) },
        p4.headOption map { IPXACT2022scalaxb.fromXML[IPXACT2022ScalaCases.SharedType](_, IPXACT2022scalaxb.ElemName(node) :: stack) }) })
  
    def parseMemoryMapGroupGroup(node: scala.xml.Node, stack: List[IPXACT2022scalaxb.ElemName], wrap: Boolean): Parser[IPXACT2022scalaxb.DataRecord[Any]] =
      ((safeRep(parseMemoryMapGroup(node, IPXACT2022scalaxb.ElemName(node) :: stack)) ~
      safeRep(IPXACT2022scalaxb.ElemName(Some("http://www.accellera.org/XMLSchema/IPXACT/1685-2022"), "memoryRemap")) ~
      opt(IPXACT2022scalaxb.ElemName(Some("http://www.accellera.org/XMLSchema/IPXACT/1685-2022"), "addressUnitBits")) ~
      opt(IPXACT2022scalaxb.ElemName(Some("http://www.accellera.org/XMLSchema/IPXACT/1685-2022"), "shared"))) ^^
        { case p1 ~ p2 ~ p3 ~ p4 => IPXACT2022scalaxb.DataRecord(IPXACT2022ScalaCases.MemoryMapGroupSequence(p1,
        p2 map { IPXACT2022scalaxb.fromXML[IPXACT2022ScalaCases.MemoryRemapType](_, IPXACT2022scalaxb.ElemName(node) :: stack) },
        p3.headOption map { IPXACT2022scalaxb.fromXML[IPXACT2022ScalaCases.UnsignedPositiveLongintExpressionable](_, IPXACT2022scalaxb.ElemName(node) :: stack) },
        p4.headOption map { IPXACT2022scalaxb.fromXML[IPXACT2022ScalaCases.SharedType](_, IPXACT2022scalaxb.ElemName(node) :: stack) })) })
    
    def parsemixedMemoryMapGroupGroup(node: scala.xml.Node, stack: List[IPXACT2022scalaxb.ElemName]): Parser[Seq[IPXACT2022scalaxb.DataRecord[Any]]] =
      ((safeRep(parsemixedMemoryMapGroup(node, IPXACT2022scalaxb.ElemName(node) :: stack)) ~
      optTextRecord ~ 
      (safeRep(IPXACT2022scalaxb.ElemName(Some("http://www.accellera.org/XMLSchema/IPXACT/1685-2022"), "memoryRemap")) ^^
      (_.toSeq map { x => IPXACT2022scalaxb.DataRecord(x.namespace, Some(x.name), IPXACT2022scalaxb.fromXML[IPXACT2022ScalaCases.MemoryRemapType](x, IPXACT2022scalaxb.ElemName(node) :: stack)) })) ~
      optTextRecord ~ 
      (opt(IPXACT2022scalaxb.ElemName(Some("http://www.accellera.org/XMLSchema/IPXACT/1685-2022"), "addressUnitBits")) ^^
      (_ map { x => IPXACT2022scalaxb.DataRecord(x.namespace, Some(x.name), IPXACT2022scalaxb.fromXML[IPXACT2022ScalaCases.UnsignedPositiveLongintExpressionable](x, IPXACT2022scalaxb.ElemName(node) :: stack)) })) ~
      optTextRecord ~ 
      (opt(IPXACT2022scalaxb.ElemName(Some("http://www.accellera.org/XMLSchema/IPXACT/1685-2022"), "shared")) ^^
      (_ map { x => IPXACT2022scalaxb.DataRecord(x.namespace, Some(x.name), IPXACT2022scalaxb.fromXML[String](x, IPXACT2022scalaxb.ElemName(node) :: stack)) })) ~
      optTextRecord) ^^ 
        { case p1 ~ p2 ~ p3 ~ p4 ~ p5 ~ p6 ~ p7 ~ p8 => Seq.concat(p1.flatten,
        p2.toList,
        p3,
        p4.toList,
        p5.toList,
        p6.toList,
        p7.toList,
        p8.toList) })
  }

  trait DefaultIPXACT2022ScalaCases_MemoryMapGroupSequenceFormat extends IPXACT2022scalaxb.XMLFormat[IPXACT2022ScalaCases.MemoryMapGroupSequence] {
    def reads(seq: scala.xml.NodeSeq, stack: List[IPXACT2022scalaxb.ElemName]): Either[String, IPXACT2022ScalaCases.MemoryMapGroupSequence] = Left("don't call me.")
    
    def writes(__obj: IPXACT2022ScalaCases.MemoryMapGroupSequence, __namespace: Option[String], __elementLabel: Option[String],
        __scope: scala.xml.NamespaceBinding, __typeAttribute: Boolean): scala.xml.NodeSeq =
      Seq.concat(__obj.memoryMapOption1 flatMap { x => IPXACT2022scalaxb.toXML[IPXACT2022scalaxb.DataRecord[IPXACT2022ScalaCases.MemoryMapOption]](x, x.namespace, x.key, __scope, false) },
        __obj.memoryRemap flatMap { IPXACT2022scalaxb.toXML[IPXACT2022ScalaCases.MemoryRemapType](_, Some("http://www.accellera.org/XMLSchema/IPXACT/1685-2022"), Some("memoryRemap"), __scope, false) },
        __obj.addressUnitBits map { IPXACT2022scalaxb.toXML[IPXACT2022ScalaCases.UnsignedPositiveLongintExpressionable](_, Some("http://www.accellera.org/XMLSchema/IPXACT/1685-2022"), Some("addressUnitBits"), __scope, false) } getOrElse {Nil},
        __obj.shared map { IPXACT2022scalaxb.toXML[IPXACT2022ScalaCases.SharedType](_, Some("http://www.accellera.org/XMLSchema/IPXACT/1685-2022"), Some("shared"), __scope, false) } getOrElse {Nil})


  }


  trait IPXACT2022ScalaCases_MemoryMapDefinitionGroupGroupFormat extends IPXACT2022scalaxb.AnyElemNameParser {
    def parseMemoryMapDefinitionGroupGroup(node: scala.xml.Node, stack: List[IPXACT2022scalaxb.ElemName]): Parser[IPXACT2022ScalaCases.MemoryMapDefinitionGroupSequence] =
      ((opt(((IPXACT2022scalaxb.ElemName(Some("http://www.accellera.org/XMLSchema/IPXACT/1685-2022"), "addressBlock")) ^^
      (x => IPXACT2022scalaxb.DataRecord(x.namespace, Some(x.name), IPXACT2022scalaxb.fromXML[IPXACT2022ScalaCases.AddressBlockType](x, IPXACT2022scalaxb.ElemName(node) :: stack)))) |
      ((IPXACT2022scalaxb.ElemName(Some("http://www.accellera.org/XMLSchema/IPXACT/1685-2022"), "bank")) ^^
      (x => IPXACT2022scalaxb.DataRecord(x.namespace, Some(x.name), IPXACT2022scalaxb.fromXML[IPXACT2022ScalaCases.AddressBankType](x, IPXACT2022scalaxb.ElemName(node) :: stack))))) ~
      opt(IPXACT2022scalaxb.ElemName(Some("http://www.accellera.org/XMLSchema/IPXACT/1685-2022"), "addressUnitBits")) ~
      opt(IPXACT2022scalaxb.ElemName(Some("http://www.accellera.org/XMLSchema/IPXACT/1685-2022"), "shared"))) ^^
        { case p1 ~ p2 ~ p3 => IPXACT2022ScalaCases.MemoryMapDefinitionGroupSequence(p1,
        p2.headOption map { IPXACT2022scalaxb.fromXML[IPXACT2022ScalaCases.UnsignedPositiveLongintExpressionable](_, IPXACT2022scalaxb.ElemName(node) :: stack) },
        p3.headOption map { IPXACT2022scalaxb.fromXML[IPXACT2022ScalaCases.SharedType](_, IPXACT2022scalaxb.ElemName(node) :: stack) }) })
  
    def parseMemoryMapDefinitionGroupGroup(node: scala.xml.Node, stack: List[IPXACT2022scalaxb.ElemName], wrap: Boolean): Parser[IPXACT2022scalaxb.DataRecord[Any]] =
      ((opt(((IPXACT2022scalaxb.ElemName(Some("http://www.accellera.org/XMLSchema/IPXACT/1685-2022"), "addressBlock")) ^^
      (x => IPXACT2022scalaxb.DataRecord(x.namespace, Some(x.name), IPXACT2022scalaxb.fromXML[IPXACT2022ScalaCases.AddressBlockType](x, IPXACT2022scalaxb.ElemName(node) :: stack)))) |
      ((IPXACT2022scalaxb.ElemName(Some("http://www.accellera.org/XMLSchema/IPXACT/1685-2022"), "bank")) ^^
      (x => IPXACT2022scalaxb.DataRecord(x.namespace, Some(x.name), IPXACT2022scalaxb.fromXML[IPXACT2022ScalaCases.AddressBankType](x, IPXACT2022scalaxb.ElemName(node) :: stack))))) ~
      opt(IPXACT2022scalaxb.ElemName(Some("http://www.accellera.org/XMLSchema/IPXACT/1685-2022"), "addressUnitBits")) ~
      opt(IPXACT2022scalaxb.ElemName(Some("http://www.accellera.org/XMLSchema/IPXACT/1685-2022"), "shared"))) ^^
        { case p1 ~ p2 ~ p3 => IPXACT2022scalaxb.DataRecord(IPXACT2022ScalaCases.MemoryMapDefinitionGroupSequence(p1,
        p2.headOption map { IPXACT2022scalaxb.fromXML[IPXACT2022ScalaCases.UnsignedPositiveLongintExpressionable](_, IPXACT2022scalaxb.ElemName(node) :: stack) },
        p3.headOption map { IPXACT2022scalaxb.fromXML[IPXACT2022ScalaCases.SharedType](_, IPXACT2022scalaxb.ElemName(node) :: stack) })) })
    
    def parsemixedMemoryMapDefinitionGroupGroup(node: scala.xml.Node, stack: List[IPXACT2022scalaxb.ElemName]): Parser[Seq[IPXACT2022scalaxb.DataRecord[Any]]] =
      ((opt((((opt(IPXACT2022scalaxb.ElemName(Some("http://www.accellera.org/XMLSchema/IPXACT/1685-2022"), "addressBlock")) ^^
      (_ map { x => IPXACT2022scalaxb.DataRecord(x.namespace, Some(x.name), IPXACT2022scalaxb.fromXML[IPXACT2022ScalaCases.AddressBlockType](x, IPXACT2022scalaxb.ElemName(node) :: stack)) })) ~
      optTextRecord) ^^ 
        { case p1 ~ p2 => Seq.concat(p1.toList,
        p2.toList) }) ||| 
      (((opt(IPXACT2022scalaxb.ElemName(Some("http://www.accellera.org/XMLSchema/IPXACT/1685-2022"), "bank")) ^^
      (_ map { x => IPXACT2022scalaxb.DataRecord(x.namespace, Some(x.name), IPXACT2022scalaxb.fromXML[IPXACT2022ScalaCases.AddressBankType](x, IPXACT2022scalaxb.ElemName(node) :: stack)) })) ~
      optTextRecord) ^^ 
        { case p1 ~ p2 => Seq.concat(p1.toList,
        p2.toList) })) ~ 
      optTextRecord ~ 
      (opt(IPXACT2022scalaxb.ElemName(Some("http://www.accellera.org/XMLSchema/IPXACT/1685-2022"), "addressUnitBits")) ^^
      (_ map { x => IPXACT2022scalaxb.DataRecord(x.namespace, Some(x.name), IPXACT2022scalaxb.fromXML[IPXACT2022ScalaCases.UnsignedPositiveLongintExpressionable](x, IPXACT2022scalaxb.ElemName(node) :: stack)) })) ~
      optTextRecord ~ 
      (opt(IPXACT2022scalaxb.ElemName(Some("http://www.accellera.org/XMLSchema/IPXACT/1685-2022"), "shared")) ^^
      (_ map { x => IPXACT2022scalaxb.DataRecord(x.namespace, Some(x.name), IPXACT2022scalaxb.fromXML[String](x, IPXACT2022scalaxb.ElemName(node) :: stack)) })) ~
      optTextRecord) ^^ 
        { case p1 ~ p2 ~ p3 ~ p4 ~ p5 ~ p6 => Seq.concat(p1 getOrElse {Nil},
        p2.toList,
        p3.toList,
        p4.toList,
        p5.toList,
        p6.toList) })
  }

  trait DefaultIPXACT2022ScalaCases_MemoryMapDefinitionGroupSequenceFormat extends IPXACT2022scalaxb.XMLFormat[IPXACT2022ScalaCases.MemoryMapDefinitionGroupSequence] {
    def reads(seq: scala.xml.NodeSeq, stack: List[IPXACT2022scalaxb.ElemName]): Either[String, IPXACT2022ScalaCases.MemoryMapDefinitionGroupSequence] = Left("don't call me.")
    
    def writes(__obj: IPXACT2022ScalaCases.MemoryMapDefinitionGroupSequence, __namespace: Option[String], __elementLabel: Option[String],
        __scope: scala.xml.NamespaceBinding, __typeAttribute: Boolean): scala.xml.NodeSeq =
      Seq.concat(__obj.memorymapdefinitiongroupoption1 map { x => IPXACT2022scalaxb.toXML[IPXACT2022scalaxb.DataRecord[IPXACT2022ScalaCases.MemoryMapDefinitionGroupOption1]](x, x.namespace, x.key, __scope, false) } getOrElse {Nil},
        __obj.addressUnitBits map { IPXACT2022scalaxb.toXML[IPXACT2022ScalaCases.UnsignedPositiveLongintExpressionable](_, Some("http://www.accellera.org/XMLSchema/IPXACT/1685-2022"), Some("addressUnitBits"), __scope, false) } getOrElse {Nil},
        __obj.shared map { IPXACT2022scalaxb.toXML[IPXACT2022ScalaCases.SharedType](_, Some("http://www.accellera.org/XMLSchema/IPXACT/1685-2022"), Some("shared"), __scope, false) } getOrElse {Nil})


  }


/** A group elements for a memoryMap
*/
  trait IPXACT2022ScalaCases_MemoryMapGroupFormat extends IPXACT2022scalaxb.AnyElemNameParser {
    def parseMemoryMapGroup(node: scala.xml.Node, stack: List[IPXACT2022scalaxb.ElemName]): Parser[IPXACT2022scalaxb.DataRecord[IPXACT2022ScalaCases.MemoryMapOption]] =
      (((IPXACT2022scalaxb.ElemName(Some("http://www.accellera.org/XMLSchema/IPXACT/1685-2022"), "addressBlock")) ^^
      (x => IPXACT2022scalaxb.DataRecord(x.namespace, Some(x.name), IPXACT2022scalaxb.fromXML[IPXACT2022ScalaCases.AddressBlockType](x, IPXACT2022scalaxb.ElemName(node) :: stack)))) |
      ((IPXACT2022scalaxb.ElemName(Some("http://www.accellera.org/XMLSchema/IPXACT/1685-2022"), "bank")) ^^
      (x => IPXACT2022scalaxb.DataRecord(x.namespace, Some(x.name), IPXACT2022scalaxb.fromXML[IPXACT2022ScalaCases.AddressBankType](x, IPXACT2022scalaxb.ElemName(node) :: stack)))) |
      ((IPXACT2022scalaxb.ElemName(Some("http://www.accellera.org/XMLSchema/IPXACT/1685-2022"), "subspaceMap")) ^^
      (x => IPXACT2022scalaxb.DataRecord(x.namespace, Some(x.name), IPXACT2022scalaxb.fromXML[IPXACT2022ScalaCases.SubspaceRefType](x, IPXACT2022scalaxb.ElemName(node) :: stack)))))
  
    def parseMemoryMapGroup(node: scala.xml.Node, stack: List[IPXACT2022scalaxb.ElemName], wrap: Boolean): Parser[IPXACT2022scalaxb.DataRecord[IPXACT2022ScalaCases.MemoryMapOption]] =
      (((IPXACT2022scalaxb.ElemName(Some("http://www.accellera.org/XMLSchema/IPXACT/1685-2022"), "addressBlock")) ^^
      (x => IPXACT2022scalaxb.DataRecord(x.namespace, Some(x.name), IPXACT2022scalaxb.fromXML[IPXACT2022ScalaCases.AddressBlockType](x, IPXACT2022scalaxb.ElemName(node) :: stack)))) |
      ((IPXACT2022scalaxb.ElemName(Some("http://www.accellera.org/XMLSchema/IPXACT/1685-2022"), "bank")) ^^
      (x => IPXACT2022scalaxb.DataRecord(x.namespace, Some(x.name), IPXACT2022scalaxb.fromXML[IPXACT2022ScalaCases.AddressBankType](x, IPXACT2022scalaxb.ElemName(node) :: stack)))) |
      ((IPXACT2022scalaxb.ElemName(Some("http://www.accellera.org/XMLSchema/IPXACT/1685-2022"), "subspaceMap")) ^^
      (x => IPXACT2022scalaxb.DataRecord(x.namespace, Some(x.name), IPXACT2022scalaxb.fromXML[IPXACT2022ScalaCases.SubspaceRefType](x, IPXACT2022scalaxb.ElemName(node) :: stack)))))
    
    def parsemixedMemoryMapGroup(node: scala.xml.Node, stack: List[IPXACT2022scalaxb.ElemName]): Parser[Seq[IPXACT2022scalaxb.DataRecord[Any]]] =
      (((((IPXACT2022scalaxb.ElemName(Some("http://www.accellera.org/XMLSchema/IPXACT/1685-2022"), "addressBlock")) ^^
      (x => IPXACT2022scalaxb.DataRecord(x.namespace, Some(x.name), IPXACT2022scalaxb.fromXML[IPXACT2022ScalaCases.AddressBlockType](x, IPXACT2022scalaxb.ElemName(node) :: stack)))) ~
      optTextRecord) ^^ 
        { case p1 ~ p2 => Seq.concat(Seq(p1),
        p2.toList) }) ||| 
      ((((IPXACT2022scalaxb.ElemName(Some("http://www.accellera.org/XMLSchema/IPXACT/1685-2022"), "bank")) ^^
      (x => IPXACT2022scalaxb.DataRecord(x.namespace, Some(x.name), IPXACT2022scalaxb.fromXML[IPXACT2022ScalaCases.AddressBankType](x, IPXACT2022scalaxb.ElemName(node) :: stack)))) ~
      optTextRecord) ^^ 
        { case p1 ~ p2 => Seq.concat(Seq(p1),
        p2.toList) }) ||| 
      ((((IPXACT2022scalaxb.ElemName(Some("http://www.accellera.org/XMLSchema/IPXACT/1685-2022"), "subspaceMap")) ^^
      (x => IPXACT2022scalaxb.DataRecord(x.namespace, Some(x.name), IPXACT2022scalaxb.fromXML[IPXACT2022ScalaCases.SubspaceRefType](x, IPXACT2022scalaxb.ElemName(node) :: stack)))) ~
      optTextRecord) ^^ 
        { case p1 ~ p2 => Seq.concat(Seq(p1),
        p2.toList) }))
  }


  trait IPXACT2022ScalaCases_MemoryMapDefinitionTypeGroupGroupFormat extends IPXACT2022scalaxb.AnyElemNameParser {
    def parseMemoryMapDefinitionTypeGroupGroup(node: scala.xml.Node, stack: List[IPXACT2022scalaxb.ElemName]): Parser[IPXACT2022ScalaCases.MemoryMapDefinitionTypeGroupSequence] =
      ((safeRep(((IPXACT2022scalaxb.ElemName(Some("http://www.accellera.org/XMLSchema/IPXACT/1685-2022"), "addressBlock")) ^^
      (x => IPXACT2022scalaxb.DataRecord(x.namespace, Some(x.name), IPXACT2022scalaxb.fromXML[IPXACT2022ScalaCases.AddressBlockType](x, IPXACT2022scalaxb.ElemName(node) :: stack)))) |
      ((IPXACT2022scalaxb.ElemName(Some("http://www.accellera.org/XMLSchema/IPXACT/1685-2022"), "bank")) ^^
      (x => IPXACT2022scalaxb.DataRecord(x.namespace, Some(x.name), IPXACT2022scalaxb.fromXML[IPXACT2022ScalaCases.AddressBankDefinitionType](x, IPXACT2022scalaxb.ElemName(node) :: stack))))) ~
      safeRep(IPXACT2022scalaxb.ElemName(Some("http://www.accellera.org/XMLSchema/IPXACT/1685-2022"), "memoryRemap")) ~
      opt(IPXACT2022scalaxb.ElemName(Some("http://www.accellera.org/XMLSchema/IPXACT/1685-2022"), "addressUnitBits")) ~
      opt(IPXACT2022scalaxb.ElemName(Some("http://www.accellera.org/XMLSchema/IPXACT/1685-2022"), "shared"))) ^^
        { case p1 ~ p2 ~ p3 ~ p4 => IPXACT2022ScalaCases.MemoryMapDefinitionTypeGroupSequence(p1,
        p2 map { IPXACT2022scalaxb.fromXML[IPXACT2022ScalaCases.MemoryRemapDefinitionType](_, IPXACT2022scalaxb.ElemName(node) :: stack) },
        p3.headOption map { IPXACT2022scalaxb.fromXML[IPXACT2022ScalaCases.UnsignedPositiveLongintExpressionable](_, IPXACT2022scalaxb.ElemName(node) :: stack) },
        p4.headOption map { IPXACT2022scalaxb.fromXML[IPXACT2022ScalaCases.SharedType](_, IPXACT2022scalaxb.ElemName(node) :: stack) }) })
  
    def parseMemoryMapDefinitionTypeGroupGroup(node: scala.xml.Node, stack: List[IPXACT2022scalaxb.ElemName], wrap: Boolean): Parser[IPXACT2022scalaxb.DataRecord[Any]] =
      ((safeRep(((IPXACT2022scalaxb.ElemName(Some("http://www.accellera.org/XMLSchema/IPXACT/1685-2022"), "addressBlock")) ^^
      (x => IPXACT2022scalaxb.DataRecord(x.namespace, Some(x.name), IPXACT2022scalaxb.fromXML[IPXACT2022ScalaCases.AddressBlockType](x, IPXACT2022scalaxb.ElemName(node) :: stack)))) |
      ((IPXACT2022scalaxb.ElemName(Some("http://www.accellera.org/XMLSchema/IPXACT/1685-2022"), "bank")) ^^
      (x => IPXACT2022scalaxb.DataRecord(x.namespace, Some(x.name), IPXACT2022scalaxb.fromXML[IPXACT2022ScalaCases.AddressBankDefinitionType](x, IPXACT2022scalaxb.ElemName(node) :: stack))))) ~
      safeRep(IPXACT2022scalaxb.ElemName(Some("http://www.accellera.org/XMLSchema/IPXACT/1685-2022"), "memoryRemap")) ~
      opt(IPXACT2022scalaxb.ElemName(Some("http://www.accellera.org/XMLSchema/IPXACT/1685-2022"), "addressUnitBits")) ~
      opt(IPXACT2022scalaxb.ElemName(Some("http://www.accellera.org/XMLSchema/IPXACT/1685-2022"), "shared"))) ^^
        { case p1 ~ p2 ~ p3 ~ p4 => IPXACT2022scalaxb.DataRecord(IPXACT2022ScalaCases.MemoryMapDefinitionTypeGroupSequence(p1,
        p2 map { IPXACT2022scalaxb.fromXML[IPXACT2022ScalaCases.MemoryRemapDefinitionType](_, IPXACT2022scalaxb.ElemName(node) :: stack) },
        p3.headOption map { IPXACT2022scalaxb.fromXML[IPXACT2022ScalaCases.UnsignedPositiveLongintExpressionable](_, IPXACT2022scalaxb.ElemName(node) :: stack) },
        p4.headOption map { IPXACT2022scalaxb.fromXML[IPXACT2022ScalaCases.SharedType](_, IPXACT2022scalaxb.ElemName(node) :: stack) })) })
    
    def parsemixedMemoryMapDefinitionTypeGroupGroup(node: scala.xml.Node, stack: List[IPXACT2022scalaxb.ElemName]): Parser[Seq[IPXACT2022scalaxb.DataRecord[Any]]] =
      ((safeRep(((((IPXACT2022scalaxb.ElemName(Some("http://www.accellera.org/XMLSchema/IPXACT/1685-2022"), "addressBlock")) ^^
      (x => IPXACT2022scalaxb.DataRecord(x.namespace, Some(x.name), IPXACT2022scalaxb.fromXML[IPXACT2022ScalaCases.AddressBlockType](x, IPXACT2022scalaxb.ElemName(node) :: stack)))) ~
      optTextRecord) ^^ 
        { case p1 ~ p2 => Seq.concat(Seq(p1),
        p2.toList) }) ||| 
      ((((IPXACT2022scalaxb.ElemName(Some("http://www.accellera.org/XMLSchema/IPXACT/1685-2022"), "bank")) ^^
      (x => IPXACT2022scalaxb.DataRecord(x.namespace, Some(x.name), IPXACT2022scalaxb.fromXML[IPXACT2022ScalaCases.AddressBankDefinitionType](x, IPXACT2022scalaxb.ElemName(node) :: stack)))) ~
      optTextRecord) ^^ 
        { case p1 ~ p2 => Seq.concat(Seq(p1),
        p2.toList) })) ~ 
      optTextRecord ~ 
      (safeRep(IPXACT2022scalaxb.ElemName(Some("http://www.accellera.org/XMLSchema/IPXACT/1685-2022"), "memoryRemap")) ^^
      (_.toSeq map { x => IPXACT2022scalaxb.DataRecord(x.namespace, Some(x.name), IPXACT2022scalaxb.fromXML[IPXACT2022ScalaCases.MemoryRemapDefinitionType](x, IPXACT2022scalaxb.ElemName(node) :: stack)) })) ~
      optTextRecord ~ 
      (opt(IPXACT2022scalaxb.ElemName(Some("http://www.accellera.org/XMLSchema/IPXACT/1685-2022"), "addressUnitBits")) ^^
      (_ map { x => IPXACT2022scalaxb.DataRecord(x.namespace, Some(x.name), IPXACT2022scalaxb.fromXML[IPXACT2022ScalaCases.UnsignedPositiveLongintExpressionable](x, IPXACT2022scalaxb.ElemName(node) :: stack)) })) ~
      optTextRecord ~ 
      (opt(IPXACT2022scalaxb.ElemName(Some("http://www.accellera.org/XMLSchema/IPXACT/1685-2022"), "shared")) ^^
      (_ map { x => IPXACT2022scalaxb.DataRecord(x.namespace, Some(x.name), IPXACT2022scalaxb.fromXML[String](x, IPXACT2022scalaxb.ElemName(node) :: stack)) })) ~
      optTextRecord) ^^ 
        { case p1 ~ p2 ~ p3 ~ p4 ~ p5 ~ p6 ~ p7 ~ p8 => Seq.concat(p1.flatten,
        p2.toList,
        p3,
        p4.toList,
        p5.toList,
        p6.toList,
        p7.toList,
        p8.toList) })
  }

  trait DefaultIPXACT2022ScalaCases_MemoryMapDefinitionTypeGroupSequenceFormat extends IPXACT2022scalaxb.XMLFormat[IPXACT2022ScalaCases.MemoryMapDefinitionTypeGroupSequence] {
    def reads(seq: scala.xml.NodeSeq, stack: List[IPXACT2022scalaxb.ElemName]): Either[String, IPXACT2022ScalaCases.MemoryMapDefinitionTypeGroupSequence] = Left("don't call me.")
    
    def writes(__obj: IPXACT2022ScalaCases.MemoryMapDefinitionTypeGroupSequence, __namespace: Option[String], __elementLabel: Option[String],
        __scope: scala.xml.NamespaceBinding, __typeAttribute: Boolean): scala.xml.NodeSeq =
      Seq.concat(__obj.memorymapdefinitiontypegroupoption1 flatMap { x => IPXACT2022scalaxb.toXML[IPXACT2022scalaxb.DataRecord[IPXACT2022ScalaCases.MemoryMapDefinitionTypeGroupOption1]](x, x.namespace, x.key, __scope, false) },
        __obj.memoryRemap flatMap { IPXACT2022scalaxb.toXML[IPXACT2022ScalaCases.MemoryRemapDefinitionType](_, Some("http://www.accellera.org/XMLSchema/IPXACT/1685-2022"), Some("memoryRemap"), __scope, false) },
        __obj.addressUnitBits map { IPXACT2022scalaxb.toXML[IPXACT2022ScalaCases.UnsignedPositiveLongintExpressionable](_, Some("http://www.accellera.org/XMLSchema/IPXACT/1685-2022"), Some("addressUnitBits"), __scope, false) } getOrElse {Nil},
        __obj.shared map { IPXACT2022scalaxb.toXML[IPXACT2022ScalaCases.SharedType](_, Some("http://www.accellera.org/XMLSchema/IPXACT/1685-2022"), Some("shared"), __scope, false) } getOrElse {Nil})


  }


/** This is a group of optional elements commonly added to various types of address blocks in a memory map.
*/
  trait IPXACT2022ScalaCases_AddressBlockExtensionsGroupFormat extends IPXACT2022ScalaCases_MemoryBlockDataGroupFormat with IPXACT2022ScalaCases_RegisterDataGroupFormat {
    def parseAddressBlockExtensionsGroup(node: scala.xml.Node, stack: List[IPXACT2022scalaxb.ElemName]): Parser[IPXACT2022ScalaCases.AddressBlockExtensionsSequence] =
      (((parseMemoryBlockDataGroup(node, IPXACT2022scalaxb.ElemName(node) :: stack)) ~
      safeRep(parseRegisterDataGroup(node, IPXACT2022scalaxb.ElemName(node) :: stack))) ^^
        { case p1 ~ p2 => IPXACT2022ScalaCases.AddressBlockExtensionsSequence(p1,
        p2) })
  
    def parseAddressBlockExtensionsGroup(node: scala.xml.Node, stack: List[IPXACT2022scalaxb.ElemName], wrap: Boolean): Parser[IPXACT2022scalaxb.DataRecord[Any]] =
      (((parseMemoryBlockDataGroup(node, IPXACT2022scalaxb.ElemName(node) :: stack)) ~
      safeRep(parseRegisterDataGroup(node, IPXACT2022scalaxb.ElemName(node) :: stack))) ^^
        { case p1 ~ p2 => IPXACT2022scalaxb.DataRecord(IPXACT2022ScalaCases.AddressBlockExtensionsSequence(p1,
        p2)) })
    
    def parsemixedAddressBlockExtensionsGroup(node: scala.xml.Node, stack: List[IPXACT2022scalaxb.ElemName]): Parser[Seq[IPXACT2022scalaxb.DataRecord[Any]]] =
      (((parsemixedMemoryBlockDataGroup(node, IPXACT2022scalaxb.ElemName(node) :: stack)) ~
      optTextRecord ~ 
      safeRep(parsemixedRegisterDataGroup(node, IPXACT2022scalaxb.ElemName(node) :: stack)) ~
      optTextRecord) ^^ 
        { case p1 ~ p2 ~ p3 ~ p4 => Seq.concat(p1,
        p2.toList,
        p3.flatten,
        p4.toList) })
  }

  trait DefaultIPXACT2022ScalaCases_AddressBlockExtensionsSequenceFormat extends IPXACT2022scalaxb.XMLFormat[IPXACT2022ScalaCases.AddressBlockExtensionsSequence] {
    def reads(seq: scala.xml.NodeSeq, stack: List[IPXACT2022scalaxb.ElemName]): Either[String, IPXACT2022ScalaCases.AddressBlockExtensionsSequence] = Left("don't call me.")
    
    def writes(__obj: IPXACT2022ScalaCases.AddressBlockExtensionsSequence, __namespace: Option[String], __elementLabel: Option[String],
        __scope: scala.xml.NamespaceBinding, __typeAttribute: Boolean): scala.xml.NodeSeq =
      Seq.concat(IPXACT2022scalaxb.toXML[IPXACT2022ScalaCases.MemoryBlockDataSequence](__obj.memoryBlockDataSequence1, None, Some("memoryBlockDataSequence1"), __scope, false),
        __obj.registerDataOption2 flatMap { x => IPXACT2022scalaxb.toXML[IPXACT2022scalaxb.DataRecord[IPXACT2022ScalaCases.RegisterDataOption]](x, x.namespace, x.key, __scope, false) })


  }


/** This group of elements is common to top level banks and banked banks.
*/
  trait IPXACT2022ScalaCases_BankBaseGroupFormat extends IPXACT2022ScalaCases_MemoryBlockDataGroupFormat {
    def parseBankBaseGroup(node: scala.xml.Node, stack: List[IPXACT2022scalaxb.ElemName]): Parser[IPXACT2022ScalaCases.BankBaseSequence] =
      ((safeRep(((IPXACT2022scalaxb.ElemName(Some("http://www.accellera.org/XMLSchema/IPXACT/1685-2022"), "addressBlock")) ^^
      (x => IPXACT2022scalaxb.DataRecord(x.namespace, Some(x.name), IPXACT2022scalaxb.fromXML[IPXACT2022ScalaCases.BankedBlockType](x, IPXACT2022scalaxb.ElemName(node) :: stack)))) |
      ((IPXACT2022scalaxb.ElemName(Some("http://www.accellera.org/XMLSchema/IPXACT/1685-2022"), "bank")) ^^
      (x => IPXACT2022scalaxb.DataRecord(x.namespace, Some(x.name), IPXACT2022scalaxb.fromXML[IPXACT2022ScalaCases.Bank2](x, IPXACT2022scalaxb.ElemName(node) :: stack)))) |
      ((IPXACT2022scalaxb.ElemName(Some("http://www.accellera.org/XMLSchema/IPXACT/1685-2022"), "subspaceMap")) ^^
      (x => IPXACT2022scalaxb.DataRecord(x.namespace, Some(x.name), IPXACT2022scalaxb.fromXML[IPXACT2022ScalaCases.BankedSubspaceType](x, IPXACT2022scalaxb.ElemName(node) :: stack))))) ~
      (parseMemoryBlockDataGroup(node, IPXACT2022scalaxb.ElemName(node) :: stack))) ^^
        { case p1 ~ p2 => IPXACT2022ScalaCases.BankBaseSequence(p1,
        p2) })
  
    def parseBankBaseGroup(node: scala.xml.Node, stack: List[IPXACT2022scalaxb.ElemName], wrap: Boolean): Parser[IPXACT2022scalaxb.DataRecord[Any]] =
      ((safeRep(((IPXACT2022scalaxb.ElemName(Some("http://www.accellera.org/XMLSchema/IPXACT/1685-2022"), "addressBlock")) ^^
      (x => IPXACT2022scalaxb.DataRecord(x.namespace, Some(x.name), IPXACT2022scalaxb.fromXML[IPXACT2022ScalaCases.BankedBlockType](x, IPXACT2022scalaxb.ElemName(node) :: stack)))) |
      ((IPXACT2022scalaxb.ElemName(Some("http://www.accellera.org/XMLSchema/IPXACT/1685-2022"), "bank")) ^^
      (x => IPXACT2022scalaxb.DataRecord(x.namespace, Some(x.name), IPXACT2022scalaxb.fromXML[IPXACT2022ScalaCases.Bank2](x, IPXACT2022scalaxb.ElemName(node) :: stack)))) |
      ((IPXACT2022scalaxb.ElemName(Some("http://www.accellera.org/XMLSchema/IPXACT/1685-2022"), "subspaceMap")) ^^
      (x => IPXACT2022scalaxb.DataRecord(x.namespace, Some(x.name), IPXACT2022scalaxb.fromXML[IPXACT2022ScalaCases.BankedSubspaceType](x, IPXACT2022scalaxb.ElemName(node) :: stack))))) ~
      (parseMemoryBlockDataGroup(node, IPXACT2022scalaxb.ElemName(node) :: stack))) ^^
        { case p1 ~ p2 => IPXACT2022scalaxb.DataRecord(IPXACT2022ScalaCases.BankBaseSequence(p1,
        p2)) })
    
    def parsemixedBankBaseGroup(node: scala.xml.Node, stack: List[IPXACT2022scalaxb.ElemName]): Parser[Seq[IPXACT2022scalaxb.DataRecord[Any]]] =
      ((safeRep(((((IPXACT2022scalaxb.ElemName(Some("http://www.accellera.org/XMLSchema/IPXACT/1685-2022"), "addressBlock")) ^^
      (x => IPXACT2022scalaxb.DataRecord(x.namespace, Some(x.name), IPXACT2022scalaxb.fromXML[IPXACT2022ScalaCases.BankedBlockType](x, IPXACT2022scalaxb.ElemName(node) :: stack)))) ~
      optTextRecord) ^^ 
        { case p1 ~ p2 => Seq.concat(Seq(p1),
        p2.toList) }) ||| 
      ((((IPXACT2022scalaxb.ElemName(Some("http://www.accellera.org/XMLSchema/IPXACT/1685-2022"), "bank")) ^^
      (x => IPXACT2022scalaxb.DataRecord(x.namespace, Some(x.name), IPXACT2022scalaxb.fromXML[IPXACT2022ScalaCases.Bank2](x, IPXACT2022scalaxb.ElemName(node) :: stack)))) ~
      optTextRecord) ^^ 
        { case p1 ~ p2 => Seq.concat(Seq(p1),
        p2.toList) }) ||| 
      ((((IPXACT2022scalaxb.ElemName(Some("http://www.accellera.org/XMLSchema/IPXACT/1685-2022"), "subspaceMap")) ^^
      (x => IPXACT2022scalaxb.DataRecord(x.namespace, Some(x.name), IPXACT2022scalaxb.fromXML[IPXACT2022ScalaCases.BankedSubspaceType](x, IPXACT2022scalaxb.ElemName(node) :: stack)))) ~
      optTextRecord) ^^ 
        { case p1 ~ p2 => Seq.concat(Seq(p1),
        p2.toList) })) ~ 
      optTextRecord ~ 
      (parsemixedMemoryBlockDataGroup(node, IPXACT2022scalaxb.ElemName(node) :: stack)) ~
      optTextRecord) ^^ 
        { case p1 ~ p2 ~ p3 ~ p4 => Seq.concat(p1.flatten,
        p2.toList,
        p3,
        p4.toList) })
  }

  trait DefaultIPXACT2022ScalaCases_BankBaseSequenceFormat extends IPXACT2022scalaxb.XMLFormat[IPXACT2022ScalaCases.BankBaseSequence] {
    def reads(seq: scala.xml.NodeSeq, stack: List[IPXACT2022scalaxb.ElemName]): Either[String, IPXACT2022ScalaCases.BankBaseSequence] = Left("don't call me.")
    
    def writes(__obj: IPXACT2022ScalaCases.BankBaseSequence, __namespace: Option[String], __elementLabel: Option[String],
        __scope: scala.xml.NamespaceBinding, __typeAttribute: Boolean): scala.xml.NodeSeq =
      Seq.concat(__obj.bankbaseoption1 flatMap { x => IPXACT2022scalaxb.toXML[IPXACT2022scalaxb.DataRecord[IPXACT2022ScalaCases.BankBaseOption1]](x, x.namespace, x.key, __scope, false) },
        IPXACT2022scalaxb.toXML[IPXACT2022ScalaCases.MemoryBlockDataSequence](__obj.memoryBlockDataSequence2, None, Some("memoryBlockDataSequence2"), __scope, false))


  }


/** This group of elements is common to top level banks and banked banks.
*/
  trait IPXACT2022ScalaCases_LocalBankBaseGroupFormat extends IPXACT2022ScalaCases_MemoryBlockDataGroupFormat {
    def parseLocalBankBaseGroup(node: scala.xml.Node, stack: List[IPXACT2022scalaxb.ElemName]): Parser[IPXACT2022ScalaCases.LocalBankBaseSequence] =
      ((safeRep(((IPXACT2022scalaxb.ElemName(Some("http://www.accellera.org/XMLSchema/IPXACT/1685-2022"), "addressBlock")) ^^
      (x => IPXACT2022scalaxb.DataRecord(x.namespace, Some(x.name), IPXACT2022scalaxb.fromXML[IPXACT2022ScalaCases.BankedBlockType](x, IPXACT2022scalaxb.ElemName(node) :: stack)))) |
      ((IPXACT2022scalaxb.ElemName(Some("http://www.accellera.org/XMLSchema/IPXACT/1685-2022"), "bank")) ^^
      (x => IPXACT2022scalaxb.DataRecord(x.namespace, Some(x.name), IPXACT2022scalaxb.fromXML[IPXACT2022ScalaCases.LocalBankedBankType](x, IPXACT2022scalaxb.ElemName(node) :: stack))))) ~
      (parseMemoryBlockDataGroup(node, IPXACT2022scalaxb.ElemName(node) :: stack)) ~
      opt(IPXACT2022scalaxb.ElemName(Some("http://www.accellera.org/XMLSchema/IPXACT/1685-2022"), "vendorExtensions"))) ^^
        { case p1 ~ p2 ~ p3 => IPXACT2022ScalaCases.LocalBankBaseSequence(p1,
        p2,
        p3.headOption map { IPXACT2022scalaxb.fromXML[IPXACT2022ScalaCases.VendorExtensions](_, IPXACT2022scalaxb.ElemName(node) :: stack) }) })
  
    def parseLocalBankBaseGroup(node: scala.xml.Node, stack: List[IPXACT2022scalaxb.ElemName], wrap: Boolean): Parser[IPXACT2022scalaxb.DataRecord[Any]] =
      ((safeRep(((IPXACT2022scalaxb.ElemName(Some("http://www.accellera.org/XMLSchema/IPXACT/1685-2022"), "addressBlock")) ^^
      (x => IPXACT2022scalaxb.DataRecord(x.namespace, Some(x.name), IPXACT2022scalaxb.fromXML[IPXACT2022ScalaCases.BankedBlockType](x, IPXACT2022scalaxb.ElemName(node) :: stack)))) |
      ((IPXACT2022scalaxb.ElemName(Some("http://www.accellera.org/XMLSchema/IPXACT/1685-2022"), "bank")) ^^
      (x => IPXACT2022scalaxb.DataRecord(x.namespace, Some(x.name), IPXACT2022scalaxb.fromXML[IPXACT2022ScalaCases.LocalBankedBankType](x, IPXACT2022scalaxb.ElemName(node) :: stack))))) ~
      (parseMemoryBlockDataGroup(node, IPXACT2022scalaxb.ElemName(node) :: stack)) ~
      opt(IPXACT2022scalaxb.ElemName(Some("http://www.accellera.org/XMLSchema/IPXACT/1685-2022"), "vendorExtensions"))) ^^
        { case p1 ~ p2 ~ p3 => IPXACT2022scalaxb.DataRecord(IPXACT2022ScalaCases.LocalBankBaseSequence(p1,
        p2,
        p3.headOption map { IPXACT2022scalaxb.fromXML[IPXACT2022ScalaCases.VendorExtensions](_, IPXACT2022scalaxb.ElemName(node) :: stack) })) })
    
    def parsemixedLocalBankBaseGroup(node: scala.xml.Node, stack: List[IPXACT2022scalaxb.ElemName]): Parser[Seq[IPXACT2022scalaxb.DataRecord[Any]]] =
      ((safeRep(((((IPXACT2022scalaxb.ElemName(Some("http://www.accellera.org/XMLSchema/IPXACT/1685-2022"), "addressBlock")) ^^
      (x => IPXACT2022scalaxb.DataRecord(x.namespace, Some(x.name), IPXACT2022scalaxb.fromXML[IPXACT2022ScalaCases.BankedBlockType](x, IPXACT2022scalaxb.ElemName(node) :: stack)))) ~
      optTextRecord) ^^ 
        { case p1 ~ p2 => Seq.concat(Seq(p1),
        p2.toList) }) ||| 
      ((((IPXACT2022scalaxb.ElemName(Some("http://www.accellera.org/XMLSchema/IPXACT/1685-2022"), "bank")) ^^
      (x => IPXACT2022scalaxb.DataRecord(x.namespace, Some(x.name), IPXACT2022scalaxb.fromXML[IPXACT2022ScalaCases.LocalBankedBankType](x, IPXACT2022scalaxb.ElemName(node) :: stack)))) ~
      optTextRecord) ^^ 
        { case p1 ~ p2 => Seq.concat(Seq(p1),
        p2.toList) })) ~ 
      optTextRecord ~ 
      (parsemixedMemoryBlockDataGroup(node, IPXACT2022scalaxb.ElemName(node) :: stack)) ~
      optTextRecord ~ 
      (opt(IPXACT2022scalaxb.ElemName(Some("http://www.accellera.org/XMLSchema/IPXACT/1685-2022"), "vendorExtensions")) ^^
      (_ map { x => IPXACT2022scalaxb.DataRecord(x.namespace, Some(x.name), IPXACT2022scalaxb.fromXML[IPXACT2022ScalaCases.VendorExtensions](x, IPXACT2022scalaxb.ElemName(node) :: stack)) })) ~
      optTextRecord) ^^ 
        { case p1 ~ p2 ~ p3 ~ p4 ~ p5 ~ p6 => Seq.concat(p1.flatten,
        p2.toList,
        p3,
        p4.toList,
        p5.toList,
        p6.toList) })
  }

  trait DefaultIPXACT2022ScalaCases_LocalBankBaseSequenceFormat extends IPXACT2022scalaxb.XMLFormat[IPXACT2022ScalaCases.LocalBankBaseSequence] {
    def reads(seq: scala.xml.NodeSeq, stack: List[IPXACT2022scalaxb.ElemName]): Either[String, IPXACT2022ScalaCases.LocalBankBaseSequence] = Left("don't call me.")
    
    def writes(__obj: IPXACT2022ScalaCases.LocalBankBaseSequence, __namespace: Option[String], __elementLabel: Option[String],
        __scope: scala.xml.NamespaceBinding, __typeAttribute: Boolean): scala.xml.NodeSeq =
      Seq.concat(__obj.localbankbaseoption1 flatMap { x => IPXACT2022scalaxb.toXML[IPXACT2022scalaxb.DataRecord[IPXACT2022ScalaCases.LocalBankBaseOption1]](x, x.namespace, x.key, __scope, false) },
        IPXACT2022scalaxb.toXML[IPXACT2022ScalaCases.MemoryBlockDataSequence](__obj.memoryBlockDataSequence2, None, Some("memoryBlockDataSequence2"), __scope, false),
        __obj.vendorExtensions map { IPXACT2022scalaxb.toXML[IPXACT2022ScalaCases.VendorExtensions](_, Some("http://www.accellera.org/XMLSchema/IPXACT/1685-2022"), Some("vendorExtensions"), __scope, false) } getOrElse {Nil})


  }


/** This group of optional elements can be used to provide additional descriptions to an address block or bank.

Note that this is a group, not an element.  It does not appear in the XML, but its contents may.
*/
  trait IPXACT2022ScalaCases_MemoryBlockDataGroupFormat extends IPXACT2022scalaxb.AnyElemNameParser {
    def parseMemoryBlockDataGroup(node: scala.xml.Node, stack: List[IPXACT2022scalaxb.ElemName]): Parser[IPXACT2022ScalaCases.MemoryBlockDataSequence] =
      ((opt(IPXACT2022scalaxb.ElemName(Some("http://www.accellera.org/XMLSchema/IPXACT/1685-2022"), "usage")) ~
      opt(IPXACT2022scalaxb.ElemName(Some("http://www.accellera.org/XMLSchema/IPXACT/1685-2022"), "volatile")) ~
      opt(IPXACT2022scalaxb.ElemName(Some("http://www.accellera.org/XMLSchema/IPXACT/1685-2022"), "accessPolicies")) ~
      opt(IPXACT2022scalaxb.ElemName(Some("http://www.accellera.org/XMLSchema/IPXACT/1685-2022"), "parameters"))) ^^
        { case p1 ~ p2 ~ p3 ~ p4 => IPXACT2022ScalaCases.MemoryBlockDataSequence(p1.headOption map { IPXACT2022scalaxb.fromXML[IPXACT2022ScalaCases.UsageType](_, IPXACT2022scalaxb.ElemName(node) :: stack) },
        p2.headOption map { IPXACT2022scalaxb.fromXML[Boolean](_, IPXACT2022scalaxb.ElemName(node) :: stack) },
        p3.headOption map { IPXACT2022scalaxb.fromXML[IPXACT2022ScalaCases.AccessPolicies](_, IPXACT2022scalaxb.ElemName(node) :: stack) },
        p4.headOption map { IPXACT2022scalaxb.fromXML[IPXACT2022ScalaCases.Parameters](_, IPXACT2022scalaxb.ElemName(node) :: stack) }) })
  
    def parseMemoryBlockDataGroup(node: scala.xml.Node, stack: List[IPXACT2022scalaxb.ElemName], wrap: Boolean): Parser[IPXACT2022scalaxb.DataRecord[Any]] =
      ((opt(IPXACT2022scalaxb.ElemName(Some("http://www.accellera.org/XMLSchema/IPXACT/1685-2022"), "usage")) ~
      opt(IPXACT2022scalaxb.ElemName(Some("http://www.accellera.org/XMLSchema/IPXACT/1685-2022"), "volatile")) ~
      opt(IPXACT2022scalaxb.ElemName(Some("http://www.accellera.org/XMLSchema/IPXACT/1685-2022"), "accessPolicies")) ~
      opt(IPXACT2022scalaxb.ElemName(Some("http://www.accellera.org/XMLSchema/IPXACT/1685-2022"), "parameters"))) ^^
        { case p1 ~ p2 ~ p3 ~ p4 => IPXACT2022scalaxb.DataRecord(IPXACT2022ScalaCases.MemoryBlockDataSequence(p1.headOption map { IPXACT2022scalaxb.fromXML[IPXACT2022ScalaCases.UsageType](_, IPXACT2022scalaxb.ElemName(node) :: stack) },
        p2.headOption map { IPXACT2022scalaxb.fromXML[Boolean](_, IPXACT2022scalaxb.ElemName(node) :: stack) },
        p3.headOption map { IPXACT2022scalaxb.fromXML[IPXACT2022ScalaCases.AccessPolicies](_, IPXACT2022scalaxb.ElemName(node) :: stack) },
        p4.headOption map { IPXACT2022scalaxb.fromXML[IPXACT2022ScalaCases.Parameters](_, IPXACT2022scalaxb.ElemName(node) :: stack) })) })
    
    def parsemixedMemoryBlockDataGroup(node: scala.xml.Node, stack: List[IPXACT2022scalaxb.ElemName]): Parser[Seq[IPXACT2022scalaxb.DataRecord[Any]]] =
      (((opt(IPXACT2022scalaxb.ElemName(Some("http://www.accellera.org/XMLSchema/IPXACT/1685-2022"), "usage")) ^^
      (_ map { x => IPXACT2022scalaxb.DataRecord(x.namespace, Some(x.name), IPXACT2022scalaxb.fromXML[String](x, IPXACT2022scalaxb.ElemName(node) :: stack)) })) ~
      optTextRecord ~ 
      (opt(IPXACT2022scalaxb.ElemName(Some("http://www.accellera.org/XMLSchema/IPXACT/1685-2022"), "volatile")) ^^
      (_ map { x => IPXACT2022scalaxb.DataRecord(x.namespace, Some(x.name), IPXACT2022scalaxb.fromXML[Boolean](x, IPXACT2022scalaxb.ElemName(node) :: stack)) })) ~
      optTextRecord ~ 
      (opt(IPXACT2022scalaxb.ElemName(Some("http://www.accellera.org/XMLSchema/IPXACT/1685-2022"), "accessPolicies")) ^^
      (_ map { x => IPXACT2022scalaxb.DataRecord(x.namespace, Some(x.name), IPXACT2022scalaxb.fromXML[IPXACT2022ScalaCases.AccessPolicies](x, IPXACT2022scalaxb.ElemName(node) :: stack)) })) ~
      optTextRecord ~ 
      (opt(IPXACT2022scalaxb.ElemName(Some("http://www.accellera.org/XMLSchema/IPXACT/1685-2022"), "parameters")) ^^
      (_ map { x => IPXACT2022scalaxb.DataRecord(x.namespace, Some(x.name), IPXACT2022scalaxb.fromXML[IPXACT2022ScalaCases.Parameters](x, IPXACT2022scalaxb.ElemName(node) :: stack)) })) ~
      optTextRecord) ^^ 
        { case p1 ~ p2 ~ p3 ~ p4 ~ p5 ~ p6 ~ p7 ~ p8 => Seq.concat(p1.toList,
        p2.toList,
        p3.toList,
        p4.toList,
        p5.toList,
        p6.toList,
        p7.toList,
        p8.toList) })
  }

  trait DefaultIPXACT2022ScalaCases_MemoryBlockDataSequenceFormat extends IPXACT2022scalaxb.XMLFormat[IPXACT2022ScalaCases.MemoryBlockDataSequence] {
    def reads(seq: scala.xml.NodeSeq, stack: List[IPXACT2022scalaxb.ElemName]): Either[String, IPXACT2022ScalaCases.MemoryBlockDataSequence] = Left("don't call me.")
    
    def writes(__obj: IPXACT2022ScalaCases.MemoryBlockDataSequence, __namespace: Option[String], __elementLabel: Option[String],
        __scope: scala.xml.NamespaceBinding, __typeAttribute: Boolean): scala.xml.NodeSeq =
      Seq.concat(__obj.usage map { IPXACT2022scalaxb.toXML[IPXACT2022ScalaCases.UsageType](_, Some("http://www.accellera.org/XMLSchema/IPXACT/1685-2022"), Some("usage"), __scope, false) } getOrElse {Nil},
        __obj.volatile map { IPXACT2022scalaxb.toXML[Boolean](_, Some("http://www.accellera.org/XMLSchema/IPXACT/1685-2022"), Some("volatile"), __scope, false) } getOrElse {Nil},
        __obj.accessPolicies map { IPXACT2022scalaxb.toXML[IPXACT2022ScalaCases.AccessPolicies](_, Some("http://www.accellera.org/XMLSchema/IPXACT/1685-2022"), Some("accessPolicies"), __scope, false) } getOrElse {Nil},
        __obj.parameters map { IPXACT2022scalaxb.toXML[IPXACT2022ScalaCases.Parameters](_, Some("http://www.accellera.org/XMLSchema/IPXACT/1685-2022"), Some("parameters"), __scope, false) } getOrElse {Nil})


  }


/** Additional field data
*/
  trait IPXACT2022ScalaCases_FieldDataGroupFormat extends IPXACT2022scalaxb.AnyElemNameParser {
    def parseFieldDataGroup(node: scala.xml.Node, stack: List[IPXACT2022scalaxb.ElemName]): Parser[IPXACT2022ScalaCases.FieldDataSequence] =
      ((opt(IPXACT2022scalaxb.ElemName(Some("http://www.accellera.org/XMLSchema/IPXACT/1685-2022"), "fieldAccessPolicies")) ~
      opt(IPXACT2022scalaxb.ElemName(Some("http://www.accellera.org/XMLSchema/IPXACT/1685-2022"), "enumeratedValues"))) ^^
        { case p1 ~ p2 => IPXACT2022ScalaCases.FieldDataSequence(p1.headOption map { IPXACT2022scalaxb.fromXML[IPXACT2022ScalaCases.FieldAccessPolicies](_, IPXACT2022scalaxb.ElemName(node) :: stack) },
        p2.headOption map { IPXACT2022scalaxb.fromXML[IPXACT2022ScalaCases.EnumeratedValues](_, IPXACT2022scalaxb.ElemName(node) :: stack) }) })
  
    def parseFieldDataGroup(node: scala.xml.Node, stack: List[IPXACT2022scalaxb.ElemName], wrap: Boolean): Parser[IPXACT2022scalaxb.DataRecord[Any]] =
      ((opt(IPXACT2022scalaxb.ElemName(Some("http://www.accellera.org/XMLSchema/IPXACT/1685-2022"), "fieldAccessPolicies")) ~
      opt(IPXACT2022scalaxb.ElemName(Some("http://www.accellera.org/XMLSchema/IPXACT/1685-2022"), "enumeratedValues"))) ^^
        { case p1 ~ p2 => IPXACT2022scalaxb.DataRecord(IPXACT2022ScalaCases.FieldDataSequence(p1.headOption map { IPXACT2022scalaxb.fromXML[IPXACT2022ScalaCases.FieldAccessPolicies](_, IPXACT2022scalaxb.ElemName(node) :: stack) },
        p2.headOption map { IPXACT2022scalaxb.fromXML[IPXACT2022ScalaCases.EnumeratedValues](_, IPXACT2022scalaxb.ElemName(node) :: stack) })) })
    
    def parsemixedFieldDataGroup(node: scala.xml.Node, stack: List[IPXACT2022scalaxb.ElemName]): Parser[Seq[IPXACT2022scalaxb.DataRecord[Any]]] =
      (((opt(IPXACT2022scalaxb.ElemName(Some("http://www.accellera.org/XMLSchema/IPXACT/1685-2022"), "fieldAccessPolicies")) ^^
      (_ map { x => IPXACT2022scalaxb.DataRecord(x.namespace, Some(x.name), IPXACT2022scalaxb.fromXML[IPXACT2022ScalaCases.FieldAccessPolicies](x, IPXACT2022scalaxb.ElemName(node) :: stack)) })) ~
      optTextRecord ~ 
      (opt(IPXACT2022scalaxb.ElemName(Some("http://www.accellera.org/XMLSchema/IPXACT/1685-2022"), "enumeratedValues")) ^^
      (_ map { x => IPXACT2022scalaxb.DataRecord(x.namespace, Some(x.name), IPXACT2022scalaxb.fromXML[IPXACT2022ScalaCases.EnumeratedValues](x, IPXACT2022scalaxb.ElemName(node) :: stack)) })) ~
      optTextRecord) ^^ 
        { case p1 ~ p2 ~ p3 ~ p4 => Seq.concat(p1.toList,
        p2.toList,
        p3.toList,
        p4.toList) })
  }

  trait DefaultIPXACT2022ScalaCases_FieldDataSequenceFormat extends IPXACT2022scalaxb.XMLFormat[IPXACT2022ScalaCases.FieldDataSequence] {
    def reads(seq: scala.xml.NodeSeq, stack: List[IPXACT2022scalaxb.ElemName]): Either[String, IPXACT2022ScalaCases.FieldDataSequence] = Left("don't call me.")
    
    def writes(__obj: IPXACT2022ScalaCases.FieldDataSequence, __namespace: Option[String], __elementLabel: Option[String],
        __scope: scala.xml.NamespaceBinding, __typeAttribute: Boolean): scala.xml.NodeSeq =
      Seq.concat(__obj.fieldAccessPolicies map { IPXACT2022scalaxb.toXML[IPXACT2022ScalaCases.FieldAccessPolicies](_, Some("http://www.accellera.org/XMLSchema/IPXACT/1685-2022"), Some("fieldAccessPolicies"), __scope, false) } getOrElse {Nil},
        __obj.enumeratedValues map { IPXACT2022scalaxb.toXML[IPXACT2022ScalaCases.EnumeratedValues](_, Some("http://www.accellera.org/XMLSchema/IPXACT/1685-2022"), Some("enumeratedValues"), __scope, false) } getOrElse {Nil})


  }


/** Register file defnition specific information
*/
  trait IPXACT2022ScalaCases_RegisterFileDefinitionGroupGroupFormat extends IPXACT2022ScalaCases_RegisterDataGroupFormat {
    def parseRegisterFileDefinitionGroupGroup(node: scala.xml.Node, stack: List[IPXACT2022scalaxb.ElemName]): Parser[IPXACT2022ScalaCases.RegisterFileDefinitionGroupSequence] =
      ((opt(IPXACT2022scalaxb.ElemName(Some("http://www.accellera.org/XMLSchema/IPXACT/1685-2022"), "typeIdentifier")) ~
      (IPXACT2022scalaxb.ElemName(Some("http://www.accellera.org/XMLSchema/IPXACT/1685-2022"), "range")) ~
      opt(IPXACT2022scalaxb.ElemName(Some("http://www.accellera.org/XMLSchema/IPXACT/1685-2022"), "accessPolicies")) ~
      safeRep(parseRegisterDataGroup(node, IPXACT2022scalaxb.ElemName(node) :: stack))) ^^
        { case p1 ~ p2 ~ p3 ~ p4 => IPXACT2022ScalaCases.RegisterFileDefinitionGroupSequence(p1.headOption map { IPXACT2022scalaxb.fromXML[String](_, IPXACT2022scalaxb.ElemName(node) :: stack) },
        IPXACT2022scalaxb.fromXML[IPXACT2022ScalaCases.UnsignedPositiveLongintExpressionable](p2, IPXACT2022scalaxb.ElemName(node) :: stack),
        p3.headOption map { IPXACT2022scalaxb.fromXML[IPXACT2022ScalaCases.AccessPolicies](_, IPXACT2022scalaxb.ElemName(node) :: stack) },
        p4) })
  
    def parseRegisterFileDefinitionGroupGroup(node: scala.xml.Node, stack: List[IPXACT2022scalaxb.ElemName], wrap: Boolean): Parser[IPXACT2022scalaxb.DataRecord[Any]] =
      ((opt(IPXACT2022scalaxb.ElemName(Some("http://www.accellera.org/XMLSchema/IPXACT/1685-2022"), "typeIdentifier")) ~
      (IPXACT2022scalaxb.ElemName(Some("http://www.accellera.org/XMLSchema/IPXACT/1685-2022"), "range")) ~
      opt(IPXACT2022scalaxb.ElemName(Some("http://www.accellera.org/XMLSchema/IPXACT/1685-2022"), "accessPolicies")) ~
      safeRep(parseRegisterDataGroup(node, IPXACT2022scalaxb.ElemName(node) :: stack))) ^^
        { case p1 ~ p2 ~ p3 ~ p4 => IPXACT2022scalaxb.DataRecord(IPXACT2022ScalaCases.RegisterFileDefinitionGroupSequence(p1.headOption map { IPXACT2022scalaxb.fromXML[String](_, IPXACT2022scalaxb.ElemName(node) :: stack) },
        IPXACT2022scalaxb.fromXML[IPXACT2022ScalaCases.UnsignedPositiveLongintExpressionable](p2, IPXACT2022scalaxb.ElemName(node) :: stack),
        p3.headOption map { IPXACT2022scalaxb.fromXML[IPXACT2022ScalaCases.AccessPolicies](_, IPXACT2022scalaxb.ElemName(node) :: stack) },
        p4)) })
    
    def parsemixedRegisterFileDefinitionGroupGroup(node: scala.xml.Node, stack: List[IPXACT2022scalaxb.ElemName]): Parser[Seq[IPXACT2022scalaxb.DataRecord[Any]]] =
      (((opt(IPXACT2022scalaxb.ElemName(Some("http://www.accellera.org/XMLSchema/IPXACT/1685-2022"), "typeIdentifier")) ^^
      (_ map { x => IPXACT2022scalaxb.DataRecord(x.namespace, Some(x.name), IPXACT2022scalaxb.fromXML[String](x, IPXACT2022scalaxb.ElemName(node) :: stack)) })) ~
      optTextRecord ~ 
      ((IPXACT2022scalaxb.ElemName(Some("http://www.accellera.org/XMLSchema/IPXACT/1685-2022"), "range")) ^^
      (x => IPXACT2022scalaxb.DataRecord(x.namespace, Some(x.name), IPXACT2022scalaxb.fromXML[IPXACT2022ScalaCases.UnsignedPositiveLongintExpressionable](x, IPXACT2022scalaxb.ElemName(node) :: stack)))) ~
      optTextRecord ~ 
      (opt(IPXACT2022scalaxb.ElemName(Some("http://www.accellera.org/XMLSchema/IPXACT/1685-2022"), "accessPolicies")) ^^
      (_ map { x => IPXACT2022scalaxb.DataRecord(x.namespace, Some(x.name), IPXACT2022scalaxb.fromXML[IPXACT2022ScalaCases.AccessPolicies](x, IPXACT2022scalaxb.ElemName(node) :: stack)) })) ~
      optTextRecord ~ 
      safeRep(parsemixedRegisterDataGroup(node, IPXACT2022scalaxb.ElemName(node) :: stack)) ~
      optTextRecord) ^^ 
        { case p1 ~ p2 ~ p3 ~ p4 ~ p5 ~ p6 ~ p7 ~ p8 => Seq.concat(p1.toList,
        p2.toList,
        Seq(p3),
        p4.toList,
        p5.toList,
        p6.toList,
        p7.flatten,
        p8.toList) })
  }

  trait DefaultIPXACT2022ScalaCases_RegisterFileDefinitionGroupSequenceFormat extends IPXACT2022scalaxb.XMLFormat[IPXACT2022ScalaCases.RegisterFileDefinitionGroupSequence] {
    def reads(seq: scala.xml.NodeSeq, stack: List[IPXACT2022scalaxb.ElemName]): Either[String, IPXACT2022ScalaCases.RegisterFileDefinitionGroupSequence] = Left("don't call me.")
    
    def writes(__obj: IPXACT2022ScalaCases.RegisterFileDefinitionGroupSequence, __namespace: Option[String], __elementLabel: Option[String],
        __scope: scala.xml.NamespaceBinding, __typeAttribute: Boolean): scala.xml.NodeSeq =
      Seq.concat(__obj.typeIdentifier map { IPXACT2022scalaxb.toXML[String](_, Some("http://www.accellera.org/XMLSchema/IPXACT/1685-2022"), Some("typeIdentifier"), __scope, false) } getOrElse {Nil},
        IPXACT2022scalaxb.toXML[IPXACT2022ScalaCases.UnsignedPositiveLongintExpressionable](__obj.range, Some("http://www.accellera.org/XMLSchema/IPXACT/1685-2022"), Some("range"), __scope, false),
        __obj.accessPolicies map { IPXACT2022scalaxb.toXML[IPXACT2022ScalaCases.AccessPolicies](_, Some("http://www.accellera.org/XMLSchema/IPXACT/1685-2022"), Some("accessPolicies"), __scope, false) } getOrElse {Nil},
        __obj.registerDataOption4 flatMap { x => IPXACT2022scalaxb.toXML[IPXACT2022scalaxb.DataRecord[IPXACT2022ScalaCases.RegisterDataOption]](x, x.namespace, x.key, __scope, false) })


  }


/** Register definition specific information
*/
  trait IPXACT2022ScalaCases_RegisterDefinitionGroupGroupFormat extends IPXACT2022scalaxb.AnyElemNameParser {
    def parseRegisterDefinitionGroupGroup(node: scala.xml.Node, stack: List[IPXACT2022scalaxb.ElemName]): Parser[IPXACT2022ScalaCases.RegisterDefinitionGroupSequence] =
      ((opt(IPXACT2022scalaxb.ElemName(Some("http://www.accellera.org/XMLSchema/IPXACT/1685-2022"), "typeIdentifier")) ~
      (IPXACT2022scalaxb.ElemName(Some("http://www.accellera.org/XMLSchema/IPXACT/1685-2022"), "size")) ~
      opt(IPXACT2022scalaxb.ElemName(Some("http://www.accellera.org/XMLSchema/IPXACT/1685-2022"), "volatile")) ~
      opt(IPXACT2022scalaxb.ElemName(Some("http://www.accellera.org/XMLSchema/IPXACT/1685-2022"), "accessPolicies")) ~
      safeRep(((IPXACT2022scalaxb.ElemName(Some("http://www.accellera.org/XMLSchema/IPXACT/1685-2022"), "field"))) ^^
        { case p1 => IPXACT2022ScalaCases.RegisterDefinitionGroupSequence2(IPXACT2022scalaxb.fromXML[IPXACT2022ScalaCases.FieldType](p1, IPXACT2022scalaxb.ElemName(node) :: stack)) })) ^^
        { case p1 ~ p2 ~ p3 ~ p4 ~ p5 => IPXACT2022ScalaCases.RegisterDefinitionGroupSequence(p1.headOption map { IPXACT2022scalaxb.fromXML[String](_, IPXACT2022scalaxb.ElemName(node) :: stack) },
        IPXACT2022scalaxb.fromXML[IPXACT2022ScalaCases.UnsignedPositiveIntExpressionable](p2, IPXACT2022scalaxb.ElemName(node) :: stack),
        p3.headOption map { IPXACT2022scalaxb.fromXML[Boolean](_, IPXACT2022scalaxb.ElemName(node) :: stack) },
        p4.headOption map { IPXACT2022scalaxb.fromXML[IPXACT2022ScalaCases.AccessPolicies](_, IPXACT2022scalaxb.ElemName(node) :: stack) },
        p5) })
  
    def parseRegisterDefinitionGroupGroup(node: scala.xml.Node, stack: List[IPXACT2022scalaxb.ElemName], wrap: Boolean): Parser[IPXACT2022scalaxb.DataRecord[Any]] =
      ((opt(IPXACT2022scalaxb.ElemName(Some("http://www.accellera.org/XMLSchema/IPXACT/1685-2022"), "typeIdentifier")) ~
      (IPXACT2022scalaxb.ElemName(Some("http://www.accellera.org/XMLSchema/IPXACT/1685-2022"), "size")) ~
      opt(IPXACT2022scalaxb.ElemName(Some("http://www.accellera.org/XMLSchema/IPXACT/1685-2022"), "volatile")) ~
      opt(IPXACT2022scalaxb.ElemName(Some("http://www.accellera.org/XMLSchema/IPXACT/1685-2022"), "accessPolicies")) ~
      safeRep(((IPXACT2022scalaxb.ElemName(Some("http://www.accellera.org/XMLSchema/IPXACT/1685-2022"), "field"))) ^^
        { case p1 => IPXACT2022ScalaCases.RegisterDefinitionGroupSequence2(IPXACT2022scalaxb.fromXML[IPXACT2022ScalaCases.FieldType](p1, IPXACT2022scalaxb.ElemName(node) :: stack)) })) ^^
        { case p1 ~ p2 ~ p3 ~ p4 ~ p5 => IPXACT2022scalaxb.DataRecord(IPXACT2022ScalaCases.RegisterDefinitionGroupSequence(p1.headOption map { IPXACT2022scalaxb.fromXML[String](_, IPXACT2022scalaxb.ElemName(node) :: stack) },
        IPXACT2022scalaxb.fromXML[IPXACT2022ScalaCases.UnsignedPositiveIntExpressionable](p2, IPXACT2022scalaxb.ElemName(node) :: stack),
        p3.headOption map { IPXACT2022scalaxb.fromXML[Boolean](_, IPXACT2022scalaxb.ElemName(node) :: stack) },
        p4.headOption map { IPXACT2022scalaxb.fromXML[IPXACT2022ScalaCases.AccessPolicies](_, IPXACT2022scalaxb.ElemName(node) :: stack) },
        p5)) })
    
    def parsemixedRegisterDefinitionGroupGroup(node: scala.xml.Node, stack: List[IPXACT2022scalaxb.ElemName]): Parser[Seq[IPXACT2022scalaxb.DataRecord[Any]]] =
      (((opt(IPXACT2022scalaxb.ElemName(Some("http://www.accellera.org/XMLSchema/IPXACT/1685-2022"), "typeIdentifier")) ^^
      (_ map { x => IPXACT2022scalaxb.DataRecord(x.namespace, Some(x.name), IPXACT2022scalaxb.fromXML[String](x, IPXACT2022scalaxb.ElemName(node) :: stack)) })) ~
      optTextRecord ~ 
      ((IPXACT2022scalaxb.ElemName(Some("http://www.accellera.org/XMLSchema/IPXACT/1685-2022"), "size")) ^^
      (x => IPXACT2022scalaxb.DataRecord(x.namespace, Some(x.name), IPXACT2022scalaxb.fromXML[IPXACT2022ScalaCases.UnsignedPositiveIntExpressionable](x, IPXACT2022scalaxb.ElemName(node) :: stack)))) ~
      optTextRecord ~ 
      (opt(IPXACT2022scalaxb.ElemName(Some("http://www.accellera.org/XMLSchema/IPXACT/1685-2022"), "volatile")) ^^
      (_ map { x => IPXACT2022scalaxb.DataRecord(x.namespace, Some(x.name), IPXACT2022scalaxb.fromXML[Boolean](x, IPXACT2022scalaxb.ElemName(node) :: stack)) })) ~
      optTextRecord ~ 
      (opt(IPXACT2022scalaxb.ElemName(Some("http://www.accellera.org/XMLSchema/IPXACT/1685-2022"), "accessPolicies")) ^^
      (_ map { x => IPXACT2022scalaxb.DataRecord(x.namespace, Some(x.name), IPXACT2022scalaxb.fromXML[IPXACT2022ScalaCases.AccessPolicies](x, IPXACT2022scalaxb.ElemName(node) :: stack)) })) ~
      optTextRecord ~ 
      safeRep((((IPXACT2022scalaxb.ElemName(Some("http://www.accellera.org/XMLSchema/IPXACT/1685-2022"), "field")) ^^
      (x => IPXACT2022scalaxb.DataRecord(x.namespace, Some(x.name), IPXACT2022scalaxb.fromXML[IPXACT2022ScalaCases.FieldType](x, IPXACT2022scalaxb.ElemName(node) :: stack)))) ~
      optTextRecord) ^^ 
        { case p1 ~ p2 => Seq.concat(Seq(p1),
        p2.toList) }) ~ 
      optTextRecord) ^^ 
        { case p1 ~ p2 ~ p3 ~ p4 ~ p5 ~ p6 ~ p7 ~ p8 ~ p9 ~ p10 => Seq.concat(p1.toList,
        p2.toList,
        Seq(p3),
        p4.toList,
        p5.toList,
        p6.toList,
        p7.toList,
        p8.toList,
        p9.flatten,
        p10.toList) })
  }

  trait DefaultIPXACT2022ScalaCases_RegisterDefinitionGroupSequence2Format extends IPXACT2022scalaxb.XMLFormat[IPXACT2022ScalaCases.RegisterDefinitionGroupSequence2] {
    def reads(seq: scala.xml.NodeSeq, stack: List[IPXACT2022scalaxb.ElemName]): Either[String, IPXACT2022ScalaCases.RegisterDefinitionGroupSequence2] = Left("don't call me.")
    
    def writes(__obj: IPXACT2022ScalaCases.RegisterDefinitionGroupSequence2, __namespace: Option[String], __elementLabel: Option[String],
        __scope: scala.xml.NamespaceBinding, __typeAttribute: Boolean): scala.xml.NodeSeq =
      IPXACT2022scalaxb.toXML[IPXACT2022ScalaCases.FieldType](__obj.field, Some("http://www.accellera.org/XMLSchema/IPXACT/1685-2022"), Some("field"), __scope, false)

  }
  trait DefaultIPXACT2022ScalaCases_RegisterDefinitionGroupSequenceFormat extends IPXACT2022scalaxb.XMLFormat[IPXACT2022ScalaCases.RegisterDefinitionGroupSequence] {
    def reads(seq: scala.xml.NodeSeq, stack: List[IPXACT2022scalaxb.ElemName]): Either[String, IPXACT2022ScalaCases.RegisterDefinitionGroupSequence] = Left("don't call me.")
    
    def writes(__obj: IPXACT2022ScalaCases.RegisterDefinitionGroupSequence, __namespace: Option[String], __elementLabel: Option[String],
        __scope: scala.xml.NamespaceBinding, __typeAttribute: Boolean): scala.xml.NodeSeq =
      Seq.concat(__obj.typeIdentifier map { IPXACT2022scalaxb.toXML[String](_, Some("http://www.accellera.org/XMLSchema/IPXACT/1685-2022"), Some("typeIdentifier"), __scope, false) } getOrElse {Nil},
        IPXACT2022scalaxb.toXML[IPXACT2022ScalaCases.UnsignedPositiveIntExpressionable](__obj.size, Some("http://www.accellera.org/XMLSchema/IPXACT/1685-2022"), Some("size"), __scope, false),
        __obj.volatile map { IPXACT2022scalaxb.toXML[Boolean](_, Some("http://www.accellera.org/XMLSchema/IPXACT/1685-2022"), Some("volatile"), __scope, false) } getOrElse {Nil},
        __obj.accessPolicies map { IPXACT2022scalaxb.toXML[IPXACT2022ScalaCases.AccessPolicies](_, Some("http://www.accellera.org/XMLSchema/IPXACT/1685-2022"), Some("accessPolicies"), __scope, false) } getOrElse {Nil},
        __obj.registerdefinitiongroupsequence2 flatMap { IPXACT2022scalaxb.toXML[IPXACT2022ScalaCases.RegisterDefinitionGroupSequence2](_, None, Some("registerdefinitiongroupsequence2"), __scope, false) })


  }

  trait DefaultIPXACT2022ScalaCases_DesignInstantiationTypeFormat extends IPXACT2022scalaxb.ElemNameParser[IPXACT2022ScalaCases.DesignInstantiationType] with IPXACT2022ScalaCases_NameGroupNMTOKENGroupFormat {
    val targetNamespace: Option[String] = Some("http://www.accellera.org/XMLSchema/IPXACT/1685-2022")
    
    override def typeName: Option[String] = Some("designInstantiationType")

    def parser(node: scala.xml.Node, stack: List[IPXACT2022scalaxb.ElemName]): Parser[IPXACT2022ScalaCases.DesignInstantiationType] =
      phrase((parseNameGroupNMTOKENGroup(node, IPXACT2022scalaxb.ElemName(node) :: stack)) ~
      (IPXACT2022scalaxb.ElemName(Some("http://www.accellera.org/XMLSchema/IPXACT/1685-2022"), "designRef")) ~
      opt(IPXACT2022scalaxb.ElemName(Some("http://www.accellera.org/XMLSchema/IPXACT/1685-2022"), "vendorExtensions")) ^^
      { case p1 ~ p2 ~ p3 =>
      IPXACT2022ScalaCases.DesignInstantiationType(p1,
        IPXACT2022scalaxb.fromXML[IPXACT2022ScalaCases.ConfigurableLibraryRefType](p2, IPXACT2022scalaxb.ElemName(node) :: stack),
        p3.headOption map { IPXACT2022scalaxb.fromXML[IPXACT2022ScalaCases.VendorExtensions](_, IPXACT2022scalaxb.ElemName(node) :: stack) },
        scala.collection.immutable.ListMap(List(
        (node \ "@{http://www.w3.org/XML/1998/namespace}id").headOption map { x => IPXACT2022scalaxb.DataRecord(x, node, IPXACT2022scalaxb.fromXML[String](x, IPXACT2022scalaxb.ElemName(node) :: stack)) } map { "@{http://www.w3.org/XML/1998/namespace}id" -> _ }
        ).flatten[(String, IPXACT2022scalaxb.DataRecord[Any])]: _*)) })
    
    override def writesAttribute(__obj: IPXACT2022ScalaCases.DesignInstantiationType, __scope: scala.xml.NamespaceBinding): scala.xml.MetaData = {
      var attr: scala.xml.MetaData  = scala.xml.Null
      __obj.attributes.toList map {
        case ("@{http://www.w3.org/XML/1998/namespace}id", _) => __obj.xmlid foreach { x => attr = scala.xml.Attribute(__scope.getPrefix("http://www.w3.org/XML/1998/namespace"), "id", x.toString, attr) }
        case (key, x) => attr = scala.xml.Attribute((x.namespace map { __scope.getPrefix(_) }).orNull, x.key.orNull, x.value.toString, attr)
      }
      attr
    }

    def writesChildNodes(__obj: IPXACT2022ScalaCases.DesignInstantiationType, __scope: scala.xml.NamespaceBinding): Seq[scala.xml.Node] =
      Seq.concat(IPXACT2022scalaxb.toXML[IPXACT2022ScalaCases.NameGroupNMTOKENSequence](__obj.nameGroupNMTOKENSequence1, None, Some("nameGroupNMTOKENSequence1"), __scope, false),
        IPXACT2022scalaxb.toXML[IPXACT2022ScalaCases.ConfigurableLibraryRefType](__obj.designRef, Some("http://www.accellera.org/XMLSchema/IPXACT/1685-2022"), Some("designRef"), __scope, false),
        __obj.vendorExtensions map { IPXACT2022scalaxb.toXML[IPXACT2022ScalaCases.VendorExtensions](_, Some("http://www.accellera.org/XMLSchema/IPXACT/1685-2022"), Some("vendorExtensions"), __scope, false) } getOrElse {Nil})

  }

  trait DefaultIPXACT2022ScalaCases_DesignConfigurationInstantiationTypeFormat extends IPXACT2022scalaxb.ElemNameParser[IPXACT2022ScalaCases.DesignConfigurationInstantiationType] with IPXACT2022ScalaCases_NameGroupNMTOKENGroupFormat {
    val targetNamespace: Option[String] = Some("http://www.accellera.org/XMLSchema/IPXACT/1685-2022")
    
    override def typeName: Option[String] = Some("designConfigurationInstantiationType")

    def parser(node: scala.xml.Node, stack: List[IPXACT2022scalaxb.ElemName]): Parser[IPXACT2022ScalaCases.DesignConfigurationInstantiationType] =
      phrase((parseNameGroupNMTOKENGroup(node, IPXACT2022scalaxb.ElemName(node) :: stack)) ~
      opt(IPXACT2022scalaxb.ElemName(Some("http://www.accellera.org/XMLSchema/IPXACT/1685-2022"), "language")) ~
      (IPXACT2022scalaxb.ElemName(Some("http://www.accellera.org/XMLSchema/IPXACT/1685-2022"), "designConfigurationRef")) ~
      opt(IPXACT2022scalaxb.ElemName(Some("http://www.accellera.org/XMLSchema/IPXACT/1685-2022"), "parameters")) ~
      opt(IPXACT2022scalaxb.ElemName(Some("http://www.accellera.org/XMLSchema/IPXACT/1685-2022"), "vendorExtensions")) ^^
      { case p1 ~ p2 ~ p3 ~ p4 ~ p5 =>
      IPXACT2022ScalaCases.DesignConfigurationInstantiationType(p1,
        p2.headOption map { IPXACT2022scalaxb.fromXML[IPXACT2022ScalaCases.LanguageType](_, IPXACT2022scalaxb.ElemName(node) :: stack) },
        IPXACT2022scalaxb.fromXML[IPXACT2022ScalaCases.ConfigurableLibraryRefType](p3, IPXACT2022scalaxb.ElemName(node) :: stack),
        p4.headOption map { IPXACT2022scalaxb.fromXML[IPXACT2022ScalaCases.Parameters](_, IPXACT2022scalaxb.ElemName(node) :: stack) },
        p5.headOption map { IPXACT2022scalaxb.fromXML[IPXACT2022ScalaCases.VendorExtensions](_, IPXACT2022scalaxb.ElemName(node) :: stack) },
        scala.collection.immutable.ListMap(List(
        (node \ "@{http://www.w3.org/XML/1998/namespace}id").headOption map { x => IPXACT2022scalaxb.DataRecord(x, node, IPXACT2022scalaxb.fromXML[String](x, IPXACT2022scalaxb.ElemName(node) :: stack)) } map { "@{http://www.w3.org/XML/1998/namespace}id" -> _ }
        ).flatten[(String, IPXACT2022scalaxb.DataRecord[Any])]: _*)) })
    
    override def writesAttribute(__obj: IPXACT2022ScalaCases.DesignConfigurationInstantiationType, __scope: scala.xml.NamespaceBinding): scala.xml.MetaData = {
      var attr: scala.xml.MetaData  = scala.xml.Null
      __obj.attributes.toList map {
        case ("@{http://www.w3.org/XML/1998/namespace}id", _) => __obj.xmlid foreach { x => attr = scala.xml.Attribute(__scope.getPrefix("http://www.w3.org/XML/1998/namespace"), "id", x.toString, attr) }
        case (key, x) => attr = scala.xml.Attribute((x.namespace map { __scope.getPrefix(_) }).orNull, x.key.orNull, x.value.toString, attr)
      }
      attr
    }

    def writesChildNodes(__obj: IPXACT2022ScalaCases.DesignConfigurationInstantiationType, __scope: scala.xml.NamespaceBinding): Seq[scala.xml.Node] =
      Seq.concat(IPXACT2022scalaxb.toXML[IPXACT2022ScalaCases.NameGroupNMTOKENSequence](__obj.nameGroupNMTOKENSequence1, None, Some("nameGroupNMTOKENSequence1"), __scope, false),
        __obj.language map { IPXACT2022scalaxb.toXML[IPXACT2022ScalaCases.LanguageType](_, Some("http://www.accellera.org/XMLSchema/IPXACT/1685-2022"), Some("language"), __scope, false) } getOrElse {Nil},
        IPXACT2022scalaxb.toXML[IPXACT2022ScalaCases.ConfigurableLibraryRefType](__obj.designConfigurationRef, Some("http://www.accellera.org/XMLSchema/IPXACT/1685-2022"), Some("designConfigurationRef"), __scope, false),
        __obj.parameters map { IPXACT2022scalaxb.toXML[IPXACT2022ScalaCases.Parameters](_, Some("http://www.accellera.org/XMLSchema/IPXACT/1685-2022"), Some("parameters"), __scope, false) } getOrElse {Nil},
        __obj.vendorExtensions map { IPXACT2022scalaxb.toXML[IPXACT2022ScalaCases.VendorExtensions](_, Some("http://www.accellera.org/XMLSchema/IPXACT/1685-2022"), Some("vendorExtensions"), __scope, false) } getOrElse {Nil})

  }

  trait DefaultIPXACT2022ScalaCases_ModuleParametersFormat extends IPXACT2022scalaxb.ElemNameParser[IPXACT2022ScalaCases.ModuleParameters] {
    val targetNamespace: Option[String] = Some("http://www.accellera.org/XMLSchema/IPXACT/1685-2022")
    
    def parser(node: scala.xml.Node, stack: List[IPXACT2022scalaxb.ElemName]): Parser[IPXACT2022ScalaCases.ModuleParameters] =
      phrase(safeRep(IPXACT2022scalaxb.ElemName(Some("http://www.accellera.org/XMLSchema/IPXACT/1685-2022"), "moduleParameter")) ^^
      { case p1 =>
      IPXACT2022ScalaCases.ModuleParameters(p1 map { IPXACT2022scalaxb.fromXML[IPXACT2022ScalaCases.ModuleParameterType](_, IPXACT2022scalaxb.ElemName(node) :: stack) }) })
    
    def writesChildNodes(__obj: IPXACT2022ScalaCases.ModuleParameters, __scope: scala.xml.NamespaceBinding): Seq[scala.xml.Node] =
      (__obj.moduleParameter flatMap { IPXACT2022scalaxb.toXML[IPXACT2022ScalaCases.ModuleParameterType](_, Some("http://www.accellera.org/XMLSchema/IPXACT/1685-2022"), Some("moduleParameter"), __scope, false) })
  }
  trait DefaultIPXACT2022ScalaCases_ClearboxElementRefsFormat extends IPXACT2022scalaxb.ElemNameParser[IPXACT2022ScalaCases.ClearboxElementRefs] {
    val targetNamespace: Option[String] = Some("http://www.accellera.org/XMLSchema/IPXACT/1685-2022")
    
    def parser(node: scala.xml.Node, stack: List[IPXACT2022scalaxb.ElemName]): Parser[IPXACT2022ScalaCases.ClearboxElementRefs] =
      phrase(safeRep(IPXACT2022scalaxb.ElemName(Some("http://www.accellera.org/XMLSchema/IPXACT/1685-2022"), "clearboxElementRef")) ^^
      { case p1 =>
      IPXACT2022ScalaCases.ClearboxElementRefs(p1 map { IPXACT2022scalaxb.fromXML[IPXACT2022ScalaCases.ClearboxElementRefType](_, IPXACT2022scalaxb.ElemName(node) :: stack) }) })
    
    def writesChildNodes(__obj: IPXACT2022ScalaCases.ClearboxElementRefs, __scope: scala.xml.NamespaceBinding): Seq[scala.xml.Node] =
      (__obj.clearboxElementRef flatMap { IPXACT2022scalaxb.toXML[IPXACT2022ScalaCases.ClearboxElementRefType](_, Some("http://www.accellera.org/XMLSchema/IPXACT/1685-2022"), Some("clearboxElementRef"), __scope, false) })
  }
  trait DefaultIPXACT2022ScalaCases_ComponentInstantiationTypeFormat extends IPXACT2022scalaxb.ElemNameParser[IPXACT2022ScalaCases.ComponentInstantiationType] with IPXACT2022ScalaCases_NameGroupNMTOKENGroupFormat {
    val targetNamespace: Option[String] = Some("http://www.accellera.org/XMLSchema/IPXACT/1685-2022")
    
    override def typeName: Option[String] = Some("componentInstantiationType")

    def parser(node: scala.xml.Node, stack: List[IPXACT2022scalaxb.ElemName]): Parser[IPXACT2022ScalaCases.ComponentInstantiationType] =
      phrase((parseNameGroupNMTOKENGroup(node, IPXACT2022scalaxb.ElemName(node) :: stack)) ~
      opt(IPXACT2022scalaxb.ElemName(Some("http://www.accellera.org/XMLSchema/IPXACT/1685-2022"), "isVirtual")) ~
      opt(IPXACT2022scalaxb.ElemName(Some("http://www.accellera.org/XMLSchema/IPXACT/1685-2022"), "language")) ~
      opt(IPXACT2022scalaxb.ElemName(Some("http://www.accellera.org/XMLSchema/IPXACT/1685-2022"), "libraryName")) ~
      opt(IPXACT2022scalaxb.ElemName(Some("http://www.accellera.org/XMLSchema/IPXACT/1685-2022"), "packageName")) ~
      opt(IPXACT2022scalaxb.ElemName(Some("http://www.accellera.org/XMLSchema/IPXACT/1685-2022"), "moduleName")) ~
      opt(IPXACT2022scalaxb.ElemName(Some("http://www.accellera.org/XMLSchema/IPXACT/1685-2022"), "architectureName")) ~
      opt(IPXACT2022scalaxb.ElemName(Some("http://www.accellera.org/XMLSchema/IPXACT/1685-2022"), "configurationName")) ~
      opt(IPXACT2022scalaxb.ElemName(Some("http://www.accellera.org/XMLSchema/IPXACT/1685-2022"), "moduleParameters")) ~
      safeRep(IPXACT2022scalaxb.ElemName(Some("http://www.accellera.org/XMLSchema/IPXACT/1685-2022"), "defaultFileBuilder")) ~
      safeRep(IPXACT2022scalaxb.ElemName(Some("http://www.accellera.org/XMLSchema/IPXACT/1685-2022"), "fileSetRef")) ~
      safeRep(IPXACT2022scalaxb.ElemName(Some("http://www.accellera.org/XMLSchema/IPXACT/1685-2022"), "constraintSetRef")) ~
      opt(IPXACT2022scalaxb.ElemName(Some("http://www.accellera.org/XMLSchema/IPXACT/1685-2022"), "clearboxElementRefs")) ~
      opt(IPXACT2022scalaxb.ElemName(Some("http://www.accellera.org/XMLSchema/IPXACT/1685-2022"), "parameters")) ~
      opt(IPXACT2022scalaxb.ElemName(Some("http://www.accellera.org/XMLSchema/IPXACT/1685-2022"), "vendorExtensions")) ^^
      { case p1 ~ p2 ~ p3 ~ p4 ~ p5 ~ p6 ~ p7 ~ p8 ~ p9 ~ p10 ~ p11 ~ p12 ~ p13 ~ p14 ~ p15 =>
      IPXACT2022ScalaCases.ComponentInstantiationType(p1,
        p2.headOption map { IPXACT2022scalaxb.fromXML[Boolean](_, IPXACT2022scalaxb.ElemName(node) :: stack) },
        p3.headOption map { IPXACT2022scalaxb.fromXML[IPXACT2022ScalaCases.LanguageType](_, IPXACT2022scalaxb.ElemName(node) :: stack) },
        p4.headOption map { IPXACT2022scalaxb.fromXML[String](_, IPXACT2022scalaxb.ElemName(node) :: stack) },
        p5.headOption map { IPXACT2022scalaxb.fromXML[String](_, IPXACT2022scalaxb.ElemName(node) :: stack) },
        p6.headOption map { IPXACT2022scalaxb.fromXML[String](_, IPXACT2022scalaxb.ElemName(node) :: stack) },
        p7.headOption map { IPXACT2022scalaxb.fromXML[String](_, IPXACT2022scalaxb.ElemName(node) :: stack) },
        p8.headOption map { IPXACT2022scalaxb.fromXML[String](_, IPXACT2022scalaxb.ElemName(node) :: stack) },
        p9.headOption map { IPXACT2022scalaxb.fromXML[IPXACT2022ScalaCases.ModuleParameters](_, IPXACT2022scalaxb.ElemName(node) :: stack) },
        p10 map { IPXACT2022scalaxb.fromXML[IPXACT2022ScalaCases.FileBuilderType](_, IPXACT2022scalaxb.ElemName(node) :: stack) },
        p11 map { IPXACT2022scalaxb.fromXML[IPXACT2022ScalaCases.FileSetRef](_, IPXACT2022scalaxb.ElemName(node) :: stack) },
        p12 map { IPXACT2022scalaxb.fromXML[IPXACT2022ScalaCases.ConstraintSetRef](_, IPXACT2022scalaxb.ElemName(node) :: stack) },
        p13.headOption map { IPXACT2022scalaxb.fromXML[IPXACT2022ScalaCases.ClearboxElementRefs](_, IPXACT2022scalaxb.ElemName(node) :: stack) },
        p14.headOption map { IPXACT2022scalaxb.fromXML[IPXACT2022ScalaCases.Parameters](_, IPXACT2022scalaxb.ElemName(node) :: stack) },
        p15.headOption map { IPXACT2022scalaxb.fromXML[IPXACT2022ScalaCases.VendorExtensions](_, IPXACT2022scalaxb.ElemName(node) :: stack) },
        scala.collection.immutable.ListMap(List(
        (node \ "@{http://www.w3.org/XML/1998/namespace}id").headOption map { x => IPXACT2022scalaxb.DataRecord(x, node, IPXACT2022scalaxb.fromXML[String](x, IPXACT2022scalaxb.ElemName(node) :: stack)) } map { "@{http://www.w3.org/XML/1998/namespace}id" -> _ }
        ).flatten[(String, IPXACT2022scalaxb.DataRecord[Any])]: _*)) })
    
    override def writesAttribute(__obj: IPXACT2022ScalaCases.ComponentInstantiationType, __scope: scala.xml.NamespaceBinding): scala.xml.MetaData = {
      var attr: scala.xml.MetaData  = scala.xml.Null
      __obj.attributes.toList map {
        case ("@{http://www.w3.org/XML/1998/namespace}id", _) => __obj.xmlid foreach { x => attr = scala.xml.Attribute(__scope.getPrefix("http://www.w3.org/XML/1998/namespace"), "id", x.toString, attr) }
        case (key, x) => attr = scala.xml.Attribute((x.namespace map { __scope.getPrefix(_) }).orNull, x.key.orNull, x.value.toString, attr)
      }
      attr
    }

    def writesChildNodes(__obj: IPXACT2022ScalaCases.ComponentInstantiationType, __scope: scala.xml.NamespaceBinding): Seq[scala.xml.Node] =
      Seq.concat(IPXACT2022scalaxb.toXML[IPXACT2022ScalaCases.NameGroupNMTOKENSequence](__obj.nameGroupNMTOKENSequence1, None, Some("nameGroupNMTOKENSequence1"), __scope, false),
        __obj.isVirtual map { IPXACT2022scalaxb.toXML[Boolean](_, Some("http://www.accellera.org/XMLSchema/IPXACT/1685-2022"), Some("isVirtual"), __scope, false) } getOrElse {Nil},
        __obj.language map { IPXACT2022scalaxb.toXML[IPXACT2022ScalaCases.LanguageType](_, Some("http://www.accellera.org/XMLSchema/IPXACT/1685-2022"), Some("language"), __scope, false) } getOrElse {Nil},
        __obj.libraryName map { IPXACT2022scalaxb.toXML[String](_, Some("http://www.accellera.org/XMLSchema/IPXACT/1685-2022"), Some("libraryName"), __scope, false) } getOrElse {Nil},
        __obj.packageName map { IPXACT2022scalaxb.toXML[String](_, Some("http://www.accellera.org/XMLSchema/IPXACT/1685-2022"), Some("packageName"), __scope, false) } getOrElse {Nil},
        __obj.moduleName map { IPXACT2022scalaxb.toXML[String](_, Some("http://www.accellera.org/XMLSchema/IPXACT/1685-2022"), Some("moduleName"), __scope, false) } getOrElse {Nil},
        __obj.architectureName map { IPXACT2022scalaxb.toXML[String](_, Some("http://www.accellera.org/XMLSchema/IPXACT/1685-2022"), Some("architectureName"), __scope, false) } getOrElse {Nil},
        __obj.configurationName map { IPXACT2022scalaxb.toXML[String](_, Some("http://www.accellera.org/XMLSchema/IPXACT/1685-2022"), Some("configurationName"), __scope, false) } getOrElse {Nil},
        __obj.moduleParameters map { IPXACT2022scalaxb.toXML[IPXACT2022ScalaCases.ModuleParameters](_, Some("http://www.accellera.org/XMLSchema/IPXACT/1685-2022"), Some("moduleParameters"), __scope, false) } getOrElse {Nil},
        __obj.defaultFileBuilder flatMap { IPXACT2022scalaxb.toXML[IPXACT2022ScalaCases.FileBuilderType](_, Some("http://www.accellera.org/XMLSchema/IPXACT/1685-2022"), Some("defaultFileBuilder"), __scope, false) },
        __obj.fileSetRef flatMap { IPXACT2022scalaxb.toXML[IPXACT2022ScalaCases.FileSetRef](_, Some("http://www.accellera.org/XMLSchema/IPXACT/1685-2022"), Some("fileSetRef"), __scope, false) },
        __obj.constraintSetRef flatMap { IPXACT2022scalaxb.toXML[IPXACT2022ScalaCases.ConstraintSetRef](_, Some("http://www.accellera.org/XMLSchema/IPXACT/1685-2022"), Some("constraintSetRef"), __scope, false) },
        __obj.clearboxElementRefs map { IPXACT2022scalaxb.toXML[IPXACT2022ScalaCases.ClearboxElementRefs](_, Some("http://www.accellera.org/XMLSchema/IPXACT/1685-2022"), Some("clearboxElementRefs"), __scope, false) } getOrElse {Nil},
        __obj.parameters map { IPXACT2022scalaxb.toXML[IPXACT2022ScalaCases.Parameters](_, Some("http://www.accellera.org/XMLSchema/IPXACT/1685-2022"), Some("parameters"), __scope, false) } getOrElse {Nil},
        __obj.vendorExtensions map { IPXACT2022scalaxb.toXML[IPXACT2022ScalaCases.VendorExtensions](_, Some("http://www.accellera.org/XMLSchema/IPXACT/1685-2022"), Some("vendorExtensions"), __scope, false) } getOrElse {Nil})

  }

  trait DefaultIPXACT2022ScalaCases_EnvIdentifierFormat extends IPXACT2022scalaxb.XMLFormat[IPXACT2022ScalaCases.EnvIdentifier] with IPXACT2022scalaxb.CanWriteChildNodes[IPXACT2022ScalaCases.EnvIdentifier] {
    val targetNamespace: Option[String] = Some("http://www.accellera.org/XMLSchema/IPXACT/1685-2022")
    def reads(seq: scala.xml.NodeSeq, stack: List[IPXACT2022scalaxb.ElemName]): Either[String, IPXACT2022ScalaCases.EnvIdentifier] = seq match {
      case node: scala.xml.Node => Right(IPXACT2022ScalaCases.EnvIdentifier(IPXACT2022scalaxb.fromXML[String](node, IPXACT2022scalaxb.ElemName(node) :: stack),
        scala.collection.immutable.ListMap(List(
        (node \ "@{http://www.w3.org/XML/1998/namespace}id").headOption map { x => IPXACT2022scalaxb.DataRecord(x, node, IPXACT2022scalaxb.fromXML[String](x, IPXACT2022scalaxb.ElemName(node) :: stack)) } map { "@{http://www.w3.org/XML/1998/namespace}id" -> _ }
        ).flatten[(String, IPXACT2022scalaxb.DataRecord[Any])]: _*)))
      case _ => Left("reads failed: seq must be scala.xml.Node")
    }
    
    override def writesAttribute(__obj: IPXACT2022ScalaCases.EnvIdentifier, __scope: scala.xml.NamespaceBinding): scala.xml.MetaData = {
      var attr: scala.xml.MetaData  = scala.xml.Null
      __obj.attributes.toList map {
        case ("@{http://www.w3.org/XML/1998/namespace}id", _) => __obj.xmlid foreach { x => attr = scala.xml.Attribute(__scope.getPrefix("http://www.w3.org/XML/1998/namespace"), "id", x.toString, attr) }
        case (key, x) => attr = scala.xml.Attribute((x.namespace map { __scope.getPrefix(_) }).orNull, x.key.orNull, x.value.toString, attr)
      }
      attr
    }

    def writesChildNodes(__obj: IPXACT2022ScalaCases.EnvIdentifier, __scope: scala.xml.NamespaceBinding): Seq[scala.xml.Node] =
      Seq(scala.xml.Text(__obj.value.toString))

  }

  trait DefaultIPXACT2022ScalaCases_ViewFormat extends IPXACT2022scalaxb.ElemNameParser[IPXACT2022ScalaCases.View] with IPXACT2022ScalaCases_NameGroupNMTOKENGroupFormat {
    val targetNamespace: Option[String] = Some("http://www.accellera.org/XMLSchema/IPXACT/1685-2022")
    
    def parser(node: scala.xml.Node, stack: List[IPXACT2022scalaxb.ElemName]): Parser[IPXACT2022ScalaCases.View] =
      phrase((parseNameGroupNMTOKENGroup(node, IPXACT2022scalaxb.ElemName(node) :: stack)) ~
      safeRep(IPXACT2022scalaxb.ElemName(Some("http://www.accellera.org/XMLSchema/IPXACT/1685-2022"), "envIdentifier")) ~
      opt(IPXACT2022scalaxb.ElemName(Some("http://www.accellera.org/XMLSchema/IPXACT/1685-2022"), "componentInstantiationRef")) ~
      opt(IPXACT2022scalaxb.ElemName(Some("http://www.accellera.org/XMLSchema/IPXACT/1685-2022"), "designInstantiationRef")) ~
      opt(IPXACT2022scalaxb.ElemName(Some("http://www.accellera.org/XMLSchema/IPXACT/1685-2022"), "designConfigurationInstantiationRef")) ~
      opt(IPXACT2022scalaxb.ElemName(Some("http://www.accellera.org/XMLSchema/IPXACT/1685-2022"), "vendorExtensions")) ^^
      { case p1 ~ p2 ~ p3 ~ p4 ~ p5 ~ p6 =>
      IPXACT2022ScalaCases.View(p1,
        p2 map { IPXACT2022scalaxb.fromXML[IPXACT2022ScalaCases.EnvIdentifier](_, IPXACT2022scalaxb.ElemName(node) :: stack) },
        p3.headOption map { IPXACT2022scalaxb.fromXML[String](_, IPXACT2022scalaxb.ElemName(node) :: stack) },
        p4.headOption map { IPXACT2022scalaxb.fromXML[String](_, IPXACT2022scalaxb.ElemName(node) :: stack) },
        p5.headOption map { IPXACT2022scalaxb.fromXML[String](_, IPXACT2022scalaxb.ElemName(node) :: stack) },
        p6.headOption map { IPXACT2022scalaxb.fromXML[IPXACT2022ScalaCases.VendorExtensions](_, IPXACT2022scalaxb.ElemName(node) :: stack) },
        scala.collection.immutable.ListMap(List(
        (node \ "@{http://www.w3.org/XML/1998/namespace}id").headOption map { x => IPXACT2022scalaxb.DataRecord(x, node, IPXACT2022scalaxb.fromXML[String](x, IPXACT2022scalaxb.ElemName(node) :: stack)) } map { "@{http://www.w3.org/XML/1998/namespace}id" -> _ }
        ).flatten[(String, IPXACT2022scalaxb.DataRecord[Any])]: _*)) })
    
    override def writesAttribute(__obj: IPXACT2022ScalaCases.View, __scope: scala.xml.NamespaceBinding): scala.xml.MetaData = {
      var attr: scala.xml.MetaData  = scala.xml.Null
      __obj.attributes.toList map {
        case ("@{http://www.w3.org/XML/1998/namespace}id", _) => __obj.xmlid foreach { x => attr = scala.xml.Attribute(__scope.getPrefix("http://www.w3.org/XML/1998/namespace"), "id", x.toString, attr) }
        case (key, x) => attr = scala.xml.Attribute((x.namespace map { __scope.getPrefix(_) }).orNull, x.key.orNull, x.value.toString, attr)
      }
      attr
    }

    def writesChildNodes(__obj: IPXACT2022ScalaCases.View, __scope: scala.xml.NamespaceBinding): Seq[scala.xml.Node] =
      Seq.concat(IPXACT2022scalaxb.toXML[IPXACT2022ScalaCases.NameGroupNMTOKENSequence](__obj.nameGroupNMTOKENSequence1, None, Some("nameGroupNMTOKENSequence1"), __scope, false),
        __obj.envIdentifier flatMap { IPXACT2022scalaxb.toXML[IPXACT2022ScalaCases.EnvIdentifier](_, Some("http://www.accellera.org/XMLSchema/IPXACT/1685-2022"), Some("envIdentifier"), __scope, false) },
        __obj.componentInstantiationRef map { IPXACT2022scalaxb.toXML[String](_, Some("http://www.accellera.org/XMLSchema/IPXACT/1685-2022"), Some("componentInstantiationRef"), __scope, false) } getOrElse {Nil},
        __obj.designInstantiationRef map { IPXACT2022scalaxb.toXML[String](_, Some("http://www.accellera.org/XMLSchema/IPXACT/1685-2022"), Some("designInstantiationRef"), __scope, false) } getOrElse {Nil},
        __obj.designConfigurationInstantiationRef map { IPXACT2022scalaxb.toXML[String](_, Some("http://www.accellera.org/XMLSchema/IPXACT/1685-2022"), Some("designConfigurationInstantiationRef"), __scope, false) } getOrElse {Nil},
        __obj.vendorExtensions map { IPXACT2022scalaxb.toXML[IPXACT2022ScalaCases.VendorExtensions](_, Some("http://www.accellera.org/XMLSchema/IPXACT/1685-2022"), Some("vendorExtensions"), __scope, false) } getOrElse {Nil})

  }

  trait DefaultIPXACT2022ScalaCases_ViewsFormat extends IPXACT2022scalaxb.ElemNameParser[IPXACT2022ScalaCases.Views] {
    val targetNamespace: Option[String] = Some("http://www.accellera.org/XMLSchema/IPXACT/1685-2022")
    
    def parser(node: scala.xml.Node, stack: List[IPXACT2022scalaxb.ElemName]): Parser[IPXACT2022ScalaCases.Views] =
      phrase(safeRep(IPXACT2022scalaxb.ElemName(Some("http://www.accellera.org/XMLSchema/IPXACT/1685-2022"), "view")) ^^
      { case p1 =>
      IPXACT2022ScalaCases.Views(p1 map { IPXACT2022scalaxb.fromXML[IPXACT2022ScalaCases.View](_, IPXACT2022scalaxb.ElemName(node) :: stack) }) })
    
    def writesChildNodes(__obj: IPXACT2022ScalaCases.Views, __scope: scala.xml.NamespaceBinding): Seq[scala.xml.Node] =
      (__obj.view flatMap { IPXACT2022scalaxb.toXML[IPXACT2022ScalaCases.View](_, Some("http://www.accellera.org/XMLSchema/IPXACT/1685-2022"), Some("view"), __scope, false) })
  }
  trait DefaultIPXACT2022ScalaCases_InstantiationsFormat extends IPXACT2022scalaxb.ElemNameParser[IPXACT2022ScalaCases.Instantiations] with IPXACT2022ScalaCases_InstantiationsGroupGroupFormat {
    val targetNamespace: Option[String] = Some("http://www.accellera.org/XMLSchema/IPXACT/1685-2022")
    
    def parser(node: scala.xml.Node, stack: List[IPXACT2022scalaxb.ElemName]): Parser[IPXACT2022ScalaCases.Instantiations] =
      phrase(safeRep((parseInstantiationsGroupGroup(node, IPXACT2022scalaxb.ElemName(node) :: stack, true))) ^^
      { case p1 =>
      IPXACT2022ScalaCases.Instantiations(p1) })
    
    def writesChildNodes(__obj: IPXACT2022ScalaCases.Instantiations, __scope: scala.xml.NamespaceBinding): Seq[scala.xml.Node] =
      (__obj.instantiationsoption flatMap { x => IPXACT2022scalaxb.toXML[IPXACT2022scalaxb.DataRecord[Any]](x, x.namespace, x.key, __scope, false) })
  }
  trait DefaultIPXACT2022ScalaCases_PortsFormat extends IPXACT2022scalaxb.ElemNameParser[IPXACT2022ScalaCases.Ports] {
    val targetNamespace: Option[String] = Some("http://www.accellera.org/XMLSchema/IPXACT/1685-2022")
    
    def parser(node: scala.xml.Node, stack: List[IPXACT2022scalaxb.ElemName]): Parser[IPXACT2022ScalaCases.Ports] =
      phrase(safeRep(IPXACT2022scalaxb.ElemName(Some("http://www.accellera.org/XMLSchema/IPXACT/1685-2022"), "port")) ^^
      { case p1 =>
      IPXACT2022ScalaCases.Ports(p1 map { IPXACT2022scalaxb.fromXML[IPXACT2022ScalaCases.Port2](_, IPXACT2022scalaxb.ElemName(node) :: stack) }) })
    
    def writesChildNodes(__obj: IPXACT2022ScalaCases.Ports, __scope: scala.xml.NamespaceBinding): Seq[scala.xml.Node] =
      (__obj.port flatMap { IPXACT2022scalaxb.toXML[IPXACT2022ScalaCases.Port2](_, Some("http://www.accellera.org/XMLSchema/IPXACT/1685-2022"), Some("port"), __scope, false) })
  }
  trait DefaultIPXACT2022ScalaCases_ModelTypeFormat extends IPXACT2022scalaxb.ElemNameParser[IPXACT2022ScalaCases.ModelType] {
    val targetNamespace: Option[String] = Some("http://www.accellera.org/XMLSchema/IPXACT/1685-2022")
    
    override def typeName: Option[String] = Some("modelType")

    def parser(node: scala.xml.Node, stack: List[IPXACT2022scalaxb.ElemName]): Parser[IPXACT2022ScalaCases.ModelType] =
      phrase(opt(IPXACT2022scalaxb.ElemName(Some("http://www.accellera.org/XMLSchema/IPXACT/1685-2022"), "views")) ~
      opt(IPXACT2022scalaxb.ElemName(Some("http://www.accellera.org/XMLSchema/IPXACT/1685-2022"), "instantiations")) ~
      opt(IPXACT2022scalaxb.ElemName(Some("http://www.accellera.org/XMLSchema/IPXACT/1685-2022"), "ports")) ^^
      { case p1 ~ p2 ~ p3 =>
      IPXACT2022ScalaCases.ModelType(p1.headOption map { IPXACT2022scalaxb.fromXML[IPXACT2022ScalaCases.Views](_, IPXACT2022scalaxb.ElemName(node) :: stack) },
        p2.headOption map { IPXACT2022scalaxb.fromXML[IPXACT2022ScalaCases.Instantiations](_, IPXACT2022scalaxb.ElemName(node) :: stack) },
        p3.headOption map { IPXACT2022scalaxb.fromXML[IPXACT2022ScalaCases.Ports](_, IPXACT2022scalaxb.ElemName(node) :: stack) }) })
    
    def writesChildNodes(__obj: IPXACT2022ScalaCases.ModelType, __scope: scala.xml.NamespaceBinding): Seq[scala.xml.Node] =
      Seq.concat(__obj.views map { IPXACT2022scalaxb.toXML[IPXACT2022ScalaCases.Views](_, Some("http://www.accellera.org/XMLSchema/IPXACT/1685-2022"), Some("views"), __scope, false) } getOrElse {Nil},
        __obj.instantiations map { IPXACT2022scalaxb.toXML[IPXACT2022ScalaCases.Instantiations](_, Some("http://www.accellera.org/XMLSchema/IPXACT/1685-2022"), Some("instantiations"), __scope, false) } getOrElse {Nil},
        __obj.ports map { IPXACT2022scalaxb.toXML[IPXACT2022ScalaCases.Ports](_, Some("http://www.accellera.org/XMLSchema/IPXACT/1685-2022"), Some("ports"), __scope, false) } getOrElse {Nil})

  }

  trait DefaultIPXACT2022ScalaCases_EnvIdentifier2Format extends IPXACT2022scalaxb.XMLFormat[IPXACT2022ScalaCases.EnvIdentifier2] with IPXACT2022scalaxb.CanWriteChildNodes[IPXACT2022ScalaCases.EnvIdentifier2] {
    val targetNamespace: Option[String] = Some("http://www.accellera.org/XMLSchema/IPXACT/1685-2022")
    def reads(seq: scala.xml.NodeSeq, stack: List[IPXACT2022scalaxb.ElemName]): Either[String, IPXACT2022ScalaCases.EnvIdentifier2] = seq match {
      case node: scala.xml.Node => Right(IPXACT2022ScalaCases.EnvIdentifier2(IPXACT2022scalaxb.fromXML[String](node, IPXACT2022scalaxb.ElemName(node) :: stack),
        scala.collection.immutable.ListMap(List(
        (node \ "@{http://www.w3.org/XML/1998/namespace}id").headOption map { x => IPXACT2022scalaxb.DataRecord(x, node, IPXACT2022scalaxb.fromXML[String](x, IPXACT2022scalaxb.ElemName(node) :: stack)) } map { "@{http://www.w3.org/XML/1998/namespace}id" -> _ }
        ).flatten[(String, IPXACT2022scalaxb.DataRecord[Any])]: _*)))
      case _ => Left("reads failed: seq must be scala.xml.Node")
    }
    
    override def writesAttribute(__obj: IPXACT2022ScalaCases.EnvIdentifier2, __scope: scala.xml.NamespaceBinding): scala.xml.MetaData = {
      var attr: scala.xml.MetaData  = scala.xml.Null
      __obj.attributes.toList map {
        case ("@{http://www.w3.org/XML/1998/namespace}id", _) => __obj.xmlid foreach { x => attr = scala.xml.Attribute(__scope.getPrefix("http://www.w3.org/XML/1998/namespace"), "id", x.toString, attr) }
        case (key, x) => attr = scala.xml.Attribute((x.namespace map { __scope.getPrefix(_) }).orNull, x.key.orNull, x.value.toString, attr)
      }
      attr
    }

    def writesChildNodes(__obj: IPXACT2022ScalaCases.EnvIdentifier2, __scope: scala.xml.NamespaceBinding): Seq[scala.xml.Node] =
      Seq(scala.xml.Text(__obj.value.toString))

  }

  trait DefaultIPXACT2022ScalaCases_View2Format extends IPXACT2022scalaxb.ElemNameParser[IPXACT2022ScalaCases.View2] with IPXACT2022ScalaCases_NameGroupNMTOKENGroupFormat {
    val targetNamespace: Option[String] = Some("http://www.accellera.org/XMLSchema/IPXACT/1685-2022")
    
    def parser(node: scala.xml.Node, stack: List[IPXACT2022scalaxb.ElemName]): Parser[IPXACT2022ScalaCases.View2] =
      phrase((parseNameGroupNMTOKENGroup(node, IPXACT2022scalaxb.ElemName(node) :: stack)) ~
      safeRep(IPXACT2022scalaxb.ElemName(Some("http://www.accellera.org/XMLSchema/IPXACT/1685-2022"), "envIdentifier")) ~
      opt(IPXACT2022scalaxb.ElemName(Some("http://www.accellera.org/XMLSchema/IPXACT/1685-2022"), "componentInstantiationRef")) ~
      opt(IPXACT2022scalaxb.ElemName(Some("http://www.accellera.org/XMLSchema/IPXACT/1685-2022"), "vendorExtensions")) ^^
      { case p1 ~ p2 ~ p3 ~ p4 =>
      IPXACT2022ScalaCases.View2(p1,
        p2 map { IPXACT2022scalaxb.fromXML[IPXACT2022ScalaCases.EnvIdentifier2](_, IPXACT2022scalaxb.ElemName(node) :: stack) },
        p3.headOption map { IPXACT2022scalaxb.fromXML[String](_, IPXACT2022scalaxb.ElemName(node) :: stack) },
        p4.headOption map { IPXACT2022scalaxb.fromXML[IPXACT2022ScalaCases.VendorExtensions](_, IPXACT2022scalaxb.ElemName(node) :: stack) },
        scala.collection.immutable.ListMap(List(
        (node \ "@{http://www.w3.org/XML/1998/namespace}id").headOption map { x => IPXACT2022scalaxb.DataRecord(x, node, IPXACT2022scalaxb.fromXML[String](x, IPXACT2022scalaxb.ElemName(node) :: stack)) } map { "@{http://www.w3.org/XML/1998/namespace}id" -> _ }
        ).flatten[(String, IPXACT2022scalaxb.DataRecord[Any])]: _*)) })
    
    override def writesAttribute(__obj: IPXACT2022ScalaCases.View2, __scope: scala.xml.NamespaceBinding): scala.xml.MetaData = {
      var attr: scala.xml.MetaData  = scala.xml.Null
      __obj.attributes.toList map {
        case ("@{http://www.w3.org/XML/1998/namespace}id", _) => __obj.xmlid foreach { x => attr = scala.xml.Attribute(__scope.getPrefix("http://www.w3.org/XML/1998/namespace"), "id", x.toString, attr) }
        case (key, x) => attr = scala.xml.Attribute((x.namespace map { __scope.getPrefix(_) }).orNull, x.key.orNull, x.value.toString, attr)
      }
      attr
    }

    def writesChildNodes(__obj: IPXACT2022ScalaCases.View2, __scope: scala.xml.NamespaceBinding): Seq[scala.xml.Node] =
      Seq.concat(IPXACT2022scalaxb.toXML[IPXACT2022ScalaCases.NameGroupNMTOKENSequence](__obj.nameGroupNMTOKENSequence1, None, Some("nameGroupNMTOKENSequence1"), __scope, false),
        __obj.envIdentifier flatMap { IPXACT2022scalaxb.toXML[IPXACT2022ScalaCases.EnvIdentifier2](_, Some("http://www.accellera.org/XMLSchema/IPXACT/1685-2022"), Some("envIdentifier"), __scope, false) },
        __obj.componentInstantiationRef map { IPXACT2022scalaxb.toXML[String](_, Some("http://www.accellera.org/XMLSchema/IPXACT/1685-2022"), Some("componentInstantiationRef"), __scope, false) } getOrElse {Nil},
        __obj.vendorExtensions map { IPXACT2022scalaxb.toXML[IPXACT2022ScalaCases.VendorExtensions](_, Some("http://www.accellera.org/XMLSchema/IPXACT/1685-2022"), Some("vendorExtensions"), __scope, false) } getOrElse {Nil})

  }

  trait DefaultIPXACT2022ScalaCases_Views2Format extends IPXACT2022scalaxb.ElemNameParser[IPXACT2022ScalaCases.Views2] {
    val targetNamespace: Option[String] = Some("http://www.accellera.org/XMLSchema/IPXACT/1685-2022")
    
    def parser(node: scala.xml.Node, stack: List[IPXACT2022scalaxb.ElemName]): Parser[IPXACT2022ScalaCases.Views2] =
      phrase(safeRep(IPXACT2022scalaxb.ElemName(Some("http://www.accellera.org/XMLSchema/IPXACT/1685-2022"), "view")) ^^
      { case p1 =>
      IPXACT2022ScalaCases.Views2(p1 map { IPXACT2022scalaxb.fromXML[IPXACT2022ScalaCases.View2](_, IPXACT2022scalaxb.ElemName(node) :: stack) }) })
    
    def writesChildNodes(__obj: IPXACT2022ScalaCases.Views2, __scope: scala.xml.NamespaceBinding): Seq[scala.xml.Node] =
      (__obj.view flatMap { IPXACT2022scalaxb.toXML[IPXACT2022ScalaCases.View2](_, Some("http://www.accellera.org/XMLSchema/IPXACT/1685-2022"), Some("view"), __scope, false) })
  }
  trait DefaultIPXACT2022ScalaCases_Instantiations2Format extends IPXACT2022scalaxb.ElemNameParser[IPXACT2022ScalaCases.Instantiations2] {
    val targetNamespace: Option[String] = Some("http://www.accellera.org/XMLSchema/IPXACT/1685-2022")
    
    def parser(node: scala.xml.Node, stack: List[IPXACT2022scalaxb.ElemName]): Parser[IPXACT2022ScalaCases.Instantiations2] =
      phrase(safeRep(IPXACT2022scalaxb.ElemName(Some("http://www.accellera.org/XMLSchema/IPXACT/1685-2022"), "componentInstantiation")) ^^
      { case p1 =>
      IPXACT2022ScalaCases.Instantiations2(p1 map { IPXACT2022scalaxb.fromXML[IPXACT2022ScalaCases.ComponentInstantiationType](_, IPXACT2022scalaxb.ElemName(node) :: stack) }) })
    
    def writesChildNodes(__obj: IPXACT2022ScalaCases.Instantiations2, __scope: scala.xml.NamespaceBinding): Seq[scala.xml.Node] =
      (__obj.componentInstantiation flatMap { IPXACT2022scalaxb.toXML[IPXACT2022ScalaCases.ComponentInstantiationType](_, Some("http://www.accellera.org/XMLSchema/IPXACT/1685-2022"), Some("componentInstantiation"), __scope, false) })
  }
  trait DefaultIPXACT2022ScalaCases_Ports2Format extends IPXACT2022scalaxb.ElemNameParser[IPXACT2022ScalaCases.Ports2] {
    val targetNamespace: Option[String] = Some("http://www.accellera.org/XMLSchema/IPXACT/1685-2022")
    
    def parser(node: scala.xml.Node, stack: List[IPXACT2022scalaxb.ElemName]): Parser[IPXACT2022ScalaCases.Ports2] =
      phrase(safeRep(IPXACT2022scalaxb.ElemName(Some("http://www.accellera.org/XMLSchema/IPXACT/1685-2022"), "port")) ^^
      { case p1 =>
      IPXACT2022ScalaCases.Ports2(p1 map { IPXACT2022scalaxb.fromXML[IPXACT2022ScalaCases.AbstractorPortType](_, IPXACT2022scalaxb.ElemName(node) :: stack) }) })
    
    def writesChildNodes(__obj: IPXACT2022ScalaCases.Ports2, __scope: scala.xml.NamespaceBinding): Seq[scala.xml.Node] =
      (__obj.port flatMap { IPXACT2022scalaxb.toXML[IPXACT2022ScalaCases.AbstractorPortType](_, Some("http://www.accellera.org/XMLSchema/IPXACT/1685-2022"), Some("port"), __scope, false) })
  }
  trait DefaultIPXACT2022ScalaCases_AbstractorModelTypeFormat extends IPXACT2022scalaxb.ElemNameParser[IPXACT2022ScalaCases.AbstractorModelType] {
    val targetNamespace: Option[String] = Some("http://www.accellera.org/XMLSchema/IPXACT/1685-2022")
    
    override def typeName: Option[String] = Some("abstractorModelType")

    def parser(node: scala.xml.Node, stack: List[IPXACT2022scalaxb.ElemName]): Parser[IPXACT2022ScalaCases.AbstractorModelType] =
      phrase(opt(IPXACT2022scalaxb.ElemName(Some("http://www.accellera.org/XMLSchema/IPXACT/1685-2022"), "views")) ~
      opt(IPXACT2022scalaxb.ElemName(Some("http://www.accellera.org/XMLSchema/IPXACT/1685-2022"), "instantiations")) ~
      opt(IPXACT2022scalaxb.ElemName(Some("http://www.accellera.org/XMLSchema/IPXACT/1685-2022"), "ports")) ^^
      { case p1 ~ p2 ~ p3 =>
      IPXACT2022ScalaCases.AbstractorModelType(p1.headOption map { IPXACT2022scalaxb.fromXML[IPXACT2022ScalaCases.Views2](_, IPXACT2022scalaxb.ElemName(node) :: stack) },
        p2.headOption map { IPXACT2022scalaxb.fromXML[IPXACT2022ScalaCases.Instantiations2](_, IPXACT2022scalaxb.ElemName(node) :: stack) },
        p3.headOption map { IPXACT2022scalaxb.fromXML[IPXACT2022ScalaCases.Ports2](_, IPXACT2022scalaxb.ElemName(node) :: stack) }) })
    
    def writesChildNodes(__obj: IPXACT2022ScalaCases.AbstractorModelType, __scope: scala.xml.NamespaceBinding): Seq[scala.xml.Node] =
      Seq.concat(__obj.views map { IPXACT2022scalaxb.toXML[IPXACT2022ScalaCases.Views2](_, Some("http://www.accellera.org/XMLSchema/IPXACT/1685-2022"), Some("views"), __scope, false) } getOrElse {Nil},
        __obj.instantiations map { IPXACT2022scalaxb.toXML[IPXACT2022ScalaCases.Instantiations2](_, Some("http://www.accellera.org/XMLSchema/IPXACT/1685-2022"), Some("instantiations"), __scope, false) } getOrElse {Nil},
        __obj.ports map { IPXACT2022scalaxb.toXML[IPXACT2022ScalaCases.Ports2](_, Some("http://www.accellera.org/XMLSchema/IPXACT/1685-2022"), Some("ports"), __scope, false) } getOrElse {Nil})

  }

  trait DefaultIPXACT2022ScalaCases_ClearboxElementRefTypeFormat extends IPXACT2022scalaxb.ElemNameParser[IPXACT2022ScalaCases.ClearboxElementRefType] {
    val targetNamespace: Option[String] = Some("http://www.accellera.org/XMLSchema/IPXACT/1685-2022")
    
    override def typeName: Option[String] = Some("clearboxElementRefType")

    def parser(node: scala.xml.Node, stack: List[IPXACT2022scalaxb.ElemName]): Parser[IPXACT2022ScalaCases.ClearboxElementRefType] =
      phrase(safeRep(IPXACT2022scalaxb.ElemName(Some("http://www.accellera.org/XMLSchema/IPXACT/1685-2022"), "location")) ~
      opt(IPXACT2022scalaxb.ElemName(Some("http://www.accellera.org/XMLSchema/IPXACT/1685-2022"), "vendorExtensions")) ^^
      { case p1 ~ p2 =>
      IPXACT2022ScalaCases.ClearboxElementRefType(p1 map { IPXACT2022scalaxb.fromXML[IPXACT2022ScalaCases.SlicesType](_, IPXACT2022scalaxb.ElemName(node) :: stack) },
        p2.headOption map { IPXACT2022scalaxb.fromXML[IPXACT2022ScalaCases.VendorExtensions](_, IPXACT2022scalaxb.ElemName(node) :: stack) },
        scala.collection.immutable.ListMap(List(
        (node \ "@name").headOption map { x => IPXACT2022scalaxb.DataRecord(x, node, IPXACT2022scalaxb.fromXML[String](x, IPXACT2022scalaxb.ElemName(node) :: stack)) } map { "@name" -> _ },
        (node \ "@{http://www.w3.org/XML/1998/namespace}id").headOption map { x => IPXACT2022scalaxb.DataRecord(x, node, IPXACT2022scalaxb.fromXML[String](x, IPXACT2022scalaxb.ElemName(node) :: stack)) } map { "@{http://www.w3.org/XML/1998/namespace}id" -> _ }
        ).flatten[(String, IPXACT2022scalaxb.DataRecord[Any])]: _*)) })
    
    override def writesAttribute(__obj: IPXACT2022ScalaCases.ClearboxElementRefType, __scope: scala.xml.NamespaceBinding): scala.xml.MetaData = {
      var attr: scala.xml.MetaData  = scala.xml.Null
      __obj.attributes.toList map {
        case ("@name", _) => attr = scala.xml.Attribute(null, "name", __obj.name.toString, attr)
        case ("@{http://www.w3.org/XML/1998/namespace}id", _) => __obj.xmlid foreach { x => attr = scala.xml.Attribute(__scope.getPrefix("http://www.w3.org/XML/1998/namespace"), "id", x.toString, attr) }
        case (key, x) => attr = scala.xml.Attribute((x.namespace map { __scope.getPrefix(_) }).orNull, x.key.orNull, x.value.toString, attr)
      }
      attr
    }

    def writesChildNodes(__obj: IPXACT2022ScalaCases.ClearboxElementRefType, __scope: scala.xml.NamespaceBinding): Seq[scala.xml.Node] =
      Seq.concat(__obj.location flatMap { IPXACT2022scalaxb.toXML[IPXACT2022ScalaCases.SlicesType](_, Some("http://www.accellera.org/XMLSchema/IPXACT/1685-2022"), Some("location"), __scope, false) },
        __obj.vendorExtensions map { IPXACT2022scalaxb.toXML[IPXACT2022ScalaCases.VendorExtensions](_, Some("http://www.accellera.org/XMLSchema/IPXACT/1685-2022"), Some("vendorExtensions"), __scope, false) } getOrElse {Nil})

  }

  trait DefaultIPXACT2022ScalaCases_LanguageTypeFormat extends IPXACT2022scalaxb.XMLFormat[IPXACT2022ScalaCases.LanguageType] with IPXACT2022scalaxb.CanWriteChildNodes[IPXACT2022ScalaCases.LanguageType] {
    val targetNamespace: Option[String] = Some("http://www.accellera.org/XMLSchema/IPXACT/1685-2022")
    def reads(seq: scala.xml.NodeSeq, stack: List[IPXACT2022scalaxb.ElemName]): Either[String, IPXACT2022ScalaCases.LanguageType] = seq match {
      case node: scala.xml.Node => Right(IPXACT2022ScalaCases.LanguageType(IPXACT2022scalaxb.fromXML[String](node, IPXACT2022scalaxb.ElemName(node) :: stack),
        scala.collection.immutable.ListMap(List(
        (node \ "@strict").headOption map { x => IPXACT2022scalaxb.DataRecord(x, node, IPXACT2022scalaxb.fromXML[Boolean](x, IPXACT2022scalaxb.ElemName(node) :: stack)) } orElse Some(IPXACT2022scalaxb.DataRecord(None, None, IPXACT2022scalaxb.fromXML[Boolean](scala.xml.Text("false"), IPXACT2022scalaxb.ElemName(node) :: stack))) map { "@strict" -> _ }
        ).flatten[(String, IPXACT2022scalaxb.DataRecord[Any])]: _*)))
      case _ => Left("reads failed: seq must be scala.xml.Node")
    }
    
    override def writesAttribute(__obj: IPXACT2022ScalaCases.LanguageType, __scope: scala.xml.NamespaceBinding): scala.xml.MetaData = {
      var attr: scala.xml.MetaData  = scala.xml.Null
      __obj.attributes.toList map {
        case ("@strict", _) => if (__obj.strict.toString != "false") attr = scala.xml.Attribute(null, "strict", __obj.strict.toString, attr)
        case (key, x) => attr = scala.xml.Attribute((x.namespace map { __scope.getPrefix(_) }).orNull, x.key.orNull, x.value.toString, attr)
      }
      attr
    }

    def writesChildNodes(__obj: IPXACT2022ScalaCases.LanguageType, __scope: scala.xml.NamespaceBinding): Seq[scala.xml.Node] =
      Seq(scala.xml.Text(__obj.value.toString))

  }


  trait IPXACT2022ScalaCases_InstantiationsGroupGroupFormat extends IPXACT2022scalaxb.AnyElemNameParser {
    def parseInstantiationsGroupGroup(node: scala.xml.Node, stack: List[IPXACT2022scalaxb.ElemName]): Parser[IPXACT2022scalaxb.DataRecord[IPXACT2022ScalaCases.InstantiationsGroupOption]] =
      (((IPXACT2022scalaxb.ElemName(Some("http://www.accellera.org/XMLSchema/IPXACT/1685-2022"), "componentInstantiation")) ^^
      (x => IPXACT2022scalaxb.DataRecord(x.namespace, Some(x.name), IPXACT2022scalaxb.fromXML[IPXACT2022ScalaCases.ComponentInstantiationType](x, IPXACT2022scalaxb.ElemName(node) :: stack)))) |
      ((IPXACT2022scalaxb.ElemName(Some("http://www.accellera.org/XMLSchema/IPXACT/1685-2022"), "designInstantiation")) ^^
      (x => IPXACT2022scalaxb.DataRecord(x.namespace, Some(x.name), IPXACT2022scalaxb.fromXML[IPXACT2022ScalaCases.DesignInstantiationType](x, IPXACT2022scalaxb.ElemName(node) :: stack)))) |
      ((IPXACT2022scalaxb.ElemName(Some("http://www.accellera.org/XMLSchema/IPXACT/1685-2022"), "designConfigurationInstantiation")) ^^
      (x => IPXACT2022scalaxb.DataRecord(x.namespace, Some(x.name), IPXACT2022scalaxb.fromXML[IPXACT2022ScalaCases.DesignConfigurationInstantiationType](x, IPXACT2022scalaxb.ElemName(node) :: stack)))))
  
    def parseInstantiationsGroupGroup(node: scala.xml.Node, stack: List[IPXACT2022scalaxb.ElemName], wrap: Boolean): Parser[IPXACT2022scalaxb.DataRecord[IPXACT2022ScalaCases.InstantiationsGroupOption]] =
      (((IPXACT2022scalaxb.ElemName(Some("http://www.accellera.org/XMLSchema/IPXACT/1685-2022"), "componentInstantiation")) ^^
      (x => IPXACT2022scalaxb.DataRecord(x.namespace, Some(x.name), IPXACT2022scalaxb.fromXML[IPXACT2022ScalaCases.ComponentInstantiationType](x, IPXACT2022scalaxb.ElemName(node) :: stack)))) |
      ((IPXACT2022scalaxb.ElemName(Some("http://www.accellera.org/XMLSchema/IPXACT/1685-2022"), "designInstantiation")) ^^
      (x => IPXACT2022scalaxb.DataRecord(x.namespace, Some(x.name), IPXACT2022scalaxb.fromXML[IPXACT2022ScalaCases.DesignInstantiationType](x, IPXACT2022scalaxb.ElemName(node) :: stack)))) |
      ((IPXACT2022scalaxb.ElemName(Some("http://www.accellera.org/XMLSchema/IPXACT/1685-2022"), "designConfigurationInstantiation")) ^^
      (x => IPXACT2022scalaxb.DataRecord(x.namespace, Some(x.name), IPXACT2022scalaxb.fromXML[IPXACT2022ScalaCases.DesignConfigurationInstantiationType](x, IPXACT2022scalaxb.ElemName(node) :: stack)))))
    
    def parsemixedInstantiationsGroupGroup(node: scala.xml.Node, stack: List[IPXACT2022scalaxb.ElemName]): Parser[Seq[IPXACT2022scalaxb.DataRecord[Any]]] =
      ((((safeRep(IPXACT2022scalaxb.ElemName(Some("http://www.accellera.org/XMLSchema/IPXACT/1685-2022"), "componentInstantiation")) ^^
      (_.toSeq map { x => IPXACT2022scalaxb.DataRecord(x.namespace, Some(x.name), IPXACT2022scalaxb.fromXML[IPXACT2022ScalaCases.ComponentInstantiationType](x, IPXACT2022scalaxb.ElemName(node) :: stack)) })) ~
      optTextRecord) ^^ 
        { case p1 ~ p2 => Seq.concat(p1,
        p2.toList) }) ||| 
      (((safeRep(IPXACT2022scalaxb.ElemName(Some("http://www.accellera.org/XMLSchema/IPXACT/1685-2022"), "designInstantiation")) ^^
      (_.toSeq map { x => IPXACT2022scalaxb.DataRecord(x.namespace, Some(x.name), IPXACT2022scalaxb.fromXML[IPXACT2022ScalaCases.DesignInstantiationType](x, IPXACT2022scalaxb.ElemName(node) :: stack)) })) ~
      optTextRecord) ^^ 
        { case p1 ~ p2 => Seq.concat(p1,
        p2.toList) }) ||| 
      (((safeRep(IPXACT2022scalaxb.ElemName(Some("http://www.accellera.org/XMLSchema/IPXACT/1685-2022"), "designConfigurationInstantiation")) ^^
      (_.toSeq map { x => IPXACT2022scalaxb.DataRecord(x.namespace, Some(x.name), IPXACT2022scalaxb.fromXML[IPXACT2022ScalaCases.DesignConfigurationInstantiationType](x, IPXACT2022scalaxb.ElemName(node) :: stack)) })) ~
      optTextRecord) ^^ 
        { case p1 ~ p2 => Seq.concat(p1,
        p2.toList) }))
  }

  def buildIPXACT2022ScalaCases_ComponentPortDirectionTypeFormat = new DefaultIPXACT2022ScalaCases_ComponentPortDirectionTypeFormat {}
  trait DefaultIPXACT2022ScalaCases_ComponentPortDirectionTypeFormat extends IPXACT2022scalaxb.XMLFormat[IPXACT2022ScalaCases.ComponentPortDirectionType] {
    val targetNamespace: Option[String] = Some("http://www.accellera.org/XMLSchema/IPXACT/1685-2022")
    
    def fromString(value: String, scope: scala.xml.NamespaceBinding): IPXACT2022ScalaCases.ComponentPortDirectionType =
        (fromString0(value, scope)).apply(IPXACT2022scalaxb.fromXML[String](scala.xml.Text(value)))

    private def fromString0(value: String, scope: scala.xml.NamespaceBinding): PartialFunction[Any, IPXACT2022ScalaCases.ComponentPortDirectionType] = {
      case x: String if x == IPXACT2022scalaxb.fromXML[String](scala.xml.Text("in")) => IPXACT2022ScalaCases.InValue
      case x: String if x == IPXACT2022scalaxb.fromXML[String](scala.xml.Text("out")) => IPXACT2022ScalaCases.OutValue
      case x: String if x == IPXACT2022scalaxb.fromXML[String](scala.xml.Text("inout")) => IPXACT2022ScalaCases.InoutValue
      case x: String if x == IPXACT2022scalaxb.fromXML[String](scala.xml.Text("phantom")) => IPXACT2022ScalaCases.Phantom

    }



    def reads(seq: scala.xml.NodeSeq, stack: List[IPXACT2022scalaxb.ElemName]): Either[String, IPXACT2022ScalaCases.ComponentPortDirectionType] = seq match {
      case elem: scala.xml.Elem => Right(fromString(elem.text, elem.scope))
      case _ => Right(fromString(seq.text, scala.xml.TopScope))
    }
    
    def writes(__obj: IPXACT2022ScalaCases.ComponentPortDirectionType, __namespace: Option[String], __elementLabel: Option[String],
        __scope: scala.xml.NamespaceBinding, __typeAttribute: Boolean): scala.xml.NodeSeq =
      scala.xml.Elem(IPXACT2022scalaxb.Helper.getPrefix(__namespace, __scope).orNull,
        __elementLabel getOrElse { sys.error("missing element label.") },
        scala.xml.Null, __scope, true, scala.xml.Text(__obj.toString))
  }
  trait DefaultIPXACT2022ScalaCases_PortTypableFormat extends IPXACT2022scalaxb.XMLFormat[IPXACT2022ScalaCases.PortTypable] {
    def reads(seq: scala.xml.NodeSeq, stack: List[IPXACT2022scalaxb.ElemName]): Either[String, IPXACT2022ScalaCases.PortTypable] = seq match {
      case node: scala.xml.Node =>     
        IPXACT2022scalaxb.Helper.instanceType(node) match {
          
          case _ => Right(IPXACT2022scalaxb.fromXML[IPXACT2022ScalaCases.PortType](node, stack))
        }
      case _ => Left("reads failed: seq must be scala.xml.Node")  
    }
    
    def writes(__obj: IPXACT2022ScalaCases.PortTypable, __namespace: Option[String], __elementLabel: Option[String],
        __scope: scala.xml.NamespaceBinding, __typeAttribute: Boolean): scala.xml.NodeSeq = __obj match {
      case x: IPXACT2022ScalaCases.Port2 => IPXACT2022scalaxb.toXML[IPXACT2022ScalaCases.Port2](x, __namespace, __elementLabel, __scope, true)
      case x: IPXACT2022ScalaCases.PortType => IPXACT2022scalaxb.toXML[IPXACT2022ScalaCases.PortType](x, __namespace, __elementLabel, __scope, __typeAttribute)
    }
  }
  trait DefaultIPXACT2022ScalaCases_PortTypeFormat extends IPXACT2022scalaxb.ElemNameParser[IPXACT2022ScalaCases.PortType] with IPXACT2022ScalaCases_NameGroupPortGroupFormat {
    val targetNamespace: Option[String] = Some("http://www.accellera.org/XMLSchema/IPXACT/1685-2022")
    
    override def typeName: Option[String] = Some("portType")

    def parser(node: scala.xml.Node, stack: List[IPXACT2022scalaxb.ElemName]): Parser[IPXACT2022ScalaCases.PortType] =
      phrase((parseNameGroupPortGroup(node, IPXACT2022scalaxb.ElemName(node) :: stack)) ~
      (((IPXACT2022scalaxb.ElemName(Some("http://www.accellera.org/XMLSchema/IPXACT/1685-2022"), "wire")) ^^
      (x => IPXACT2022scalaxb.DataRecord(x.namespace, Some(x.name), IPXACT2022scalaxb.fromXML[IPXACT2022ScalaCases.PortWireTypable](x, IPXACT2022scalaxb.ElemName(node) :: stack)))) |
      ((IPXACT2022scalaxb.ElemName(Some("http://www.accellera.org/XMLSchema/IPXACT/1685-2022"), "transactional")) ^^
      (x => IPXACT2022scalaxb.DataRecord(x.namespace, Some(x.name), IPXACT2022scalaxb.fromXML[IPXACT2022ScalaCases.PortTransactionalType](x, IPXACT2022scalaxb.ElemName(node) :: stack)))) |
      ((IPXACT2022scalaxb.ElemName(Some("http://www.accellera.org/XMLSchema/IPXACT/1685-2022"), "structured")) ^^
      (x => IPXACT2022scalaxb.DataRecord(x.namespace, Some(x.name), IPXACT2022scalaxb.fromXML[IPXACT2022ScalaCases.PortStructuredType](x, IPXACT2022scalaxb.ElemName(node) :: stack))))) ~
      opt(IPXACT2022scalaxb.ElemName(Some("http://www.accellera.org/XMLSchema/IPXACT/1685-2022"), "fieldMaps")) ~
      opt(IPXACT2022scalaxb.ElemName(Some("http://www.accellera.org/XMLSchema/IPXACT/1685-2022"), "arrays")) ~
      opt(IPXACT2022scalaxb.ElemName(Some("http://www.accellera.org/XMLSchema/IPXACT/1685-2022"), "access")) ~
      opt(IPXACT2022scalaxb.ElemName(Some("http://www.accellera.org/XMLSchema/IPXACT/1685-2022"), "parameters")) ~
      opt(IPXACT2022scalaxb.ElemName(Some("http://www.accellera.org/XMLSchema/IPXACT/1685-2022"), "vendorExtensions")) ^^
      { case p1 ~ p2 ~ p3 ~ p4 ~ p5 ~ p6 ~ p7 =>
      IPXACT2022ScalaCases.PortType(p1,
        p2,
        p3.headOption map { IPXACT2022scalaxb.fromXML[IPXACT2022ScalaCases.FieldMaps](_, IPXACT2022scalaxb.ElemName(node) :: stack) },
        p4.headOption map { IPXACT2022scalaxb.fromXML[IPXACT2022ScalaCases.Arrays](_, IPXACT2022scalaxb.ElemName(node) :: stack) },
        p5.headOption map { IPXACT2022scalaxb.fromXML[IPXACT2022ScalaCases.PortAccessType](_, IPXACT2022scalaxb.ElemName(node) :: stack) },
        p6.headOption map { IPXACT2022scalaxb.fromXML[IPXACT2022ScalaCases.Parameters](_, IPXACT2022scalaxb.ElemName(node) :: stack) },
        p7.headOption map { IPXACT2022scalaxb.fromXML[IPXACT2022ScalaCases.VendorExtensions](_, IPXACT2022scalaxb.ElemName(node) :: stack) },
        scala.collection.immutable.ListMap(List(
        (node \ "@{http://www.w3.org/XML/1998/namespace}id").headOption map { x => IPXACT2022scalaxb.DataRecord(x, node, IPXACT2022scalaxb.fromXML[String](x, IPXACT2022scalaxb.ElemName(node) :: stack)) } map { "@{http://www.w3.org/XML/1998/namespace}id" -> _ }
        ).flatten[(String, IPXACT2022scalaxb.DataRecord[Any])]: _*)) })
    
    override def writesAttribute(__obj: IPXACT2022ScalaCases.PortType, __scope: scala.xml.NamespaceBinding): scala.xml.MetaData = {
      var attr: scala.xml.MetaData  = scala.xml.Null
      __obj.attributes.toList map {
        case ("@{http://www.w3.org/XML/1998/namespace}id", _) => __obj.xmlid foreach { x => attr = scala.xml.Attribute(__scope.getPrefix("http://www.w3.org/XML/1998/namespace"), "id", x.toString, attr) }
        case (key, x) => attr = scala.xml.Attribute((x.namespace map { __scope.getPrefix(_) }).orNull, x.key.orNull, x.value.toString, attr)
      }
      attr
    }

    def writesChildNodes(__obj: IPXACT2022ScalaCases.PortType, __scope: scala.xml.NamespaceBinding): Seq[scala.xml.Node] =
      Seq.concat(IPXACT2022scalaxb.toXML[IPXACT2022ScalaCases.NameGroupPortSequence](__obj.nameGroupPortSequence1, None, Some("nameGroupPortSequence1"), __scope, false),
        (Some(__obj.porttypableoption) map {x => IPXACT2022scalaxb.toXML[IPXACT2022scalaxb.DataRecord[IPXACT2022ScalaCases.PortTypableOption]](x, x.namespace, x.key, __scope, false)}).get,
        __obj.fieldMaps map { IPXACT2022scalaxb.toXML[IPXACT2022ScalaCases.FieldMaps](_, Some("http://www.accellera.org/XMLSchema/IPXACT/1685-2022"), Some("fieldMaps"), __scope, false) } getOrElse {Nil},
        __obj.arrays map { IPXACT2022scalaxb.toXML[IPXACT2022ScalaCases.Arrays](_, Some("http://www.accellera.org/XMLSchema/IPXACT/1685-2022"), Some("arrays"), __scope, false) } getOrElse {Nil},
        __obj.access map { IPXACT2022scalaxb.toXML[IPXACT2022ScalaCases.PortAccessType](_, Some("http://www.accellera.org/XMLSchema/IPXACT/1685-2022"), Some("access"), __scope, false) } getOrElse {Nil},
        __obj.parameters map { IPXACT2022scalaxb.toXML[IPXACT2022ScalaCases.Parameters](_, Some("http://www.accellera.org/XMLSchema/IPXACT/1685-2022"), Some("parameters"), __scope, false) } getOrElse {Nil},
        __obj.vendorExtensions map { IPXACT2022scalaxb.toXML[IPXACT2022ScalaCases.VendorExtensions](_, Some("http://www.accellera.org/XMLSchema/IPXACT/1685-2022"), Some("vendorExtensions"), __scope, false) } getOrElse {Nil})

  }

  trait DefaultIPXACT2022ScalaCases_AbstractorPortTypeFormat extends IPXACT2022scalaxb.ElemNameParser[IPXACT2022ScalaCases.AbstractorPortType] with IPXACT2022ScalaCases_NameGroupPortGroupFormat {
    val targetNamespace: Option[String] = Some("http://www.accellera.org/XMLSchema/IPXACT/1685-2022")
    
    override def typeName: Option[String] = Some("abstractorPortType")

    def parser(node: scala.xml.Node, stack: List[IPXACT2022scalaxb.ElemName]): Parser[IPXACT2022ScalaCases.AbstractorPortType] =
      phrase((parseNameGroupPortGroup(node, IPXACT2022scalaxb.ElemName(node) :: stack)) ~
      (((IPXACT2022scalaxb.ElemName(Some("http://www.accellera.org/XMLSchema/IPXACT/1685-2022"), "wire")) ^^
      (x => IPXACT2022scalaxb.DataRecord(x.namespace, Some(x.name), IPXACT2022scalaxb.fromXML[IPXACT2022ScalaCases.AbstractorPortWireType](x, IPXACT2022scalaxb.ElemName(node) :: stack)))) |
      ((IPXACT2022scalaxb.ElemName(Some("http://www.accellera.org/XMLSchema/IPXACT/1685-2022"), "transactional")) ^^
      (x => IPXACT2022scalaxb.DataRecord(x.namespace, Some(x.name), IPXACT2022scalaxb.fromXML[IPXACT2022ScalaCases.AbstractorPortTransactionalType](x, IPXACT2022scalaxb.ElemName(node) :: stack)))) |
      ((IPXACT2022scalaxb.ElemName(Some("http://www.accellera.org/XMLSchema/IPXACT/1685-2022"), "structured")) ^^
      (x => IPXACT2022scalaxb.DataRecord(x.namespace, Some(x.name), IPXACT2022scalaxb.fromXML[IPXACT2022ScalaCases.AbstractorPortStructuredType](x, IPXACT2022scalaxb.ElemName(node) :: stack))))) ~
      opt(IPXACT2022scalaxb.ElemName(Some("http://www.accellera.org/XMLSchema/IPXACT/1685-2022"), "arrays")) ~
      opt(IPXACT2022scalaxb.ElemName(Some("http://www.accellera.org/XMLSchema/IPXACT/1685-2022"), "access")) ~
      opt(IPXACT2022scalaxb.ElemName(Some("http://www.accellera.org/XMLSchema/IPXACT/1685-2022"), "parameters")) ~
      opt(IPXACT2022scalaxb.ElemName(Some("http://www.accellera.org/XMLSchema/IPXACT/1685-2022"), "vendorExtensions")) ^^
      { case p1 ~ p2 ~ p3 ~ p4 ~ p5 ~ p6 =>
      IPXACT2022ScalaCases.AbstractorPortType(p1,
        p2,
        p3.headOption map { IPXACT2022scalaxb.fromXML[IPXACT2022ScalaCases.Arrays](_, IPXACT2022scalaxb.ElemName(node) :: stack) },
        p4.headOption map { IPXACT2022scalaxb.fromXML[IPXACT2022ScalaCases.PortAccessType](_, IPXACT2022scalaxb.ElemName(node) :: stack) },
        p5.headOption map { IPXACT2022scalaxb.fromXML[IPXACT2022ScalaCases.Parameters](_, IPXACT2022scalaxb.ElemName(node) :: stack) },
        p6.headOption map { IPXACT2022scalaxb.fromXML[IPXACT2022ScalaCases.VendorExtensions](_, IPXACT2022scalaxb.ElemName(node) :: stack) },
        scala.collection.immutable.ListMap(List(
        (node \ "@{http://www.w3.org/XML/1998/namespace}id").headOption map { x => IPXACT2022scalaxb.DataRecord(x, node, IPXACT2022scalaxb.fromXML[String](x, IPXACT2022scalaxb.ElemName(node) :: stack)) } map { "@{http://www.w3.org/XML/1998/namespace}id" -> _ }
        ).flatten[(String, IPXACT2022scalaxb.DataRecord[Any])]: _*)) })
    
    override def writesAttribute(__obj: IPXACT2022ScalaCases.AbstractorPortType, __scope: scala.xml.NamespaceBinding): scala.xml.MetaData = {
      var attr: scala.xml.MetaData  = scala.xml.Null
      __obj.attributes.toList map {
        case ("@{http://www.w3.org/XML/1998/namespace}id", _) => __obj.xmlid foreach { x => attr = scala.xml.Attribute(__scope.getPrefix("http://www.w3.org/XML/1998/namespace"), "id", x.toString, attr) }
        case (key, x) => attr = scala.xml.Attribute((x.namespace map { __scope.getPrefix(_) }).orNull, x.key.orNull, x.value.toString, attr)
      }
      attr
    }

    def writesChildNodes(__obj: IPXACT2022ScalaCases.AbstractorPortType, __scope: scala.xml.NamespaceBinding): Seq[scala.xml.Node] =
      Seq.concat(IPXACT2022scalaxb.toXML[IPXACT2022ScalaCases.NameGroupPortSequence](__obj.nameGroupPortSequence1, None, Some("nameGroupPortSequence1"), __scope, false),
        (Some(__obj.abstractorporttypeoption) map {x => IPXACT2022scalaxb.toXML[IPXACT2022scalaxb.DataRecord[IPXACT2022ScalaCases.AbstractorPortTypeOption]](x, x.namespace, x.key, __scope, false)}).get,
        __obj.arrays map { IPXACT2022scalaxb.toXML[IPXACT2022ScalaCases.Arrays](_, Some("http://www.accellera.org/XMLSchema/IPXACT/1685-2022"), Some("arrays"), __scope, false) } getOrElse {Nil},
        __obj.access map { IPXACT2022scalaxb.toXML[IPXACT2022ScalaCases.PortAccessType](_, Some("http://www.accellera.org/XMLSchema/IPXACT/1685-2022"), Some("access"), __scope, false) } getOrElse {Nil},
        __obj.parameters map { IPXACT2022scalaxb.toXML[IPXACT2022ScalaCases.Parameters](_, Some("http://www.accellera.org/XMLSchema/IPXACT/1685-2022"), Some("parameters"), __scope, false) } getOrElse {Nil},
        __obj.vendorExtensions map { IPXACT2022scalaxb.toXML[IPXACT2022ScalaCases.VendorExtensions](_, Some("http://www.accellera.org/XMLSchema/IPXACT/1685-2022"), Some("vendorExtensions"), __scope, false) } getOrElse {Nil})

  }

  def buildIPXACT2022ScalaCases_InitiativeTypeFormat = new DefaultIPXACT2022ScalaCases_InitiativeTypeFormat {}
  trait DefaultIPXACT2022ScalaCases_InitiativeTypeFormat extends IPXACT2022scalaxb.XMLFormat[IPXACT2022ScalaCases.InitiativeType] {
    val targetNamespace: Option[String] = Some("http://www.accellera.org/XMLSchema/IPXACT/1685-2022")
    
    def fromString(value: String, scope: scala.xml.NamespaceBinding): IPXACT2022ScalaCases.InitiativeType =
        (fromString0(value, scope)).apply(IPXACT2022scalaxb.fromXML[String](scala.xml.Text(value)))

    private def fromString0(value: String, scope: scala.xml.NamespaceBinding): PartialFunction[Any, IPXACT2022ScalaCases.InitiativeType] = {
      case x: String if x == IPXACT2022scalaxb.fromXML[String](scala.xml.Text("requires")) => IPXACT2022ScalaCases.Requires
      case x: String if x == IPXACT2022scalaxb.fromXML[String](scala.xml.Text("provides")) => IPXACT2022ScalaCases.Provides
      case x: String if x == IPXACT2022scalaxb.fromXML[String](scala.xml.Text("both")) => IPXACT2022ScalaCases.Both
      case x: String if x == IPXACT2022scalaxb.fromXML[String](scala.xml.Text("phantom")) => IPXACT2022ScalaCases.PhantomValue

    }



    def reads(seq: scala.xml.NodeSeq, stack: List[IPXACT2022scalaxb.ElemName]): Either[String, IPXACT2022ScalaCases.InitiativeType] = seq match {
      case elem: scala.xml.Elem => Right(fromString(elem.text, elem.scope))
      case _ => Right(fromString(seq.text, scala.xml.TopScope))
    }
    
    def writes(__obj: IPXACT2022ScalaCases.InitiativeType, __namespace: Option[String], __elementLabel: Option[String],
        __scope: scala.xml.NamespaceBinding, __typeAttribute: Boolean): scala.xml.NodeSeq =
      scala.xml.Elem(IPXACT2022scalaxb.Helper.getPrefix(__namespace, __scope).orNull,
        __elementLabel getOrElse { sys.error("missing element label.") },
        scala.xml.Null, __scope, true, scala.xml.Text(__obj.toString))
  }
  trait DefaultIPXACT2022ScalaCases_ProtocolTypeFormat extends IPXACT2022scalaxb.XMLFormat[IPXACT2022ScalaCases.ProtocolType] with IPXACT2022scalaxb.CanWriteChildNodes[IPXACT2022ScalaCases.ProtocolType] {
    val targetNamespace: Option[String] = Some("http://www.accellera.org/XMLSchema/IPXACT/1685-2022")
    def reads(seq: scala.xml.NodeSeq, stack: List[IPXACT2022scalaxb.ElemName]): Either[String, IPXACT2022ScalaCases.ProtocolType] = seq match {
      case node: scala.xml.Node => Right(IPXACT2022ScalaCases.ProtocolType(IPXACT2022scalaxb.fromXML[IPXACT2022ScalaCases.ProtocolTypeType](node, IPXACT2022scalaxb.ElemName(node) :: stack),
        scala.collection.immutable.ListMap(List(
        (node \ "@custom").headOption map { x => IPXACT2022scalaxb.DataRecord(x, node, IPXACT2022scalaxb.fromXML[String](x, IPXACT2022scalaxb.ElemName(node) :: stack)) } map { "@custom" -> _ }
        ).flatten[(String, IPXACT2022scalaxb.DataRecord[Any])]: _*)))
      case _ => Left("reads failed: seq must be scala.xml.Node")
    }
    
    override def writesAttribute(__obj: IPXACT2022ScalaCases.ProtocolType, __scope: scala.xml.NamespaceBinding): scala.xml.MetaData = {
      var attr: scala.xml.MetaData  = scala.xml.Null
      __obj.attributes.toList map {
        case ("@custom", _) => __obj.custom foreach { x => attr = scala.xml.Attribute(null, "custom", x.toString, attr) }
        case (key, x) => attr = scala.xml.Attribute((x.namespace map { __scope.getPrefix(_) }).orNull, x.key.orNull, x.value.toString, attr)
      }
      attr
    }

    def writesChildNodes(__obj: IPXACT2022ScalaCases.ProtocolType, __scope: scala.xml.NamespaceBinding): Seq[scala.xml.Node] =
      Seq(scala.xml.Text(__obj.value.toString))

  }

  trait DefaultIPXACT2022ScalaCases_ProtocolFormat extends IPXACT2022scalaxb.ElemNameParser[IPXACT2022ScalaCases.Protocol] {
    val targetNamespace: Option[String] = Some("http://www.accellera.org/XMLSchema/IPXACT/1685-2022")
    
    def parser(node: scala.xml.Node, stack: List[IPXACT2022scalaxb.ElemName]): Parser[IPXACT2022ScalaCases.Protocol] =
      phrase((IPXACT2022scalaxb.ElemName(Some("http://www.accellera.org/XMLSchema/IPXACT/1685-2022"), "protocolType")) ~
      opt(IPXACT2022scalaxb.ElemName(Some("http://www.accellera.org/XMLSchema/IPXACT/1685-2022"), "payload")) ^^
      { case p1 ~ p2 =>
      IPXACT2022ScalaCases.Protocol(IPXACT2022scalaxb.fromXML[IPXACT2022ScalaCases.ProtocolType](p1, IPXACT2022scalaxb.ElemName(node) :: stack),
        p2.headOption map { IPXACT2022scalaxb.fromXML[IPXACT2022ScalaCases.Payload](_, IPXACT2022scalaxb.ElemName(node) :: stack) }) })
    
    def writesChildNodes(__obj: IPXACT2022ScalaCases.Protocol, __scope: scala.xml.NamespaceBinding): Seq[scala.xml.Node] =
      Seq.concat(IPXACT2022scalaxb.toXML[IPXACT2022ScalaCases.ProtocolType](__obj.protocolType, Some("http://www.accellera.org/XMLSchema/IPXACT/1685-2022"), Some("protocolType"), __scope, false),
        __obj.payload map { IPXACT2022scalaxb.toXML[IPXACT2022ScalaCases.Payload](_, Some("http://www.accellera.org/XMLSchema/IPXACT/1685-2022"), Some("payload"), __scope, false) } getOrElse {Nil})

  }

  def buildIPXACT2022ScalaCases_ProtocolTypeTypeFormat = new DefaultIPXACT2022ScalaCases_ProtocolTypeTypeFormat {}
  trait DefaultIPXACT2022ScalaCases_ProtocolTypeTypeFormat extends IPXACT2022scalaxb.XMLFormat[IPXACT2022ScalaCases.ProtocolTypeType] {
    val targetNamespace: Option[String] = Some("http://www.accellera.org/XMLSchema/IPXACT/1685-2022")
    
    def fromString(value: String, scope: scala.xml.NamespaceBinding): IPXACT2022ScalaCases.ProtocolTypeType =
        (fromString0(value, scope)).apply(IPXACT2022scalaxb.fromXML[String](scala.xml.Text(value)))

    private def fromString0(value: String, scope: scala.xml.NamespaceBinding): PartialFunction[Any, IPXACT2022ScalaCases.ProtocolTypeType] = {
      case x: String if x == IPXACT2022scalaxb.fromXML[String](scala.xml.Text("tlm")) => IPXACT2022ScalaCases.Tlm
      case x: String if x == IPXACT2022scalaxb.fromXML[String](scala.xml.Text("custom")) => IPXACT2022ScalaCases.Custom

    }



    def reads(seq: scala.xml.NodeSeq, stack: List[IPXACT2022scalaxb.ElemName]): Either[String, IPXACT2022ScalaCases.ProtocolTypeType] = seq match {
      case elem: scala.xml.Elem => Right(fromString(elem.text, elem.scope))
      case _ => Right(fromString(seq.text, scala.xml.TopScope))
    }
    
    def writes(__obj: IPXACT2022ScalaCases.ProtocolTypeType, __namespace: Option[String], __elementLabel: Option[String],
        __scope: scala.xml.NamespaceBinding, __typeAttribute: Boolean): scala.xml.NodeSeq =
      scala.xml.Elem(IPXACT2022scalaxb.Helper.getPrefix(__namespace, __scope).orNull,
        __elementLabel getOrElse { sys.error("missing element label.") },
        scala.xml.Null, __scope, true, scala.xml.Text(__obj.toString))
  }
  def buildIPXACT2022ScalaCases_KindTypeFormat = new DefaultIPXACT2022ScalaCases_KindTypeFormat {}
  trait DefaultIPXACT2022ScalaCases_KindTypeFormat extends IPXACT2022scalaxb.XMLFormat[IPXACT2022ScalaCases.KindType] {
    val targetNamespace: Option[String] = Some("http://www.accellera.org/XMLSchema/IPXACT/1685-2022")
    
    def fromString(value: String, scope: scala.xml.NamespaceBinding): IPXACT2022ScalaCases.KindType =
        (fromString0(value, scope)).apply(IPXACT2022scalaxb.fromXML[String](scala.xml.Text(value)))

    private def fromString0(value: String, scope: scala.xml.NamespaceBinding): PartialFunction[Any, IPXACT2022ScalaCases.KindType] = {
      case x: String if x == IPXACT2022scalaxb.fromXML[String](scala.xml.Text("tlm_port")) => IPXACT2022ScalaCases.Tlm_port
      case x: String if x == IPXACT2022scalaxb.fromXML[String](scala.xml.Text("tlm_socket")) => IPXACT2022ScalaCases.Tlm_socket
      case x: String if x == IPXACT2022scalaxb.fromXML[String](scala.xml.Text("simple_socket")) => IPXACT2022ScalaCases.Simple_socket
      case x: String if x == IPXACT2022scalaxb.fromXML[String](scala.xml.Text("multi_socket")) => IPXACT2022ScalaCases.Multi_socket
      case x: String if x == IPXACT2022scalaxb.fromXML[String](scala.xml.Text("custom")) => IPXACT2022ScalaCases.CustomValue

    }



    def reads(seq: scala.xml.NodeSeq, stack: List[IPXACT2022scalaxb.ElemName]): Either[String, IPXACT2022ScalaCases.KindType] = seq match {
      case elem: scala.xml.Elem => Right(fromString(elem.text, elem.scope))
      case _ => Right(fromString(seq.text, scala.xml.TopScope))
    }
    
    def writes(__obj: IPXACT2022ScalaCases.KindType, __namespace: Option[String], __elementLabel: Option[String],
        __scope: scala.xml.NamespaceBinding, __typeAttribute: Boolean): scala.xml.NodeSeq =
      scala.xml.Elem(IPXACT2022scalaxb.Helper.getPrefix(__namespace, __scope).orNull,
        __elementLabel getOrElse { sys.error("missing element label.") },
        scala.xml.Null, __scope, true, scala.xml.Text(__obj.toString))
  }
  trait DefaultIPXACT2022ScalaCases_KindFormat extends IPXACT2022scalaxb.XMLFormat[IPXACT2022ScalaCases.Kind] with IPXACT2022scalaxb.CanWriteChildNodes[IPXACT2022ScalaCases.Kind] {
    val targetNamespace: Option[String] = Some("http://www.accellera.org/XMLSchema/IPXACT/1685-2022")
    def reads(seq: scala.xml.NodeSeq, stack: List[IPXACT2022scalaxb.ElemName]): Either[String, IPXACT2022ScalaCases.Kind] = seq match {
      case node: scala.xml.Node => Right(IPXACT2022ScalaCases.Kind(IPXACT2022scalaxb.fromXML[IPXACT2022ScalaCases.KindType](node, IPXACT2022scalaxb.ElemName(node) :: stack),
        scala.collection.immutable.ListMap(List(
        (node \ "@custom").headOption map { x => IPXACT2022scalaxb.DataRecord(x, node, IPXACT2022scalaxb.fromXML[String](x, IPXACT2022scalaxb.ElemName(node) :: stack)) } map { "@custom" -> _ }
        ).flatten[(String, IPXACT2022scalaxb.DataRecord[Any])]: _*)))
      case _ => Left("reads failed: seq must be scala.xml.Node")
    }
    
    override def writesAttribute(__obj: IPXACT2022ScalaCases.Kind, __scope: scala.xml.NamespaceBinding): scala.xml.MetaData = {
      var attr: scala.xml.MetaData  = scala.xml.Null
      __obj.attributes.toList map {
        case ("@custom", _) => __obj.custom foreach { x => attr = scala.xml.Attribute(null, "custom", x.toString, attr) }
        case (key, x) => attr = scala.xml.Attribute((x.namespace map { __scope.getPrefix(_) }).orNull, x.key.orNull, x.value.toString, attr)
      }
      attr
    }

    def writesChildNodes(__obj: IPXACT2022ScalaCases.Kind, __scope: scala.xml.NamespaceBinding): Seq[scala.xml.Node] =
      Seq(scala.xml.Text(__obj.value.toString))

  }

  def buildIPXACT2022ScalaCases_SimplePortAccessTypeFormat = new DefaultIPXACT2022ScalaCases_SimplePortAccessTypeFormat {}
  trait DefaultIPXACT2022ScalaCases_SimplePortAccessTypeFormat extends IPXACT2022scalaxb.XMLFormat[IPXACT2022ScalaCases.SimplePortAccessType] {
    val targetNamespace: Option[String] = Some("http://www.accellera.org/XMLSchema/IPXACT/1685-2022")
    
    def fromString(value: String, scope: scala.xml.NamespaceBinding): IPXACT2022ScalaCases.SimplePortAccessType =
        (fromString0(value, scope)).apply(IPXACT2022scalaxb.fromXML[String](scala.xml.Text(value)))

    private def fromString0(value: String, scope: scala.xml.NamespaceBinding): PartialFunction[Any, IPXACT2022ScalaCases.SimplePortAccessType] = {
      case x: String if x == IPXACT2022scalaxb.fromXML[String](scala.xml.Text("ref")) => IPXACT2022ScalaCases.Ref
      case x: String if x == IPXACT2022scalaxb.fromXML[String](scala.xml.Text("ptr")) => IPXACT2022ScalaCases.Ptr

    }



    def reads(seq: scala.xml.NodeSeq, stack: List[IPXACT2022scalaxb.ElemName]): Either[String, IPXACT2022ScalaCases.SimplePortAccessType] = seq match {
      case elem: scala.xml.Elem => Right(fromString(elem.text, elem.scope))
      case _ => Right(fromString(seq.text, scala.xml.TopScope))
    }
    
    def writes(__obj: IPXACT2022ScalaCases.SimplePortAccessType, __namespace: Option[String], __elementLabel: Option[String],
        __scope: scala.xml.NamespaceBinding, __typeAttribute: Boolean): scala.xml.NodeSeq =
      scala.xml.Elem(IPXACT2022scalaxb.Helper.getPrefix(__namespace, __scope).orNull,
        __elementLabel getOrElse { sys.error("missing element label.") },
        scala.xml.Null, __scope, true, scala.xml.Text(__obj.toString))
  }
  def buildIPXACT2022ScalaCases_TypeFormat = new DefaultIPXACT2022ScalaCases_TypeFormat {}
  trait DefaultIPXACT2022ScalaCases_TypeFormat extends IPXACT2022scalaxb.XMLFormat[IPXACT2022ScalaCases.Type] {
    val targetNamespace: Option[String] = Some("http://www.accellera.org/XMLSchema/IPXACT/1685-2022")
    
    def fromString(value: String, scope: scala.xml.NamespaceBinding): IPXACT2022ScalaCases.Type =
        (fromString0(value, scope)).apply(IPXACT2022scalaxb.fromXML[String](scala.xml.Text(value)))

    private def fromString0(value: String, scope: scala.xml.NamespaceBinding): PartialFunction[Any, IPXACT2022ScalaCases.Type] = {
      case x: String if x == IPXACT2022scalaxb.fromXML[String](scala.xml.Text("generic")) => IPXACT2022ScalaCases.Generic
      case x: String if x == IPXACT2022scalaxb.fromXML[String](scala.xml.Text("specific")) => IPXACT2022ScalaCases.Specific

    }



    def reads(seq: scala.xml.NodeSeq, stack: List[IPXACT2022scalaxb.ElemName]): Either[String, IPXACT2022ScalaCases.Type] = seq match {
      case elem: scala.xml.Elem => Right(fromString(elem.text, elem.scope))
      case _ => Right(fromString(seq.text, scala.xml.TopScope))
    }
    
    def writes(__obj: IPXACT2022ScalaCases.Type, __namespace: Option[String], __elementLabel: Option[String],
        __scope: scala.xml.NamespaceBinding, __typeAttribute: Boolean): scala.xml.NodeSeq =
      scala.xml.Elem(IPXACT2022scalaxb.Helper.getPrefix(__namespace, __scope).orNull,
        __elementLabel getOrElse { sys.error("missing element label.") },
        scala.xml.Null, __scope, true, scala.xml.Text(__obj.toString))
  }
  trait DefaultIPXACT2022ScalaCases_ExtensionFormat extends IPXACT2022scalaxb.XMLFormat[IPXACT2022ScalaCases.Extension] with IPXACT2022scalaxb.CanWriteChildNodes[IPXACT2022ScalaCases.Extension] {
    val targetNamespace: Option[String] = Some("http://www.accellera.org/XMLSchema/IPXACT/1685-2022")
    def reads(seq: scala.xml.NodeSeq, stack: List[IPXACT2022scalaxb.ElemName]): Either[String, IPXACT2022ScalaCases.Extension] = seq match {
      case node: scala.xml.Node => Right(IPXACT2022ScalaCases.Extension(IPXACT2022scalaxb.fromXML[String](node, IPXACT2022scalaxb.ElemName(node) :: stack),
        scala.collection.immutable.ListMap(List(
        (node \ "@mandatory").headOption map { x => IPXACT2022scalaxb.DataRecord(x, node, IPXACT2022scalaxb.fromXML[Boolean](x, IPXACT2022scalaxb.ElemName(node) :: stack)) } orElse Some(IPXACT2022scalaxb.DataRecord(None, None, IPXACT2022scalaxb.fromXML[Boolean](scala.xml.Text("false"), IPXACT2022scalaxb.ElemName(node) :: stack))) map { "@mandatory" -> _ }
        ).flatten[(String, IPXACT2022scalaxb.DataRecord[Any])]: _*)))
      case _ => Left("reads failed: seq must be scala.xml.Node")
    }
    
    override def writesAttribute(__obj: IPXACT2022ScalaCases.Extension, __scope: scala.xml.NamespaceBinding): scala.xml.MetaData = {
      var attr: scala.xml.MetaData  = scala.xml.Null
      __obj.attributes.toList map {
        case ("@mandatory", _) => if (__obj.mandatory.toString != "false") attr = scala.xml.Attribute(null, "mandatory", __obj.mandatory.toString, attr)
        case (key, x) => attr = scala.xml.Attribute((x.namespace map { __scope.getPrefix(_) }).orNull, x.key.orNull, x.value.toString, attr)
      }
      attr
    }

    def writesChildNodes(__obj: IPXACT2022ScalaCases.Extension, __scope: scala.xml.NamespaceBinding): Seq[scala.xml.Node] =
      Seq(scala.xml.Text(__obj.value.toString))

  }

  trait DefaultIPXACT2022ScalaCases_PayloadFormat extends IPXACT2022scalaxb.ElemNameParser[IPXACT2022ScalaCases.Payload] {
    val targetNamespace: Option[String] = Some("http://www.accellera.org/XMLSchema/IPXACT/1685-2022")
    
    def parser(node: scala.xml.Node, stack: List[IPXACT2022scalaxb.ElemName]): Parser[IPXACT2022ScalaCases.Payload] =
      phrase(opt(IPXACT2022scalaxb.ElemName(Some("http://www.accellera.org/XMLSchema/IPXACT/1685-2022"), "name")) ~
      (IPXACT2022scalaxb.ElemName(Some("http://www.accellera.org/XMLSchema/IPXACT/1685-2022"), "type")) ~
      opt(IPXACT2022scalaxb.ElemName(Some("http://www.accellera.org/XMLSchema/IPXACT/1685-2022"), "extension")) ~
      opt(IPXACT2022scalaxb.ElemName(Some("http://www.accellera.org/XMLSchema/IPXACT/1685-2022"), "vendorExtensions")) ^^
      { case p1 ~ p2 ~ p3 ~ p4 =>
      IPXACT2022ScalaCases.Payload(p1.headOption map { IPXACT2022scalaxb.fromXML[String](_, IPXACT2022scalaxb.ElemName(node) :: stack) },
        IPXACT2022scalaxb.fromXML[IPXACT2022ScalaCases.Type](p2, IPXACT2022scalaxb.ElemName(node) :: stack),
        p3.headOption map { IPXACT2022scalaxb.fromXML[IPXACT2022ScalaCases.Extension](_, IPXACT2022scalaxb.ElemName(node) :: stack) },
        p4.headOption map { IPXACT2022scalaxb.fromXML[IPXACT2022ScalaCases.VendorExtensions](_, IPXACT2022scalaxb.ElemName(node) :: stack) }) })
    
    def writesChildNodes(__obj: IPXACT2022ScalaCases.Payload, __scope: scala.xml.NamespaceBinding): Seq[scala.xml.Node] =
      Seq.concat(__obj.name map { IPXACT2022scalaxb.toXML[String](_, Some("http://www.accellera.org/XMLSchema/IPXACT/1685-2022"), Some("name"), __scope, false) } getOrElse {Nil},
        IPXACT2022scalaxb.toXML[IPXACT2022ScalaCases.Type](__obj.typeValue, Some("http://www.accellera.org/XMLSchema/IPXACT/1685-2022"), Some("type"), __scope, false),
        __obj.extension map { IPXACT2022scalaxb.toXML[IPXACT2022ScalaCases.Extension](_, Some("http://www.accellera.org/XMLSchema/IPXACT/1685-2022"), Some("extension"), __scope, false) } getOrElse {Nil},
        __obj.vendorExtensions map { IPXACT2022scalaxb.toXML[IPXACT2022ScalaCases.VendorExtensions](_, Some("http://www.accellera.org/XMLSchema/IPXACT/1685-2022"), Some("vendorExtensions"), __scope, false) } getOrElse {Nil})

  }

  trait DefaultIPXACT2022ScalaCases_TypeParametersFormat extends IPXACT2022scalaxb.ElemNameParser[IPXACT2022ScalaCases.TypeParameters] {
    val targetNamespace: Option[String] = Some("http://www.accellera.org/XMLSchema/IPXACT/1685-2022")
    
    def parser(node: scala.xml.Node, stack: List[IPXACT2022scalaxb.ElemName]): Parser[IPXACT2022ScalaCases.TypeParameters] =
      phrase(safeRep(IPXACT2022scalaxb.ElemName(Some("http://www.accellera.org/XMLSchema/IPXACT/1685-2022"), "typeParameter")) ~
      safeRep(IPXACT2022scalaxb.ElemName(Some("http://www.accellera.org/XMLSchema/IPXACT/1685-2022"), "serviceTypeDef")) ^^
      { case p1 ~ p2 =>
      IPXACT2022ScalaCases.TypeParameters(p1 map { IPXACT2022scalaxb.fromXML[IPXACT2022ScalaCases.ModuleParameterType](_, IPXACT2022scalaxb.ElemName(node) :: stack) },
        p2 map { IPXACT2022scalaxb.fromXML[IPXACT2022ScalaCases.ServiceTypeDef](_, IPXACT2022scalaxb.ElemName(node) :: stack) }) })
    
    def writesChildNodes(__obj: IPXACT2022ScalaCases.TypeParameters, __scope: scala.xml.NamespaceBinding): Seq[scala.xml.Node] =
      Seq.concat(__obj.typeParameter flatMap { IPXACT2022scalaxb.toXML[IPXACT2022ScalaCases.ModuleParameterType](_, Some("http://www.accellera.org/XMLSchema/IPXACT/1685-2022"), Some("typeParameter"), __scope, false) },
        __obj.serviceTypeDef flatMap { IPXACT2022scalaxb.toXML[IPXACT2022ScalaCases.ServiceTypeDef](_, Some("http://www.accellera.org/XMLSchema/IPXACT/1685-2022"), Some("serviceTypeDef"), __scope, false) })

  }

  trait DefaultIPXACT2022ScalaCases_TypeNameFormat extends IPXACT2022scalaxb.XMLFormat[IPXACT2022ScalaCases.TypeName] with IPXACT2022scalaxb.CanWriteChildNodes[IPXACT2022ScalaCases.TypeName] {
    val targetNamespace: Option[String] = Some("http://www.accellera.org/XMLSchema/IPXACT/1685-2022")
    def reads(seq: scala.xml.NodeSeq, stack: List[IPXACT2022scalaxb.ElemName]): Either[String, IPXACT2022ScalaCases.TypeName] = seq match {
      case node: scala.xml.Node => Right(IPXACT2022ScalaCases.TypeName(IPXACT2022scalaxb.fromXML[String](node, IPXACT2022scalaxb.ElemName(node) :: stack),
        scala.collection.immutable.ListMap(List(
        (node \ "@exact").headOption map { x => IPXACT2022scalaxb.DataRecord(x, node, IPXACT2022scalaxb.fromXML[Boolean](x, IPXACT2022scalaxb.ElemName(node) :: stack)) } orElse Some(IPXACT2022scalaxb.DataRecord(None, None, IPXACT2022scalaxb.fromXML[Boolean](scala.xml.Text("true"), IPXACT2022scalaxb.ElemName(node) :: stack))) map { "@exact" -> _ }
        ).flatten[(String, IPXACT2022scalaxb.DataRecord[Any])]: _*)))
      case _ => Left("reads failed: seq must be scala.xml.Node")
    }
    
    override def writesAttribute(__obj: IPXACT2022ScalaCases.TypeName, __scope: scala.xml.NamespaceBinding): scala.xml.MetaData = {
      var attr: scala.xml.MetaData  = scala.xml.Null
      __obj.attributes.toList map {
        case ("@exact", _) => if (__obj.exact.toString != "true") attr = scala.xml.Attribute(null, "exact", __obj.exact.toString, attr)
        case (key, x) => attr = scala.xml.Attribute((x.namespace map { __scope.getPrefix(_) }).orNull, x.key.orNull, x.value.toString, attr)
      }
      attr
    }

    def writesChildNodes(__obj: IPXACT2022ScalaCases.TypeName, __scope: scala.xml.NamespaceBinding): Seq[scala.xml.Node] =
      Seq(scala.xml.Text(__obj.value.toString))

  }

  trait DefaultIPXACT2022ScalaCases_TypeDefinitionFormat extends IPXACT2022scalaxb.XMLFormat[IPXACT2022ScalaCases.TypeDefinition] with IPXACT2022scalaxb.CanWriteChildNodes[IPXACT2022ScalaCases.TypeDefinition] {
    val targetNamespace: Option[String] = Some("http://www.accellera.org/XMLSchema/IPXACT/1685-2022")
    def reads(seq: scala.xml.NodeSeq, stack: List[IPXACT2022scalaxb.ElemName]): Either[String, IPXACT2022ScalaCases.TypeDefinition] = seq match {
      case node: scala.xml.Node => Right(IPXACT2022ScalaCases.TypeDefinition(IPXACT2022scalaxb.fromXML[String](node, IPXACT2022scalaxb.ElemName(node) :: stack),
        scala.collection.immutable.ListMap(List(
        (node \ "@{http://www.w3.org/XML/1998/namespace}id").headOption map { x => IPXACT2022scalaxb.DataRecord(x, node, IPXACT2022scalaxb.fromXML[String](x, IPXACT2022scalaxb.ElemName(node) :: stack)) } map { "@{http://www.w3.org/XML/1998/namespace}id" -> _ }
        ).flatten[(String, IPXACT2022scalaxb.DataRecord[Any])]: _*)))
      case _ => Left("reads failed: seq must be scala.xml.Node")
    }
    
    override def writesAttribute(__obj: IPXACT2022ScalaCases.TypeDefinition, __scope: scala.xml.NamespaceBinding): scala.xml.MetaData = {
      var attr: scala.xml.MetaData  = scala.xml.Null
      __obj.attributes.toList map {
        case ("@{http://www.w3.org/XML/1998/namespace}id", _) => __obj.xmlid foreach { x => attr = scala.xml.Attribute(__scope.getPrefix("http://www.w3.org/XML/1998/namespace"), "id", x.toString, attr) }
        case (key, x) => attr = scala.xml.Attribute((x.namespace map { __scope.getPrefix(_) }).orNull, x.key.orNull, x.value.toString, attr)
      }
      attr
    }

    def writesChildNodes(__obj: IPXACT2022ScalaCases.TypeDefinition, __scope: scala.xml.NamespaceBinding): Seq[scala.xml.Node] =
      Seq(scala.xml.Text(__obj.value.toString))

  }

  trait DefaultIPXACT2022ScalaCases_ViewRef6Format extends IPXACT2022scalaxb.XMLFormat[IPXACT2022ScalaCases.ViewRef6] with IPXACT2022scalaxb.CanWriteChildNodes[IPXACT2022ScalaCases.ViewRef6] {
    val targetNamespace: Option[String] = Some("http://www.accellera.org/XMLSchema/IPXACT/1685-2022")
    def reads(seq: scala.xml.NodeSeq, stack: List[IPXACT2022scalaxb.ElemName]): Either[String, IPXACT2022ScalaCases.ViewRef6] = seq match {
      case node: scala.xml.Node => Right(IPXACT2022ScalaCases.ViewRef6(IPXACT2022scalaxb.fromXML[String](node, IPXACT2022scalaxb.ElemName(node) :: stack),
        scala.collection.immutable.ListMap(List(
        (node \ "@{http://www.w3.org/XML/1998/namespace}id").headOption map { x => IPXACT2022scalaxb.DataRecord(x, node, IPXACT2022scalaxb.fromXML[String](x, IPXACT2022scalaxb.ElemName(node) :: stack)) } map { "@{http://www.w3.org/XML/1998/namespace}id" -> _ }
        ).flatten[(String, IPXACT2022scalaxb.DataRecord[Any])]: _*)))
      case _ => Left("reads failed: seq must be scala.xml.Node")
    }
    
    override def writesAttribute(__obj: IPXACT2022ScalaCases.ViewRef6, __scope: scala.xml.NamespaceBinding): scala.xml.MetaData = {
      var attr: scala.xml.MetaData  = scala.xml.Null
      __obj.attributes.toList map {
        case ("@{http://www.w3.org/XML/1998/namespace}id", _) => __obj.xmlid foreach { x => attr = scala.xml.Attribute(__scope.getPrefix("http://www.w3.org/XML/1998/namespace"), "id", x.toString, attr) }
        case (key, x) => attr = scala.xml.Attribute((x.namespace map { __scope.getPrefix(_) }).orNull, x.key.orNull, x.value.toString, attr)
      }
      attr
    }

    def writesChildNodes(__obj: IPXACT2022ScalaCases.ViewRef6, __scope: scala.xml.NamespaceBinding): Seq[scala.xml.Node] =
      Seq(scala.xml.Text(__obj.value.toString))

  }

  trait DefaultIPXACT2022ScalaCases_TransTypeDefFormat extends IPXACT2022scalaxb.ElemNameParser[IPXACT2022ScalaCases.TransTypeDef] {
    val targetNamespace: Option[String] = Some("http://www.accellera.org/XMLSchema/IPXACT/1685-2022")
    
    def parser(node: scala.xml.Node, stack: List[IPXACT2022scalaxb.ElemName]): Parser[IPXACT2022ScalaCases.TransTypeDef] =
      phrase(opt(IPXACT2022scalaxb.ElemName(Some("http://www.accellera.org/XMLSchema/IPXACT/1685-2022"), "typeName")) ~
      safeRep(IPXACT2022scalaxb.ElemName(Some("http://www.accellera.org/XMLSchema/IPXACT/1685-2022"), "typeDefinition")) ~
      opt(IPXACT2022scalaxb.ElemName(Some("http://www.accellera.org/XMLSchema/IPXACT/1685-2022"), "typeParameters")) ~
      safeRep(IPXACT2022scalaxb.ElemName(Some("http://www.accellera.org/XMLSchema/IPXACT/1685-2022"), "viewRef")) ^^
      { case p1 ~ p2 ~ p3 ~ p4 =>
      IPXACT2022ScalaCases.TransTypeDef(p1.headOption map { IPXACT2022scalaxb.fromXML[IPXACT2022ScalaCases.TypeName](_, IPXACT2022scalaxb.ElemName(node) :: stack) },
        p2 map { IPXACT2022scalaxb.fromXML[IPXACT2022ScalaCases.TypeDefinition](_, IPXACT2022scalaxb.ElemName(node) :: stack) },
        p3.headOption map { IPXACT2022scalaxb.fromXML[IPXACT2022ScalaCases.TypeParameters](_, IPXACT2022scalaxb.ElemName(node) :: stack) },
        p4 map { IPXACT2022scalaxb.fromXML[IPXACT2022ScalaCases.ViewRef6](_, IPXACT2022scalaxb.ElemName(node) :: stack) },
        scala.collection.immutable.ListMap(List(
        (node \ "@{http://www.w3.org/XML/1998/namespace}id").headOption map { x => IPXACT2022scalaxb.DataRecord(x, node, IPXACT2022scalaxb.fromXML[String](x, IPXACT2022scalaxb.ElemName(node) :: stack)) } map { "@{http://www.w3.org/XML/1998/namespace}id" -> _ }
        ).flatten[(String, IPXACT2022scalaxb.DataRecord[Any])]: _*)) })
    
    override def writesAttribute(__obj: IPXACT2022ScalaCases.TransTypeDef, __scope: scala.xml.NamespaceBinding): scala.xml.MetaData = {
      var attr: scala.xml.MetaData  = scala.xml.Null
      __obj.attributes.toList map {
        case ("@{http://www.w3.org/XML/1998/namespace}id", _) => __obj.xmlid foreach { x => attr = scala.xml.Attribute(__scope.getPrefix("http://www.w3.org/XML/1998/namespace"), "id", x.toString, attr) }
        case (key, x) => attr = scala.xml.Attribute((x.namespace map { __scope.getPrefix(_) }).orNull, x.key.orNull, x.value.toString, attr)
      }
      attr
    }

    def writesChildNodes(__obj: IPXACT2022ScalaCases.TransTypeDef, __scope: scala.xml.NamespaceBinding): Seq[scala.xml.Node] =
      Seq.concat(__obj.typeName map { IPXACT2022scalaxb.toXML[IPXACT2022ScalaCases.TypeName](_, Some("http://www.accellera.org/XMLSchema/IPXACT/1685-2022"), Some("typeName"), __scope, false) } getOrElse {Nil},
        __obj.typeDefinition flatMap { IPXACT2022scalaxb.toXML[IPXACT2022ScalaCases.TypeDefinition](_, Some("http://www.accellera.org/XMLSchema/IPXACT/1685-2022"), Some("typeDefinition"), __scope, false) },
        __obj.typeParameters map { IPXACT2022scalaxb.toXML[IPXACT2022ScalaCases.TypeParameters](_, Some("http://www.accellera.org/XMLSchema/IPXACT/1685-2022"), Some("typeParameters"), __scope, false) } getOrElse {Nil},
        __obj.viewRef flatMap { IPXACT2022scalaxb.toXML[IPXACT2022ScalaCases.ViewRef6](_, Some("http://www.accellera.org/XMLSchema/IPXACT/1685-2022"), Some("viewRef"), __scope, false) })

  }

  trait DefaultIPXACT2022ScalaCases_TypeName2Format extends IPXACT2022scalaxb.XMLFormat[IPXACT2022ScalaCases.TypeName2] with IPXACT2022scalaxb.CanWriteChildNodes[IPXACT2022ScalaCases.TypeName2] {
    val targetNamespace: Option[String] = Some("http://www.accellera.org/XMLSchema/IPXACT/1685-2022")
    def reads(seq: scala.xml.NodeSeq, stack: List[IPXACT2022scalaxb.ElemName]): Either[String, IPXACT2022ScalaCases.TypeName2] = seq match {
      case node: scala.xml.Node => Right(IPXACT2022ScalaCases.TypeName2(IPXACT2022scalaxb.fromXML[String](node, IPXACT2022scalaxb.ElemName(node) :: stack),
        scala.collection.immutable.ListMap(List(
        (node \ "@implicit").headOption map { x => IPXACT2022scalaxb.DataRecord(x, node, IPXACT2022scalaxb.fromXML[Boolean](x, IPXACT2022scalaxb.ElemName(node) :: stack)) } orElse Some(IPXACT2022scalaxb.DataRecord(None, None, IPXACT2022scalaxb.fromXML[Boolean](scala.xml.Text("false"), IPXACT2022scalaxb.ElemName(node) :: stack))) map { "@implicit" -> _ }
        ).flatten[(String, IPXACT2022scalaxb.DataRecord[Any])]: _*)))
      case _ => Left("reads failed: seq must be scala.xml.Node")
    }
    
    override def writesAttribute(__obj: IPXACT2022ScalaCases.TypeName2, __scope: scala.xml.NamespaceBinding): scala.xml.MetaData = {
      var attr: scala.xml.MetaData  = scala.xml.Null
      __obj.attributes.toList map {
        case ("@implicit", _) => if (__obj.implicitValue.toString != "false") attr = scala.xml.Attribute(null, "implicit", __obj.implicitValue.toString, attr)
        case (key, x) => attr = scala.xml.Attribute((x.namespace map { __scope.getPrefix(_) }).orNull, x.key.orNull, x.value.toString, attr)
      }
      attr
    }

    def writesChildNodes(__obj: IPXACT2022ScalaCases.TypeName2, __scope: scala.xml.NamespaceBinding): Seq[scala.xml.Node] =
      Seq(scala.xml.Text(__obj.value.toString))

  }

  trait DefaultIPXACT2022ScalaCases_TypeDefinition2Format extends IPXACT2022scalaxb.XMLFormat[IPXACT2022ScalaCases.TypeDefinition2] with IPXACT2022scalaxb.CanWriteChildNodes[IPXACT2022ScalaCases.TypeDefinition2] {
    val targetNamespace: Option[String] = Some("http://www.accellera.org/XMLSchema/IPXACT/1685-2022")
    def reads(seq: scala.xml.NodeSeq, stack: List[IPXACT2022scalaxb.ElemName]): Either[String, IPXACT2022ScalaCases.TypeDefinition2] = seq match {
      case node: scala.xml.Node => Right(IPXACT2022ScalaCases.TypeDefinition2(IPXACT2022scalaxb.fromXML[String](node, IPXACT2022scalaxb.ElemName(node) :: stack),
        scala.collection.immutable.ListMap(List(
        (node \ "@{http://www.w3.org/XML/1998/namespace}id").headOption map { x => IPXACT2022scalaxb.DataRecord(x, node, IPXACT2022scalaxb.fromXML[String](x, IPXACT2022scalaxb.ElemName(node) :: stack)) } map { "@{http://www.w3.org/XML/1998/namespace}id" -> _ }
        ).flatten[(String, IPXACT2022scalaxb.DataRecord[Any])]: _*)))
      case _ => Left("reads failed: seq must be scala.xml.Node")
    }
    
    override def writesAttribute(__obj: IPXACT2022ScalaCases.TypeDefinition2, __scope: scala.xml.NamespaceBinding): scala.xml.MetaData = {
      var attr: scala.xml.MetaData  = scala.xml.Null
      __obj.attributes.toList map {
        case ("@{http://www.w3.org/XML/1998/namespace}id", _) => __obj.xmlid foreach { x => attr = scala.xml.Attribute(__scope.getPrefix("http://www.w3.org/XML/1998/namespace"), "id", x.toString, attr) }
        case (key, x) => attr = scala.xml.Attribute((x.namespace map { __scope.getPrefix(_) }).orNull, x.key.orNull, x.value.toString, attr)
      }
      attr
    }

    def writesChildNodes(__obj: IPXACT2022ScalaCases.TypeDefinition2, __scope: scala.xml.NamespaceBinding): Seq[scala.xml.Node] =
      Seq(scala.xml.Text(__obj.value.toString))

  }

  trait DefaultIPXACT2022ScalaCases_ServiceTypeDefFormat extends IPXACT2022scalaxb.ElemNameParser[IPXACT2022ScalaCases.ServiceTypeDef] {
    val targetNamespace: Option[String] = Some("http://www.accellera.org/XMLSchema/IPXACT/1685-2022")
    
    def parser(node: scala.xml.Node, stack: List[IPXACT2022scalaxb.ElemName]): Parser[IPXACT2022ScalaCases.ServiceTypeDef] =
      phrase((IPXACT2022scalaxb.ElemName(Some("http://www.accellera.org/XMLSchema/IPXACT/1685-2022"), "typeName")) ~
      safeRep(IPXACT2022scalaxb.ElemName(Some("http://www.accellera.org/XMLSchema/IPXACT/1685-2022"), "typeDefinition")) ~
      opt(IPXACT2022scalaxb.ElemName(Some("http://www.accellera.org/XMLSchema/IPXACT/1685-2022"), "typeParameters")) ^^
      { case p1 ~ p2 ~ p3 =>
      IPXACT2022ScalaCases.ServiceTypeDef(IPXACT2022scalaxb.fromXML[IPXACT2022ScalaCases.TypeName2](p1, IPXACT2022scalaxb.ElemName(node) :: stack),
        p2 map { IPXACT2022scalaxb.fromXML[IPXACT2022ScalaCases.TypeDefinition2](_, IPXACT2022scalaxb.ElemName(node) :: stack) },
        p3.headOption map { IPXACT2022scalaxb.fromXML[IPXACT2022ScalaCases.TypeParameters](_, IPXACT2022scalaxb.ElemName(node) :: stack) },
        scala.collection.immutable.ListMap(List(
        (node \ "@{http://www.w3.org/XML/1998/namespace}id").headOption map { x => IPXACT2022scalaxb.DataRecord(x, node, IPXACT2022scalaxb.fromXML[String](x, IPXACT2022scalaxb.ElemName(node) :: stack)) } map { "@{http://www.w3.org/XML/1998/namespace}id" -> _ }
        ).flatten[(String, IPXACT2022scalaxb.DataRecord[Any])]: _*)) })
    
    override def writesAttribute(__obj: IPXACT2022ScalaCases.ServiceTypeDef, __scope: scala.xml.NamespaceBinding): scala.xml.MetaData = {
      var attr: scala.xml.MetaData  = scala.xml.Null
      __obj.attributes.toList map {
        case ("@{http://www.w3.org/XML/1998/namespace}id", _) => __obj.xmlid foreach { x => attr = scala.xml.Attribute(__scope.getPrefix("http://www.w3.org/XML/1998/namespace"), "id", x.toString, attr) }
        case (key, x) => attr = scala.xml.Attribute((x.namespace map { __scope.getPrefix(_) }).orNull, x.key.orNull, x.value.toString, attr)
      }
      attr
    }

    def writesChildNodes(__obj: IPXACT2022ScalaCases.ServiceTypeDef, __scope: scala.xml.NamespaceBinding): Seq[scala.xml.Node] =
      Seq.concat(IPXACT2022scalaxb.toXML[IPXACT2022ScalaCases.TypeName2](__obj.typeName, Some("http://www.accellera.org/XMLSchema/IPXACT/1685-2022"), Some("typeName"), __scope, false),
        __obj.typeDefinition flatMap { IPXACT2022scalaxb.toXML[IPXACT2022ScalaCases.TypeDefinition2](_, Some("http://www.accellera.org/XMLSchema/IPXACT/1685-2022"), Some("typeDefinition"), __scope, false) },
        __obj.typeParameters map { IPXACT2022scalaxb.toXML[IPXACT2022ScalaCases.TypeParameters](_, Some("http://www.accellera.org/XMLSchema/IPXACT/1685-2022"), Some("typeParameters"), __scope, false) } getOrElse {Nil})

  }

  trait DefaultIPXACT2022ScalaCases_TypeName3Format extends IPXACT2022scalaxb.XMLFormat[IPXACT2022ScalaCases.TypeName3] with IPXACT2022scalaxb.CanWriteChildNodes[IPXACT2022ScalaCases.TypeName3] {
    val targetNamespace: Option[String] = Some("http://www.accellera.org/XMLSchema/IPXACT/1685-2022")
    def reads(seq: scala.xml.NodeSeq, stack: List[IPXACT2022scalaxb.ElemName]): Either[String, IPXACT2022ScalaCases.TypeName3] = seq match {
      case node: scala.xml.Node => Right(IPXACT2022ScalaCases.TypeName3(IPXACT2022scalaxb.fromXML[String](node, IPXACT2022scalaxb.ElemName(node) :: stack),
        scala.collection.immutable.ListMap(List(
        (node \ "@constrained").headOption map { x => IPXACT2022scalaxb.DataRecord(x, node, IPXACT2022scalaxb.fromXML[Seq[String]](x, IPXACT2022scalaxb.ElemName(node) :: stack)) } map { "@constrained" -> _ }
        ).flatten[(String, IPXACT2022scalaxb.DataRecord[Any])]: _*)))
      case _ => Left("reads failed: seq must be scala.xml.Node")
    }
    
    override def writesAttribute(__obj: IPXACT2022ScalaCases.TypeName3, __scope: scala.xml.NamespaceBinding): scala.xml.MetaData = {
      var attr: scala.xml.MetaData  = scala.xml.Null
      __obj.attributes.toList map {
        case ("@constrained", _) => __obj.constrained foreach { x => attr = scala.xml.Attribute(null, "constrained", x.map(x => x.toString).mkString(" "), attr) }
        case (key, x) => attr = scala.xml.Attribute((x.namespace map { __scope.getPrefix(_) }).orNull, x.key.orNull, x.value.toString, attr)
      }
      attr
    }

    def writesChildNodes(__obj: IPXACT2022ScalaCases.TypeName3, __scope: scala.xml.NamespaceBinding): Seq[scala.xml.Node] =
      Seq(scala.xml.Text(__obj.value.toString))

  }

  trait DefaultIPXACT2022ScalaCases_TypeDefinition3Format extends IPXACT2022scalaxb.XMLFormat[IPXACT2022ScalaCases.TypeDefinition3] with IPXACT2022scalaxb.CanWriteChildNodes[IPXACT2022ScalaCases.TypeDefinition3] {
    val targetNamespace: Option[String] = Some("http://www.accellera.org/XMLSchema/IPXACT/1685-2022")
    def reads(seq: scala.xml.NodeSeq, stack: List[IPXACT2022scalaxb.ElemName]): Either[String, IPXACT2022ScalaCases.TypeDefinition3] = seq match {
      case node: scala.xml.Node => Right(IPXACT2022ScalaCases.TypeDefinition3(IPXACT2022scalaxb.fromXML[String](node, IPXACT2022scalaxb.ElemName(node) :: stack),
        scala.collection.immutable.ListMap(List(
        (node \ "@{http://www.w3.org/XML/1998/namespace}id").headOption map { x => IPXACT2022scalaxb.DataRecord(x, node, IPXACT2022scalaxb.fromXML[String](x, IPXACT2022scalaxb.ElemName(node) :: stack)) } map { "@{http://www.w3.org/XML/1998/namespace}id" -> _ }
        ).flatten[(String, IPXACT2022scalaxb.DataRecord[Any])]: _*)))
      case _ => Left("reads failed: seq must be scala.xml.Node")
    }
    
    override def writesAttribute(__obj: IPXACT2022ScalaCases.TypeDefinition3, __scope: scala.xml.NamespaceBinding): scala.xml.MetaData = {
      var attr: scala.xml.MetaData  = scala.xml.Null
      __obj.attributes.toList map {
        case ("@{http://www.w3.org/XML/1998/namespace}id", _) => __obj.xmlid foreach { x => attr = scala.xml.Attribute(__scope.getPrefix("http://www.w3.org/XML/1998/namespace"), "id", x.toString, attr) }
        case (key, x) => attr = scala.xml.Attribute((x.namespace map { __scope.getPrefix(_) }).orNull, x.key.orNull, x.value.toString, attr)
      }
      attr
    }

    def writesChildNodes(__obj: IPXACT2022ScalaCases.TypeDefinition3, __scope: scala.xml.NamespaceBinding): Seq[scala.xml.Node] =
      Seq(scala.xml.Text(__obj.value.toString))

  }

  trait DefaultIPXACT2022ScalaCases_ViewRef7Format extends IPXACT2022scalaxb.XMLFormat[IPXACT2022ScalaCases.ViewRef7] with IPXACT2022scalaxb.CanWriteChildNodes[IPXACT2022ScalaCases.ViewRef7] {
    val targetNamespace: Option[String] = Some("http://www.accellera.org/XMLSchema/IPXACT/1685-2022")
    def reads(seq: scala.xml.NodeSeq, stack: List[IPXACT2022scalaxb.ElemName]): Either[String, IPXACT2022ScalaCases.ViewRef7] = seq match {
      case node: scala.xml.Node => Right(IPXACT2022ScalaCases.ViewRef7(IPXACT2022scalaxb.fromXML[String](node, IPXACT2022scalaxb.ElemName(node) :: stack),
        scala.collection.immutable.ListMap(List(
        (node \ "@{http://www.w3.org/XML/1998/namespace}id").headOption map { x => IPXACT2022scalaxb.DataRecord(x, node, IPXACT2022scalaxb.fromXML[String](x, IPXACT2022scalaxb.ElemName(node) :: stack)) } map { "@{http://www.w3.org/XML/1998/namespace}id" -> _ }
        ).flatten[(String, IPXACT2022scalaxb.DataRecord[Any])]: _*)))
      case _ => Left("reads failed: seq must be scala.xml.Node")
    }
    
    override def writesAttribute(__obj: IPXACT2022ScalaCases.ViewRef7, __scope: scala.xml.NamespaceBinding): scala.xml.MetaData = {
      var attr: scala.xml.MetaData  = scala.xml.Null
      __obj.attributes.toList map {
        case ("@{http://www.w3.org/XML/1998/namespace}id", _) => __obj.xmlid foreach { x => attr = scala.xml.Attribute(__scope.getPrefix("http://www.w3.org/XML/1998/namespace"), "id", x.toString, attr) }
        case (key, x) => attr = scala.xml.Attribute((x.namespace map { __scope.getPrefix(_) }).orNull, x.key.orNull, x.value.toString, attr)
      }
      attr
    }

    def writesChildNodes(__obj: IPXACT2022ScalaCases.ViewRef7, __scope: scala.xml.NamespaceBinding): Seq[scala.xml.Node] =
      Seq(scala.xml.Text(__obj.value.toString))

  }

  trait DefaultIPXACT2022ScalaCases_WireTypeDefFormat extends IPXACT2022scalaxb.ElemNameParser[IPXACT2022ScalaCases.WireTypeDef] {
    val targetNamespace: Option[String] = Some("http://www.accellera.org/XMLSchema/IPXACT/1685-2022")
    
    def parser(node: scala.xml.Node, stack: List[IPXACT2022scalaxb.ElemName]): Parser[IPXACT2022ScalaCases.WireTypeDef] =
      phrase(opt(IPXACT2022scalaxb.ElemName(Some("http://www.accellera.org/XMLSchema/IPXACT/1685-2022"), "typeName")) ~
      safeRep(IPXACT2022scalaxb.ElemName(Some("http://www.accellera.org/XMLSchema/IPXACT/1685-2022"), "typeDefinition")) ~
      safeRep(IPXACT2022scalaxb.ElemName(Some("http://www.accellera.org/XMLSchema/IPXACT/1685-2022"), "viewRef")) ^^
      { case p1 ~ p2 ~ p3 =>
      IPXACT2022ScalaCases.WireTypeDef(p1.headOption map { IPXACT2022scalaxb.fromXML[IPXACT2022ScalaCases.TypeName3](_, IPXACT2022scalaxb.ElemName(node) :: stack) },
        p2 map { IPXACT2022scalaxb.fromXML[IPXACT2022ScalaCases.TypeDefinition3](_, IPXACT2022scalaxb.ElemName(node) :: stack) },
        p3 map { IPXACT2022scalaxb.fromXML[IPXACT2022ScalaCases.ViewRef7](_, IPXACT2022scalaxb.ElemName(node) :: stack) },
        scala.collection.immutable.ListMap(List(
        (node \ "@{http://www.w3.org/XML/1998/namespace}id").headOption map { x => IPXACT2022scalaxb.DataRecord(x, node, IPXACT2022scalaxb.fromXML[String](x, IPXACT2022scalaxb.ElemName(node) :: stack)) } map { "@{http://www.w3.org/XML/1998/namespace}id" -> _ }
        ).flatten[(String, IPXACT2022scalaxb.DataRecord[Any])]: _*)) })
    
    override def writesAttribute(__obj: IPXACT2022ScalaCases.WireTypeDef, __scope: scala.xml.NamespaceBinding): scala.xml.MetaData = {
      var attr: scala.xml.MetaData  = scala.xml.Null
      __obj.attributes.toList map {
        case ("@{http://www.w3.org/XML/1998/namespace}id", _) => __obj.xmlid foreach { x => attr = scala.xml.Attribute(__scope.getPrefix("http://www.w3.org/XML/1998/namespace"), "id", x.toString, attr) }
        case (key, x) => attr = scala.xml.Attribute((x.namespace map { __scope.getPrefix(_) }).orNull, x.key.orNull, x.value.toString, attr)
      }
      attr
    }

    def writesChildNodes(__obj: IPXACT2022ScalaCases.WireTypeDef, __scope: scala.xml.NamespaceBinding): Seq[scala.xml.Node] =
      Seq.concat(__obj.typeName map { IPXACT2022scalaxb.toXML[IPXACT2022ScalaCases.TypeName3](_, Some("http://www.accellera.org/XMLSchema/IPXACT/1685-2022"), Some("typeName"), __scope, false) } getOrElse {Nil},
        __obj.typeDefinition flatMap { IPXACT2022scalaxb.toXML[IPXACT2022ScalaCases.TypeDefinition3](_, Some("http://www.accellera.org/XMLSchema/IPXACT/1685-2022"), Some("typeDefinition"), __scope, false) },
        __obj.viewRef flatMap { IPXACT2022scalaxb.toXML[IPXACT2022ScalaCases.ViewRef7](_, Some("http://www.accellera.org/XMLSchema/IPXACT/1685-2022"), Some("viewRef"), __scope, false) })

  }

  trait DefaultIPXACT2022ScalaCases_WireTypeDefsFormat extends IPXACT2022scalaxb.ElemNameParser[IPXACT2022ScalaCases.WireTypeDefs] {
    val targetNamespace: Option[String] = Some("http://www.accellera.org/XMLSchema/IPXACT/1685-2022")
    
    def parser(node: scala.xml.Node, stack: List[IPXACT2022scalaxb.ElemName]): Parser[IPXACT2022ScalaCases.WireTypeDefs] =
      phrase(safeRep(IPXACT2022scalaxb.ElemName(Some("http://www.accellera.org/XMLSchema/IPXACT/1685-2022"), "wireTypeDef")) ^^
      { case p1 =>
      IPXACT2022ScalaCases.WireTypeDefs(p1 map { IPXACT2022scalaxb.fromXML[IPXACT2022ScalaCases.WireTypeDef](_, IPXACT2022scalaxb.ElemName(node) :: stack) }) })
    
    def writesChildNodes(__obj: IPXACT2022ScalaCases.WireTypeDefs, __scope: scala.xml.NamespaceBinding): Seq[scala.xml.Node] =
      (__obj.wireTypeDef flatMap { IPXACT2022scalaxb.toXML[IPXACT2022ScalaCases.WireTypeDef](_, Some("http://www.accellera.org/XMLSchema/IPXACT/1685-2022"), Some("wireTypeDef"), __scope, false) })
  }
  trait DefaultIPXACT2022ScalaCases_TransTypeDefsFormat extends IPXACT2022scalaxb.ElemNameParser[IPXACT2022ScalaCases.TransTypeDefs] {
    val targetNamespace: Option[String] = Some("http://www.accellera.org/XMLSchema/IPXACT/1685-2022")
    
    def parser(node: scala.xml.Node, stack: List[IPXACT2022scalaxb.ElemName]): Parser[IPXACT2022ScalaCases.TransTypeDefs] =
      phrase(safeRep(IPXACT2022scalaxb.ElemName(Some("http://www.accellera.org/XMLSchema/IPXACT/1685-2022"), "transTypeDef")) ^^
      { case p1 =>
      IPXACT2022ScalaCases.TransTypeDefs(p1 map { IPXACT2022scalaxb.fromXML[IPXACT2022ScalaCases.TransTypeDef](_, IPXACT2022scalaxb.ElemName(node) :: stack) }) })
    
    def writesChildNodes(__obj: IPXACT2022ScalaCases.TransTypeDefs, __scope: scala.xml.NamespaceBinding): Seq[scala.xml.Node] =
      (__obj.transTypeDef flatMap { IPXACT2022scalaxb.toXML[IPXACT2022ScalaCases.TransTypeDef](_, Some("http://www.accellera.org/XMLSchema/IPXACT/1685-2022"), Some("transTypeDef"), __scope, false) })
  }
  trait DefaultIPXACT2022ScalaCases_Port2Format extends IPXACT2022scalaxb.ElemNameParser[IPXACT2022ScalaCases.Port2] with IPXACT2022ScalaCases_NameGroupPortGroupFormat {
    val targetNamespace: Option[String] = Some("http://www.accellera.org/XMLSchema/IPXACT/1685-2022")
    
    def parser(node: scala.xml.Node, stack: List[IPXACT2022scalaxb.ElemName]): Parser[IPXACT2022ScalaCases.Port2] =
      phrase((parseNameGroupPortGroup(node, IPXACT2022scalaxb.ElemName(node) :: stack)) ~
      (((IPXACT2022scalaxb.ElemName(Some("http://www.accellera.org/XMLSchema/IPXACT/1685-2022"), "wire")) ^^
      (x => IPXACT2022scalaxb.DataRecord(x.namespace, Some(x.name), IPXACT2022scalaxb.fromXML[IPXACT2022ScalaCases.PortWireTypable](x, IPXACT2022scalaxb.ElemName(node) :: stack)))) |
      ((IPXACT2022scalaxb.ElemName(Some("http://www.accellera.org/XMLSchema/IPXACT/1685-2022"), "transactional")) ^^
      (x => IPXACT2022scalaxb.DataRecord(x.namespace, Some(x.name), IPXACT2022scalaxb.fromXML[IPXACT2022ScalaCases.PortTransactionalType](x, IPXACT2022scalaxb.ElemName(node) :: stack)))) |
      ((IPXACT2022scalaxb.ElemName(Some("http://www.accellera.org/XMLSchema/IPXACT/1685-2022"), "structured")) ^^
      (x => IPXACT2022scalaxb.DataRecord(x.namespace, Some(x.name), IPXACT2022scalaxb.fromXML[IPXACT2022ScalaCases.PortStructuredType](x, IPXACT2022scalaxb.ElemName(node) :: stack))))) ~
      opt(IPXACT2022scalaxb.ElemName(Some("http://www.accellera.org/XMLSchema/IPXACT/1685-2022"), "fieldMaps")) ~
      opt(IPXACT2022scalaxb.ElemName(Some("http://www.accellera.org/XMLSchema/IPXACT/1685-2022"), "arrays")) ~
      opt(IPXACT2022scalaxb.ElemName(Some("http://www.accellera.org/XMLSchema/IPXACT/1685-2022"), "access")) ~
      opt(IPXACT2022scalaxb.ElemName(Some("http://www.accellera.org/XMLSchema/IPXACT/1685-2022"), "parameters")) ~
      opt(IPXACT2022scalaxb.ElemName(Some("http://www.accellera.org/XMLSchema/IPXACT/1685-2022"), "vendorExtensions")) ^^
      { case p1 ~ p2 ~ p3 ~ p4 ~ p5 ~ p6 ~ p7 =>
      IPXACT2022ScalaCases.Port2(p1,
        p2,
        p3.headOption map { IPXACT2022scalaxb.fromXML[IPXACT2022ScalaCases.FieldMaps](_, IPXACT2022scalaxb.ElemName(node) :: stack) },
        p4.headOption map { IPXACT2022scalaxb.fromXML[IPXACT2022ScalaCases.Arrays](_, IPXACT2022scalaxb.ElemName(node) :: stack) },
        p5.headOption map { IPXACT2022scalaxb.fromXML[IPXACT2022ScalaCases.PortAccessType](_, IPXACT2022scalaxb.ElemName(node) :: stack) },
        p6.headOption map { IPXACT2022scalaxb.fromXML[IPXACT2022ScalaCases.Parameters](_, IPXACT2022scalaxb.ElemName(node) :: stack) },
        p7.headOption map { IPXACT2022scalaxb.fromXML[IPXACT2022ScalaCases.VendorExtensions](_, IPXACT2022scalaxb.ElemName(node) :: stack) },
        scala.collection.immutable.ListMap(List(
        (node \ "@{http://www.w3.org/XML/1998/namespace}id").headOption map { x => IPXACT2022scalaxb.DataRecord(x, node, IPXACT2022scalaxb.fromXML[String](x, IPXACT2022scalaxb.ElemName(node) :: stack)) } map { "@{http://www.w3.org/XML/1998/namespace}id" -> _ }
        ).flatten[(String, IPXACT2022scalaxb.DataRecord[Any])]: _*)) })
    
    override def writesAttribute(__obj: IPXACT2022ScalaCases.Port2, __scope: scala.xml.NamespaceBinding): scala.xml.MetaData = {
      var attr: scala.xml.MetaData  = scala.xml.Null
      __obj.attributes.toList map {
        case ("@{http://www.w3.org/XML/1998/namespace}id", _) => __obj.xmlid foreach { x => attr = scala.xml.Attribute(__scope.getPrefix("http://www.w3.org/XML/1998/namespace"), "id", x.toString, attr) }
        case (key, x) => attr = scala.xml.Attribute((x.namespace map { __scope.getPrefix(_) }).orNull, x.key.orNull, x.value.toString, attr)
      }
      attr
    }

    def writesChildNodes(__obj: IPXACT2022ScalaCases.Port2, __scope: scala.xml.NamespaceBinding): Seq[scala.xml.Node] =
      Seq.concat(IPXACT2022scalaxb.toXML[IPXACT2022ScalaCases.NameGroupPortSequence](__obj.nameGroupPortSequence1, None, Some("nameGroupPortSequence1"), __scope, false),
        (Some(__obj.porttypableoption) map {x => IPXACT2022scalaxb.toXML[IPXACT2022scalaxb.DataRecord[IPXACT2022ScalaCases.PortTypableOption]](x, x.namespace, x.key, __scope, false)}).get,
        __obj.fieldMaps map { IPXACT2022scalaxb.toXML[IPXACT2022ScalaCases.FieldMaps](_, Some("http://www.accellera.org/XMLSchema/IPXACT/1685-2022"), Some("fieldMaps"), __scope, false) } getOrElse {Nil},
        __obj.arrays map { IPXACT2022scalaxb.toXML[IPXACT2022ScalaCases.Arrays](_, Some("http://www.accellera.org/XMLSchema/IPXACT/1685-2022"), Some("arrays"), __scope, false) } getOrElse {Nil},
        __obj.access map { IPXACT2022scalaxb.toXML[IPXACT2022ScalaCases.PortAccessType](_, Some("http://www.accellera.org/XMLSchema/IPXACT/1685-2022"), Some("access"), __scope, false) } getOrElse {Nil},
        __obj.parameters map { IPXACT2022scalaxb.toXML[IPXACT2022ScalaCases.Parameters](_, Some("http://www.accellera.org/XMLSchema/IPXACT/1685-2022"), Some("parameters"), __scope, false) } getOrElse {Nil},
        __obj.vendorExtensions map { IPXACT2022scalaxb.toXML[IPXACT2022ScalaCases.VendorExtensions](_, Some("http://www.accellera.org/XMLSchema/IPXACT/1685-2022"), Some("vendorExtensions"), __scope, false) } getOrElse {Nil})

  }

  trait DefaultIPXACT2022ScalaCases_FieldSlice2Format extends IPXACT2022scalaxb.ElemNameParser[IPXACT2022ScalaCases.FieldSlice2] with IPXACT2022ScalaCases_FieldSliceReferenceGroupGroupFormat {
    val targetNamespace: Option[String] = Some("http://www.accellera.org/XMLSchema/IPXACT/1685-2022")
    
    def parser(node: scala.xml.Node, stack: List[IPXACT2022scalaxb.ElemName]): Parser[IPXACT2022ScalaCases.FieldSlice2] =
      phrase((parseFieldSliceReferenceGroupGroup(node, IPXACT2022scalaxb.ElemName(node) :: stack)) ^^
      { case p1 =>
      IPXACT2022ScalaCases.FieldSlice2(p1) })
    
    def writesChildNodes(__obj: IPXACT2022ScalaCases.FieldSlice2, __scope: scala.xml.NamespaceBinding): Seq[scala.xml.Node] =
      (IPXACT2022scalaxb.toXML[IPXACT2022ScalaCases.FieldSliceReferenceGroupSequence](__obj.fieldSliceReferenceGroupSequence1, None, Some("fieldSliceReferenceGroupSequence1"), __scope, false))
  }
  trait DefaultIPXACT2022ScalaCases_ModeRef4Format extends IPXACT2022scalaxb.XMLFormat[IPXACT2022ScalaCases.ModeRef4] with IPXACT2022scalaxb.CanWriteChildNodes[IPXACT2022ScalaCases.ModeRef4] {
    val targetNamespace: Option[String] = Some("http://www.accellera.org/XMLSchema/IPXACT/1685-2022")
    def reads(seq: scala.xml.NodeSeq, stack: List[IPXACT2022scalaxb.ElemName]): Either[String, IPXACT2022ScalaCases.ModeRef4] = seq match {
      case node: scala.xml.Node => Right(IPXACT2022ScalaCases.ModeRef4(IPXACT2022scalaxb.fromXML[String](node, IPXACT2022scalaxb.ElemName(node) :: stack),
        scala.collection.immutable.ListMap(List(
        (node \ "@priority").headOption map { x => IPXACT2022scalaxb.DataRecord(x, node, IPXACT2022scalaxb.fromXML[BigInt](x, IPXACT2022scalaxb.ElemName(node) :: stack)) } map { "@priority" -> _ },
        (node \ "@{http://www.w3.org/XML/1998/namespace}id").headOption map { x => IPXACT2022scalaxb.DataRecord(x, node, IPXACT2022scalaxb.fromXML[String](x, IPXACT2022scalaxb.ElemName(node) :: stack)) } map { "@{http://www.w3.org/XML/1998/namespace}id" -> _ }
        ).flatten[(String, IPXACT2022scalaxb.DataRecord[Any])]: _*)))
      case _ => Left("reads failed: seq must be scala.xml.Node")
    }
    
    override def writesAttribute(__obj: IPXACT2022ScalaCases.ModeRef4, __scope: scala.xml.NamespaceBinding): scala.xml.MetaData = {
      var attr: scala.xml.MetaData  = scala.xml.Null
      __obj.attributes.toList map {
        case ("@priority", _) => attr = scala.xml.Attribute(null, "priority", __obj.priority.toString, attr)
        case ("@{http://www.w3.org/XML/1998/namespace}id", _) => __obj.xmlid foreach { x => attr = scala.xml.Attribute(__scope.getPrefix("http://www.w3.org/XML/1998/namespace"), "id", x.toString, attr) }
        case (key, x) => attr = scala.xml.Attribute((x.namespace map { __scope.getPrefix(_) }).orNull, x.key.orNull, x.value.toString, attr)
      }
      attr
    }

    def writesChildNodes(__obj: IPXACT2022ScalaCases.ModeRef4, __scope: scala.xml.NamespaceBinding): Seq[scala.xml.Node] =
      Seq(scala.xml.Text(__obj.value.toString))

  }

  trait DefaultIPXACT2022ScalaCases_FieldMapFormat extends IPXACT2022scalaxb.ElemNameParser[IPXACT2022ScalaCases.FieldMap] {
    val targetNamespace: Option[String] = Some("http://www.accellera.org/XMLSchema/IPXACT/1685-2022")
    
    def parser(node: scala.xml.Node, stack: List[IPXACT2022scalaxb.ElemName]): Parser[IPXACT2022ScalaCases.FieldMap] =
      phrase((IPXACT2022scalaxb.ElemName(Some("http://www.accellera.org/XMLSchema/IPXACT/1685-2022"), "fieldSlice")) ~
      safeRep(IPXACT2022scalaxb.ElemName(Some("http://www.accellera.org/XMLSchema/IPXACT/1685-2022"), "subPortReference")) ~
      opt(IPXACT2022scalaxb.ElemName(Some("http://www.accellera.org/XMLSchema/IPXACT/1685-2022"), "partSelect")) ~
      safeRep(IPXACT2022scalaxb.ElemName(Some("http://www.accellera.org/XMLSchema/IPXACT/1685-2022"), "modeRef")) ^^
      { case p1 ~ p2 ~ p3 ~ p4 =>
      IPXACT2022ScalaCases.FieldMap(IPXACT2022scalaxb.fromXML[IPXACT2022ScalaCases.FieldSlice2](p1, IPXACT2022scalaxb.ElemName(node) :: stack),
        p2 map { IPXACT2022scalaxb.fromXML[IPXACT2022ScalaCases.SubPortReference](_, IPXACT2022scalaxb.ElemName(node) :: stack) },
        p3.headOption map { IPXACT2022scalaxb.fromXML[IPXACT2022ScalaCases.PartSelect](_, IPXACT2022scalaxb.ElemName(node) :: stack) },
        p4 map { IPXACT2022scalaxb.fromXML[IPXACT2022ScalaCases.ModeRef4](_, IPXACT2022scalaxb.ElemName(node) :: stack) },
        scala.collection.immutable.ListMap(List(
        (node \ "@{http://www.w3.org/XML/1998/namespace}id").headOption map { x => IPXACT2022scalaxb.DataRecord(x, node, IPXACT2022scalaxb.fromXML[String](x, IPXACT2022scalaxb.ElemName(node) :: stack)) } map { "@{http://www.w3.org/XML/1998/namespace}id" -> _ }
        ).flatten[(String, IPXACT2022scalaxb.DataRecord[Any])]: _*)) })
    
    override def writesAttribute(__obj: IPXACT2022ScalaCases.FieldMap, __scope: scala.xml.NamespaceBinding): scala.xml.MetaData = {
      var attr: scala.xml.MetaData  = scala.xml.Null
      __obj.attributes.toList map {
        case ("@{http://www.w3.org/XML/1998/namespace}id", _) => __obj.xmlid foreach { x => attr = scala.xml.Attribute(__scope.getPrefix("http://www.w3.org/XML/1998/namespace"), "id", x.toString, attr) }
        case (key, x) => attr = scala.xml.Attribute((x.namespace map { __scope.getPrefix(_) }).orNull, x.key.orNull, x.value.toString, attr)
      }
      attr
    }

    def writesChildNodes(__obj: IPXACT2022ScalaCases.FieldMap, __scope: scala.xml.NamespaceBinding): Seq[scala.xml.Node] =
      Seq.concat(IPXACT2022scalaxb.toXML[IPXACT2022ScalaCases.FieldSlice2](__obj.fieldSlice, Some("http://www.accellera.org/XMLSchema/IPXACT/1685-2022"), Some("fieldSlice"), __scope, false),
        __obj.subPortReference flatMap { IPXACT2022scalaxb.toXML[IPXACT2022ScalaCases.SubPortReference](_, Some("http://www.accellera.org/XMLSchema/IPXACT/1685-2022"), Some("subPortReference"), __scope, false) },
        __obj.partSelect map { IPXACT2022scalaxb.toXML[IPXACT2022ScalaCases.PartSelect](_, Some("http://www.accellera.org/XMLSchema/IPXACT/1685-2022"), Some("partSelect"), __scope, false) } getOrElse {Nil},
        __obj.modeRef flatMap { IPXACT2022scalaxb.toXML[IPXACT2022ScalaCases.ModeRef4](_, Some("http://www.accellera.org/XMLSchema/IPXACT/1685-2022"), Some("modeRef"), __scope, false) })

  }

  trait DefaultIPXACT2022ScalaCases_FieldMapsFormat extends IPXACT2022scalaxb.ElemNameParser[IPXACT2022ScalaCases.FieldMaps] {
    val targetNamespace: Option[String] = Some("http://www.accellera.org/XMLSchema/IPXACT/1685-2022")
    
    def parser(node: scala.xml.Node, stack: List[IPXACT2022scalaxb.ElemName]): Parser[IPXACT2022ScalaCases.FieldMaps] =
      phrase(safeRep(IPXACT2022scalaxb.ElemName(Some("http://www.accellera.org/XMLSchema/IPXACT/1685-2022"), "fieldMap")) ^^
      { case p1 =>
      IPXACT2022ScalaCases.FieldMaps(p1 map { IPXACT2022scalaxb.fromXML[IPXACT2022ScalaCases.FieldMap](_, IPXACT2022scalaxb.ElemName(node) :: stack) }) })
    
    def writesChildNodes(__obj: IPXACT2022ScalaCases.FieldMaps, __scope: scala.xml.NamespaceBinding): Seq[scala.xml.Node] =
      (__obj.fieldMap flatMap { IPXACT2022scalaxb.toXML[IPXACT2022ScalaCases.FieldMap](_, Some("http://www.accellera.org/XMLSchema/IPXACT/1685-2022"), Some("fieldMap"), __scope, false) })
  }
  trait DefaultIPXACT2022ScalaCases_PowerConstraintsFormat extends IPXACT2022scalaxb.ElemNameParser[IPXACT2022ScalaCases.PowerConstraints] {
    val targetNamespace: Option[String] = Some("http://www.accellera.org/XMLSchema/IPXACT/1685-2022")
    
    def parser(node: scala.xml.Node, stack: List[IPXACT2022scalaxb.ElemName]): Parser[IPXACT2022ScalaCases.PowerConstraints] =
      phrase(safeRep(IPXACT2022scalaxb.ElemName(Some("http://www.accellera.org/XMLSchema/IPXACT/1685-2022"), "powerConstraint")) ^^
      { case p1 =>
      IPXACT2022ScalaCases.PowerConstraints(p1 map { IPXACT2022scalaxb.fromXML[IPXACT2022ScalaCases.WirePowerConstraintType](_, IPXACT2022scalaxb.ElemName(node) :: stack) }) })
    
    def writesChildNodes(__obj: IPXACT2022ScalaCases.PowerConstraints, __scope: scala.xml.NamespaceBinding): Seq[scala.xml.Node] =
      (__obj.powerConstraint flatMap { IPXACT2022scalaxb.toXML[IPXACT2022ScalaCases.WirePowerConstraintType](_, Some("http://www.accellera.org/XMLSchema/IPXACT/1685-2022"), Some("powerConstraint"), __scope, false) })
  }
  trait DefaultIPXACT2022ScalaCases_PortWireTypableFormat extends IPXACT2022scalaxb.XMLFormat[IPXACT2022ScalaCases.PortWireTypable] {
    def reads(seq: scala.xml.NodeSeq, stack: List[IPXACT2022scalaxb.ElemName]): Either[String, IPXACT2022ScalaCases.PortWireTypable] = seq match {
      case node: scala.xml.Node =>     
        IPXACT2022scalaxb.Helper.instanceType(node) match {
          case (Some("http://www.accellera.org/XMLSchema/IPXACT/1685-2022"), Some("abstractorPortWireType")) => Right(IPXACT2022scalaxb.fromXML[IPXACT2022ScalaCases.AbstractorPortWireType](node, stack))
          case _ => Right(IPXACT2022scalaxb.fromXML[IPXACT2022ScalaCases.PortWireType](node, stack))
        }
      case _ => Left("reads failed: seq must be scala.xml.Node")  
    }
    
    def writes(__obj: IPXACT2022ScalaCases.PortWireTypable, __namespace: Option[String], __elementLabel: Option[String],
        __scope: scala.xml.NamespaceBinding, __typeAttribute: Boolean): scala.xml.NodeSeq = __obj match {
      case x: IPXACT2022ScalaCases.AbstractorPortWireType => IPXACT2022scalaxb.toXML[IPXACT2022ScalaCases.AbstractorPortWireType](x, __namespace, __elementLabel, __scope, true)
      case x: IPXACT2022ScalaCases.PortWireType => IPXACT2022scalaxb.toXML[IPXACT2022ScalaCases.PortWireType](x, __namespace, __elementLabel, __scope, __typeAttribute)
    }
  }
  trait DefaultIPXACT2022ScalaCases_PortWireTypeFormat extends IPXACT2022scalaxb.ElemNameParser[IPXACT2022ScalaCases.PortWireType] {
    val targetNamespace: Option[String] = Some("http://www.accellera.org/XMLSchema/IPXACT/1685-2022")
    
    override def typeName: Option[String] = Some("portWireType")

    def parser(node: scala.xml.Node, stack: List[IPXACT2022scalaxb.ElemName]): Parser[IPXACT2022ScalaCases.PortWireType] =
      phrase((IPXACT2022scalaxb.ElemName(Some("http://www.accellera.org/XMLSchema/IPXACT/1685-2022"), "direction")) ~
      opt(IPXACT2022scalaxb.ElemName(Some("http://www.accellera.org/XMLSchema/IPXACT/1685-2022"), "qualifier")) ~
      opt(IPXACT2022scalaxb.ElemName(Some("http://www.accellera.org/XMLSchema/IPXACT/1685-2022"), "vectors")) ~
      opt(IPXACT2022scalaxb.ElemName(Some("http://www.accellera.org/XMLSchema/IPXACT/1685-2022"), "wireTypeDefs")) ~
      opt(IPXACT2022scalaxb.ElemName(Some("http://www.accellera.org/XMLSchema/IPXACT/1685-2022"), "domainTypeDefs")) ~
      opt(IPXACT2022scalaxb.ElemName(Some("http://www.accellera.org/XMLSchema/IPXACT/1685-2022"), "signalTypeDefs")) ~
      opt(IPXACT2022scalaxb.ElemName(Some("http://www.accellera.org/XMLSchema/IPXACT/1685-2022"), "drivers")) ~
      opt(IPXACT2022scalaxb.ElemName(Some("http://www.accellera.org/XMLSchema/IPXACT/1685-2022"), "constraintSets")) ~
      opt(IPXACT2022scalaxb.ElemName(Some("http://www.accellera.org/XMLSchema/IPXACT/1685-2022"), "powerConstraints")) ^^
      { case p1 ~ p2 ~ p3 ~ p4 ~ p5 ~ p6 ~ p7 ~ p8 ~ p9 =>
      IPXACT2022ScalaCases.PortWireType(IPXACT2022scalaxb.fromXML[IPXACT2022ScalaCases.ComponentPortDirectionType](p1, IPXACT2022scalaxb.ElemName(node) :: stack),
        p2.headOption map { IPXACT2022scalaxb.fromXML[IPXACT2022ScalaCases.QualifierType](_, IPXACT2022scalaxb.ElemName(node) :: stack) },
        p3.headOption map { IPXACT2022scalaxb.fromXML[IPXACT2022ScalaCases.ExtendedVectorsType](_, IPXACT2022scalaxb.ElemName(node) :: stack) },
        p4.headOption map { IPXACT2022scalaxb.fromXML[IPXACT2022ScalaCases.WireTypeDefs](_, IPXACT2022scalaxb.ElemName(node) :: stack) },
        p5.headOption map { IPXACT2022scalaxb.fromXML[IPXACT2022ScalaCases.DomainTypeDefs](_, IPXACT2022scalaxb.ElemName(node) :: stack) },
        p6.headOption map { IPXACT2022scalaxb.fromXML[IPXACT2022ScalaCases.SignalTypeDefs](_, IPXACT2022scalaxb.ElemName(node) :: stack) },
        p7.headOption map { IPXACT2022scalaxb.fromXML[IPXACT2022ScalaCases.Drivers](_, IPXACT2022scalaxb.ElemName(node) :: stack) },
        p8.headOption map { IPXACT2022scalaxb.fromXML[IPXACT2022ScalaCases.ConstraintSets](_, IPXACT2022scalaxb.ElemName(node) :: stack) },
        p9.headOption map { IPXACT2022scalaxb.fromXML[IPXACT2022ScalaCases.PowerConstraints](_, IPXACT2022scalaxb.ElemName(node) :: stack) },
        scala.collection.immutable.ListMap(List(
        (node \ "@allLogicalDirectionsAllowed").headOption map { x => IPXACT2022scalaxb.DataRecord(x, node, IPXACT2022scalaxb.fromXML[Boolean](x, IPXACT2022scalaxb.ElemName(node) :: stack)) } orElse Some(IPXACT2022scalaxb.DataRecord(None, None, IPXACT2022scalaxb.fromXML[Boolean](scala.xml.Text("false"), IPXACT2022scalaxb.ElemName(node) :: stack))) map { "@allLogicalDirectionsAllowed" -> _ }
        ).flatten[(String, IPXACT2022scalaxb.DataRecord[Any])]: _*)) })
    
    override def writesAttribute(__obj: IPXACT2022ScalaCases.PortWireType, __scope: scala.xml.NamespaceBinding): scala.xml.MetaData = {
      var attr: scala.xml.MetaData  = scala.xml.Null
      __obj.attributes.toList map {
        case ("@allLogicalDirectionsAllowed", _) => if (__obj.allLogicalDirectionsAllowed.toString != "false") attr = scala.xml.Attribute(null, "allLogicalDirectionsAllowed", __obj.allLogicalDirectionsAllowed.toString, attr)
        case (key, x) => attr = scala.xml.Attribute((x.namespace map { __scope.getPrefix(_) }).orNull, x.key.orNull, x.value.toString, attr)
      }
      attr
    }

    def writesChildNodes(__obj: IPXACT2022ScalaCases.PortWireType, __scope: scala.xml.NamespaceBinding): Seq[scala.xml.Node] =
      Seq.concat(IPXACT2022scalaxb.toXML[IPXACT2022ScalaCases.ComponentPortDirectionType](__obj.direction, Some("http://www.accellera.org/XMLSchema/IPXACT/1685-2022"), Some("direction"), __scope, false),
        __obj.qualifier map { IPXACT2022scalaxb.toXML[IPXACT2022ScalaCases.QualifierType](_, Some("http://www.accellera.org/XMLSchema/IPXACT/1685-2022"), Some("qualifier"), __scope, false) } getOrElse {Nil},
        __obj.vectors map { IPXACT2022scalaxb.toXML[IPXACT2022ScalaCases.ExtendedVectorsType](_, Some("http://www.accellera.org/XMLSchema/IPXACT/1685-2022"), Some("vectors"), __scope, false) } getOrElse {Nil},
        __obj.wireTypeDefs map { IPXACT2022scalaxb.toXML[IPXACT2022ScalaCases.WireTypeDefs](_, Some("http://www.accellera.org/XMLSchema/IPXACT/1685-2022"), Some("wireTypeDefs"), __scope, false) } getOrElse {Nil},
        __obj.domainTypeDefs map { IPXACT2022scalaxb.toXML[IPXACT2022ScalaCases.DomainTypeDefs](_, Some("http://www.accellera.org/XMLSchema/IPXACT/1685-2022"), Some("domainTypeDefs"), __scope, false) } getOrElse {Nil},
        __obj.signalTypeDefs map { IPXACT2022scalaxb.toXML[IPXACT2022ScalaCases.SignalTypeDefs](_, Some("http://www.accellera.org/XMLSchema/IPXACT/1685-2022"), Some("signalTypeDefs"), __scope, false) } getOrElse {Nil},
        __obj.drivers map { IPXACT2022scalaxb.toXML[IPXACT2022ScalaCases.Drivers](_, Some("http://www.accellera.org/XMLSchema/IPXACT/1685-2022"), Some("drivers"), __scope, false) } getOrElse {Nil},
        __obj.constraintSets map { IPXACT2022scalaxb.toXML[IPXACT2022ScalaCases.ConstraintSets](_, Some("http://www.accellera.org/XMLSchema/IPXACT/1685-2022"), Some("constraintSets"), __scope, false) } getOrElse {Nil},
        __obj.powerConstraints map { IPXACT2022scalaxb.toXML[IPXACT2022ScalaCases.PowerConstraints](_, Some("http://www.accellera.org/XMLSchema/IPXACT/1685-2022"), Some("powerConstraints"), __scope, false) } getOrElse {Nil})

  }

  trait DefaultIPXACT2022ScalaCases_ConnectionFormat extends IPXACT2022scalaxb.ElemNameParser[IPXACT2022ScalaCases.Connection] {
    val targetNamespace: Option[String] = Some("http://www.accellera.org/XMLSchema/IPXACT/1685-2022")
    
    def parser(node: scala.xml.Node, stack: List[IPXACT2022scalaxb.ElemName]): Parser[IPXACT2022ScalaCases.Connection] =
      phrase(opt(IPXACT2022scalaxb.ElemName(Some("http://www.accellera.org/XMLSchema/IPXACT/1685-2022"), "maxConnections")) ~
      opt(IPXACT2022scalaxb.ElemName(Some("http://www.accellera.org/XMLSchema/IPXACT/1685-2022"), "minConnections")) ^^
      { case p1 ~ p2 =>
      IPXACT2022ScalaCases.Connection(p1.headOption map { IPXACT2022scalaxb.fromXML[IPXACT2022ScalaCases.UnsignedIntExpressionable](_, IPXACT2022scalaxb.ElemName(node) :: stack) },
        p2.headOption map { IPXACT2022scalaxb.fromXML[IPXACT2022ScalaCases.UnsignedIntExpressionable](_, IPXACT2022scalaxb.ElemName(node) :: stack) }) })
    
    def writesChildNodes(__obj: IPXACT2022ScalaCases.Connection, __scope: scala.xml.NamespaceBinding): Seq[scala.xml.Node] =
      Seq.concat(__obj.maxConnections map { IPXACT2022scalaxb.toXML[IPXACT2022ScalaCases.UnsignedIntExpressionable](_, Some("http://www.accellera.org/XMLSchema/IPXACT/1685-2022"), Some("maxConnections"), __scope, false) } getOrElse {Nil},
        __obj.minConnections map { IPXACT2022scalaxb.toXML[IPXACT2022ScalaCases.UnsignedIntExpressionable](_, Some("http://www.accellera.org/XMLSchema/IPXACT/1685-2022"), Some("minConnections"), __scope, false) } getOrElse {Nil})

  }

  trait DefaultIPXACT2022ScalaCases_PowerConstraints2Format extends IPXACT2022scalaxb.ElemNameParser[IPXACT2022ScalaCases.PowerConstraints2] {
    val targetNamespace: Option[String] = Some("http://www.accellera.org/XMLSchema/IPXACT/1685-2022")
    
    def parser(node: scala.xml.Node, stack: List[IPXACT2022scalaxb.ElemName]): Parser[IPXACT2022ScalaCases.PowerConstraints2] =
      phrase(safeRep(IPXACT2022scalaxb.ElemName(Some("http://www.accellera.org/XMLSchema/IPXACT/1685-2022"), "powerConstraint")) ^^
      { case p1 =>
      IPXACT2022ScalaCases.PowerConstraints2(p1 map { IPXACT2022scalaxb.fromXML[IPXACT2022ScalaCases.TransactionalPowerConstraintType](_, IPXACT2022scalaxb.ElemName(node) :: stack) }) })
    
    def writesChildNodes(__obj: IPXACT2022ScalaCases.PowerConstraints2, __scope: scala.xml.NamespaceBinding): Seq[scala.xml.Node] =
      (__obj.powerConstraint flatMap { IPXACT2022scalaxb.toXML[IPXACT2022ScalaCases.TransactionalPowerConstraintType](_, Some("http://www.accellera.org/XMLSchema/IPXACT/1685-2022"), Some("powerConstraint"), __scope, false) })
  }
  trait DefaultIPXACT2022ScalaCases_PortTransactionalTypeFormat extends IPXACT2022scalaxb.ElemNameParser[IPXACT2022ScalaCases.PortTransactionalType] {
    val targetNamespace: Option[String] = Some("http://www.accellera.org/XMLSchema/IPXACT/1685-2022")
    
    override def typeName: Option[String] = Some("portTransactionalType")

    def parser(node: scala.xml.Node, stack: List[IPXACT2022scalaxb.ElemName]): Parser[IPXACT2022ScalaCases.PortTransactionalType] =
      phrase((IPXACT2022scalaxb.ElemName(Some("http://www.accellera.org/XMLSchema/IPXACT/1685-2022"), "initiative")) ~
      opt(IPXACT2022scalaxb.ElemName(Some("http://www.accellera.org/XMLSchema/IPXACT/1685-2022"), "kind")) ~
      opt(IPXACT2022scalaxb.ElemName(Some("http://www.accellera.org/XMLSchema/IPXACT/1685-2022"), "busWidth")) ~
      opt(IPXACT2022scalaxb.ElemName(Some("http://www.accellera.org/XMLSchema/IPXACT/1685-2022"), "qualifier")) ~
      opt(IPXACT2022scalaxb.ElemName(Some("http://www.accellera.org/XMLSchema/IPXACT/1685-2022"), "protocol")) ~
      opt(IPXACT2022scalaxb.ElemName(Some("http://www.accellera.org/XMLSchema/IPXACT/1685-2022"), "transTypeDefs")) ~
      opt(IPXACT2022scalaxb.ElemName(Some("http://www.accellera.org/XMLSchema/IPXACT/1685-2022"), "connection")) ~
      opt(IPXACT2022scalaxb.ElemName(Some("http://www.accellera.org/XMLSchema/IPXACT/1685-2022"), "powerConstraints")) ^^
      { case p1 ~ p2 ~ p3 ~ p4 ~ p5 ~ p6 ~ p7 ~ p8 =>
      IPXACT2022ScalaCases.PortTransactionalType(IPXACT2022scalaxb.fromXML[IPXACT2022ScalaCases.InitiativeType](p1, IPXACT2022scalaxb.ElemName(node) :: stack),
        p2.headOption map { IPXACT2022scalaxb.fromXML[IPXACT2022ScalaCases.Kind](_, IPXACT2022scalaxb.ElemName(node) :: stack) },
        p3.headOption map { IPXACT2022scalaxb.fromXML[IPXACT2022ScalaCases.UnsignedIntExpressionable](_, IPXACT2022scalaxb.ElemName(node) :: stack) },
        p4.headOption map { IPXACT2022scalaxb.fromXML[IPXACT2022ScalaCases.QualifierType](_, IPXACT2022scalaxb.ElemName(node) :: stack) },
        p5.headOption map { IPXACT2022scalaxb.fromXML[IPXACT2022ScalaCases.Protocol](_, IPXACT2022scalaxb.ElemName(node) :: stack) },
        p6.headOption map { IPXACT2022scalaxb.fromXML[IPXACT2022ScalaCases.TransTypeDefs](_, IPXACT2022scalaxb.ElemName(node) :: stack) },
        p7.headOption map { IPXACT2022scalaxb.fromXML[IPXACT2022ScalaCases.Connection](_, IPXACT2022scalaxb.ElemName(node) :: stack) },
        p8.headOption map { IPXACT2022scalaxb.fromXML[IPXACT2022ScalaCases.PowerConstraints2](_, IPXACT2022scalaxb.ElemName(node) :: stack) },
        scala.collection.immutable.ListMap(List(
        (node \ "@allLogicalInitiativesAllowed").headOption map { x => IPXACT2022scalaxb.DataRecord(x, node, IPXACT2022scalaxb.fromXML[Boolean](x, IPXACT2022scalaxb.ElemName(node) :: stack)) } orElse Some(IPXACT2022scalaxb.DataRecord(None, None, IPXACT2022scalaxb.fromXML[Boolean](scala.xml.Text("false"), IPXACT2022scalaxb.ElemName(node) :: stack))) map { "@allLogicalInitiativesAllowed" -> _ }
        ).flatten[(String, IPXACT2022scalaxb.DataRecord[Any])]: _*)) })
    
    override def writesAttribute(__obj: IPXACT2022ScalaCases.PortTransactionalType, __scope: scala.xml.NamespaceBinding): scala.xml.MetaData = {
      var attr: scala.xml.MetaData  = scala.xml.Null
      __obj.attributes.toList map {
        case ("@allLogicalInitiativesAllowed", _) => if (__obj.allLogicalInitiativesAllowed.toString != "false") attr = scala.xml.Attribute(null, "allLogicalInitiativesAllowed", __obj.allLogicalInitiativesAllowed.toString, attr)
        case (key, x) => attr = scala.xml.Attribute((x.namespace map { __scope.getPrefix(_) }).orNull, x.key.orNull, x.value.toString, attr)
      }
      attr
    }

    def writesChildNodes(__obj: IPXACT2022ScalaCases.PortTransactionalType, __scope: scala.xml.NamespaceBinding): Seq[scala.xml.Node] =
      Seq.concat(IPXACT2022scalaxb.toXML[IPXACT2022ScalaCases.InitiativeType](__obj.initiative, Some("http://www.accellera.org/XMLSchema/IPXACT/1685-2022"), Some("initiative"), __scope, false),
        __obj.kind map { IPXACT2022scalaxb.toXML[IPXACT2022ScalaCases.Kind](_, Some("http://www.accellera.org/XMLSchema/IPXACT/1685-2022"), Some("kind"), __scope, false) } getOrElse {Nil},
        __obj.busWidth map { IPXACT2022scalaxb.toXML[IPXACT2022ScalaCases.UnsignedIntExpressionable](_, Some("http://www.accellera.org/XMLSchema/IPXACT/1685-2022"), Some("busWidth"), __scope, false) } getOrElse {Nil},
        __obj.qualifier map { IPXACT2022scalaxb.toXML[IPXACT2022ScalaCases.QualifierType](_, Some("http://www.accellera.org/XMLSchema/IPXACT/1685-2022"), Some("qualifier"), __scope, false) } getOrElse {Nil},
        __obj.protocol map { IPXACT2022scalaxb.toXML[IPXACT2022ScalaCases.Protocol](_, Some("http://www.accellera.org/XMLSchema/IPXACT/1685-2022"), Some("protocol"), __scope, false) } getOrElse {Nil},
        __obj.transTypeDefs map { IPXACT2022scalaxb.toXML[IPXACT2022ScalaCases.TransTypeDefs](_, Some("http://www.accellera.org/XMLSchema/IPXACT/1685-2022"), Some("transTypeDefs"), __scope, false) } getOrElse {Nil},
        __obj.connection map { IPXACT2022scalaxb.toXML[IPXACT2022ScalaCases.Connection](_, Some("http://www.accellera.org/XMLSchema/IPXACT/1685-2022"), Some("connection"), __scope, false) } getOrElse {Nil},
        __obj.powerConstraints map { IPXACT2022scalaxb.toXML[IPXACT2022ScalaCases.PowerConstraints2](_, Some("http://www.accellera.org/XMLSchema/IPXACT/1685-2022"), Some("powerConstraints"), __scope, false) } getOrElse {Nil})

  }

  trait DefaultIPXACT2022ScalaCases_Connection2Format extends IPXACT2022scalaxb.ElemNameParser[IPXACT2022ScalaCases.Connection2] {
    val targetNamespace: Option[String] = Some("http://www.accellera.org/XMLSchema/IPXACT/1685-2022")
    
    def parser(node: scala.xml.Node, stack: List[IPXACT2022scalaxb.ElemName]): Parser[IPXACT2022ScalaCases.Connection2] =
      phrase(opt(IPXACT2022scalaxb.ElemName(Some("http://www.accellera.org/XMLSchema/IPXACT/1685-2022"), "maxConnections")) ~
      opt(IPXACT2022scalaxb.ElemName(Some("http://www.accellera.org/XMLSchema/IPXACT/1685-2022"), "minConnections")) ^^
      { case p1 ~ p2 =>
      IPXACT2022ScalaCases.Connection2(p1.headOption map { IPXACT2022scalaxb.fromXML[IPXACT2022ScalaCases.UnsignedIntExpressionable](_, IPXACT2022scalaxb.ElemName(node) :: stack) },
        p2.headOption map { IPXACT2022scalaxb.fromXML[IPXACT2022ScalaCases.UnsignedIntExpressionable](_, IPXACT2022scalaxb.ElemName(node) :: stack) }) })
    
    def writesChildNodes(__obj: IPXACT2022ScalaCases.Connection2, __scope: scala.xml.NamespaceBinding): Seq[scala.xml.Node] =
      Seq.concat(__obj.maxConnections map { IPXACT2022scalaxb.toXML[IPXACT2022ScalaCases.UnsignedIntExpressionable](_, Some("http://www.accellera.org/XMLSchema/IPXACT/1685-2022"), Some("maxConnections"), __scope, false) } getOrElse {Nil},
        __obj.minConnections map { IPXACT2022scalaxb.toXML[IPXACT2022ScalaCases.UnsignedIntExpressionable](_, Some("http://www.accellera.org/XMLSchema/IPXACT/1685-2022"), Some("minConnections"), __scope, false) } getOrElse {Nil})

  }

  trait DefaultIPXACT2022ScalaCases_AbstractorPortTransactionalTypeFormat extends IPXACT2022scalaxb.ElemNameParser[IPXACT2022ScalaCases.AbstractorPortTransactionalType] {
    val targetNamespace: Option[String] = Some("http://www.accellera.org/XMLSchema/IPXACT/1685-2022")
    
    override def typeName: Option[String] = Some("abstractorPortTransactionalType")

    def parser(node: scala.xml.Node, stack: List[IPXACT2022scalaxb.ElemName]): Parser[IPXACT2022ScalaCases.AbstractorPortTransactionalType] =
      phrase((IPXACT2022scalaxb.ElemName(Some("http://www.accellera.org/XMLSchema/IPXACT/1685-2022"), "initiative")) ~
      opt(IPXACT2022scalaxb.ElemName(Some("http://www.accellera.org/XMLSchema/IPXACT/1685-2022"), "kind")) ~
      opt(IPXACT2022scalaxb.ElemName(Some("http://www.accellera.org/XMLSchema/IPXACT/1685-2022"), "busWidth")) ~
      opt(IPXACT2022scalaxb.ElemName(Some("http://www.accellera.org/XMLSchema/IPXACT/1685-2022"), "qualifier")) ~
      opt(IPXACT2022scalaxb.ElemName(Some("http://www.accellera.org/XMLSchema/IPXACT/1685-2022"), "protocol")) ~
      opt(IPXACT2022scalaxb.ElemName(Some("http://www.accellera.org/XMLSchema/IPXACT/1685-2022"), "transTypeDefs")) ~
      opt(IPXACT2022scalaxb.ElemName(Some("http://www.accellera.org/XMLSchema/IPXACT/1685-2022"), "connection")) ^^
      { case p1 ~ p2 ~ p3 ~ p4 ~ p5 ~ p6 ~ p7 =>
      IPXACT2022ScalaCases.AbstractorPortTransactionalType(IPXACT2022scalaxb.fromXML[IPXACT2022ScalaCases.InitiativeType](p1, IPXACT2022scalaxb.ElemName(node) :: stack),
        p2.headOption map { IPXACT2022scalaxb.fromXML[IPXACT2022ScalaCases.Kind](_, IPXACT2022scalaxb.ElemName(node) :: stack) },
        p3.headOption map { IPXACT2022scalaxb.fromXML[IPXACT2022ScalaCases.UnsignedIntExpressionable](_, IPXACT2022scalaxb.ElemName(node) :: stack) },
        p4.headOption map { IPXACT2022scalaxb.fromXML[IPXACT2022ScalaCases.QualifierType](_, IPXACT2022scalaxb.ElemName(node) :: stack) },
        p5.headOption map { IPXACT2022scalaxb.fromXML[IPXACT2022ScalaCases.Protocol](_, IPXACT2022scalaxb.ElemName(node) :: stack) },
        p6.headOption map { IPXACT2022scalaxb.fromXML[IPXACT2022ScalaCases.TransTypeDefs](_, IPXACT2022scalaxb.ElemName(node) :: stack) },
        p7.headOption map { IPXACT2022scalaxb.fromXML[IPXACT2022ScalaCases.Connection2](_, IPXACT2022scalaxb.ElemName(node) :: stack) },
        scala.collection.immutable.ListMap(List(
        (node \ "@allLogicalInitiativesAllowed").headOption map { x => IPXACT2022scalaxb.DataRecord(x, node, IPXACT2022scalaxb.fromXML[Boolean](x, IPXACT2022scalaxb.ElemName(node) :: stack)) } orElse Some(IPXACT2022scalaxb.DataRecord(None, None, IPXACT2022scalaxb.fromXML[Boolean](scala.xml.Text("false"), IPXACT2022scalaxb.ElemName(node) :: stack))) map { "@allLogicalInitiativesAllowed" -> _ }
        ).flatten[(String, IPXACT2022scalaxb.DataRecord[Any])]: _*)) })
    
    override def writesAttribute(__obj: IPXACT2022ScalaCases.AbstractorPortTransactionalType, __scope: scala.xml.NamespaceBinding): scala.xml.MetaData = {
      var attr: scala.xml.MetaData  = scala.xml.Null
      __obj.attributes.toList map {
        case ("@allLogicalInitiativesAllowed", _) => if (__obj.allLogicalInitiativesAllowed.toString != "false") attr = scala.xml.Attribute(null, "allLogicalInitiativesAllowed", __obj.allLogicalInitiativesAllowed.toString, attr)
        case (key, x) => attr = scala.xml.Attribute((x.namespace map { __scope.getPrefix(_) }).orNull, x.key.orNull, x.value.toString, attr)
      }
      attr
    }

    def writesChildNodes(__obj: IPXACT2022ScalaCases.AbstractorPortTransactionalType, __scope: scala.xml.NamespaceBinding): Seq[scala.xml.Node] =
      Seq.concat(IPXACT2022scalaxb.toXML[IPXACT2022ScalaCases.InitiativeType](__obj.initiative, Some("http://www.accellera.org/XMLSchema/IPXACT/1685-2022"), Some("initiative"), __scope, false),
        __obj.kind map { IPXACT2022scalaxb.toXML[IPXACT2022ScalaCases.Kind](_, Some("http://www.accellera.org/XMLSchema/IPXACT/1685-2022"), Some("kind"), __scope, false) } getOrElse {Nil},
        __obj.busWidth map { IPXACT2022scalaxb.toXML[IPXACT2022ScalaCases.UnsignedIntExpressionable](_, Some("http://www.accellera.org/XMLSchema/IPXACT/1685-2022"), Some("busWidth"), __scope, false) } getOrElse {Nil},
        __obj.qualifier map { IPXACT2022scalaxb.toXML[IPXACT2022ScalaCases.QualifierType](_, Some("http://www.accellera.org/XMLSchema/IPXACT/1685-2022"), Some("qualifier"), __scope, false) } getOrElse {Nil},
        __obj.protocol map { IPXACT2022scalaxb.toXML[IPXACT2022ScalaCases.Protocol](_, Some("http://www.accellera.org/XMLSchema/IPXACT/1685-2022"), Some("protocol"), __scope, false) } getOrElse {Nil},
        __obj.transTypeDefs map { IPXACT2022scalaxb.toXML[IPXACT2022ScalaCases.TransTypeDefs](_, Some("http://www.accellera.org/XMLSchema/IPXACT/1685-2022"), Some("transTypeDefs"), __scope, false) } getOrElse {Nil},
        __obj.connection map { IPXACT2022scalaxb.toXML[IPXACT2022ScalaCases.Connection2](_, Some("http://www.accellera.org/XMLSchema/IPXACT/1685-2022"), Some("connection"), __scope, false) } getOrElse {Nil})

  }

  trait DefaultIPXACT2022ScalaCases_AbstractorPortWireTypeFormat extends IPXACT2022scalaxb.ElemNameParser[IPXACT2022ScalaCases.AbstractorPortWireType] {
    val targetNamespace: Option[String] = Some("http://www.accellera.org/XMLSchema/IPXACT/1685-2022")
    
    override def typeName: Option[String] = Some("abstractorPortWireType")

    def parser(node: scala.xml.Node, stack: List[IPXACT2022scalaxb.ElemName]): Parser[IPXACT2022ScalaCases.AbstractorPortWireType] =
      phrase((IPXACT2022scalaxb.ElemName(Some("http://www.accellera.org/XMLSchema/IPXACT/1685-2022"), "direction")) ~
      opt(IPXACT2022scalaxb.ElemName(Some("http://www.accellera.org/XMLSchema/IPXACT/1685-2022"), "qualifier")) ~
      opt(IPXACT2022scalaxb.ElemName(Some("http://www.accellera.org/XMLSchema/IPXACT/1685-2022"), "vectors")) ~
      opt(IPXACT2022scalaxb.ElemName(Some("http://www.accellera.org/XMLSchema/IPXACT/1685-2022"), "wireTypeDefs")) ~
      opt(IPXACT2022scalaxb.ElemName(Some("http://www.accellera.org/XMLSchema/IPXACT/1685-2022"), "domainTypeDefs")) ~
      opt(IPXACT2022scalaxb.ElemName(Some("http://www.accellera.org/XMLSchema/IPXACT/1685-2022"), "signalTypeDefs")) ~
      opt(IPXACT2022scalaxb.ElemName(Some("http://www.accellera.org/XMLSchema/IPXACT/1685-2022"), "drivers")) ~
      opt(IPXACT2022scalaxb.ElemName(Some("http://www.accellera.org/XMLSchema/IPXACT/1685-2022"), "constraintSets")) ~
      opt(IPXACT2022scalaxb.ElemName(Some("http://www.accellera.org/XMLSchema/IPXACT/1685-2022"), "powerConstraints")) ^^
      { case p1 ~ p2 ~ p3 ~ p4 ~ p5 ~ p6 ~ p7 ~ p8 ~ p9 =>
      IPXACT2022ScalaCases.AbstractorPortWireType(IPXACT2022scalaxb.fromXML[IPXACT2022ScalaCases.ComponentPortDirectionType](p1, IPXACT2022scalaxb.ElemName(node) :: stack),
        p2.headOption map { IPXACT2022scalaxb.fromXML[IPXACT2022ScalaCases.QualifierType](_, IPXACT2022scalaxb.ElemName(node) :: stack) },
        p3.headOption map { IPXACT2022scalaxb.fromXML[IPXACT2022ScalaCases.ExtendedVectorsType](_, IPXACT2022scalaxb.ElemName(node) :: stack) },
        p4.headOption map { IPXACT2022scalaxb.fromXML[IPXACT2022ScalaCases.WireTypeDefs](_, IPXACT2022scalaxb.ElemName(node) :: stack) },
        p5.headOption map { IPXACT2022scalaxb.fromXML[IPXACT2022ScalaCases.DomainTypeDefs](_, IPXACT2022scalaxb.ElemName(node) :: stack) },
        p6.headOption map { IPXACT2022scalaxb.fromXML[IPXACT2022ScalaCases.SignalTypeDefs](_, IPXACT2022scalaxb.ElemName(node) :: stack) },
        p7.headOption map { IPXACT2022scalaxb.fromXML[IPXACT2022ScalaCases.Drivers](_, IPXACT2022scalaxb.ElemName(node) :: stack) },
        p8.headOption map { IPXACT2022scalaxb.fromXML[IPXACT2022ScalaCases.ConstraintSets](_, IPXACT2022scalaxb.ElemName(node) :: stack) },
        p9.headOption map { IPXACT2022scalaxb.fromXML[IPXACT2022ScalaCases.PowerConstraints](_, IPXACT2022scalaxb.ElemName(node) :: stack) },
        scala.collection.immutable.ListMap(List(
        (node \ "@allLogicalDirectionsAllowed").headOption map { x => IPXACT2022scalaxb.DataRecord(x, node, IPXACT2022scalaxb.fromXML[Boolean](x, IPXACT2022scalaxb.ElemName(node) :: stack)) } orElse Some(IPXACT2022scalaxb.DataRecord(None, None, IPXACT2022scalaxb.fromXML[Boolean](scala.xml.Text("false"), IPXACT2022scalaxb.ElemName(node) :: stack))) map { "@allLogicalDirectionsAllowed" -> _ }
        ).flatten[(String, IPXACT2022scalaxb.DataRecord[Any])]: _*)) })
    
    override def writesAttribute(__obj: IPXACT2022ScalaCases.AbstractorPortWireType, __scope: scala.xml.NamespaceBinding): scala.xml.MetaData = {
      var attr: scala.xml.MetaData  = scala.xml.Null
      __obj.attributes.toList map {
        case ("@allLogicalDirectionsAllowed", _) => if (__obj.allLogicalDirectionsAllowed.toString != "false") attr = scala.xml.Attribute(null, "allLogicalDirectionsAllowed", __obj.allLogicalDirectionsAllowed.toString, attr)
        case (key, x) => attr = scala.xml.Attribute((x.namespace map { __scope.getPrefix(_) }).orNull, x.key.orNull, x.value.toString, attr)
      }
      attr
    }

    def writesChildNodes(__obj: IPXACT2022ScalaCases.AbstractorPortWireType, __scope: scala.xml.NamespaceBinding): Seq[scala.xml.Node] =
      Seq.concat(IPXACT2022scalaxb.toXML[IPXACT2022ScalaCases.ComponentPortDirectionType](__obj.direction, Some("http://www.accellera.org/XMLSchema/IPXACT/1685-2022"), Some("direction"), __scope, false),
        __obj.qualifier map { IPXACT2022scalaxb.toXML[IPXACT2022ScalaCases.QualifierType](_, Some("http://www.accellera.org/XMLSchema/IPXACT/1685-2022"), Some("qualifier"), __scope, false) } getOrElse {Nil},
        __obj.vectors map { IPXACT2022scalaxb.toXML[IPXACT2022ScalaCases.ExtendedVectorsType](_, Some("http://www.accellera.org/XMLSchema/IPXACT/1685-2022"), Some("vectors"), __scope, false) } getOrElse {Nil},
        __obj.wireTypeDefs map { IPXACT2022scalaxb.toXML[IPXACT2022ScalaCases.WireTypeDefs](_, Some("http://www.accellera.org/XMLSchema/IPXACT/1685-2022"), Some("wireTypeDefs"), __scope, false) } getOrElse {Nil},
        __obj.domainTypeDefs map { IPXACT2022scalaxb.toXML[IPXACT2022ScalaCases.DomainTypeDefs](_, Some("http://www.accellera.org/XMLSchema/IPXACT/1685-2022"), Some("domainTypeDefs"), __scope, false) } getOrElse {Nil},
        __obj.signalTypeDefs map { IPXACT2022scalaxb.toXML[IPXACT2022ScalaCases.SignalTypeDefs](_, Some("http://www.accellera.org/XMLSchema/IPXACT/1685-2022"), Some("signalTypeDefs"), __scope, false) } getOrElse {Nil},
        __obj.drivers map { IPXACT2022scalaxb.toXML[IPXACT2022ScalaCases.Drivers](_, Some("http://www.accellera.org/XMLSchema/IPXACT/1685-2022"), Some("drivers"), __scope, false) } getOrElse {Nil},
        __obj.constraintSets map { IPXACT2022scalaxb.toXML[IPXACT2022ScalaCases.ConstraintSets](_, Some("http://www.accellera.org/XMLSchema/IPXACT/1685-2022"), Some("constraintSets"), __scope, false) } getOrElse {Nil},
        __obj.powerConstraints map { IPXACT2022scalaxb.toXML[IPXACT2022ScalaCases.PowerConstraints](_, Some("http://www.accellera.org/XMLSchema/IPXACT/1685-2022"), Some("powerConstraints"), __scope, false) } getOrElse {Nil})

  }

  trait DefaultIPXACT2022ScalaCases_Vector4Format extends IPXACT2022scalaxb.ElemNameParser[IPXACT2022ScalaCases.Vector4] {
    val targetNamespace: Option[String] = Some("http://www.accellera.org/XMLSchema/IPXACT/1685-2022")
    
    def parser(node: scala.xml.Node, stack: List[IPXACT2022scalaxb.ElemName]): Parser[IPXACT2022ScalaCases.Vector4] =
      phrase((IPXACT2022scalaxb.ElemName(Some("http://www.accellera.org/XMLSchema/IPXACT/1685-2022"), "left")) ~
      (IPXACT2022scalaxb.ElemName(Some("http://www.accellera.org/XMLSchema/IPXACT/1685-2022"), "right")) ^^
      { case p1 ~ p2 =>
      IPXACT2022ScalaCases.Vector4(IPXACT2022scalaxb.fromXML[IPXACT2022ScalaCases.UnsignedIntExpressionable](p1, IPXACT2022scalaxb.ElemName(node) :: stack),
        IPXACT2022scalaxb.fromXML[IPXACT2022ScalaCases.UnsignedIntExpressionable](p2, IPXACT2022scalaxb.ElemName(node) :: stack),
        scala.collection.immutable.ListMap(List(
        (node \ "@vectorId").headOption map { x => IPXACT2022scalaxb.DataRecord(x, node, IPXACT2022scalaxb.fromXML[String](x, IPXACT2022scalaxb.ElemName(node) :: stack)) } map { "@vectorId" -> _ },
        (node \ "@{http://www.w3.org/XML/1998/namespace}id").headOption map { x => IPXACT2022scalaxb.DataRecord(x, node, IPXACT2022scalaxb.fromXML[String](x, IPXACT2022scalaxb.ElemName(node) :: stack)) } map { "@{http://www.w3.org/XML/1998/namespace}id" -> _ }
        ).flatten[(String, IPXACT2022scalaxb.DataRecord[Any])]: _*)) })
    
    override def writesAttribute(__obj: IPXACT2022ScalaCases.Vector4, __scope: scala.xml.NamespaceBinding): scala.xml.MetaData = {
      var attr: scala.xml.MetaData  = scala.xml.Null
      __obj.attributes.toList map {
        case ("@vectorId", _) => __obj.vectorId foreach { x => attr = scala.xml.Attribute(null, "vectorId", x.toString, attr) }
        case ("@{http://www.w3.org/XML/1998/namespace}id", _) => __obj.xmlid foreach { x => attr = scala.xml.Attribute(__scope.getPrefix("http://www.w3.org/XML/1998/namespace"), "id", x.toString, attr) }
        case (key, x) => attr = scala.xml.Attribute((x.namespace map { __scope.getPrefix(_) }).orNull, x.key.orNull, x.value.toString, attr)
      }
      attr
    }

    def writesChildNodes(__obj: IPXACT2022ScalaCases.Vector4, __scope: scala.xml.NamespaceBinding): Seq[scala.xml.Node] =
      Seq.concat(IPXACT2022scalaxb.toXML[IPXACT2022ScalaCases.UnsignedIntExpressionable](__obj.left, Some("http://www.accellera.org/XMLSchema/IPXACT/1685-2022"), Some("left"), __scope, false),
        IPXACT2022scalaxb.toXML[IPXACT2022ScalaCases.UnsignedIntExpressionable](__obj.right, Some("http://www.accellera.org/XMLSchema/IPXACT/1685-2022"), Some("right"), __scope, false))

  }

  trait DefaultIPXACT2022ScalaCases_ExtendedVectorsTypeFormat extends IPXACT2022scalaxb.ElemNameParser[IPXACT2022ScalaCases.ExtendedVectorsType] {
    val targetNamespace: Option[String] = Some("http://www.accellera.org/XMLSchema/IPXACT/1685-2022")
    
    override def typeName: Option[String] = Some("extendedVectorsType")

    def parser(node: scala.xml.Node, stack: List[IPXACT2022scalaxb.ElemName]): Parser[IPXACT2022ScalaCases.ExtendedVectorsType] =
      phrase(safeRep(IPXACT2022scalaxb.ElemName(Some("http://www.accellera.org/XMLSchema/IPXACT/1685-2022"), "vector")) ^^
      { case p1 =>
      IPXACT2022ScalaCases.ExtendedVectorsType(p1 map { IPXACT2022scalaxb.fromXML[IPXACT2022ScalaCases.Vector4](_, IPXACT2022scalaxb.ElemName(node) :: stack) }) })
    
    def writesChildNodes(__obj: IPXACT2022ScalaCases.ExtendedVectorsType, __scope: scala.xml.NamespaceBinding): Seq[scala.xml.Node] =
      (__obj.vector flatMap { IPXACT2022scalaxb.toXML[IPXACT2022ScalaCases.Vector4](_, Some("http://www.accellera.org/XMLSchema/IPXACT/1685-2022"), Some("vector"), __scope, false) })
  }

  trait DefaultIPXACT2022ScalaCases_AccessHandles13Format extends IPXACT2022scalaxb.ElemNameParser[IPXACT2022ScalaCases.AccessHandles13] {
    val targetNamespace: Option[String] = Some("http://www.accellera.org/XMLSchema/IPXACT/1685-2022")
    
    def parser(node: scala.xml.Node, stack: List[IPXACT2022scalaxb.ElemName]): Parser[IPXACT2022ScalaCases.AccessHandles13] =
      phrase(safeRep(((IPXACT2022scalaxb.ElemName(Some("http://www.accellera.org/XMLSchema/IPXACT/1685-2022"), "accessHandle"))) ^^
        { case p1 => IPXACT2022ScalaCases.AccessHandles13Sequence1(IPXACT2022scalaxb.fromXML[IPXACT2022ScalaCases.PortAccessHandle](p1, IPXACT2022scalaxb.ElemName(node) :: stack)) }) ^^
      { case p1 =>
      IPXACT2022ScalaCases.AccessHandles13(p1) })
    
    def writesChildNodes(__obj: IPXACT2022ScalaCases.AccessHandles13, __scope: scala.xml.NamespaceBinding): Seq[scala.xml.Node] =
      (__obj.accesshandles13sequence1 flatMap { IPXACT2022scalaxb.toXML[IPXACT2022ScalaCases.AccessHandles13Sequence1](_, None, Some("accesshandles13sequence1"), __scope, false) })
  }

  trait DefaultIPXACT2022ScalaCases_AccessHandles13Sequence1Format extends IPXACT2022scalaxb.XMLFormat[IPXACT2022ScalaCases.AccessHandles13Sequence1] {
    def reads(seq: scala.xml.NodeSeq, stack: List[IPXACT2022scalaxb.ElemName]): Either[String, IPXACT2022ScalaCases.AccessHandles13Sequence1] = Left("don't call me.")
    
    def writes(__obj: IPXACT2022ScalaCases.AccessHandles13Sequence1, __namespace: Option[String], __elementLabel: Option[String],
        __scope: scala.xml.NamespaceBinding, __typeAttribute: Boolean): scala.xml.NodeSeq =
      IPXACT2022scalaxb.toXML[IPXACT2022ScalaCases.PortAccessHandle](__obj.accessHandle, Some("http://www.accellera.org/XMLSchema/IPXACT/1685-2022"), Some("accessHandle"), __scope, false)

  }
  trait DefaultIPXACT2022ScalaCases_PortAccessTypeFormat extends IPXACT2022scalaxb.ElemNameParser[IPXACT2022ScalaCases.PortAccessType] {
    val targetNamespace: Option[String] = Some("http://www.accellera.org/XMLSchema/IPXACT/1685-2022")
    
    override def typeName: Option[String] = Some("portAccessType")

    def parser(node: scala.xml.Node, stack: List[IPXACT2022scalaxb.ElemName]): Parser[IPXACT2022ScalaCases.PortAccessType] =
      phrase(opt(IPXACT2022scalaxb.ElemName(Some("http://www.accellera.org/XMLSchema/IPXACT/1685-2022"), "portAccessType")) ~
      opt(IPXACT2022scalaxb.ElemName(Some("http://www.accellera.org/XMLSchema/IPXACT/1685-2022"), "accessHandles")) ^^
      { case p1 ~ p2 =>
      IPXACT2022ScalaCases.PortAccessType(p1.headOption map { IPXACT2022scalaxb.fromXML[IPXACT2022ScalaCases.SimplePortAccessType](_, IPXACT2022scalaxb.ElemName(node) :: stack) },
        p2.headOption map { IPXACT2022scalaxb.fromXML[IPXACT2022ScalaCases.AccessHandles13](_, IPXACT2022scalaxb.ElemName(node) :: stack) }) })
    
    def writesChildNodes(__obj: IPXACT2022ScalaCases.PortAccessType, __scope: scala.xml.NamespaceBinding): Seq[scala.xml.Node] =
      Seq.concat(__obj.portAccessType map { IPXACT2022scalaxb.toXML[IPXACT2022ScalaCases.SimplePortAccessType](_, Some("http://www.accellera.org/XMLSchema/IPXACT/1685-2022"), Some("portAccessType"), __scope, false) } getOrElse {Nil},
        __obj.accessHandles map { IPXACT2022scalaxb.toXML[IPXACT2022ScalaCases.AccessHandles13](_, Some("http://www.accellera.org/XMLSchema/IPXACT/1685-2022"), Some("accessHandles"), __scope, false) } getOrElse {Nil})

  }

  def buildIPXACT2022ScalaCases_SignalTypeFormat = new DefaultIPXACT2022ScalaCases_SignalTypeFormat {}
  trait DefaultIPXACT2022ScalaCases_SignalTypeFormat extends IPXACT2022scalaxb.XMLFormat[IPXACT2022ScalaCases.SignalType] {
    val targetNamespace: Option[String] = Some("http://www.accellera.org/XMLSchema/IPXACT/1685-2022")
    
    def fromString(value: String, scope: scala.xml.NamespaceBinding): IPXACT2022ScalaCases.SignalType =
        (fromString0(value, scope)).apply(IPXACT2022scalaxb.fromXML[String](scala.xml.Text(value)))

    private def fromString0(value: String, scope: scala.xml.NamespaceBinding): PartialFunction[Any, IPXACT2022ScalaCases.SignalType] = {
      case x: String if x == IPXACT2022scalaxb.fromXML[String](scala.xml.Text("continuous-conservative")) => IPXACT2022ScalaCases.Continuousu45conservative
      case x: String if x == IPXACT2022scalaxb.fromXML[String](scala.xml.Text("continuous-non-conservative")) => IPXACT2022ScalaCases.Continuousu45nonu45conservative
      case x: String if x == IPXACT2022scalaxb.fromXML[String](scala.xml.Text("discrete")) => IPXACT2022ScalaCases.Discrete
      case x: String if x == IPXACT2022scalaxb.fromXML[String](scala.xml.Text("digital")) => IPXACT2022ScalaCases.Digital

    }



    def reads(seq: scala.xml.NodeSeq, stack: List[IPXACT2022scalaxb.ElemName]): Either[String, IPXACT2022ScalaCases.SignalType] = seq match {
      case elem: scala.xml.Elem => Right(fromString(elem.text, elem.scope))
      case _ => Right(fromString(seq.text, scala.xml.TopScope))
    }
    
    def writes(__obj: IPXACT2022ScalaCases.SignalType, __namespace: Option[String], __elementLabel: Option[String],
        __scope: scala.xml.NamespaceBinding, __typeAttribute: Boolean): scala.xml.NodeSeq =
      scala.xml.Elem(IPXACT2022scalaxb.Helper.getPrefix(__namespace, __scope).orNull,
        __elementLabel getOrElse { sys.error("missing element label.") },
        scala.xml.Null, __scope, true, scala.xml.Text(__obj.toString))
  }
  trait DefaultIPXACT2022ScalaCases_ViewRef8Format extends IPXACT2022scalaxb.XMLFormat[IPXACT2022ScalaCases.ViewRef8] with IPXACT2022scalaxb.CanWriteChildNodes[IPXACT2022ScalaCases.ViewRef8] {
    val targetNamespace: Option[String] = Some("http://www.accellera.org/XMLSchema/IPXACT/1685-2022")
    def reads(seq: scala.xml.NodeSeq, stack: List[IPXACT2022scalaxb.ElemName]): Either[String, IPXACT2022ScalaCases.ViewRef8] = seq match {
      case node: scala.xml.Node => Right(IPXACT2022ScalaCases.ViewRef8(IPXACT2022scalaxb.fromXML[String](node, IPXACT2022scalaxb.ElemName(node) :: stack),
        scala.collection.immutable.ListMap(List(
        (node \ "@{http://www.w3.org/XML/1998/namespace}id").headOption map { x => IPXACT2022scalaxb.DataRecord(x, node, IPXACT2022scalaxb.fromXML[String](x, IPXACT2022scalaxb.ElemName(node) :: stack)) } map { "@{http://www.w3.org/XML/1998/namespace}id" -> _ }
        ).flatten[(String, IPXACT2022scalaxb.DataRecord[Any])]: _*)))
      case _ => Left("reads failed: seq must be scala.xml.Node")
    }
    
    override def writesAttribute(__obj: IPXACT2022ScalaCases.ViewRef8, __scope: scala.xml.NamespaceBinding): scala.xml.MetaData = {
      var attr: scala.xml.MetaData  = scala.xml.Null
      __obj.attributes.toList map {
        case ("@{http://www.w3.org/XML/1998/namespace}id", _) => __obj.xmlid foreach { x => attr = scala.xml.Attribute(__scope.getPrefix("http://www.w3.org/XML/1998/namespace"), "id", x.toString, attr) }
        case (key, x) => attr = scala.xml.Attribute((x.namespace map { __scope.getPrefix(_) }).orNull, x.key.orNull, x.value.toString, attr)
      }
      attr
    }

    def writesChildNodes(__obj: IPXACT2022ScalaCases.ViewRef8, __scope: scala.xml.NamespaceBinding): Seq[scala.xml.Node] =
      Seq(scala.xml.Text(__obj.value.toString))

  }

  trait DefaultIPXACT2022ScalaCases_SignalTypeDefFormat extends IPXACT2022scalaxb.ElemNameParser[IPXACT2022ScalaCases.SignalTypeDef] {
    val targetNamespace: Option[String] = Some("http://www.accellera.org/XMLSchema/IPXACT/1685-2022")
    
    def parser(node: scala.xml.Node, stack: List[IPXACT2022scalaxb.ElemName]): Parser[IPXACT2022ScalaCases.SignalTypeDef] =
      phrase((IPXACT2022scalaxb.ElemName(Some("http://www.accellera.org/XMLSchema/IPXACT/1685-2022"), "signalType")) ~
      safeRep(IPXACT2022scalaxb.ElemName(Some("http://www.accellera.org/XMLSchema/IPXACT/1685-2022"), "viewRef")) ^^
      { case p1 ~ p2 =>
      IPXACT2022ScalaCases.SignalTypeDef(IPXACT2022scalaxb.fromXML[IPXACT2022ScalaCases.SignalType](p1, IPXACT2022scalaxb.ElemName(node) :: stack),
        p2 map { IPXACT2022scalaxb.fromXML[IPXACT2022ScalaCases.ViewRef8](_, IPXACT2022scalaxb.ElemName(node) :: stack) },
        scala.collection.immutable.ListMap(List(
        (node \ "@{http://www.w3.org/XML/1998/namespace}id").headOption map { x => IPXACT2022scalaxb.DataRecord(x, node, IPXACT2022scalaxb.fromXML[String](x, IPXACT2022scalaxb.ElemName(node) :: stack)) } map { "@{http://www.w3.org/XML/1998/namespace}id" -> _ }
        ).flatten[(String, IPXACT2022scalaxb.DataRecord[Any])]: _*)) })
    
    override def writesAttribute(__obj: IPXACT2022ScalaCases.SignalTypeDef, __scope: scala.xml.NamespaceBinding): scala.xml.MetaData = {
      var attr: scala.xml.MetaData  = scala.xml.Null
      __obj.attributes.toList map {
        case ("@{http://www.w3.org/XML/1998/namespace}id", _) => __obj.xmlid foreach { x => attr = scala.xml.Attribute(__scope.getPrefix("http://www.w3.org/XML/1998/namespace"), "id", x.toString, attr) }
        case (key, x) => attr = scala.xml.Attribute((x.namespace map { __scope.getPrefix(_) }).orNull, x.key.orNull, x.value.toString, attr)
      }
      attr
    }

    def writesChildNodes(__obj: IPXACT2022ScalaCases.SignalTypeDef, __scope: scala.xml.NamespaceBinding): Seq[scala.xml.Node] =
      Seq.concat(IPXACT2022scalaxb.toXML[IPXACT2022ScalaCases.SignalType](__obj.signalType, Some("http://www.accellera.org/XMLSchema/IPXACT/1685-2022"), Some("signalType"), __scope, false),
        __obj.viewRef flatMap { IPXACT2022scalaxb.toXML[IPXACT2022ScalaCases.ViewRef8](_, Some("http://www.accellera.org/XMLSchema/IPXACT/1685-2022"), Some("viewRef"), __scope, false) })

  }

  trait DefaultIPXACT2022ScalaCases_TypeName4Format extends IPXACT2022scalaxb.XMLFormat[IPXACT2022ScalaCases.TypeName4] with IPXACT2022scalaxb.CanWriteChildNodes[IPXACT2022ScalaCases.TypeName4] {
    val targetNamespace: Option[String] = Some("http://www.accellera.org/XMLSchema/IPXACT/1685-2022")
    def reads(seq: scala.xml.NodeSeq, stack: List[IPXACT2022scalaxb.ElemName]): Either[String, IPXACT2022ScalaCases.TypeName4] = seq match {
      case node: scala.xml.Node => Right(IPXACT2022ScalaCases.TypeName4(IPXACT2022scalaxb.fromXML[String](node, IPXACT2022scalaxb.ElemName(node) :: stack),
        scala.collection.immutable.ListMap(List(
        (node \ "@{http://www.w3.org/XML/1998/namespace}id").headOption map { x => IPXACT2022scalaxb.DataRecord(x, node, IPXACT2022scalaxb.fromXML[String](x, IPXACT2022scalaxb.ElemName(node) :: stack)) } map { "@{http://www.w3.org/XML/1998/namespace}id" -> _ }
        ).flatten[(String, IPXACT2022scalaxb.DataRecord[Any])]: _*)))
      case _ => Left("reads failed: seq must be scala.xml.Node")
    }
    
    override def writesAttribute(__obj: IPXACT2022ScalaCases.TypeName4, __scope: scala.xml.NamespaceBinding): scala.xml.MetaData = {
      var attr: scala.xml.MetaData  = scala.xml.Null
      __obj.attributes.toList map {
        case ("@{http://www.w3.org/XML/1998/namespace}id", _) => __obj.xmlid foreach { x => attr = scala.xml.Attribute(__scope.getPrefix("http://www.w3.org/XML/1998/namespace"), "id", x.toString, attr) }
        case (key, x) => attr = scala.xml.Attribute((x.namespace map { __scope.getPrefix(_) }).orNull, x.key.orNull, x.value.toString, attr)
      }
      attr
    }

    def writesChildNodes(__obj: IPXACT2022ScalaCases.TypeName4, __scope: scala.xml.NamespaceBinding): Seq[scala.xml.Node] =
      Seq(scala.xml.Text(__obj.value.toString))

  }

  trait DefaultIPXACT2022ScalaCases_TypeDefinition4Format extends IPXACT2022scalaxb.XMLFormat[IPXACT2022ScalaCases.TypeDefinition4] with IPXACT2022scalaxb.CanWriteChildNodes[IPXACT2022ScalaCases.TypeDefinition4] {
    val targetNamespace: Option[String] = Some("http://www.accellera.org/XMLSchema/IPXACT/1685-2022")
    def reads(seq: scala.xml.NodeSeq, stack: List[IPXACT2022scalaxb.ElemName]): Either[String, IPXACT2022ScalaCases.TypeDefinition4] = seq match {
      case node: scala.xml.Node => Right(IPXACT2022ScalaCases.TypeDefinition4(IPXACT2022scalaxb.fromXML[String](node, IPXACT2022scalaxb.ElemName(node) :: stack),
        scala.collection.immutable.ListMap(List(
        (node \ "@{http://www.w3.org/XML/1998/namespace}id").headOption map { x => IPXACT2022scalaxb.DataRecord(x, node, IPXACT2022scalaxb.fromXML[String](x, IPXACT2022scalaxb.ElemName(node) :: stack)) } map { "@{http://www.w3.org/XML/1998/namespace}id" -> _ }
        ).flatten[(String, IPXACT2022scalaxb.DataRecord[Any])]: _*)))
      case _ => Left("reads failed: seq must be scala.xml.Node")
    }
    
    override def writesAttribute(__obj: IPXACT2022ScalaCases.TypeDefinition4, __scope: scala.xml.NamespaceBinding): scala.xml.MetaData = {
      var attr: scala.xml.MetaData  = scala.xml.Null
      __obj.attributes.toList map {
        case ("@{http://www.w3.org/XML/1998/namespace}id", _) => __obj.xmlid foreach { x => attr = scala.xml.Attribute(__scope.getPrefix("http://www.w3.org/XML/1998/namespace"), "id", x.toString, attr) }
        case (key, x) => attr = scala.xml.Attribute((x.namespace map { __scope.getPrefix(_) }).orNull, x.key.orNull, x.value.toString, attr)
      }
      attr
    }

    def writesChildNodes(__obj: IPXACT2022ScalaCases.TypeDefinition4, __scope: scala.xml.NamespaceBinding): Seq[scala.xml.Node] =
      Seq(scala.xml.Text(__obj.value.toString))

  }

  trait DefaultIPXACT2022ScalaCases_ViewRef9Format extends IPXACT2022scalaxb.XMLFormat[IPXACT2022ScalaCases.ViewRef9] with IPXACT2022scalaxb.CanWriteChildNodes[IPXACT2022ScalaCases.ViewRef9] {
    val targetNamespace: Option[String] = Some("http://www.accellera.org/XMLSchema/IPXACT/1685-2022")
    def reads(seq: scala.xml.NodeSeq, stack: List[IPXACT2022scalaxb.ElemName]): Either[String, IPXACT2022ScalaCases.ViewRef9] = seq match {
      case node: scala.xml.Node => Right(IPXACT2022ScalaCases.ViewRef9(IPXACT2022scalaxb.fromXML[String](node, IPXACT2022scalaxb.ElemName(node) :: stack),
        scala.collection.immutable.ListMap(List(
        (node \ "@{http://www.w3.org/XML/1998/namespace}id").headOption map { x => IPXACT2022scalaxb.DataRecord(x, node, IPXACT2022scalaxb.fromXML[String](x, IPXACT2022scalaxb.ElemName(node) :: stack)) } map { "@{http://www.w3.org/XML/1998/namespace}id" -> _ }
        ).flatten[(String, IPXACT2022scalaxb.DataRecord[Any])]: _*)))
      case _ => Left("reads failed: seq must be scala.xml.Node")
    }
    
    override def writesAttribute(__obj: IPXACT2022ScalaCases.ViewRef9, __scope: scala.xml.NamespaceBinding): scala.xml.MetaData = {
      var attr: scala.xml.MetaData  = scala.xml.Null
      __obj.attributes.toList map {
        case ("@{http://www.w3.org/XML/1998/namespace}id", _) => __obj.xmlid foreach { x => attr = scala.xml.Attribute(__scope.getPrefix("http://www.w3.org/XML/1998/namespace"), "id", x.toString, attr) }
        case (key, x) => attr = scala.xml.Attribute((x.namespace map { __scope.getPrefix(_) }).orNull, x.key.orNull, x.value.toString, attr)
      }
      attr
    }

    def writesChildNodes(__obj: IPXACT2022ScalaCases.ViewRef9, __scope: scala.xml.NamespaceBinding): Seq[scala.xml.Node] =
      Seq(scala.xml.Text(__obj.value.toString))

  }

  trait DefaultIPXACT2022ScalaCases_DomainTypeDefFormat extends IPXACT2022scalaxb.ElemNameParser[IPXACT2022ScalaCases.DomainTypeDef] {
    val targetNamespace: Option[String] = Some("http://www.accellera.org/XMLSchema/IPXACT/1685-2022")
    
    def parser(node: scala.xml.Node, stack: List[IPXACT2022scalaxb.ElemName]): Parser[IPXACT2022ScalaCases.DomainTypeDef] =
      phrase(opt(IPXACT2022scalaxb.ElemName(Some("http://www.accellera.org/XMLSchema/IPXACT/1685-2022"), "typeName")) ~
      safeRep(IPXACT2022scalaxb.ElemName(Some("http://www.accellera.org/XMLSchema/IPXACT/1685-2022"), "typeDefinition")) ~
      safeRep(IPXACT2022scalaxb.ElemName(Some("http://www.accellera.org/XMLSchema/IPXACT/1685-2022"), "viewRef")) ^^
      { case p1 ~ p2 ~ p3 =>
      IPXACT2022ScalaCases.DomainTypeDef(p1.headOption map { IPXACT2022scalaxb.fromXML[IPXACT2022ScalaCases.TypeName4](_, IPXACT2022scalaxb.ElemName(node) :: stack) },
        p2 map { IPXACT2022scalaxb.fromXML[IPXACT2022ScalaCases.TypeDefinition4](_, IPXACT2022scalaxb.ElemName(node) :: stack) },
        p3 map { IPXACT2022scalaxb.fromXML[IPXACT2022ScalaCases.ViewRef9](_, IPXACT2022scalaxb.ElemName(node) :: stack) },
        scala.collection.immutable.ListMap(List(
        (node \ "@{http://www.w3.org/XML/1998/namespace}id").headOption map { x => IPXACT2022scalaxb.DataRecord(x, node, IPXACT2022scalaxb.fromXML[String](x, IPXACT2022scalaxb.ElemName(node) :: stack)) } map { "@{http://www.w3.org/XML/1998/namespace}id" -> _ }
        ).flatten[(String, IPXACT2022scalaxb.DataRecord[Any])]: _*)) })
    
    override def writesAttribute(__obj: IPXACT2022ScalaCases.DomainTypeDef, __scope: scala.xml.NamespaceBinding): scala.xml.MetaData = {
      var attr: scala.xml.MetaData  = scala.xml.Null
      __obj.attributes.toList map {
        case ("@{http://www.w3.org/XML/1998/namespace}id", _) => __obj.xmlid foreach { x => attr = scala.xml.Attribute(__scope.getPrefix("http://www.w3.org/XML/1998/namespace"), "id", x.toString, attr) }
        case (key, x) => attr = scala.xml.Attribute((x.namespace map { __scope.getPrefix(_) }).orNull, x.key.orNull, x.value.toString, attr)
      }
      attr
    }

    def writesChildNodes(__obj: IPXACT2022ScalaCases.DomainTypeDef, __scope: scala.xml.NamespaceBinding): Seq[scala.xml.Node] =
      Seq.concat(__obj.typeName map { IPXACT2022scalaxb.toXML[IPXACT2022ScalaCases.TypeName4](_, Some("http://www.accellera.org/XMLSchema/IPXACT/1685-2022"), Some("typeName"), __scope, false) } getOrElse {Nil},
        __obj.typeDefinition flatMap { IPXACT2022scalaxb.toXML[IPXACT2022ScalaCases.TypeDefinition4](_, Some("http://www.accellera.org/XMLSchema/IPXACT/1685-2022"), Some("typeDefinition"), __scope, false) },
        __obj.viewRef flatMap { IPXACT2022scalaxb.toXML[IPXACT2022ScalaCases.ViewRef9](_, Some("http://www.accellera.org/XMLSchema/IPXACT/1685-2022"), Some("viewRef"), __scope, false) })

  }

  trait DefaultIPXACT2022ScalaCases_DomainTypeDefsFormat extends IPXACT2022scalaxb.ElemNameParser[IPXACT2022ScalaCases.DomainTypeDefs] {
    val targetNamespace: Option[String] = Some("http://www.accellera.org/XMLSchema/IPXACT/1685-2022")
    
    def parser(node: scala.xml.Node, stack: List[IPXACT2022scalaxb.ElemName]): Parser[IPXACT2022ScalaCases.DomainTypeDefs] =
      phrase(safeRep(IPXACT2022scalaxb.ElemName(Some("http://www.accellera.org/XMLSchema/IPXACT/1685-2022"), "domainTypeDef")) ^^
      { case p1 =>
      IPXACT2022ScalaCases.DomainTypeDefs(p1 map { IPXACT2022scalaxb.fromXML[IPXACT2022ScalaCases.DomainTypeDef](_, IPXACT2022scalaxb.ElemName(node) :: stack) }) })
    
    def writesChildNodes(__obj: IPXACT2022ScalaCases.DomainTypeDefs, __scope: scala.xml.NamespaceBinding): Seq[scala.xml.Node] =
      (__obj.domainTypeDef flatMap { IPXACT2022scalaxb.toXML[IPXACT2022ScalaCases.DomainTypeDef](_, Some("http://www.accellera.org/XMLSchema/IPXACT/1685-2022"), Some("domainTypeDef"), __scope, false) })
  }
  trait DefaultIPXACT2022ScalaCases_SignalTypeDefsFormat extends IPXACT2022scalaxb.ElemNameParser[IPXACT2022ScalaCases.SignalTypeDefs] {
    val targetNamespace: Option[String] = Some("http://www.accellera.org/XMLSchema/IPXACT/1685-2022")
    
    def parser(node: scala.xml.Node, stack: List[IPXACT2022scalaxb.ElemName]): Parser[IPXACT2022ScalaCases.SignalTypeDefs] =
      phrase(safeRep(IPXACT2022scalaxb.ElemName(Some("http://www.accellera.org/XMLSchema/IPXACT/1685-2022"), "signalTypeDef")) ^^
      { case p1 =>
      IPXACT2022ScalaCases.SignalTypeDefs(p1 map { IPXACT2022scalaxb.fromXML[IPXACT2022ScalaCases.SignalTypeDef](_, IPXACT2022scalaxb.ElemName(node) :: stack) }) })
    
    def writesChildNodes(__obj: IPXACT2022ScalaCases.SignalTypeDefs, __scope: scala.xml.NamespaceBinding): Seq[scala.xml.Node] =
      (__obj.signalTypeDef flatMap { IPXACT2022scalaxb.toXML[IPXACT2022ScalaCases.SignalTypeDef](_, Some("http://www.accellera.org/XMLSchema/IPXACT/1685-2022"), Some("signalTypeDef"), __scope, false) })
  }
  trait DefaultIPXACT2022ScalaCases_PortPacketsTypeFormat extends IPXACT2022scalaxb.ElemNameParser[IPXACT2022ScalaCases.PortPacketsType] {
    val targetNamespace: Option[String] = Some("http://www.accellera.org/XMLSchema/IPXACT/1685-2022")
    
    override def typeName: Option[String] = Some("portPacketsType")

    def parser(node: scala.xml.Node, stack: List[IPXACT2022scalaxb.ElemName]): Parser[IPXACT2022ScalaCases.PortPacketsType] =
      phrase(safeRep(IPXACT2022scalaxb.ElemName(Some("http://www.accellera.org/XMLSchema/IPXACT/1685-2022"), "packet")) ^^
      { case p1 =>
      IPXACT2022ScalaCases.PortPacketsType(p1 map { IPXACT2022scalaxb.fromXML[IPXACT2022ScalaCases.PortPacketType](_, IPXACT2022scalaxb.ElemName(node) :: stack) }) })
    
    def writesChildNodes(__obj: IPXACT2022ScalaCases.PortPacketsType, __scope: scala.xml.NamespaceBinding): Seq[scala.xml.Node] =
      (__obj.packet flatMap { IPXACT2022scalaxb.toXML[IPXACT2022ScalaCases.PortPacketType](_, Some("http://www.accellera.org/XMLSchema/IPXACT/1685-2022"), Some("packet"), __scope, false) })
  }

  trait DefaultIPXACT2022ScalaCases_PortPacketTypeFormat extends IPXACT2022scalaxb.ElemNameParser[IPXACT2022ScalaCases.PortPacketType] with IPXACT2022ScalaCases_NameGroupGroupFormat {
    val targetNamespace: Option[String] = Some("http://www.accellera.org/XMLSchema/IPXACT/1685-2022")
    
    override def typeName: Option[String] = Some("portPacketType")

    def parser(node: scala.xml.Node, stack: List[IPXACT2022scalaxb.ElemName]): Parser[IPXACT2022ScalaCases.PortPacketType] =
      phrase((parseNameGroupGroup(node, IPXACT2022scalaxb.ElemName(node) :: stack)) ~
      opt(IPXACT2022scalaxb.ElemName(Some("http://www.accellera.org/XMLSchema/IPXACT/1685-2022"), "endianness")) ~
      (IPXACT2022scalaxb.ElemName(Some("http://www.accellera.org/XMLSchema/IPXACT/1685-2022"), "packetFields")) ~
      opt(IPXACT2022scalaxb.ElemName(Some("http://www.accellera.org/XMLSchema/IPXACT/1685-2022"), "vendorExtensions")) ^^
      { case p1 ~ p2 ~ p3 ~ p4 =>
      IPXACT2022ScalaCases.PortPacketType(p1,
        p2.headOption map { IPXACT2022scalaxb.fromXML[IPXACT2022ScalaCases.EndianessType](_, IPXACT2022scalaxb.ElemName(node) :: stack) },
        IPXACT2022scalaxb.fromXML[IPXACT2022ScalaCases.PortPacketFieldsType](p3, IPXACT2022scalaxb.ElemName(node) :: stack),
        p4.headOption map { IPXACT2022scalaxb.fromXML[IPXACT2022ScalaCases.VendorExtensions](_, IPXACT2022scalaxb.ElemName(node) :: stack) },
        scala.collection.immutable.ListMap(List(
        (node \ "@{http://www.w3.org/XML/1998/namespace}id").headOption map { x => IPXACT2022scalaxb.DataRecord(x, node, IPXACT2022scalaxb.fromXML[String](x, IPXACT2022scalaxb.ElemName(node) :: stack)) } map { "@{http://www.w3.org/XML/1998/namespace}id" -> _ }
        ).flatten[(String, IPXACT2022scalaxb.DataRecord[Any])]: _*)) })
    
    override def writesAttribute(__obj: IPXACT2022ScalaCases.PortPacketType, __scope: scala.xml.NamespaceBinding): scala.xml.MetaData = {
      var attr: scala.xml.MetaData  = scala.xml.Null
      __obj.attributes.toList map {
        case ("@{http://www.w3.org/XML/1998/namespace}id", _) => __obj.xmlid foreach { x => attr = scala.xml.Attribute(__scope.getPrefix("http://www.w3.org/XML/1998/namespace"), "id", x.toString, attr) }
        case (key, x) => attr = scala.xml.Attribute((x.namespace map { __scope.getPrefix(_) }).orNull, x.key.orNull, x.value.toString, attr)
      }
      attr
    }

    def writesChildNodes(__obj: IPXACT2022ScalaCases.PortPacketType, __scope: scala.xml.NamespaceBinding): Seq[scala.xml.Node] =
      Seq.concat(IPXACT2022scalaxb.toXML[IPXACT2022ScalaCases.NameGroupSequence](__obj.nameGroupSequence1, None, Some("nameGroupSequence1"), __scope, false),
        __obj.endianness map { IPXACT2022scalaxb.toXML[IPXACT2022ScalaCases.EndianessType](_, Some("http://www.accellera.org/XMLSchema/IPXACT/1685-2022"), Some("endianness"), __scope, false) } getOrElse {Nil},
        IPXACT2022scalaxb.toXML[IPXACT2022ScalaCases.PortPacketFieldsType](__obj.packetFields, Some("http://www.accellera.org/XMLSchema/IPXACT/1685-2022"), Some("packetFields"), __scope, false),
        __obj.vendorExtensions map { IPXACT2022scalaxb.toXML[IPXACT2022ScalaCases.VendorExtensions](_, Some("http://www.accellera.org/XMLSchema/IPXACT/1685-2022"), Some("vendorExtensions"), __scope, false) } getOrElse {Nil})

  }

  trait DefaultIPXACT2022ScalaCases_PortPacketFieldsTypeFormat extends IPXACT2022scalaxb.ElemNameParser[IPXACT2022ScalaCases.PortPacketFieldsType] {
    val targetNamespace: Option[String] = Some("http://www.accellera.org/XMLSchema/IPXACT/1685-2022")
    
    override def typeName: Option[String] = Some("portPacketFieldsType")

    def parser(node: scala.xml.Node, stack: List[IPXACT2022scalaxb.ElemName]): Parser[IPXACT2022ScalaCases.PortPacketFieldsType] =
      phrase(safeRep(IPXACT2022scalaxb.ElemName(Some("http://www.accellera.org/XMLSchema/IPXACT/1685-2022"), "packetField")) ^^
      { case p1 =>
      IPXACT2022ScalaCases.PortPacketFieldsType(p1 map { IPXACT2022scalaxb.fromXML[IPXACT2022ScalaCases.PortPacketFieldType](_, IPXACT2022scalaxb.ElemName(node) :: stack) }) })
    
    def writesChildNodes(__obj: IPXACT2022ScalaCases.PortPacketFieldsType, __scope: scala.xml.NamespaceBinding): Seq[scala.xml.Node] =
      (__obj.packetField flatMap { IPXACT2022scalaxb.toXML[IPXACT2022ScalaCases.PortPacketFieldType](_, Some("http://www.accellera.org/XMLSchema/IPXACT/1685-2022"), Some("packetField"), __scope, false) })
  }

  trait DefaultIPXACT2022ScalaCases_PortPacketFieldTypeFormat extends IPXACT2022scalaxb.ElemNameParser[IPXACT2022ScalaCases.PortPacketFieldType] with IPXACT2022ScalaCases_NameGroupGroupFormat {
    val targetNamespace: Option[String] = Some("http://www.accellera.org/XMLSchema/IPXACT/1685-2022")
    
    override def typeName: Option[String] = Some("portPacketFieldType")

    def parser(node: scala.xml.Node, stack: List[IPXACT2022scalaxb.ElemName]): Parser[IPXACT2022ScalaCases.PortPacketFieldType] =
      phrase((parseNameGroupGroup(node, IPXACT2022scalaxb.ElemName(node) :: stack)) ~
      (IPXACT2022scalaxb.ElemName(Some("http://www.accellera.org/XMLSchema/IPXACT/1685-2022"), "width")) ~
      opt(IPXACT2022scalaxb.ElemName(Some("http://www.accellera.org/XMLSchema/IPXACT/1685-2022"), "value")) ~
      opt(IPXACT2022scalaxb.ElemName(Some("http://www.accellera.org/XMLSchema/IPXACT/1685-2022"), "endianness")) ~
      opt(IPXACT2022scalaxb.ElemName(Some("http://www.accellera.org/XMLSchema/IPXACT/1685-2022"), "qualifier")) ~
      opt(IPXACT2022scalaxb.ElemName(Some("http://www.accellera.org/XMLSchema/IPXACT/1685-2022"), "vendorExtensions")) ^^
      { case p1 ~ p2 ~ p3 ~ p4 ~ p5 ~ p6 =>
      IPXACT2022ScalaCases.PortPacketFieldType(p1,
        IPXACT2022scalaxb.fromXML[IPXACT2022ScalaCases.UnresolvedUnsignedPositiveIntExpression](p2, IPXACT2022scalaxb.ElemName(node) :: stack),
        p3.headOption map { IPXACT2022scalaxb.fromXML[IPXACT2022ScalaCases.UnsignedBitVectorExpressionable](_, IPXACT2022scalaxb.ElemName(node) :: stack) },
        p4.headOption map { IPXACT2022scalaxb.fromXML[IPXACT2022ScalaCases.EndianessType](_, IPXACT2022scalaxb.ElemName(node) :: stack) },
        p5.headOption map { IPXACT2022scalaxb.fromXML[IPXACT2022ScalaCases.QualifierType](_, IPXACT2022scalaxb.ElemName(node) :: stack) },
        p6.headOption map { IPXACT2022scalaxb.fromXML[IPXACT2022ScalaCases.VendorExtensions](_, IPXACT2022scalaxb.ElemName(node) :: stack) },
        scala.collection.immutable.ListMap(List(
        (node \ "@{http://www.w3.org/XML/1998/namespace}id").headOption map { x => IPXACT2022scalaxb.DataRecord(x, node, IPXACT2022scalaxb.fromXML[String](x, IPXACT2022scalaxb.ElemName(node) :: stack)) } map { "@{http://www.w3.org/XML/1998/namespace}id" -> _ }
        ).flatten[(String, IPXACT2022scalaxb.DataRecord[Any])]: _*)) })
    
    override def writesAttribute(__obj: IPXACT2022ScalaCases.PortPacketFieldType, __scope: scala.xml.NamespaceBinding): scala.xml.MetaData = {
      var attr: scala.xml.MetaData  = scala.xml.Null
      __obj.attributes.toList map {
        case ("@{http://www.w3.org/XML/1998/namespace}id", _) => __obj.xmlid foreach { x => attr = scala.xml.Attribute(__scope.getPrefix("http://www.w3.org/XML/1998/namespace"), "id", x.toString, attr) }
        case (key, x) => attr = scala.xml.Attribute((x.namespace map { __scope.getPrefix(_) }).orNull, x.key.orNull, x.value.toString, attr)
      }
      attr
    }

    def writesChildNodes(__obj: IPXACT2022ScalaCases.PortPacketFieldType, __scope: scala.xml.NamespaceBinding): Seq[scala.xml.Node] =
      Seq.concat(IPXACT2022scalaxb.toXML[IPXACT2022ScalaCases.NameGroupSequence](__obj.nameGroupSequence1, None, Some("nameGroupSequence1"), __scope, false),
        IPXACT2022scalaxb.toXML[IPXACT2022ScalaCases.UnresolvedUnsignedPositiveIntExpression](__obj.width, Some("http://www.accellera.org/XMLSchema/IPXACT/1685-2022"), Some("width"), __scope, false),
        __obj.value map { IPXACT2022scalaxb.toXML[IPXACT2022ScalaCases.UnsignedBitVectorExpressionable](_, Some("http://www.accellera.org/XMLSchema/IPXACT/1685-2022"), Some("value"), __scope, false) } getOrElse {Nil},
        __obj.endianness map { IPXACT2022scalaxb.toXML[IPXACT2022ScalaCases.EndianessType](_, Some("http://www.accellera.org/XMLSchema/IPXACT/1685-2022"), Some("endianness"), __scope, false) } getOrElse {Nil},
        __obj.qualifier map { IPXACT2022scalaxb.toXML[IPXACT2022ScalaCases.QualifierType](_, Some("http://www.accellera.org/XMLSchema/IPXACT/1685-2022"), Some("qualifier"), __scope, false) } getOrElse {Nil},
        __obj.vendorExtensions map { IPXACT2022scalaxb.toXML[IPXACT2022ScalaCases.VendorExtensions](_, Some("http://www.accellera.org/XMLSchema/IPXACT/1685-2022"), Some("vendorExtensions"), __scope, false) } getOrElse {Nil})

  }

  trait DefaultIPXACT2022ScalaCases_ArrayType5Format extends IPXACT2022scalaxb.ElemNameParser[IPXACT2022ScalaCases.ArrayType5] {
    val targetNamespace: Option[String] = Some("http://www.accellera.org/XMLSchema/IPXACT/1685-2022")
    
    def parser(node: scala.xml.Node, stack: List[IPXACT2022scalaxb.ElemName]): Parser[IPXACT2022ScalaCases.ArrayType5] =
      phrase((IPXACT2022scalaxb.ElemName(Some("http://www.accellera.org/XMLSchema/IPXACT/1685-2022"), "left")) ~
      (IPXACT2022scalaxb.ElemName(Some("http://www.accellera.org/XMLSchema/IPXACT/1685-2022"), "right")) ^^
      { case p1 ~ p2 =>
      IPXACT2022ScalaCases.ArrayType5(IPXACT2022scalaxb.fromXML[IPXACT2022ScalaCases.UnsignedIntExpressionable](p1, IPXACT2022scalaxb.ElemName(node) :: stack),
        IPXACT2022scalaxb.fromXML[IPXACT2022ScalaCases.UnsignedIntExpressionable](p2, IPXACT2022scalaxb.ElemName(node) :: stack),
        scala.collection.immutable.ListMap(List(
        (node \ "@arrayId").headOption map { x => IPXACT2022scalaxb.DataRecord(x, node, IPXACT2022scalaxb.fromXML[String](x, IPXACT2022scalaxb.ElemName(node) :: stack)) } map { "@arrayId" -> _ },
        (node \ "@{http://www.w3.org/XML/1998/namespace}id").headOption map { x => IPXACT2022scalaxb.DataRecord(x, node, IPXACT2022scalaxb.fromXML[String](x, IPXACT2022scalaxb.ElemName(node) :: stack)) } map { "@{http://www.w3.org/XML/1998/namespace}id" -> _ }
        ).flatten[(String, IPXACT2022scalaxb.DataRecord[Any])]: _*)) })
    
    override def writesAttribute(__obj: IPXACT2022ScalaCases.ArrayType5, __scope: scala.xml.NamespaceBinding): scala.xml.MetaData = {
      var attr: scala.xml.MetaData  = scala.xml.Null
      __obj.attributes.toList map {
        case ("@arrayId", _) => __obj.arrayId foreach { x => attr = scala.xml.Attribute(null, "arrayId", x.toString, attr) }
        case ("@{http://www.w3.org/XML/1998/namespace}id", _) => __obj.xmlid foreach { x => attr = scala.xml.Attribute(__scope.getPrefix("http://www.w3.org/XML/1998/namespace"), "id", x.toString, attr) }
        case (key, x) => attr = scala.xml.Attribute((x.namespace map { __scope.getPrefix(_) }).orNull, x.key.orNull, x.value.toString, attr)
      }
      attr
    }

    def writesChildNodes(__obj: IPXACT2022ScalaCases.ArrayType5, __scope: scala.xml.NamespaceBinding): Seq[scala.xml.Node] =
      Seq.concat(IPXACT2022scalaxb.toXML[IPXACT2022ScalaCases.UnsignedIntExpressionable](__obj.left, Some("http://www.accellera.org/XMLSchema/IPXACT/1685-2022"), Some("left"), __scope, false),
        IPXACT2022scalaxb.toXML[IPXACT2022ScalaCases.UnsignedIntExpressionable](__obj.right, Some("http://www.accellera.org/XMLSchema/IPXACT/1685-2022"), Some("right"), __scope, false))

  }

  trait DefaultIPXACT2022ScalaCases_ArraysFormat extends IPXACT2022scalaxb.ElemNameParser[IPXACT2022ScalaCases.Arrays] {
    val targetNamespace: Option[String] = Some("http://www.accellera.org/XMLSchema/IPXACT/1685-2022")
    
    def parser(node: scala.xml.Node, stack: List[IPXACT2022scalaxb.ElemName]): Parser[IPXACT2022ScalaCases.Arrays] =
      phrase(safeRep(IPXACT2022scalaxb.ElemName(Some("http://www.accellera.org/XMLSchema/IPXACT/1685-2022"), "array")) ^^
      { case p1 =>
      IPXACT2022ScalaCases.Arrays(p1 map { IPXACT2022scalaxb.fromXML[IPXACT2022ScalaCases.ArrayType5](_, IPXACT2022scalaxb.ElemName(node) :: stack) }) })
    
    def writesChildNodes(__obj: IPXACT2022ScalaCases.Arrays, __scope: scala.xml.NamespaceBinding): Seq[scala.xml.Node] =
      (__obj.array flatMap { IPXACT2022scalaxb.toXML[IPXACT2022ScalaCases.ArrayType5](_, Some("http://www.accellera.org/XMLSchema/IPXACT/1685-2022"), Some("array"), __scope, false) })
  }
  trait DefaultIPXACT2022ScalaCases_TypeName5Format extends IPXACT2022scalaxb.XMLFormat[IPXACT2022ScalaCases.TypeName5] with IPXACT2022scalaxb.CanWriteChildNodes[IPXACT2022ScalaCases.TypeName5] {
    val targetNamespace: Option[String] = Some("http://www.accellera.org/XMLSchema/IPXACT/1685-2022")
    def reads(seq: scala.xml.NodeSeq, stack: List[IPXACT2022scalaxb.ElemName]): Either[String, IPXACT2022ScalaCases.TypeName5] = seq match {
      case node: scala.xml.Node => Right(IPXACT2022ScalaCases.TypeName5(IPXACT2022scalaxb.fromXML[String](node, IPXACT2022scalaxb.ElemName(node) :: stack),
        scala.collection.immutable.ListMap(List(
        (node \ "@constrained").headOption map { x => IPXACT2022scalaxb.DataRecord(x, node, IPXACT2022scalaxb.fromXML[Seq[String]](x, IPXACT2022scalaxb.ElemName(node) :: stack)) } map { "@constrained" -> _ }
        ).flatten[(String, IPXACT2022scalaxb.DataRecord[Any])]: _*)))
      case _ => Left("reads failed: seq must be scala.xml.Node")
    }
    
    override def writesAttribute(__obj: IPXACT2022ScalaCases.TypeName5, __scope: scala.xml.NamespaceBinding): scala.xml.MetaData = {
      var attr: scala.xml.MetaData  = scala.xml.Null
      __obj.attributes.toList map {
        case ("@constrained", _) => __obj.constrained foreach { x => attr = scala.xml.Attribute(null, "constrained", x.map(x => x.toString).mkString(" "), attr) }
        case (key, x) => attr = scala.xml.Attribute((x.namespace map { __scope.getPrefix(_) }).orNull, x.key.orNull, x.value.toString, attr)
      }
      attr
    }

    def writesChildNodes(__obj: IPXACT2022ScalaCases.TypeName5, __scope: scala.xml.NamespaceBinding): Seq[scala.xml.Node] =
      Seq(scala.xml.Text(__obj.value.toString))

  }

  trait DefaultIPXACT2022ScalaCases_TypeDefinition5Format extends IPXACT2022scalaxb.XMLFormat[IPXACT2022ScalaCases.TypeDefinition5] with IPXACT2022scalaxb.CanWriteChildNodes[IPXACT2022ScalaCases.TypeDefinition5] {
    val targetNamespace: Option[String] = Some("http://www.accellera.org/XMLSchema/IPXACT/1685-2022")
    def reads(seq: scala.xml.NodeSeq, stack: List[IPXACT2022scalaxb.ElemName]): Either[String, IPXACT2022ScalaCases.TypeDefinition5] = seq match {
      case node: scala.xml.Node => Right(IPXACT2022ScalaCases.TypeDefinition5(IPXACT2022scalaxb.fromXML[String](node, IPXACT2022scalaxb.ElemName(node) :: stack),
        scala.collection.immutable.ListMap(List(
        (node \ "@{http://www.w3.org/XML/1998/namespace}id").headOption map { x => IPXACT2022scalaxb.DataRecord(x, node, IPXACT2022scalaxb.fromXML[String](x, IPXACT2022scalaxb.ElemName(node) :: stack)) } map { "@{http://www.w3.org/XML/1998/namespace}id" -> _ }
        ).flatten[(String, IPXACT2022scalaxb.DataRecord[Any])]: _*)))
      case _ => Left("reads failed: seq must be scala.xml.Node")
    }
    
    override def writesAttribute(__obj: IPXACT2022ScalaCases.TypeDefinition5, __scope: scala.xml.NamespaceBinding): scala.xml.MetaData = {
      var attr: scala.xml.MetaData  = scala.xml.Null
      __obj.attributes.toList map {
        case ("@{http://www.w3.org/XML/1998/namespace}id", _) => __obj.xmlid foreach { x => attr = scala.xml.Attribute(__scope.getPrefix("http://www.w3.org/XML/1998/namespace"), "id", x.toString, attr) }
        case (key, x) => attr = scala.xml.Attribute((x.namespace map { __scope.getPrefix(_) }).orNull, x.key.orNull, x.value.toString, attr)
      }
      attr
    }

    def writesChildNodes(__obj: IPXACT2022ScalaCases.TypeDefinition5, __scope: scala.xml.NamespaceBinding): Seq[scala.xml.Node] =
      Seq(scala.xml.Text(__obj.value.toString))

  }

  trait DefaultIPXACT2022ScalaCases_TypeParameters2Format extends IPXACT2022scalaxb.ElemNameParser[IPXACT2022ScalaCases.TypeParameters2] {
    val targetNamespace: Option[String] = Some("http://www.accellera.org/XMLSchema/IPXACT/1685-2022")
    
    def parser(node: scala.xml.Node, stack: List[IPXACT2022scalaxb.ElemName]): Parser[IPXACT2022ScalaCases.TypeParameters2] =
      phrase(safeRep(IPXACT2022scalaxb.ElemName(Some("http://www.accellera.org/XMLSchema/IPXACT/1685-2022"), "typeParameter")) ^^
      { case p1 =>
      IPXACT2022ScalaCases.TypeParameters2(p1 map { IPXACT2022scalaxb.fromXML[IPXACT2022ScalaCases.ModuleParameterType](_, IPXACT2022scalaxb.ElemName(node) :: stack) }) })
    
    def writesChildNodes(__obj: IPXACT2022ScalaCases.TypeParameters2, __scope: scala.xml.NamespaceBinding): Seq[scala.xml.Node] =
      (__obj.typeParameter flatMap { IPXACT2022scalaxb.toXML[IPXACT2022ScalaCases.ModuleParameterType](_, Some("http://www.accellera.org/XMLSchema/IPXACT/1685-2022"), Some("typeParameter"), __scope, false) })
  }
  trait DefaultIPXACT2022ScalaCases_ViewRef10Format extends IPXACT2022scalaxb.XMLFormat[IPXACT2022ScalaCases.ViewRef10] with IPXACT2022scalaxb.CanWriteChildNodes[IPXACT2022ScalaCases.ViewRef10] {
    val targetNamespace: Option[String] = Some("http://www.accellera.org/XMLSchema/IPXACT/1685-2022")
    def reads(seq: scala.xml.NodeSeq, stack: List[IPXACT2022scalaxb.ElemName]): Either[String, IPXACT2022ScalaCases.ViewRef10] = seq match {
      case node: scala.xml.Node => Right(IPXACT2022ScalaCases.ViewRef10(IPXACT2022scalaxb.fromXML[String](node, IPXACT2022scalaxb.ElemName(node) :: stack),
        scala.collection.immutable.ListMap(List(
        (node \ "@{http://www.w3.org/XML/1998/namespace}id").headOption map { x => IPXACT2022scalaxb.DataRecord(x, node, IPXACT2022scalaxb.fromXML[String](x, IPXACT2022scalaxb.ElemName(node) :: stack)) } map { "@{http://www.w3.org/XML/1998/namespace}id" -> _ }
        ).flatten[(String, IPXACT2022scalaxb.DataRecord[Any])]: _*)))
      case _ => Left("reads failed: seq must be scala.xml.Node")
    }
    
    override def writesAttribute(__obj: IPXACT2022ScalaCases.ViewRef10, __scope: scala.xml.NamespaceBinding): scala.xml.MetaData = {
      var attr: scala.xml.MetaData  = scala.xml.Null
      __obj.attributes.toList map {
        case ("@{http://www.w3.org/XML/1998/namespace}id", _) => __obj.xmlid foreach { x => attr = scala.xml.Attribute(__scope.getPrefix("http://www.w3.org/XML/1998/namespace"), "id", x.toString, attr) }
        case (key, x) => attr = scala.xml.Attribute((x.namespace map { __scope.getPrefix(_) }).orNull, x.key.orNull, x.value.toString, attr)
      }
      attr
    }

    def writesChildNodes(__obj: IPXACT2022ScalaCases.ViewRef10, __scope: scala.xml.NamespaceBinding): Seq[scala.xml.Node] =
      Seq(scala.xml.Text(__obj.value.toString))

  }

  trait DefaultIPXACT2022ScalaCases_StructPortTypeDefFormat extends IPXACT2022scalaxb.ElemNameParser[IPXACT2022ScalaCases.StructPortTypeDef] {
    val targetNamespace: Option[String] = Some("http://www.accellera.org/XMLSchema/IPXACT/1685-2022")
    
    def parser(node: scala.xml.Node, stack: List[IPXACT2022scalaxb.ElemName]): Parser[IPXACT2022ScalaCases.StructPortTypeDef] =
      phrase((IPXACT2022scalaxb.ElemName(Some("http://www.accellera.org/XMLSchema/IPXACT/1685-2022"), "typeName")) ~
      safeRep(IPXACT2022scalaxb.ElemName(Some("http://www.accellera.org/XMLSchema/IPXACT/1685-2022"), "typeDefinition")) ~
      opt(IPXACT2022scalaxb.ElemName(Some("http://www.accellera.org/XMLSchema/IPXACT/1685-2022"), "typeParameters")) ~
      opt(IPXACT2022scalaxb.ElemName(Some("http://www.accellera.org/XMLSchema/IPXACT/1685-2022"), "role")) ~
      safeRep(IPXACT2022scalaxb.ElemName(Some("http://www.accellera.org/XMLSchema/IPXACT/1685-2022"), "viewRef")) ^^
      { case p1 ~ p2 ~ p3 ~ p4 ~ p5 =>
      IPXACT2022ScalaCases.StructPortTypeDef(IPXACT2022scalaxb.fromXML[IPXACT2022ScalaCases.TypeName5](p1, IPXACT2022scalaxb.ElemName(node) :: stack),
        p2 map { IPXACT2022scalaxb.fromXML[IPXACT2022ScalaCases.TypeDefinition5](_, IPXACT2022scalaxb.ElemName(node) :: stack) },
        p3.headOption map { IPXACT2022scalaxb.fromXML[IPXACT2022ScalaCases.TypeParameters2](_, IPXACT2022scalaxb.ElemName(node) :: stack) },
        p4.headOption map { IPXACT2022scalaxb.fromXML[String](_, IPXACT2022scalaxb.ElemName(node) :: stack) },
        p5 map { IPXACT2022scalaxb.fromXML[IPXACT2022ScalaCases.ViewRef10](_, IPXACT2022scalaxb.ElemName(node) :: stack) },
        scala.collection.immutable.ListMap(List(
        (node \ "@{http://www.w3.org/XML/1998/namespace}id").headOption map { x => IPXACT2022scalaxb.DataRecord(x, node, IPXACT2022scalaxb.fromXML[String](x, IPXACT2022scalaxb.ElemName(node) :: stack)) } map { "@{http://www.w3.org/XML/1998/namespace}id" -> _ }
        ).flatten[(String, IPXACT2022scalaxb.DataRecord[Any])]: _*)) })
    
    override def writesAttribute(__obj: IPXACT2022ScalaCases.StructPortTypeDef, __scope: scala.xml.NamespaceBinding): scala.xml.MetaData = {
      var attr: scala.xml.MetaData  = scala.xml.Null
      __obj.attributes.toList map {
        case ("@{http://www.w3.org/XML/1998/namespace}id", _) => __obj.xmlid foreach { x => attr = scala.xml.Attribute(__scope.getPrefix("http://www.w3.org/XML/1998/namespace"), "id", x.toString, attr) }
        case (key, x) => attr = scala.xml.Attribute((x.namespace map { __scope.getPrefix(_) }).orNull, x.key.orNull, x.value.toString, attr)
      }
      attr
    }

    def writesChildNodes(__obj: IPXACT2022ScalaCases.StructPortTypeDef, __scope: scala.xml.NamespaceBinding): Seq[scala.xml.Node] =
      Seq.concat(IPXACT2022scalaxb.toXML[IPXACT2022ScalaCases.TypeName5](__obj.typeName, Some("http://www.accellera.org/XMLSchema/IPXACT/1685-2022"), Some("typeName"), __scope, false),
        __obj.typeDefinition flatMap { IPXACT2022scalaxb.toXML[IPXACT2022ScalaCases.TypeDefinition5](_, Some("http://www.accellera.org/XMLSchema/IPXACT/1685-2022"), Some("typeDefinition"), __scope, false) },
        __obj.typeParameters map { IPXACT2022scalaxb.toXML[IPXACT2022ScalaCases.TypeParameters2](_, Some("http://www.accellera.org/XMLSchema/IPXACT/1685-2022"), Some("typeParameters"), __scope, false) } getOrElse {Nil},
        __obj.role map { IPXACT2022scalaxb.toXML[String](_, Some("http://www.accellera.org/XMLSchema/IPXACT/1685-2022"), Some("role"), __scope, false) } getOrElse {Nil},
        __obj.viewRef flatMap { IPXACT2022scalaxb.toXML[IPXACT2022ScalaCases.ViewRef10](_, Some("http://www.accellera.org/XMLSchema/IPXACT/1685-2022"), Some("viewRef"), __scope, false) })

  }

  trait DefaultIPXACT2022ScalaCases_StructPortTypeDefsFormat extends IPXACT2022scalaxb.ElemNameParser[IPXACT2022ScalaCases.StructPortTypeDefs] {
    val targetNamespace: Option[String] = Some("http://www.accellera.org/XMLSchema/IPXACT/1685-2022")
    
    def parser(node: scala.xml.Node, stack: List[IPXACT2022scalaxb.ElemName]): Parser[IPXACT2022ScalaCases.StructPortTypeDefs] =
      phrase(safeRep(IPXACT2022scalaxb.ElemName(Some("http://www.accellera.org/XMLSchema/IPXACT/1685-2022"), "structPortTypeDef")) ^^
      { case p1 =>
      IPXACT2022ScalaCases.StructPortTypeDefs(p1 map { IPXACT2022scalaxb.fromXML[IPXACT2022ScalaCases.StructPortTypeDef](_, IPXACT2022scalaxb.ElemName(node) :: stack) }) })
    
    def writesChildNodes(__obj: IPXACT2022ScalaCases.StructPortTypeDefs, __scope: scala.xml.NamespaceBinding): Seq[scala.xml.Node] =
      (__obj.structPortTypeDef flatMap { IPXACT2022scalaxb.toXML[IPXACT2022ScalaCases.StructPortTypeDef](_, Some("http://www.accellera.org/XMLSchema/IPXACT/1685-2022"), Some("structPortTypeDef"), __scope, false) })
  }
  trait DefaultIPXACT2022ScalaCases_SubPortTypeFormat extends IPXACT2022scalaxb.ElemNameParser[IPXACT2022ScalaCases.SubPortType] with IPXACT2022ScalaCases_NameGroupPortGroupFormat {
    val targetNamespace: Option[String] = Some("http://www.accellera.org/XMLSchema/IPXACT/1685-2022")
    
    override def typeName: Option[String] = Some("subPortType")

    def parser(node: scala.xml.Node, stack: List[IPXACT2022scalaxb.ElemName]): Parser[IPXACT2022ScalaCases.SubPortType] =
      phrase((parseNameGroupPortGroup(node, IPXACT2022scalaxb.ElemName(node) :: stack)) ~
      (((IPXACT2022scalaxb.ElemName(Some("http://www.accellera.org/XMLSchema/IPXACT/1685-2022"), "wire")) ^^
      (x => IPXACT2022scalaxb.DataRecord(x.namespace, Some(x.name), IPXACT2022scalaxb.fromXML[IPXACT2022ScalaCases.PortWireTypable](x, IPXACT2022scalaxb.ElemName(node) :: stack)))) |
      ((IPXACT2022scalaxb.ElemName(Some("http://www.accellera.org/XMLSchema/IPXACT/1685-2022"), "structured")) ^^
      (x => IPXACT2022scalaxb.DataRecord(x.namespace, Some(x.name), IPXACT2022scalaxb.fromXML[IPXACT2022ScalaCases.PortStructuredType](x, IPXACT2022scalaxb.ElemName(node) :: stack))))) ~
      opt(IPXACT2022scalaxb.ElemName(Some("http://www.accellera.org/XMLSchema/IPXACT/1685-2022"), "arrays")) ~
      opt(IPXACT2022scalaxb.ElemName(Some("http://www.accellera.org/XMLSchema/IPXACT/1685-2022"), "access")) ~
      opt(IPXACT2022scalaxb.ElemName(Some("http://www.accellera.org/XMLSchema/IPXACT/1685-2022"), "vendorExtensions")) ^^
      { case p1 ~ p2 ~ p3 ~ p4 ~ p5 =>
      IPXACT2022ScalaCases.SubPortType(p1,
        p2,
        p3.headOption map { IPXACT2022scalaxb.fromXML[IPXACT2022ScalaCases.Arrays](_, IPXACT2022scalaxb.ElemName(node) :: stack) },
        p4.headOption map { IPXACT2022scalaxb.fromXML[IPXACT2022ScalaCases.PortAccessType](_, IPXACT2022scalaxb.ElemName(node) :: stack) },
        p5.headOption map { IPXACT2022scalaxb.fromXML[IPXACT2022ScalaCases.VendorExtensions](_, IPXACT2022scalaxb.ElemName(node) :: stack) },
        scala.collection.immutable.ListMap(List(
        (node \ "@{http://www.w3.org/XML/1998/namespace}id").headOption map { x => IPXACT2022scalaxb.DataRecord(x, node, IPXACT2022scalaxb.fromXML[String](x, IPXACT2022scalaxb.ElemName(node) :: stack)) } map { "@{http://www.w3.org/XML/1998/namespace}id" -> _ },
        (node \ "@isIO").headOption map { x => IPXACT2022scalaxb.DataRecord(x, node, IPXACT2022scalaxb.fromXML[Boolean](x, IPXACT2022scalaxb.ElemName(node) :: stack)) } map { "@isIO" -> _ }
        ).flatten[(String, IPXACT2022scalaxb.DataRecord[Any])]: _*)) })
    
    override def writesAttribute(__obj: IPXACT2022ScalaCases.SubPortType, __scope: scala.xml.NamespaceBinding): scala.xml.MetaData = {
      var attr: scala.xml.MetaData  = scala.xml.Null
      __obj.attributes.toList map {
        case ("@{http://www.w3.org/XML/1998/namespace}id", _) => __obj.xmlid foreach { x => attr = scala.xml.Attribute(__scope.getPrefix("http://www.w3.org/XML/1998/namespace"), "id", x.toString, attr) }
        case ("@isIO", _) => __obj.isIO foreach { x => attr = scala.xml.Attribute(null, "isIO", x.toString, attr) }
        case (key, x) => attr = scala.xml.Attribute((x.namespace map { __scope.getPrefix(_) }).orNull, x.key.orNull, x.value.toString, attr)
      }
      attr
    }

    def writesChildNodes(__obj: IPXACT2022ScalaCases.SubPortType, __scope: scala.xml.NamespaceBinding): Seq[scala.xml.Node] =
      Seq.concat(IPXACT2022scalaxb.toXML[IPXACT2022ScalaCases.NameGroupPortSequence](__obj.nameGroupPortSequence1, None, Some("nameGroupPortSequence1"), __scope, false),
        (Some(__obj.subporttypeoption) map {x => IPXACT2022scalaxb.toXML[IPXACT2022scalaxb.DataRecord[IPXACT2022ScalaCases.SubPortTypeOption]](x, x.namespace, x.key, __scope, false)}).get,
        __obj.arrays map { IPXACT2022scalaxb.toXML[IPXACT2022ScalaCases.Arrays](_, Some("http://www.accellera.org/XMLSchema/IPXACT/1685-2022"), Some("arrays"), __scope, false) } getOrElse {Nil},
        __obj.access map { IPXACT2022scalaxb.toXML[IPXACT2022ScalaCases.PortAccessType](_, Some("http://www.accellera.org/XMLSchema/IPXACT/1685-2022"), Some("access"), __scope, false) } getOrElse {Nil},
        __obj.vendorExtensions map { IPXACT2022scalaxb.toXML[IPXACT2022ScalaCases.VendorExtensions](_, Some("http://www.accellera.org/XMLSchema/IPXACT/1685-2022"), Some("vendorExtensions"), __scope, false) } getOrElse {Nil})

  }

  trait DefaultIPXACT2022ScalaCases_AbstractorSubPortTypeFormat extends IPXACT2022scalaxb.ElemNameParser[IPXACT2022ScalaCases.AbstractorSubPortType] with IPXACT2022ScalaCases_NameGroupPortGroupFormat {
    val targetNamespace: Option[String] = Some("http://www.accellera.org/XMLSchema/IPXACT/1685-2022")
    
    override def typeName: Option[String] = Some("abstractorSubPortType")

    def parser(node: scala.xml.Node, stack: List[IPXACT2022scalaxb.ElemName]): Parser[IPXACT2022ScalaCases.AbstractorSubPortType] =
      phrase((parseNameGroupPortGroup(node, IPXACT2022scalaxb.ElemName(node) :: stack)) ~
      (((IPXACT2022scalaxb.ElemName(Some("http://www.accellera.org/XMLSchema/IPXACT/1685-2022"), "wire")) ^^
      (x => IPXACT2022scalaxb.DataRecord(x.namespace, Some(x.name), IPXACT2022scalaxb.fromXML[IPXACT2022ScalaCases.AbstractorPortWireType](x, IPXACT2022scalaxb.ElemName(node) :: stack)))) |
      ((IPXACT2022scalaxb.ElemName(Some("http://www.accellera.org/XMLSchema/IPXACT/1685-2022"), "structured")) ^^
      (x => IPXACT2022scalaxb.DataRecord(x.namespace, Some(x.name), IPXACT2022scalaxb.fromXML[IPXACT2022ScalaCases.AbstractorPortStructuredType](x, IPXACT2022scalaxb.ElemName(node) :: stack))))) ~
      opt(IPXACT2022scalaxb.ElemName(Some("http://www.accellera.org/XMLSchema/IPXACT/1685-2022"), "arrays")) ~
      opt(IPXACT2022scalaxb.ElemName(Some("http://www.accellera.org/XMLSchema/IPXACT/1685-2022"), "access")) ~
      opt(IPXACT2022scalaxb.ElemName(Some("http://www.accellera.org/XMLSchema/IPXACT/1685-2022"), "vendorExtensions")) ^^
      { case p1 ~ p2 ~ p3 ~ p4 ~ p5 =>
      IPXACT2022ScalaCases.AbstractorSubPortType(p1,
        p2,
        p3.headOption map { IPXACT2022scalaxb.fromXML[IPXACT2022ScalaCases.Arrays](_, IPXACT2022scalaxb.ElemName(node) :: stack) },
        p4.headOption map { IPXACT2022scalaxb.fromXML[IPXACT2022ScalaCases.PortAccessType](_, IPXACT2022scalaxb.ElemName(node) :: stack) },
        p5.headOption map { IPXACT2022scalaxb.fromXML[IPXACT2022ScalaCases.VendorExtensions](_, IPXACT2022scalaxb.ElemName(node) :: stack) },
        scala.collection.immutable.ListMap(List(
        (node \ "@{http://www.w3.org/XML/1998/namespace}id").headOption map { x => IPXACT2022scalaxb.DataRecord(x, node, IPXACT2022scalaxb.fromXML[String](x, IPXACT2022scalaxb.ElemName(node) :: stack)) } map { "@{http://www.w3.org/XML/1998/namespace}id" -> _ },
        (node \ "@isIO").headOption map { x => IPXACT2022scalaxb.DataRecord(x, node, IPXACT2022scalaxb.fromXML[Boolean](x, IPXACT2022scalaxb.ElemName(node) :: stack)) } map { "@isIO" -> _ }
        ).flatten[(String, IPXACT2022scalaxb.DataRecord[Any])]: _*)) })
    
    override def writesAttribute(__obj: IPXACT2022ScalaCases.AbstractorSubPortType, __scope: scala.xml.NamespaceBinding): scala.xml.MetaData = {
      var attr: scala.xml.MetaData  = scala.xml.Null
      __obj.attributes.toList map {
        case ("@{http://www.w3.org/XML/1998/namespace}id", _) => __obj.xmlid foreach { x => attr = scala.xml.Attribute(__scope.getPrefix("http://www.w3.org/XML/1998/namespace"), "id", x.toString, attr) }
        case ("@isIO", _) => __obj.isIO foreach { x => attr = scala.xml.Attribute(null, "isIO", x.toString, attr) }
        case (key, x) => attr = scala.xml.Attribute((x.namespace map { __scope.getPrefix(_) }).orNull, x.key.orNull, x.value.toString, attr)
      }
      attr
    }

    def writesChildNodes(__obj: IPXACT2022ScalaCases.AbstractorSubPortType, __scope: scala.xml.NamespaceBinding): Seq[scala.xml.Node] =
      Seq.concat(IPXACT2022scalaxb.toXML[IPXACT2022ScalaCases.NameGroupPortSequence](__obj.nameGroupPortSequence1, None, Some("nameGroupPortSequence1"), __scope, false),
        (Some(__obj.abstractorsubporttypeoption) map {x => IPXACT2022scalaxb.toXML[IPXACT2022scalaxb.DataRecord[IPXACT2022ScalaCases.AbstractorSubPortTypeOption]](x, x.namespace, x.key, __scope, false)}).get,
        __obj.arrays map { IPXACT2022scalaxb.toXML[IPXACT2022ScalaCases.Arrays](_, Some("http://www.accellera.org/XMLSchema/IPXACT/1685-2022"), Some("arrays"), __scope, false) } getOrElse {Nil},
        __obj.access map { IPXACT2022scalaxb.toXML[IPXACT2022ScalaCases.PortAccessType](_, Some("http://www.accellera.org/XMLSchema/IPXACT/1685-2022"), Some("access"), __scope, false) } getOrElse {Nil},
        __obj.vendorExtensions map { IPXACT2022scalaxb.toXML[IPXACT2022ScalaCases.VendorExtensions](_, Some("http://www.accellera.org/XMLSchema/IPXACT/1685-2022"), Some("vendorExtensions"), __scope, false) } getOrElse {Nil})

  }

  trait DefaultIPXACT2022ScalaCases_SubPortsFormat extends IPXACT2022scalaxb.ElemNameParser[IPXACT2022ScalaCases.SubPorts] {
    val targetNamespace: Option[String] = Some("http://www.accellera.org/XMLSchema/IPXACT/1685-2022")
    
    def parser(node: scala.xml.Node, stack: List[IPXACT2022scalaxb.ElemName]): Parser[IPXACT2022ScalaCases.SubPorts] =
      phrase(safeRep(IPXACT2022scalaxb.ElemName(Some("http://www.accellera.org/XMLSchema/IPXACT/1685-2022"), "subPort")) ^^
      { case p1 =>
      IPXACT2022ScalaCases.SubPorts(p1 map { IPXACT2022scalaxb.fromXML[IPXACT2022ScalaCases.SubPortType](_, IPXACT2022scalaxb.ElemName(node) :: stack) }) })
    
    def writesChildNodes(__obj: IPXACT2022ScalaCases.SubPorts, __scope: scala.xml.NamespaceBinding): Seq[scala.xml.Node] =
      (__obj.subPort flatMap { IPXACT2022scalaxb.toXML[IPXACT2022ScalaCases.SubPortType](_, Some("http://www.accellera.org/XMLSchema/IPXACT/1685-2022"), Some("subPort"), __scope, false) })
  }
  trait DefaultIPXACT2022ScalaCases_PortStructuredTypeFormat extends IPXACT2022scalaxb.ElemNameParser[IPXACT2022ScalaCases.PortStructuredType] with IPXACT2022ScalaCases_StructTypeGroupGroupFormat {
    val targetNamespace: Option[String] = Some("http://www.accellera.org/XMLSchema/IPXACT/1685-2022")
    
    override def typeName: Option[String] = Some("portStructuredType")

    def parser(node: scala.xml.Node, stack: List[IPXACT2022scalaxb.ElemName]): Parser[IPXACT2022ScalaCases.PortStructuredType] =
      phrase((parseStructTypeGroupGroup(node, IPXACT2022scalaxb.ElemName(node) :: stack)) ~
      opt(IPXACT2022scalaxb.ElemName(Some("http://www.accellera.org/XMLSchema/IPXACT/1685-2022"), "vectors")) ~
      opt(IPXACT2022scalaxb.ElemName(Some("http://www.accellera.org/XMLSchema/IPXACT/1685-2022"), "subPorts")) ~
      (IPXACT2022scalaxb.ElemName(Some("http://www.accellera.org/XMLSchema/IPXACT/1685-2022"), "structPortTypeDefs")) ^^
      { case p1 ~ p2 ~ p3 ~ p4 =>
      IPXACT2022ScalaCases.PortStructuredType(p1,
        p2.headOption map { IPXACT2022scalaxb.fromXML[IPXACT2022ScalaCases.ExtendedVectorsType](_, IPXACT2022scalaxb.ElemName(node) :: stack) },
        p3.headOption map { IPXACT2022scalaxb.fromXML[IPXACT2022ScalaCases.SubPorts](_, IPXACT2022scalaxb.ElemName(node) :: stack) },
        IPXACT2022scalaxb.fromXML[IPXACT2022ScalaCases.StructPortTypeDefs](p4, IPXACT2022scalaxb.ElemName(node) :: stack),
        scala.collection.immutable.ListMap(List(
        (node \ "@packed").headOption map { x => IPXACT2022scalaxb.DataRecord(x, node, IPXACT2022scalaxb.fromXML[Boolean](x, IPXACT2022scalaxb.ElemName(node) :: stack)) } orElse Some(IPXACT2022scalaxb.DataRecord(None, None, IPXACT2022scalaxb.fromXML[Boolean](scala.xml.Text("true"), IPXACT2022scalaxb.ElemName(node) :: stack))) map { "@packed" -> _ }
        ).flatten[(String, IPXACT2022scalaxb.DataRecord[Any])]: _*)) })
    
    override def writesAttribute(__obj: IPXACT2022ScalaCases.PortStructuredType, __scope: scala.xml.NamespaceBinding): scala.xml.MetaData = {
      var attr: scala.xml.MetaData  = scala.xml.Null
      __obj.attributes.toList map {
        case ("@packed", _) => if (__obj.packed.toString != "true") attr = scala.xml.Attribute(null, "packed", __obj.packed.toString, attr)
        case (key, x) => attr = scala.xml.Attribute((x.namespace map { __scope.getPrefix(_) }).orNull, x.key.orNull, x.value.toString, attr)
      }
      attr
    }

    def writesChildNodes(__obj: IPXACT2022ScalaCases.PortStructuredType, __scope: scala.xml.NamespaceBinding): Seq[scala.xml.Node] =
      Seq.concat((Some(__obj.structTypeGroupOption1) map {x => IPXACT2022scalaxb.toXML[IPXACT2022scalaxb.DataRecord[IPXACT2022ScalaCases.StructTypeGroupOption]](x, x.namespace, x.key, __scope, false)}).get,
        __obj.vectors map { IPXACT2022scalaxb.toXML[IPXACT2022ScalaCases.ExtendedVectorsType](_, Some("http://www.accellera.org/XMLSchema/IPXACT/1685-2022"), Some("vectors"), __scope, false) } getOrElse {Nil},
        __obj.subPorts map { IPXACT2022scalaxb.toXML[IPXACT2022ScalaCases.SubPorts](_, Some("http://www.accellera.org/XMLSchema/IPXACT/1685-2022"), Some("subPorts"), __scope, false) } getOrElse {Nil},
        IPXACT2022scalaxb.toXML[IPXACT2022ScalaCases.StructPortTypeDefs](__obj.structPortTypeDefs, Some("http://www.accellera.org/XMLSchema/IPXACT/1685-2022"), Some("structPortTypeDefs"), __scope, false))

  }

  trait DefaultIPXACT2022ScalaCases_SubPorts2Format extends IPXACT2022scalaxb.ElemNameParser[IPXACT2022ScalaCases.SubPorts2] {
    val targetNamespace: Option[String] = Some("http://www.accellera.org/XMLSchema/IPXACT/1685-2022")
    
    def parser(node: scala.xml.Node, stack: List[IPXACT2022scalaxb.ElemName]): Parser[IPXACT2022ScalaCases.SubPorts2] =
      phrase(safeRep(IPXACT2022scalaxb.ElemName(Some("http://www.accellera.org/XMLSchema/IPXACT/1685-2022"), "subPort")) ^^
      { case p1 =>
      IPXACT2022ScalaCases.SubPorts2(p1 map { IPXACT2022scalaxb.fromXML[IPXACT2022ScalaCases.AbstractorSubPortType](_, IPXACT2022scalaxb.ElemName(node) :: stack) }) })
    
    def writesChildNodes(__obj: IPXACT2022ScalaCases.SubPorts2, __scope: scala.xml.NamespaceBinding): Seq[scala.xml.Node] =
      (__obj.subPort flatMap { IPXACT2022scalaxb.toXML[IPXACT2022ScalaCases.AbstractorSubPortType](_, Some("http://www.accellera.org/XMLSchema/IPXACT/1685-2022"), Some("subPort"), __scope, false) })
  }
  trait DefaultIPXACT2022ScalaCases_AbstractorPortStructuredTypeFormat extends IPXACT2022scalaxb.ElemNameParser[IPXACT2022ScalaCases.AbstractorPortStructuredType] with IPXACT2022ScalaCases_StructTypeGroupGroupFormat {
    val targetNamespace: Option[String] = Some("http://www.accellera.org/XMLSchema/IPXACT/1685-2022")
    
    override def typeName: Option[String] = Some("abstractorPortStructuredType")

    def parser(node: scala.xml.Node, stack: List[IPXACT2022scalaxb.ElemName]): Parser[IPXACT2022ScalaCases.AbstractorPortStructuredType] =
      phrase((parseStructTypeGroupGroup(node, IPXACT2022scalaxb.ElemName(node) :: stack)) ~
      opt(IPXACT2022scalaxb.ElemName(Some("http://www.accellera.org/XMLSchema/IPXACT/1685-2022"), "vectors")) ~
      (IPXACT2022scalaxb.ElemName(Some("http://www.accellera.org/XMLSchema/IPXACT/1685-2022"), "subPorts")) ~
      (IPXACT2022scalaxb.ElemName(Some("http://www.accellera.org/XMLSchema/IPXACT/1685-2022"), "structPortTypeDefs")) ^^
      { case p1 ~ p2 ~ p3 ~ p4 =>
      IPXACT2022ScalaCases.AbstractorPortStructuredType(p1,
        p2.headOption map { IPXACT2022scalaxb.fromXML[IPXACT2022ScalaCases.ExtendedVectorsType](_, IPXACT2022scalaxb.ElemName(node) :: stack) },
        IPXACT2022scalaxb.fromXML[IPXACT2022ScalaCases.SubPorts2](p3, IPXACT2022scalaxb.ElemName(node) :: stack),
        IPXACT2022scalaxb.fromXML[IPXACT2022ScalaCases.StructPortTypeDefs](p4, IPXACT2022scalaxb.ElemName(node) :: stack),
        scala.collection.immutable.ListMap(List(
        (node \ "@packed").headOption map { x => IPXACT2022scalaxb.DataRecord(x, node, IPXACT2022scalaxb.fromXML[Boolean](x, IPXACT2022scalaxb.ElemName(node) :: stack)) } orElse Some(IPXACT2022scalaxb.DataRecord(None, None, IPXACT2022scalaxb.fromXML[Boolean](scala.xml.Text("true"), IPXACT2022scalaxb.ElemName(node) :: stack))) map { "@packed" -> _ }
        ).flatten[(String, IPXACT2022scalaxb.DataRecord[Any])]: _*)) })
    
    override def writesAttribute(__obj: IPXACT2022ScalaCases.AbstractorPortStructuredType, __scope: scala.xml.NamespaceBinding): scala.xml.MetaData = {
      var attr: scala.xml.MetaData  = scala.xml.Null
      __obj.attributes.toList map {
        case ("@packed", _) => if (__obj.packed.toString != "true") attr = scala.xml.Attribute(null, "packed", __obj.packed.toString, attr)
        case (key, x) => attr = scala.xml.Attribute((x.namespace map { __scope.getPrefix(_) }).orNull, x.key.orNull, x.value.toString, attr)
      }
      attr
    }

    def writesChildNodes(__obj: IPXACT2022ScalaCases.AbstractorPortStructuredType, __scope: scala.xml.NamespaceBinding): Seq[scala.xml.Node] =
      Seq.concat((Some(__obj.structTypeGroupOption1) map {x => IPXACT2022scalaxb.toXML[IPXACT2022scalaxb.DataRecord[IPXACT2022ScalaCases.StructTypeGroupOption]](x, x.namespace, x.key, __scope, false)}).get,
        __obj.vectors map { IPXACT2022scalaxb.toXML[IPXACT2022ScalaCases.ExtendedVectorsType](_, Some("http://www.accellera.org/XMLSchema/IPXACT/1685-2022"), Some("vectors"), __scope, false) } getOrElse {Nil},
        IPXACT2022scalaxb.toXML[IPXACT2022ScalaCases.SubPorts2](__obj.subPorts, Some("http://www.accellera.org/XMLSchema/IPXACT/1685-2022"), Some("subPorts"), __scope, false),
        IPXACT2022scalaxb.toXML[IPXACT2022ScalaCases.StructPortTypeDefs](__obj.structPortTypeDefs, Some("http://www.accellera.org/XMLSchema/IPXACT/1685-2022"), Some("structPortTypeDefs"), __scope, false))

  }

  trait DefaultIPXACT2022ScalaCases_WirePowerConstraintTypeFormat extends IPXACT2022scalaxb.ElemNameParser[IPXACT2022ScalaCases.WirePowerConstraintType] {
    val targetNamespace: Option[String] = Some("http://www.accellera.org/XMLSchema/IPXACT/1685-2022")
    
    override def typeName: Option[String] = Some("wirePowerConstraintType")

    def parser(node: scala.xml.Node, stack: List[IPXACT2022scalaxb.ElemName]): Parser[IPXACT2022ScalaCases.WirePowerConstraintType] =
      phrase((IPXACT2022scalaxb.ElemName(Some("http://www.accellera.org/XMLSchema/IPXACT/1685-2022"), "powerDomainRef")) ~
      opt(IPXACT2022scalaxb.ElemName(Some("http://www.accellera.org/XMLSchema/IPXACT/1685-2022"), "range")) ~
      opt(IPXACT2022scalaxb.ElemName(Some("http://www.accellera.org/XMLSchema/IPXACT/1685-2022"), "vendorExtensions")) ^^
      { case p1 ~ p2 ~ p3 =>
      IPXACT2022ScalaCases.WirePowerConstraintType(IPXACT2022scalaxb.fromXML[String](p1, IPXACT2022scalaxb.ElemName(node) :: stack),
        p2.headOption map { IPXACT2022scalaxb.fromXML[IPXACT2022ScalaCases.RangeType](_, IPXACT2022scalaxb.ElemName(node) :: stack) },
        p3.headOption map { IPXACT2022scalaxb.fromXML[IPXACT2022ScalaCases.VendorExtensions](_, IPXACT2022scalaxb.ElemName(node) :: stack) },
        scala.collection.immutable.ListMap(List(
        (node \ "@{http://www.w3.org/XML/1998/namespace}id").headOption map { x => IPXACT2022scalaxb.DataRecord(x, node, IPXACT2022scalaxb.fromXML[String](x, IPXACT2022scalaxb.ElemName(node) :: stack)) } map { "@{http://www.w3.org/XML/1998/namespace}id" -> _ }
        ).flatten[(String, IPXACT2022scalaxb.DataRecord[Any])]: _*)) })
    
    override def writesAttribute(__obj: IPXACT2022ScalaCases.WirePowerConstraintType, __scope: scala.xml.NamespaceBinding): scala.xml.MetaData = {
      var attr: scala.xml.MetaData  = scala.xml.Null
      __obj.attributes.toList map {
        case ("@{http://www.w3.org/XML/1998/namespace}id", _) => __obj.xmlid foreach { x => attr = scala.xml.Attribute(__scope.getPrefix("http://www.w3.org/XML/1998/namespace"), "id", x.toString, attr) }
        case (key, x) => attr = scala.xml.Attribute((x.namespace map { __scope.getPrefix(_) }).orNull, x.key.orNull, x.value.toString, attr)
      }
      attr
    }

    def writesChildNodes(__obj: IPXACT2022ScalaCases.WirePowerConstraintType, __scope: scala.xml.NamespaceBinding): Seq[scala.xml.Node] =
      Seq.concat(IPXACT2022scalaxb.toXML[String](__obj.powerDomainRef, Some("http://www.accellera.org/XMLSchema/IPXACT/1685-2022"), Some("powerDomainRef"), __scope, false),
        __obj.range map { IPXACT2022scalaxb.toXML[IPXACT2022ScalaCases.RangeType](_, Some("http://www.accellera.org/XMLSchema/IPXACT/1685-2022"), Some("range"), __scope, false) } getOrElse {Nil},
        __obj.vendorExtensions map { IPXACT2022scalaxb.toXML[IPXACT2022ScalaCases.VendorExtensions](_, Some("http://www.accellera.org/XMLSchema/IPXACT/1685-2022"), Some("vendorExtensions"), __scope, false) } getOrElse {Nil})

  }

  trait DefaultIPXACT2022ScalaCases_TransactionalPowerConstraintTypeFormat extends IPXACT2022scalaxb.ElemNameParser[IPXACT2022ScalaCases.TransactionalPowerConstraintType] {
    val targetNamespace: Option[String] = Some("http://www.accellera.org/XMLSchema/IPXACT/1685-2022")
    
    override def typeName: Option[String] = Some("transactionalPowerConstraintType")

    def parser(node: scala.xml.Node, stack: List[IPXACT2022scalaxb.ElemName]): Parser[IPXACT2022ScalaCases.TransactionalPowerConstraintType] =
      phrase((IPXACT2022scalaxb.ElemName(Some("http://www.accellera.org/XMLSchema/IPXACT/1685-2022"), "powerDomainRef")) ~
      opt(IPXACT2022scalaxb.ElemName(Some("http://www.accellera.org/XMLSchema/IPXACT/1685-2022"), "vendorExtensions")) ^^
      { case p1 ~ p2 =>
      IPXACT2022ScalaCases.TransactionalPowerConstraintType(IPXACT2022scalaxb.fromXML[String](p1, IPXACT2022scalaxb.ElemName(node) :: stack),
        p2.headOption map { IPXACT2022scalaxb.fromXML[IPXACT2022ScalaCases.VendorExtensions](_, IPXACT2022scalaxb.ElemName(node) :: stack) },
        scala.collection.immutable.ListMap(List(
        (node \ "@{http://www.w3.org/XML/1998/namespace}id").headOption map { x => IPXACT2022scalaxb.DataRecord(x, node, IPXACT2022scalaxb.fromXML[String](x, IPXACT2022scalaxb.ElemName(node) :: stack)) } map { "@{http://www.w3.org/XML/1998/namespace}id" -> _ }
        ).flatten[(String, IPXACT2022scalaxb.DataRecord[Any])]: _*)) })
    
    override def writesAttribute(__obj: IPXACT2022ScalaCases.TransactionalPowerConstraintType, __scope: scala.xml.NamespaceBinding): scala.xml.MetaData = {
      var attr: scala.xml.MetaData  = scala.xml.Null
      __obj.attributes.toList map {
        case ("@{http://www.w3.org/XML/1998/namespace}id", _) => __obj.xmlid foreach { x => attr = scala.xml.Attribute(__scope.getPrefix("http://www.w3.org/XML/1998/namespace"), "id", x.toString, attr) }
        case (key, x) => attr = scala.xml.Attribute((x.namespace map { __scope.getPrefix(_) }).orNull, x.key.orNull, x.value.toString, attr)
      }
      attr
    }

    def writesChildNodes(__obj: IPXACT2022ScalaCases.TransactionalPowerConstraintType, __scope: scala.xml.NamespaceBinding): Seq[scala.xml.Node] =
      Seq.concat(IPXACT2022scalaxb.toXML[String](__obj.powerDomainRef, Some("http://www.accellera.org/XMLSchema/IPXACT/1685-2022"), Some("powerDomainRef"), __scope, false),
        __obj.vendorExtensions map { IPXACT2022scalaxb.toXML[IPXACT2022ScalaCases.VendorExtensions](_, Some("http://www.accellera.org/XMLSchema/IPXACT/1685-2022"), Some("vendorExtensions"), __scope, false) } getOrElse {Nil})

  }

  trait DefaultIPXACT2022ScalaCases_StructFormat extends IPXACT2022scalaxb.XMLFormat[IPXACT2022ScalaCases.Struct] with IPXACT2022scalaxb.CanWriteChildNodes[IPXACT2022ScalaCases.Struct] {
    val targetNamespace: Option[String] = Some("http://www.accellera.org/XMLSchema/IPXACT/1685-2022")
    def reads(seq: scala.xml.NodeSeq, stack: List[IPXACT2022scalaxb.ElemName]): Either[String, IPXACT2022ScalaCases.Struct] = seq match {
      case node: scala.xml.Node => Right(IPXACT2022ScalaCases.Struct(scala.collection.immutable.ListMap(List(
        (node \ "@direction").headOption map { x => IPXACT2022scalaxb.DataRecord(x, node, IPXACT2022scalaxb.fromXML[IPXACT2022ScalaCases.ComponentPortDirectionType](x, IPXACT2022scalaxb.ElemName(node) :: stack)) } map { "@direction" -> _ }
        ).flatten[(String, IPXACT2022scalaxb.DataRecord[Any])]: _*)))
      case _ => Left("reads failed: seq must be scala.xml.Node")
    }
    
    override def writesAttribute(__obj: IPXACT2022ScalaCases.Struct, __scope: scala.xml.NamespaceBinding): scala.xml.MetaData = {
      var attr: scala.xml.MetaData  = scala.xml.Null
      __obj.attributes.toList map {
        case ("@direction", _) => __obj.direction foreach { x => attr = scala.xml.Attribute(null, "direction", x.toString, attr) }
        case (key, x) => attr = scala.xml.Attribute((x.namespace map { __scope.getPrefix(_) }).orNull, x.key.orNull, x.value.toString, attr)
      }
      attr
    }

    def writesChildNodes(__obj: IPXACT2022ScalaCases.Struct, __scope: scala.xml.NamespaceBinding): Seq[scala.xml.Node] =
      Nil

  }

  trait DefaultIPXACT2022ScalaCases_UnionFormat extends IPXACT2022scalaxb.XMLFormat[IPXACT2022ScalaCases.Union] with IPXACT2022scalaxb.CanWriteChildNodes[IPXACT2022ScalaCases.Union] {
    val targetNamespace: Option[String] = Some("http://www.accellera.org/XMLSchema/IPXACT/1685-2022")
    def reads(seq: scala.xml.NodeSeq, stack: List[IPXACT2022scalaxb.ElemName]): Either[String, IPXACT2022ScalaCases.Union] = seq match {
      case node: scala.xml.Node => Right(IPXACT2022ScalaCases.Union(scala.collection.immutable.ListMap(List(
        (node \ "@direction").headOption map { x => IPXACT2022scalaxb.DataRecord(x, node, IPXACT2022scalaxb.fromXML[IPXACT2022ScalaCases.ComponentPortDirectionType](x, IPXACT2022scalaxb.ElemName(node) :: stack)) } map { "@direction" -> _ }
        ).flatten[(String, IPXACT2022scalaxb.DataRecord[Any])]: _*)))
      case _ => Left("reads failed: seq must be scala.xml.Node")
    }
    
    override def writesAttribute(__obj: IPXACT2022ScalaCases.Union, __scope: scala.xml.NamespaceBinding): scala.xml.MetaData = {
      var attr: scala.xml.MetaData  = scala.xml.Null
      __obj.attributes.toList map {
        case ("@direction", _) => __obj.direction foreach { x => attr = scala.xml.Attribute(null, "direction", x.toString, attr) }
        case (key, x) => attr = scala.xml.Attribute((x.namespace map { __scope.getPrefix(_) }).orNull, x.key.orNull, x.value.toString, attr)
      }
      attr
    }

    def writesChildNodes(__obj: IPXACT2022ScalaCases.Union, __scope: scala.xml.NamespaceBinding): Seq[scala.xml.Node] =
      Nil

  }

  trait DefaultIPXACT2022ScalaCases_InterfaceFormat extends IPXACT2022scalaxb.XMLFormat[IPXACT2022ScalaCases.Interface] with IPXACT2022scalaxb.CanWriteChildNodes[IPXACT2022ScalaCases.Interface] {
    val targetNamespace: Option[String] = Some("http://www.accellera.org/XMLSchema/IPXACT/1685-2022")
    def reads(seq: scala.xml.NodeSeq, stack: List[IPXACT2022scalaxb.ElemName]): Either[String, IPXACT2022ScalaCases.Interface] = seq match {
      case node: scala.xml.Node => Right(IPXACT2022ScalaCases.Interface(scala.collection.immutable.ListMap(List(
        (node \ "@phantom").headOption map { x => IPXACT2022scalaxb.DataRecord(x, node, IPXACT2022scalaxb.fromXML[Boolean](x, IPXACT2022scalaxb.ElemName(node) :: stack)) } map { "@phantom" -> _ }
        ).flatten[(String, IPXACT2022scalaxb.DataRecord[Any])]: _*)))
      case _ => Left("reads failed: seq must be scala.xml.Node")
    }
    
    override def writesAttribute(__obj: IPXACT2022ScalaCases.Interface, __scope: scala.xml.NamespaceBinding): scala.xml.MetaData = {
      var attr: scala.xml.MetaData  = scala.xml.Null
      __obj.attributes.toList map {
        case ("@phantom", _) => __obj.phantom foreach { x => attr = scala.xml.Attribute(null, "phantom", x.toString, attr) }
        case (key, x) => attr = scala.xml.Attribute((x.namespace map { __scope.getPrefix(_) }).orNull, x.key.orNull, x.value.toString, attr)
      }
      attr
    }

    def writesChildNodes(__obj: IPXACT2022ScalaCases.Interface, __scope: scala.xml.NamespaceBinding): Seq[scala.xml.Node] =
      Nil

  }


  trait IPXACT2022ScalaCases_StructTypeGroupGroupFormat extends IPXACT2022scalaxb.AnyElemNameParser {
    def parseStructTypeGroupGroup(node: scala.xml.Node, stack: List[IPXACT2022scalaxb.ElemName]): Parser[IPXACT2022scalaxb.DataRecord[IPXACT2022ScalaCases.StructTypeGroupOption]] =
      (((IPXACT2022scalaxb.ElemName(Some("http://www.accellera.org/XMLSchema/IPXACT/1685-2022"), "struct")) ^^
      (x => IPXACT2022scalaxb.DataRecord(x.namespace, Some(x.name), IPXACT2022scalaxb.fromXML[IPXACT2022ScalaCases.Struct](x, IPXACT2022scalaxb.ElemName(node) :: stack)))) |
      ((IPXACT2022scalaxb.ElemName(Some("http://www.accellera.org/XMLSchema/IPXACT/1685-2022"), "union")) ^^
      (x => IPXACT2022scalaxb.DataRecord(x.namespace, Some(x.name), IPXACT2022scalaxb.fromXML[IPXACT2022ScalaCases.Union](x, IPXACT2022scalaxb.ElemName(node) :: stack)))) |
      ((IPXACT2022scalaxb.ElemName(Some("http://www.accellera.org/XMLSchema/IPXACT/1685-2022"), "interface")) ^^
      (x => IPXACT2022scalaxb.DataRecord(x.namespace, Some(x.name), IPXACT2022scalaxb.fromXML[IPXACT2022ScalaCases.Interface](x, IPXACT2022scalaxb.ElemName(node) :: stack)))))
  
    def parseStructTypeGroupGroup(node: scala.xml.Node, stack: List[IPXACT2022scalaxb.ElemName], wrap: Boolean): Parser[IPXACT2022scalaxb.DataRecord[IPXACT2022ScalaCases.StructTypeGroupOption]] =
      (((IPXACT2022scalaxb.ElemName(Some("http://www.accellera.org/XMLSchema/IPXACT/1685-2022"), "struct")) ^^
      (x => IPXACT2022scalaxb.DataRecord(x.namespace, Some(x.name), IPXACT2022scalaxb.fromXML[IPXACT2022ScalaCases.Struct](x, IPXACT2022scalaxb.ElemName(node) :: stack)))) |
      ((IPXACT2022scalaxb.ElemName(Some("http://www.accellera.org/XMLSchema/IPXACT/1685-2022"), "union")) ^^
      (x => IPXACT2022scalaxb.DataRecord(x.namespace, Some(x.name), IPXACT2022scalaxb.fromXML[IPXACT2022ScalaCases.Union](x, IPXACT2022scalaxb.ElemName(node) :: stack)))) |
      ((IPXACT2022scalaxb.ElemName(Some("http://www.accellera.org/XMLSchema/IPXACT/1685-2022"), "interface")) ^^
      (x => IPXACT2022scalaxb.DataRecord(x.namespace, Some(x.name), IPXACT2022scalaxb.fromXML[IPXACT2022ScalaCases.Interface](x, IPXACT2022scalaxb.ElemName(node) :: stack)))))
    
    def parsemixedStructTypeGroupGroup(node: scala.xml.Node, stack: List[IPXACT2022scalaxb.ElemName]): Parser[Seq[IPXACT2022scalaxb.DataRecord[Any]]] =
      (((((IPXACT2022scalaxb.ElemName(Some("http://www.accellera.org/XMLSchema/IPXACT/1685-2022"), "struct")) ^^
      (x => IPXACT2022scalaxb.DataRecord(x.namespace, Some(x.name), IPXACT2022scalaxb.fromXML[IPXACT2022ScalaCases.Struct](x, IPXACT2022scalaxb.ElemName(node) :: stack)))) ~
      optTextRecord) ^^ 
        { case p1 ~ p2 => Seq.concat(Seq(p1),
        p2.toList) }) ||| 
      ((((IPXACT2022scalaxb.ElemName(Some("http://www.accellera.org/XMLSchema/IPXACT/1685-2022"), "union")) ^^
      (x => IPXACT2022scalaxb.DataRecord(x.namespace, Some(x.name), IPXACT2022scalaxb.fromXML[IPXACT2022ScalaCases.Union](x, IPXACT2022scalaxb.ElemName(node) :: stack)))) ~
      optTextRecord) ^^ 
        { case p1 ~ p2 => Seq.concat(Seq(p1),
        p2.toList) }) ||| 
      ((((IPXACT2022scalaxb.ElemName(Some("http://www.accellera.org/XMLSchema/IPXACT/1685-2022"), "interface")) ^^
      (x => IPXACT2022scalaxb.DataRecord(x.namespace, Some(x.name), IPXACT2022scalaxb.fromXML[IPXACT2022ScalaCases.Interface](x, IPXACT2022scalaxb.ElemName(node) :: stack)))) ~
      optTextRecord) ^^ 
        { case p1 ~ p2 => Seq.concat(Seq(p1),
        p2.toList) }))
  }

  trait DefaultIPXACT2022ScalaCases_ClockDriverFormat extends IPXACT2022scalaxb.ElemNameParser[IPXACT2022ScalaCases.ClockDriver] {
    val targetNamespace: Option[String] = Some("http://www.accellera.org/XMLSchema/IPXACT/1685-2022")
    
    def parser(node: scala.xml.Node, stack: List[IPXACT2022scalaxb.ElemName]): Parser[IPXACT2022ScalaCases.ClockDriver] =
      phrase((IPXACT2022scalaxb.ElemName(Some("http://www.accellera.org/XMLSchema/IPXACT/1685-2022"), "clockPeriod")) ~
      (IPXACT2022scalaxb.ElemName(Some("http://www.accellera.org/XMLSchema/IPXACT/1685-2022"), "clockPulseOffset")) ~
      (IPXACT2022scalaxb.ElemName(Some("http://www.accellera.org/XMLSchema/IPXACT/1685-2022"), "clockPulseValue")) ~
      (IPXACT2022scalaxb.ElemName(Some("http://www.accellera.org/XMLSchema/IPXACT/1685-2022"), "clockPulseDuration")) ^^
      { case p1 ~ p2 ~ p3 ~ p4 =>
      IPXACT2022ScalaCases.ClockDriver(IPXACT2022scalaxb.fromXML[IPXACT2022ScalaCases.ClockPeriod](p1, IPXACT2022scalaxb.ElemName(node) :: stack),
        IPXACT2022scalaxb.fromXML[IPXACT2022ScalaCases.ClockPulseOffset](p2, IPXACT2022scalaxb.ElemName(node) :: stack),
        IPXACT2022scalaxb.fromXML[IPXACT2022ScalaCases.UnsignedBitExpression](p3, IPXACT2022scalaxb.ElemName(node) :: stack),
        IPXACT2022scalaxb.fromXML[IPXACT2022ScalaCases.ClockPulseDuration](p4, IPXACT2022scalaxb.ElemName(node) :: stack),
        scala.collection.immutable.ListMap(List(
        (node \ "@{http://www.w3.org/XML/1998/namespace}id").headOption map { x => IPXACT2022scalaxb.DataRecord(x, node, IPXACT2022scalaxb.fromXML[String](x, IPXACT2022scalaxb.ElemName(node) :: stack)) } map { "@{http://www.w3.org/XML/1998/namespace}id" -> _ },
        (node \ "@clockName").headOption map { x => IPXACT2022scalaxb.DataRecord(x, node, IPXACT2022scalaxb.fromXML[String](x, IPXACT2022scalaxb.ElemName(node) :: stack)) } map { "@clockName" -> _ }
        ).flatten[(String, IPXACT2022scalaxb.DataRecord[Any])]: _*)) })
    
    override def writesAttribute(__obj: IPXACT2022ScalaCases.ClockDriver, __scope: scala.xml.NamespaceBinding): scala.xml.MetaData = {
      var attr: scala.xml.MetaData  = scala.xml.Null
      __obj.attributes.toList map {
        case ("@{http://www.w3.org/XML/1998/namespace}id", _) => __obj.xmlid foreach { x => attr = scala.xml.Attribute(__scope.getPrefix("http://www.w3.org/XML/1998/namespace"), "id", x.toString, attr) }
        case ("@clockName", _) => __obj.clockName foreach { x => attr = scala.xml.Attribute(null, "clockName", x.toString, attr) }
        case (key, x) => attr = scala.xml.Attribute((x.namespace map { __scope.getPrefix(_) }).orNull, x.key.orNull, x.value.toString, attr)
      }
      attr
    }

    def writesChildNodes(__obj: IPXACT2022ScalaCases.ClockDriver, __scope: scala.xml.NamespaceBinding): Seq[scala.xml.Node] =
      Seq.concat(IPXACT2022scalaxb.toXML[IPXACT2022ScalaCases.ClockPeriod](__obj.clockPeriod, Some("http://www.accellera.org/XMLSchema/IPXACT/1685-2022"), Some("clockPeriod"), __scope, false),
        IPXACT2022scalaxb.toXML[IPXACT2022ScalaCases.ClockPulseOffset](__obj.clockPulseOffset, Some("http://www.accellera.org/XMLSchema/IPXACT/1685-2022"), Some("clockPulseOffset"), __scope, false),
        IPXACT2022scalaxb.toXML[IPXACT2022ScalaCases.UnsignedBitExpression](__obj.clockPulseValue, Some("http://www.accellera.org/XMLSchema/IPXACT/1685-2022"), Some("clockPulseValue"), __scope, false),
        IPXACT2022scalaxb.toXML[IPXACT2022ScalaCases.ClockPulseDuration](__obj.clockPulseDuration, Some("http://www.accellera.org/XMLSchema/IPXACT/1685-2022"), Some("clockPulseDuration"), __scope, false))

  }

  trait DefaultIPXACT2022ScalaCases_SingleShotOffsetFormat extends IPXACT2022scalaxb.ElemNameParser[IPXACT2022ScalaCases.SingleShotOffset] {
    val targetNamespace: Option[String] = Some("http://www.accellera.org/XMLSchema/IPXACT/1685-2022")
    
    def parser(node: scala.xml.Node, stack: List[IPXACT2022scalaxb.ElemName]): Parser[IPXACT2022ScalaCases.SingleShotOffset] =
      phrase((IPXACT2022scalaxb.ElemName(None, "value")) ^^
      { case p1 =>
      IPXACT2022ScalaCases.SingleShotOffset(IPXACT2022scalaxb.fromXML[String](p1, IPXACT2022scalaxb.ElemName(node) :: stack),
        scala.collection.immutable.ListMap(List(
        (node \ "@minimum").headOption map { x => IPXACT2022scalaxb.DataRecord(x, node, IPXACT2022scalaxb.fromXML[Double](x, IPXACT2022scalaxb.ElemName(node) :: stack)) } map { "@minimum" -> _ },
        (node \ "@maximum").headOption map { x => IPXACT2022scalaxb.DataRecord(x, node, IPXACT2022scalaxb.fromXML[Double](x, IPXACT2022scalaxb.ElemName(node) :: stack)) } map { "@maximum" -> _ },
        (node \ "@units").headOption map { x => IPXACT2022scalaxb.DataRecord(x, node, IPXACT2022scalaxb.fromXML[IPXACT2022ScalaCases.DelayValueUnitType](x, IPXACT2022scalaxb.ElemName(node) :: stack)) } orElse Some(IPXACT2022scalaxb.DataRecord(None, None, IPXACT2022scalaxb.fromXML[IPXACT2022ScalaCases.DelayValueUnitType](scala.xml.Text("ns"), IPXACT2022scalaxb.ElemName(node) :: stack))) map { "@units" -> _ }
        ).flatten[(String, IPXACT2022scalaxb.DataRecord[Any])] ::: (node match {
          case elem: scala.xml.Elem =>
            elem.attributes.toList flatMap {
              case scala.xml.UnprefixedAttribute(key, value, _) if key == "minimum" => Nil
              case scala.xml.UnprefixedAttribute(key, value, _) if key == "maximum" => Nil
              case scala.xml.UnprefixedAttribute(key, value, _) if key == "units" => Nil
              case scala.xml.UnprefixedAttribute(key, value, _) =>
                List(("@" + key, IPXACT2022scalaxb.DataRecord(None, Some(key), value.text)))
              case scala.xml.PrefixedAttribute(pre, key, value, _) =>
                val ns = elem.scope.getURI(pre)
                List(("@{" + ns + "}" + key, IPXACT2022scalaxb.DataRecord(Option[String](ns), Some(key), value.text)))
              case _ => Nil
            }
          case _ => Nil
        }): _*)) })
    
    override def writesAttribute(__obj: IPXACT2022ScalaCases.SingleShotOffset, __scope: scala.xml.NamespaceBinding): scala.xml.MetaData = {
      var attr: scala.xml.MetaData  = scala.xml.Null
      __obj.attributes.toList map {
        case ("@minimum", _) => __obj.minimum foreach { x => attr = scala.xml.Attribute(null, "minimum", x.toString, attr) }
        case ("@maximum", _) => __obj.maximum foreach { x => attr = scala.xml.Attribute(null, "maximum", x.toString, attr) }
        case ("@units", _) => if (__obj.units.toString != "ns") attr = scala.xml.Attribute(null, "units", __obj.units.toString, attr)
        case (key, x) => attr = scala.xml.Attribute((x.namespace map { __scope.getPrefix(_) }).orNull, x.key.orNull, x.value.toString, attr)
      }
      attr
    }

    def writesChildNodes(__obj: IPXACT2022ScalaCases.SingleShotOffset, __scope: scala.xml.NamespaceBinding): Seq[scala.xml.Node] =
      (IPXACT2022scalaxb.toXML[String](__obj.value, None, Some("value"), __scope, false))
  }

  trait DefaultIPXACT2022ScalaCases_SingleShotValueFormat extends IPXACT2022scalaxb.ElemNameParser[IPXACT2022ScalaCases.SingleShotValue] {
    val targetNamespace: Option[String] = Some("http://www.accellera.org/XMLSchema/IPXACT/1685-2022")
    
    def parser(node: scala.xml.Node, stack: List[IPXACT2022scalaxb.ElemName]): Parser[IPXACT2022ScalaCases.SingleShotValue] =
      phrase((IPXACT2022scalaxb.ElemName(None, "value")) ^^
      { case p1 =>
      IPXACT2022ScalaCases.SingleShotValue(IPXACT2022scalaxb.fromXML[String](p1, IPXACT2022scalaxb.ElemName(node) :: stack),
        scala.collection.immutable.ListMap((node match {
          case elem: scala.xml.Elem =>
            elem.attributes.toList flatMap {
              
              case scala.xml.UnprefixedAttribute(key, value, _) =>
                List(("@" + key, IPXACT2022scalaxb.DataRecord(None, Some(key), value.text)))
              case scala.xml.PrefixedAttribute(pre, key, value, _) =>
                val ns = elem.scope.getURI(pre)
                List(("@{" + ns + "}" + key, IPXACT2022scalaxb.DataRecord(Option[String](ns), Some(key), value.text)))
              case _ => Nil
            }
          case _ => Nil
        }): _*)) })
    
    override def writesAttribute(__obj: IPXACT2022ScalaCases.SingleShotValue, __scope: scala.xml.NamespaceBinding): scala.xml.MetaData = {
      var attr: scala.xml.MetaData  = scala.xml.Null
      __obj.attributes.toList map {
        case (key, x) => attr = scala.xml.Attribute((x.namespace map { __scope.getPrefix(_) }).orNull, x.key.orNull, x.value.toString, attr)
      }
      attr
    }
    def writesChildNodes(__obj: IPXACT2022ScalaCases.SingleShotValue, __scope: scala.xml.NamespaceBinding): Seq[scala.xml.Node] =
      (IPXACT2022scalaxb.toXML[String](__obj.value, None, Some("value"), __scope, false))
  }

  trait DefaultIPXACT2022ScalaCases_SingleShotDurationFormat extends IPXACT2022scalaxb.ElemNameParser[IPXACT2022ScalaCases.SingleShotDuration] {
    val targetNamespace: Option[String] = Some("http://www.accellera.org/XMLSchema/IPXACT/1685-2022")
    
    def parser(node: scala.xml.Node, stack: List[IPXACT2022scalaxb.ElemName]): Parser[IPXACT2022ScalaCases.SingleShotDuration] =
      phrase((IPXACT2022scalaxb.ElemName(None, "value")) ^^
      { case p1 =>
      IPXACT2022ScalaCases.SingleShotDuration(IPXACT2022scalaxb.fromXML[String](p1, IPXACT2022scalaxb.ElemName(node) :: stack),
        scala.collection.immutable.ListMap(List(
        (node \ "@minimum").headOption map { x => IPXACT2022scalaxb.DataRecord(x, node, IPXACT2022scalaxb.fromXML[Double](x, IPXACT2022scalaxb.ElemName(node) :: stack)) } map { "@minimum" -> _ },
        (node \ "@maximum").headOption map { x => IPXACT2022scalaxb.DataRecord(x, node, IPXACT2022scalaxb.fromXML[Double](x, IPXACT2022scalaxb.ElemName(node) :: stack)) } map { "@maximum" -> _ },
        (node \ "@units").headOption map { x => IPXACT2022scalaxb.DataRecord(x, node, IPXACT2022scalaxb.fromXML[IPXACT2022ScalaCases.DelayValueUnitType](x, IPXACT2022scalaxb.ElemName(node) :: stack)) } orElse Some(IPXACT2022scalaxb.DataRecord(None, None, IPXACT2022scalaxb.fromXML[IPXACT2022ScalaCases.DelayValueUnitType](scala.xml.Text("ns"), IPXACT2022scalaxb.ElemName(node) :: stack))) map { "@units" -> _ }
        ).flatten[(String, IPXACT2022scalaxb.DataRecord[Any])] ::: (node match {
          case elem: scala.xml.Elem =>
            elem.attributes.toList flatMap {
              case scala.xml.UnprefixedAttribute(key, value, _) if key == "minimum" => Nil
              case scala.xml.UnprefixedAttribute(key, value, _) if key == "maximum" => Nil
              case scala.xml.UnprefixedAttribute(key, value, _) if key == "units" => Nil
              case scala.xml.UnprefixedAttribute(key, value, _) =>
                List(("@" + key, IPXACT2022scalaxb.DataRecord(None, Some(key), value.text)))
              case scala.xml.PrefixedAttribute(pre, key, value, _) =>
                val ns = elem.scope.getURI(pre)
                List(("@{" + ns + "}" + key, IPXACT2022scalaxb.DataRecord(Option[String](ns), Some(key), value.text)))
              case _ => Nil
            }
          case _ => Nil
        }): _*)) })
    
    override def writesAttribute(__obj: IPXACT2022ScalaCases.SingleShotDuration, __scope: scala.xml.NamespaceBinding): scala.xml.MetaData = {
      var attr: scala.xml.MetaData  = scala.xml.Null
      __obj.attributes.toList map {
        case ("@minimum", _) => __obj.minimum foreach { x => attr = scala.xml.Attribute(null, "minimum", x.toString, attr) }
        case ("@maximum", _) => __obj.maximum foreach { x => attr = scala.xml.Attribute(null, "maximum", x.toString, attr) }
        case ("@units", _) => if (__obj.units.toString != "ns") attr = scala.xml.Attribute(null, "units", __obj.units.toString, attr)
        case (key, x) => attr = scala.xml.Attribute((x.namespace map { __scope.getPrefix(_) }).orNull, x.key.orNull, x.value.toString, attr)
      }
      attr
    }

    def writesChildNodes(__obj: IPXACT2022ScalaCases.SingleShotDuration, __scope: scala.xml.NamespaceBinding): Seq[scala.xml.Node] =
      (IPXACT2022scalaxb.toXML[String](__obj.value, None, Some("value"), __scope, false))
  }

  trait DefaultIPXACT2022ScalaCases_SingleShotDriverFormat extends IPXACT2022scalaxb.ElemNameParser[IPXACT2022ScalaCases.SingleShotDriver] {
    val targetNamespace: Option[String] = Some("http://www.accellera.org/XMLSchema/IPXACT/1685-2022")
    
    def parser(node: scala.xml.Node, stack: List[IPXACT2022scalaxb.ElemName]): Parser[IPXACT2022ScalaCases.SingleShotDriver] =
      phrase((IPXACT2022scalaxb.ElemName(Some("http://www.accellera.org/XMLSchema/IPXACT/1685-2022"), "singleShotOffset")) ~
      (IPXACT2022scalaxb.ElemName(Some("http://www.accellera.org/XMLSchema/IPXACT/1685-2022"), "singleShotValue")) ~
      (IPXACT2022scalaxb.ElemName(Some("http://www.accellera.org/XMLSchema/IPXACT/1685-2022"), "singleShotDuration")) ^^
      { case p1 ~ p2 ~ p3 =>
      IPXACT2022ScalaCases.SingleShotDriver(IPXACT2022scalaxb.fromXML[IPXACT2022ScalaCases.SingleShotOffset](p1, IPXACT2022scalaxb.ElemName(node) :: stack),
        IPXACT2022scalaxb.fromXML[IPXACT2022ScalaCases.SingleShotValue](p2, IPXACT2022scalaxb.ElemName(node) :: stack),
        IPXACT2022scalaxb.fromXML[IPXACT2022ScalaCases.SingleShotDuration](p3, IPXACT2022scalaxb.ElemName(node) :: stack)) })
    
    def writesChildNodes(__obj: IPXACT2022ScalaCases.SingleShotDriver, __scope: scala.xml.NamespaceBinding): Seq[scala.xml.Node] =
      Seq.concat(IPXACT2022scalaxb.toXML[IPXACT2022ScalaCases.SingleShotOffset](__obj.singleShotOffset, Some("http://www.accellera.org/XMLSchema/IPXACT/1685-2022"), Some("singleShotOffset"), __scope, false),
        IPXACT2022scalaxb.toXML[IPXACT2022ScalaCases.SingleShotValue](__obj.singleShotValue, Some("http://www.accellera.org/XMLSchema/IPXACT/1685-2022"), Some("singleShotValue"), __scope, false),
        IPXACT2022scalaxb.toXML[IPXACT2022ScalaCases.SingleShotDuration](__obj.singleShotDuration, Some("http://www.accellera.org/XMLSchema/IPXACT/1685-2022"), Some("singleShotDuration"), __scope, false))

  }

  def buildIPXACT2022ScalaCases_DriverTypeTypeFormat = new DefaultIPXACT2022ScalaCases_DriverTypeTypeFormat {}
  trait DefaultIPXACT2022ScalaCases_DriverTypeTypeFormat extends IPXACT2022scalaxb.XMLFormat[IPXACT2022ScalaCases.DriverTypeType] {
    val targetNamespace: Option[String] = Some("http://www.accellera.org/XMLSchema/IPXACT/1685-2022")
    
    def fromString(value: String, scope: scala.xml.NamespaceBinding): IPXACT2022ScalaCases.DriverTypeType =
        (fromString0(value, scope)).apply(IPXACT2022scalaxb.fromXML[String](scala.xml.Text(value)))

    private def fromString0(value: String, scope: scala.xml.NamespaceBinding): PartialFunction[Any, IPXACT2022ScalaCases.DriverTypeType] = {
      case x: String if x == IPXACT2022scalaxb.fromXML[String](scala.xml.Text("clock")) => IPXACT2022ScalaCases.Clock
      case x: String if x == IPXACT2022scalaxb.fromXML[String](scala.xml.Text("singleShot")) => IPXACT2022ScalaCases.SingleShot
      case x: String if x == IPXACT2022scalaxb.fromXML[String](scala.xml.Text("any")) => IPXACT2022ScalaCases.AnyType

    }



    def reads(seq: scala.xml.NodeSeq, stack: List[IPXACT2022scalaxb.ElemName]): Either[String, IPXACT2022ScalaCases.DriverTypeType] = seq match {
      case elem: scala.xml.Elem => Right(fromString(elem.text, elem.scope))
      case _ => Right(fromString(seq.text, scala.xml.TopScope))
    }
    
    def writes(__obj: IPXACT2022ScalaCases.DriverTypeType, __namespace: Option[String], __elementLabel: Option[String],
        __scope: scala.xml.NamespaceBinding, __typeAttribute: Boolean): scala.xml.NodeSeq =
      scala.xml.Elem(IPXACT2022scalaxb.Helper.getPrefix(__namespace, __scope).orNull,
        __elementLabel getOrElse { sys.error("missing element label.") },
        scala.xml.Null, __scope, true, scala.xml.Text(__obj.toString))
  }
  trait DefaultIPXACT2022ScalaCases_RequiresDriverFormat extends IPXACT2022scalaxb.XMLFormat[IPXACT2022ScalaCases.RequiresDriver] with IPXACT2022scalaxb.CanWriteChildNodes[IPXACT2022ScalaCases.RequiresDriver] {
    val targetNamespace: Option[String] = Some("http://www.accellera.org/XMLSchema/IPXACT/1685-2022")
    def reads(seq: scala.xml.NodeSeq, stack: List[IPXACT2022scalaxb.ElemName]): Either[String, IPXACT2022ScalaCases.RequiresDriver] = seq match {
      case node: scala.xml.Node => Right(IPXACT2022ScalaCases.RequiresDriver(IPXACT2022scalaxb.fromXML[Boolean](node, IPXACT2022scalaxb.ElemName(node) :: stack),
        scala.collection.immutable.ListMap(List(
        (node \ "@driverType").headOption map { x => IPXACT2022scalaxb.DataRecord(x, node, IPXACT2022scalaxb.fromXML[IPXACT2022ScalaCases.DriverTypeType](x, IPXACT2022scalaxb.ElemName(node) :: stack)) } orElse Some(IPXACT2022scalaxb.DataRecord(None, None, IPXACT2022scalaxb.fromXML[IPXACT2022ScalaCases.DriverTypeType](scala.xml.Text("any"), IPXACT2022scalaxb.ElemName(node) :: stack))) map { "@driverType" -> _ }
        ).flatten[(String, IPXACT2022scalaxb.DataRecord[Any])]: _*)))
      case _ => Left("reads failed: seq must be scala.xml.Node")
    }
    
    override def writesAttribute(__obj: IPXACT2022ScalaCases.RequiresDriver, __scope: scala.xml.NamespaceBinding): scala.xml.MetaData = {
      var attr: scala.xml.MetaData  = scala.xml.Null
      __obj.attributes.toList map {
        case ("@driverType", _) => if (__obj.driverType.toString != "any") attr = scala.xml.Attribute(null, "driverType", __obj.driverType.toString, attr)
        case (key, x) => attr = scala.xml.Attribute((x.namespace map { __scope.getPrefix(_) }).orNull, x.key.orNull, x.value.toString, attr)
      }
      attr
    }

    def writesChildNodes(__obj: IPXACT2022ScalaCases.RequiresDriver, __scope: scala.xml.NamespaceBinding): Seq[scala.xml.Node] =
      Seq(scala.xml.Text(__obj.value.toString))

  }

  trait DefaultIPXACT2022ScalaCases_ViewRefFormat extends IPXACT2022scalaxb.XMLFormat[IPXACT2022ScalaCases.ViewRef] with IPXACT2022scalaxb.CanWriteChildNodes[IPXACT2022ScalaCases.ViewRef] {
    val targetNamespace: Option[String] = Some("http://www.accellera.org/XMLSchema/IPXACT/1685-2022")
    def reads(seq: scala.xml.NodeSeq, stack: List[IPXACT2022scalaxb.ElemName]): Either[String, IPXACT2022ScalaCases.ViewRef] = seq match {
      case node: scala.xml.Node => Right(IPXACT2022ScalaCases.ViewRef(IPXACT2022scalaxb.fromXML[String](node, IPXACT2022scalaxb.ElemName(node) :: stack),
        scala.collection.immutable.ListMap(List(
        (node \ "@{http://www.w3.org/XML/1998/namespace}id").headOption map { x => IPXACT2022scalaxb.DataRecord(x, node, IPXACT2022scalaxb.fromXML[String](x, IPXACT2022scalaxb.ElemName(node) :: stack)) } map { "@{http://www.w3.org/XML/1998/namespace}id" -> _ }
        ).flatten[(String, IPXACT2022scalaxb.DataRecord[Any])]: _*)))
      case _ => Left("reads failed: seq must be scala.xml.Node")
    }
    
    override def writesAttribute(__obj: IPXACT2022ScalaCases.ViewRef, __scope: scala.xml.NamespaceBinding): scala.xml.MetaData = {
      var attr: scala.xml.MetaData  = scala.xml.Null
      __obj.attributes.toList map {
        case ("@{http://www.w3.org/XML/1998/namespace}id", _) => __obj.xmlid foreach { x => attr = scala.xml.Attribute(__scope.getPrefix("http://www.w3.org/XML/1998/namespace"), "id", x.toString, attr) }
        case (key, x) => attr = scala.xml.Attribute((x.namespace map { __scope.getPrefix(_) }).orNull, x.key.orNull, x.value.toString, attr)
      }
      attr
    }

    def writesChildNodes(__obj: IPXACT2022ScalaCases.ViewRef, __scope: scala.xml.NamespaceBinding): Seq[scala.xml.Node] =
      Seq(scala.xml.Text(__obj.value.toString))

  }

  trait DefaultIPXACT2022ScalaCases_DriverTypeFormat extends IPXACT2022scalaxb.ElemNameParser[IPXACT2022ScalaCases.DriverType] {
    val targetNamespace: Option[String] = Some("http://www.accellera.org/XMLSchema/IPXACT/1685-2022")
    
    override def typeName: Option[String] = Some("driverType")

    def parser(node: scala.xml.Node, stack: List[IPXACT2022scalaxb.ElemName]): Parser[IPXACT2022ScalaCases.DriverType] =
      phrase(opt((opt(IPXACT2022scalaxb.ElemName(Some("http://www.accellera.org/XMLSchema/IPXACT/1685-2022"), "range")) ~
      safeRep(IPXACT2022scalaxb.ElemName(Some("http://www.accellera.org/XMLSchema/IPXACT/1685-2022"), "viewRef")) ~
      (((IPXACT2022scalaxb.ElemName(Some("http://www.accellera.org/XMLSchema/IPXACT/1685-2022"), "defaultValue")) ^^
      (x => IPXACT2022scalaxb.DataRecord(x.namespace, Some(x.name), IPXACT2022scalaxb.fromXML[IPXACT2022ScalaCases.QualifiedExpression](x, IPXACT2022scalaxb.ElemName(node) :: stack)))) |
      ((IPXACT2022scalaxb.ElemName(Some("http://www.accellera.org/XMLSchema/IPXACT/1685-2022"), "clockDriver")) ^^
      (x => IPXACT2022scalaxb.DataRecord(x.namespace, Some(x.name), IPXACT2022scalaxb.fromXML[IPXACT2022ScalaCases.ClockDriver](x, IPXACT2022scalaxb.ElemName(node) :: stack)))) |
      ((IPXACT2022scalaxb.ElemName(Some("http://www.accellera.org/XMLSchema/IPXACT/1685-2022"), "singleShotDriver")) ^^
      (x => IPXACT2022scalaxb.DataRecord(x.namespace, Some(x.name), IPXACT2022scalaxb.fromXML[IPXACT2022ScalaCases.SingleShotDriver](x, IPXACT2022scalaxb.ElemName(node) :: stack)))))) ^^
        { case p1 ~ p2 ~ p3 => IPXACT2022ScalaCases.DriverTypeSequence1(p1.headOption map { IPXACT2022scalaxb.fromXML[IPXACT2022ScalaCases.RangeType](_, IPXACT2022scalaxb.ElemName(node) :: stack) },
        p2 map { IPXACT2022scalaxb.fromXML[IPXACT2022ScalaCases.ViewRef](_, IPXACT2022scalaxb.ElemName(node) :: stack) },
        p3) }) ^^
      { case p1 =>
      IPXACT2022ScalaCases.DriverType(p1,
        scala.collection.immutable.ListMap(List(
        (node \ "@{http://www.w3.org/XML/1998/namespace}id").headOption map { x => IPXACT2022scalaxb.DataRecord(x, node, IPXACT2022scalaxb.fromXML[String](x, IPXACT2022scalaxb.ElemName(node) :: stack)) } map { "@{http://www.w3.org/XML/1998/namespace}id" -> _ }
        ).flatten[(String, IPXACT2022scalaxb.DataRecord[Any])]: _*)) })
    
    override def writesAttribute(__obj: IPXACT2022ScalaCases.DriverType, __scope: scala.xml.NamespaceBinding): scala.xml.MetaData = {
      var attr: scala.xml.MetaData  = scala.xml.Null
      __obj.attributes.toList map {
        case ("@{http://www.w3.org/XML/1998/namespace}id", _) => __obj.xmlid foreach { x => attr = scala.xml.Attribute(__scope.getPrefix("http://www.w3.org/XML/1998/namespace"), "id", x.toString, attr) }
        case (key, x) => attr = scala.xml.Attribute((x.namespace map { __scope.getPrefix(_) }).orNull, x.key.orNull, x.value.toString, attr)
      }
      attr
    }

    def writesChildNodes(__obj: IPXACT2022ScalaCases.DriverType, __scope: scala.xml.NamespaceBinding): Seq[scala.xml.Node] =
      (__obj.drivertypesequence1 map { IPXACT2022scalaxb.toXML[IPXACT2022ScalaCases.DriverTypeSequence1](_, None, Some("drivertypesequence1"), __scope, false) } getOrElse {Nil})
  }

  trait DefaultIPXACT2022ScalaCases_DriverTypeSequence1Format extends IPXACT2022scalaxb.XMLFormat[IPXACT2022ScalaCases.DriverTypeSequence1] {
    def reads(seq: scala.xml.NodeSeq, stack: List[IPXACT2022scalaxb.ElemName]): Either[String, IPXACT2022ScalaCases.DriverTypeSequence1] = Left("don't call me.")
    
    def writes(__obj: IPXACT2022ScalaCases.DriverTypeSequence1, __namespace: Option[String], __elementLabel: Option[String],
        __scope: scala.xml.NamespaceBinding, __typeAttribute: Boolean): scala.xml.NodeSeq =
      Seq.concat(__obj.range map { IPXACT2022scalaxb.toXML[IPXACT2022ScalaCases.RangeType](_, Some("http://www.accellera.org/XMLSchema/IPXACT/1685-2022"), Some("range"), __scope, false) } getOrElse {Nil},
        __obj.viewRef flatMap { IPXACT2022scalaxb.toXML[IPXACT2022ScalaCases.ViewRef](_, Some("http://www.accellera.org/XMLSchema/IPXACT/1685-2022"), Some("viewRef"), __scope, false) },
        (Some(__obj.drivertypeoption) map {x => IPXACT2022scalaxb.toXML[IPXACT2022scalaxb.DataRecord[IPXACT2022ScalaCases.DriverTypeOption]](x, x.namespace, x.key, __scope, false)}).get)


  }

  trait DefaultIPXACT2022ScalaCases_DriversFormat extends IPXACT2022scalaxb.ElemNameParser[IPXACT2022ScalaCases.Drivers] {
    val targetNamespace: Option[String] = Some("http://www.accellera.org/XMLSchema/IPXACT/1685-2022")
    
    def parser(node: scala.xml.Node, stack: List[IPXACT2022scalaxb.ElemName]): Parser[IPXACT2022ScalaCases.Drivers] =
      phrase(safeRep(IPXACT2022scalaxb.ElemName(Some("http://www.accellera.org/XMLSchema/IPXACT/1685-2022"), "driver")) ^^
      { case p1 =>
      IPXACT2022ScalaCases.Drivers(p1 map { IPXACT2022scalaxb.fromXML[IPXACT2022ScalaCases.DriverType](_, IPXACT2022scalaxb.ElemName(node) :: stack) }) })
    
    def writesChildNodes(__obj: IPXACT2022ScalaCases.Drivers, __scope: scala.xml.NamespaceBinding): Seq[scala.xml.Node] =
      (__obj.driver flatMap { IPXACT2022scalaxb.toXML[IPXACT2022ScalaCases.DriverType](_, Some("http://www.accellera.org/XMLSchema/IPXACT/1685-2022"), Some("driver"), __scope, false) })
  }
  trait DefaultIPXACT2022ScalaCases_ClockPeriodFormat extends IPXACT2022scalaxb.XMLFormat[IPXACT2022ScalaCases.ClockPeriod] with IPXACT2022scalaxb.CanWriteChildNodes[IPXACT2022ScalaCases.ClockPeriod] {
    val targetNamespace: Option[String] = Some("http://www.accellera.org/XMLSchema/IPXACT/1685-2022")
    def reads(seq: scala.xml.NodeSeq, stack: List[IPXACT2022scalaxb.ElemName]): Either[String, IPXACT2022ScalaCases.ClockPeriod] = seq match {
      case node: scala.xml.Node => Right(IPXACT2022ScalaCases.ClockPeriod(IPXACT2022scalaxb.fromXML[String](node, IPXACT2022scalaxb.ElemName(node) :: stack),
        scala.collection.immutable.ListMap(List(
        (node \ "@minimum").headOption map { x => IPXACT2022scalaxb.DataRecord(x, node, IPXACT2022scalaxb.fromXML[Double](x, IPXACT2022scalaxb.ElemName(node) :: stack)) } map { "@minimum" -> _ },
        (node \ "@maximum").headOption map { x => IPXACT2022scalaxb.DataRecord(x, node, IPXACT2022scalaxb.fromXML[Double](x, IPXACT2022scalaxb.ElemName(node) :: stack)) } map { "@maximum" -> _ },
        (node \ "@units").headOption map { x => IPXACT2022scalaxb.DataRecord(x, node, IPXACT2022scalaxb.fromXML[IPXACT2022ScalaCases.DelayValueUnitType](x, IPXACT2022scalaxb.ElemName(node) :: stack)) } orElse Some(IPXACT2022scalaxb.DataRecord(None, None, IPXACT2022scalaxb.fromXML[IPXACT2022ScalaCases.DelayValueUnitType](scala.xml.Text("ns"), IPXACT2022scalaxb.ElemName(node) :: stack))) map { "@units" -> _ }
        ).flatten[(String, IPXACT2022scalaxb.DataRecord[Any])] ::: (node match {
          case elem: scala.xml.Elem =>
            elem.attributes.toList flatMap {
              case scala.xml.UnprefixedAttribute(key, value, _) if key == "minimum" => Nil
              case scala.xml.UnprefixedAttribute(key, value, _) if key == "maximum" => Nil
              case scala.xml.UnprefixedAttribute(key, value, _) if key == "units" => Nil
              case scala.xml.UnprefixedAttribute(key, value, _) =>
                List(("@" + key, IPXACT2022scalaxb.DataRecord(None, Some(key), value.text)))
              case scala.xml.PrefixedAttribute(pre, key, value, _) =>
                val ns = elem.scope.getURI(pre)
                List(("@{" + ns + "}" + key, IPXACT2022scalaxb.DataRecord(Option[String](ns), Some(key), value.text)))
              case _ => Nil
            }
          case _ => Nil
        }): _*)))
      case _ => Left("reads failed: seq must be scala.xml.Node")
    }
    
    override def writesAttribute(__obj: IPXACT2022ScalaCases.ClockPeriod, __scope: scala.xml.NamespaceBinding): scala.xml.MetaData = {
      var attr: scala.xml.MetaData  = scala.xml.Null
      __obj.attributes.toList map {
        case ("@minimum", _) => __obj.minimum foreach { x => attr = scala.xml.Attribute(null, "minimum", x.toString, attr) }
        case ("@maximum", _) => __obj.maximum foreach { x => attr = scala.xml.Attribute(null, "maximum", x.toString, attr) }
        case ("@units", _) => if (__obj.units.toString != "ns") attr = scala.xml.Attribute(null, "units", __obj.units.toString, attr)
        case (key, x) => attr = scala.xml.Attribute((x.namespace map { __scope.getPrefix(_) }).orNull, x.key.orNull, x.value.toString, attr)
      }
      attr
    }

    def writesChildNodes(__obj: IPXACT2022ScalaCases.ClockPeriod, __scope: scala.xml.NamespaceBinding): Seq[scala.xml.Node] =
      Seq(scala.xml.Text(__obj.value.toString))

  }

  trait DefaultIPXACT2022ScalaCases_ClockPulseOffsetFormat extends IPXACT2022scalaxb.XMLFormat[IPXACT2022ScalaCases.ClockPulseOffset] with IPXACT2022scalaxb.CanWriteChildNodes[IPXACT2022ScalaCases.ClockPulseOffset] {
    val targetNamespace: Option[String] = Some("http://www.accellera.org/XMLSchema/IPXACT/1685-2022")
    def reads(seq: scala.xml.NodeSeq, stack: List[IPXACT2022scalaxb.ElemName]): Either[String, IPXACT2022ScalaCases.ClockPulseOffset] = seq match {
      case node: scala.xml.Node => Right(IPXACT2022ScalaCases.ClockPulseOffset(IPXACT2022scalaxb.fromXML[String](node, IPXACT2022scalaxb.ElemName(node) :: stack),
        scala.collection.immutable.ListMap(List(
        (node \ "@minimum").headOption map { x => IPXACT2022scalaxb.DataRecord(x, node, IPXACT2022scalaxb.fromXML[Double](x, IPXACT2022scalaxb.ElemName(node) :: stack)) } map { "@minimum" -> _ },
        (node \ "@maximum").headOption map { x => IPXACT2022scalaxb.DataRecord(x, node, IPXACT2022scalaxb.fromXML[Double](x, IPXACT2022scalaxb.ElemName(node) :: stack)) } map { "@maximum" -> _ },
        (node \ "@units").headOption map { x => IPXACT2022scalaxb.DataRecord(x, node, IPXACT2022scalaxb.fromXML[IPXACT2022ScalaCases.DelayValueUnitType](x, IPXACT2022scalaxb.ElemName(node) :: stack)) } orElse Some(IPXACT2022scalaxb.DataRecord(None, None, IPXACT2022scalaxb.fromXML[IPXACT2022ScalaCases.DelayValueUnitType](scala.xml.Text("ns"), IPXACT2022scalaxb.ElemName(node) :: stack))) map { "@units" -> _ }
        ).flatten[(String, IPXACT2022scalaxb.DataRecord[Any])] ::: (node match {
          case elem: scala.xml.Elem =>
            elem.attributes.toList flatMap {
              case scala.xml.UnprefixedAttribute(key, value, _) if key == "minimum" => Nil
              case scala.xml.UnprefixedAttribute(key, value, _) if key == "maximum" => Nil
              case scala.xml.UnprefixedAttribute(key, value, _) if key == "units" => Nil
              case scala.xml.UnprefixedAttribute(key, value, _) =>
                List(("@" + key, IPXACT2022scalaxb.DataRecord(None, Some(key), value.text)))
              case scala.xml.PrefixedAttribute(pre, key, value, _) =>
                val ns = elem.scope.getURI(pre)
                List(("@{" + ns + "}" + key, IPXACT2022scalaxb.DataRecord(Option[String](ns), Some(key), value.text)))
              case _ => Nil
            }
          case _ => Nil
        }): _*)))
      case _ => Left("reads failed: seq must be scala.xml.Node")
    }
    
    override def writesAttribute(__obj: IPXACT2022ScalaCases.ClockPulseOffset, __scope: scala.xml.NamespaceBinding): scala.xml.MetaData = {
      var attr: scala.xml.MetaData  = scala.xml.Null
      __obj.attributes.toList map {
        case ("@minimum", _) => __obj.minimum foreach { x => attr = scala.xml.Attribute(null, "minimum", x.toString, attr) }
        case ("@maximum", _) => __obj.maximum foreach { x => attr = scala.xml.Attribute(null, "maximum", x.toString, attr) }
        case ("@units", _) => if (__obj.units.toString != "ns") attr = scala.xml.Attribute(null, "units", __obj.units.toString, attr)
        case (key, x) => attr = scala.xml.Attribute((x.namespace map { __scope.getPrefix(_) }).orNull, x.key.orNull, x.value.toString, attr)
      }
      attr
    }

    def writesChildNodes(__obj: IPXACT2022ScalaCases.ClockPulseOffset, __scope: scala.xml.NamespaceBinding): Seq[scala.xml.Node] =
      Seq(scala.xml.Text(__obj.value.toString))

  }

  trait DefaultIPXACT2022ScalaCases_ClockPulseDurationFormat extends IPXACT2022scalaxb.XMLFormat[IPXACT2022ScalaCases.ClockPulseDuration] with IPXACT2022scalaxb.CanWriteChildNodes[IPXACT2022ScalaCases.ClockPulseDuration] {
    val targetNamespace: Option[String] = Some("http://www.accellera.org/XMLSchema/IPXACT/1685-2022")
    def reads(seq: scala.xml.NodeSeq, stack: List[IPXACT2022scalaxb.ElemName]): Either[String, IPXACT2022ScalaCases.ClockPulseDuration] = seq match {
      case node: scala.xml.Node => Right(IPXACT2022ScalaCases.ClockPulseDuration(IPXACT2022scalaxb.fromXML[String](node, IPXACT2022scalaxb.ElemName(node) :: stack),
        scala.collection.immutable.ListMap(List(
        (node \ "@minimum").headOption map { x => IPXACT2022scalaxb.DataRecord(x, node, IPXACT2022scalaxb.fromXML[Double](x, IPXACT2022scalaxb.ElemName(node) :: stack)) } map { "@minimum" -> _ },
        (node \ "@maximum").headOption map { x => IPXACT2022scalaxb.DataRecord(x, node, IPXACT2022scalaxb.fromXML[Double](x, IPXACT2022scalaxb.ElemName(node) :: stack)) } map { "@maximum" -> _ },
        (node \ "@units").headOption map { x => IPXACT2022scalaxb.DataRecord(x, node, IPXACT2022scalaxb.fromXML[IPXACT2022ScalaCases.DelayValueUnitType](x, IPXACT2022scalaxb.ElemName(node) :: stack)) } orElse Some(IPXACT2022scalaxb.DataRecord(None, None, IPXACT2022scalaxb.fromXML[IPXACT2022ScalaCases.DelayValueUnitType](scala.xml.Text("ns"), IPXACT2022scalaxb.ElemName(node) :: stack))) map { "@units" -> _ }
        ).flatten[(String, IPXACT2022scalaxb.DataRecord[Any])] ::: (node match {
          case elem: scala.xml.Elem =>
            elem.attributes.toList flatMap {
              case scala.xml.UnprefixedAttribute(key, value, _) if key == "minimum" => Nil
              case scala.xml.UnprefixedAttribute(key, value, _) if key == "maximum" => Nil
              case scala.xml.UnprefixedAttribute(key, value, _) if key == "units" => Nil
              case scala.xml.UnprefixedAttribute(key, value, _) =>
                List(("@" + key, IPXACT2022scalaxb.DataRecord(None, Some(key), value.text)))
              case scala.xml.PrefixedAttribute(pre, key, value, _) =>
                val ns = elem.scope.getURI(pre)
                List(("@{" + ns + "}" + key, IPXACT2022scalaxb.DataRecord(Option[String](ns), Some(key), value.text)))
              case _ => Nil
            }
          case _ => Nil
        }): _*)))
      case _ => Left("reads failed: seq must be scala.xml.Node")
    }
    
    override def writesAttribute(__obj: IPXACT2022ScalaCases.ClockPulseDuration, __scope: scala.xml.NamespaceBinding): scala.xml.MetaData = {
      var attr: scala.xml.MetaData  = scala.xml.Null
      __obj.attributes.toList map {
        case ("@minimum", _) => __obj.minimum foreach { x => attr = scala.xml.Attribute(null, "minimum", x.toString, attr) }
        case ("@maximum", _) => __obj.maximum foreach { x => attr = scala.xml.Attribute(null, "maximum", x.toString, attr) }
        case ("@units", _) => if (__obj.units.toString != "ns") attr = scala.xml.Attribute(null, "units", __obj.units.toString, attr)
        case (key, x) => attr = scala.xml.Attribute((x.namespace map { __scope.getPrefix(_) }).orNull, x.key.orNull, x.value.toString, attr)
      }
      attr
    }

    def writesChildNodes(__obj: IPXACT2022ScalaCases.ClockPulseDuration, __scope: scala.xml.NamespaceBinding): Seq[scala.xml.Node] =
      Seq(scala.xml.Text(__obj.value.toString))

  }

  trait DefaultIPXACT2022ScalaCases_ClockDriverTypableFormat extends IPXACT2022scalaxb.XMLFormat[IPXACT2022ScalaCases.ClockDriverTypable] {
    def reads(seq: scala.xml.NodeSeq, stack: List[IPXACT2022scalaxb.ElemName]): Either[String, IPXACT2022ScalaCases.ClockDriverTypable] = seq match {
      case node: scala.xml.Node =>     
        IPXACT2022scalaxb.Helper.instanceType(node) match {
          
          case _ => Right(IPXACT2022scalaxb.fromXML[IPXACT2022ScalaCases.ClockDriverType](node, stack))
        }
      case _ => Left("reads failed: seq must be scala.xml.Node")  
    }
    
    def writes(__obj: IPXACT2022ScalaCases.ClockDriverTypable, __namespace: Option[String], __elementLabel: Option[String],
        __scope: scala.xml.NamespaceBinding, __typeAttribute: Boolean): scala.xml.NodeSeq = __obj match {
      case x: IPXACT2022ScalaCases.OtherClockDriver => IPXACT2022scalaxb.toXML[IPXACT2022ScalaCases.OtherClockDriver](x, __namespace, __elementLabel, __scope, true)
      case x: IPXACT2022ScalaCases.ClockDriver => IPXACT2022scalaxb.toXML[IPXACT2022ScalaCases.ClockDriver](x, __namespace, __elementLabel, __scope, true)
      case x: IPXACT2022ScalaCases.ClockDriverType => IPXACT2022scalaxb.toXML[IPXACT2022ScalaCases.ClockDriverType](x, __namespace, __elementLabel, __scope, __typeAttribute)
    }
  }

  trait DefaultIPXACT2022ScalaCases_ClockDriverTypeFormat extends IPXACT2022scalaxb.ElemNameParser[IPXACT2022ScalaCases.ClockDriverType] {
    val targetNamespace: Option[String] = Some("http://www.accellera.org/XMLSchema/IPXACT/1685-2022")
    
    override def typeName: Option[String] = Some("clockDriverType")

    def parser(node: scala.xml.Node, stack: List[IPXACT2022scalaxb.ElemName]): Parser[IPXACT2022ScalaCases.ClockDriverType] =
      phrase((IPXACT2022scalaxb.ElemName(Some("http://www.accellera.org/XMLSchema/IPXACT/1685-2022"), "clockPeriod")) ~
      (IPXACT2022scalaxb.ElemName(Some("http://www.accellera.org/XMLSchema/IPXACT/1685-2022"), "clockPulseOffset")) ~
      (IPXACT2022scalaxb.ElemName(Some("http://www.accellera.org/XMLSchema/IPXACT/1685-2022"), "clockPulseValue")) ~
      (IPXACT2022scalaxb.ElemName(Some("http://www.accellera.org/XMLSchema/IPXACT/1685-2022"), "clockPulseDuration")) ^^
      { case p1 ~ p2 ~ p3 ~ p4 =>
      IPXACT2022ScalaCases.ClockDriverType(IPXACT2022scalaxb.fromXML[IPXACT2022ScalaCases.ClockPeriod](p1, IPXACT2022scalaxb.ElemName(node) :: stack),
        IPXACT2022scalaxb.fromXML[IPXACT2022ScalaCases.ClockPulseOffset](p2, IPXACT2022scalaxb.ElemName(node) :: stack),
        IPXACT2022scalaxb.fromXML[IPXACT2022ScalaCases.UnsignedBitExpression](p3, IPXACT2022scalaxb.ElemName(node) :: stack),
        IPXACT2022scalaxb.fromXML[IPXACT2022ScalaCases.ClockPulseDuration](p4, IPXACT2022scalaxb.ElemName(node) :: stack),
        scala.collection.immutable.ListMap(List(
        (node \ "@{http://www.w3.org/XML/1998/namespace}id").headOption map { x => IPXACT2022scalaxb.DataRecord(x, node, IPXACT2022scalaxb.fromXML[String](x, IPXACT2022scalaxb.ElemName(node) :: stack)) } map { "@{http://www.w3.org/XML/1998/namespace}id" -> _ }
        ).flatten[(String, IPXACT2022scalaxb.DataRecord[Any])]: _*)) })
    
    override def writesAttribute(__obj: IPXACT2022ScalaCases.ClockDriverType, __scope: scala.xml.NamespaceBinding): scala.xml.MetaData = {
      var attr: scala.xml.MetaData  = scala.xml.Null
      __obj.attributes.toList map {
        case ("@{http://www.w3.org/XML/1998/namespace}id", _) => __obj.xmlid foreach { x => attr = scala.xml.Attribute(__scope.getPrefix("http://www.w3.org/XML/1998/namespace"), "id", x.toString, attr) }
        case (key, x) => attr = scala.xml.Attribute((x.namespace map { __scope.getPrefix(_) }).orNull, x.key.orNull, x.value.toString, attr)
      }
      attr
    }

    def writesChildNodes(__obj: IPXACT2022ScalaCases.ClockDriverType, __scope: scala.xml.NamespaceBinding): Seq[scala.xml.Node] =
      Seq.concat(IPXACT2022scalaxb.toXML[IPXACT2022ScalaCases.ClockPeriod](__obj.clockPeriod, Some("http://www.accellera.org/XMLSchema/IPXACT/1685-2022"), Some("clockPeriod"), __scope, false),
        IPXACT2022scalaxb.toXML[IPXACT2022ScalaCases.ClockPulseOffset](__obj.clockPulseOffset, Some("http://www.accellera.org/XMLSchema/IPXACT/1685-2022"), Some("clockPulseOffset"), __scope, false),
        IPXACT2022scalaxb.toXML[IPXACT2022ScalaCases.UnsignedBitExpression](__obj.clockPulseValue, Some("http://www.accellera.org/XMLSchema/IPXACT/1685-2022"), Some("clockPulseValue"), __scope, false),
        IPXACT2022scalaxb.toXML[IPXACT2022ScalaCases.ClockPulseDuration](__obj.clockPulseDuration, Some("http://www.accellera.org/XMLSchema/IPXACT/1685-2022"), Some("clockPulseDuration"), __scope, false))

  }

  trait DefaultIPXACT2022ScalaCases_OtherClockDriverFormat extends IPXACT2022scalaxb.ElemNameParser[IPXACT2022ScalaCases.OtherClockDriver] {
    val targetNamespace: Option[String] = Some("http://www.accellera.org/XMLSchema/IPXACT/1685-2022")
    
    def parser(node: scala.xml.Node, stack: List[IPXACT2022scalaxb.ElemName]): Parser[IPXACT2022ScalaCases.OtherClockDriver] =
      phrase((IPXACT2022scalaxb.ElemName(Some("http://www.accellera.org/XMLSchema/IPXACT/1685-2022"), "clockPeriod")) ~
      (IPXACT2022scalaxb.ElemName(Some("http://www.accellera.org/XMLSchema/IPXACT/1685-2022"), "clockPulseOffset")) ~
      (IPXACT2022scalaxb.ElemName(Some("http://www.accellera.org/XMLSchema/IPXACT/1685-2022"), "clockPulseValue")) ~
      (IPXACT2022scalaxb.ElemName(Some("http://www.accellera.org/XMLSchema/IPXACT/1685-2022"), "clockPulseDuration")) ^^
      { case p1 ~ p2 ~ p3 ~ p4 =>
      IPXACT2022ScalaCases.OtherClockDriver(IPXACT2022scalaxb.fromXML[IPXACT2022ScalaCases.ClockPeriod](p1, IPXACT2022scalaxb.ElemName(node) :: stack),
        IPXACT2022scalaxb.fromXML[IPXACT2022ScalaCases.ClockPulseOffset](p2, IPXACT2022scalaxb.ElemName(node) :: stack),
        IPXACT2022scalaxb.fromXML[IPXACT2022ScalaCases.UnsignedBitExpression](p3, IPXACT2022scalaxb.ElemName(node) :: stack),
        IPXACT2022scalaxb.fromXML[IPXACT2022ScalaCases.ClockPulseDuration](p4, IPXACT2022scalaxb.ElemName(node) :: stack),
        scala.collection.immutable.ListMap(List(
        (node \ "@{http://www.w3.org/XML/1998/namespace}id").headOption map { x => IPXACT2022scalaxb.DataRecord(x, node, IPXACT2022scalaxb.fromXML[String](x, IPXACT2022scalaxb.ElemName(node) :: stack)) } map { "@{http://www.w3.org/XML/1998/namespace}id" -> _ },
        (node \ "@clockName").headOption map { x => IPXACT2022scalaxb.DataRecord(x, node, IPXACT2022scalaxb.fromXML[String](x, IPXACT2022scalaxb.ElemName(node) :: stack)) } map { "@clockName" -> _ },
        (node \ "@clockSource").headOption map { x => IPXACT2022scalaxb.DataRecord(x, node, IPXACT2022scalaxb.fromXML[String](x, IPXACT2022scalaxb.ElemName(node) :: stack)) } map { "@clockSource" -> _ }
        ).flatten[(String, IPXACT2022scalaxb.DataRecord[Any])]: _*)) })
    
    override def writesAttribute(__obj: IPXACT2022ScalaCases.OtherClockDriver, __scope: scala.xml.NamespaceBinding): scala.xml.MetaData = {
      var attr: scala.xml.MetaData  = scala.xml.Null
      __obj.attributes.toList map {
        case ("@{http://www.w3.org/XML/1998/namespace}id", _) => __obj.xmlid foreach { x => attr = scala.xml.Attribute(__scope.getPrefix("http://www.w3.org/XML/1998/namespace"), "id", x.toString, attr) }
        case ("@clockName", _) => attr = scala.xml.Attribute(null, "clockName", __obj.clockName.toString, attr)
        case ("@clockSource", _) => __obj.clockSource foreach { x => attr = scala.xml.Attribute(null, "clockSource", x.toString, attr) }
        case (key, x) => attr = scala.xml.Attribute((x.namespace map { __scope.getPrefix(_) }).orNull, x.key.orNull, x.value.toString, attr)
      }
      attr
    }

    def writesChildNodes(__obj: IPXACT2022ScalaCases.OtherClockDriver, __scope: scala.xml.NamespaceBinding): Seq[scala.xml.Node] =
      Seq.concat(IPXACT2022scalaxb.toXML[IPXACT2022ScalaCases.ClockPeriod](__obj.clockPeriod, Some("http://www.accellera.org/XMLSchema/IPXACT/1685-2022"), Some("clockPeriod"), __scope, false),
        IPXACT2022scalaxb.toXML[IPXACT2022ScalaCases.ClockPulseOffset](__obj.clockPulseOffset, Some("http://www.accellera.org/XMLSchema/IPXACT/1685-2022"), Some("clockPulseOffset"), __scope, false),
        IPXACT2022scalaxb.toXML[IPXACT2022ScalaCases.UnsignedBitExpression](__obj.clockPulseValue, Some("http://www.accellera.org/XMLSchema/IPXACT/1685-2022"), Some("clockPulseValue"), __scope, false),
        IPXACT2022scalaxb.toXML[IPXACT2022ScalaCases.ClockPulseDuration](__obj.clockPulseDuration, Some("http://www.accellera.org/XMLSchema/IPXACT/1685-2022"), Some("clockPulseDuration"), __scope, false))

  }

  trait DefaultIPXACT2022ScalaCases_UnsignedLongintExpressionableFormat extends IPXACT2022scalaxb.XMLFormat[IPXACT2022ScalaCases.UnsignedLongintExpressionable] {
    def reads(seq: scala.xml.NodeSeq, stack: List[IPXACT2022scalaxb.ElemName]): Either[String, IPXACT2022ScalaCases.UnsignedLongintExpressionable] = seq match {
      case node: scala.xml.Node =>     
        IPXACT2022scalaxb.Helper.instanceType(node) match {
          
          case _ => Right(IPXACT2022scalaxb.fromXML[IPXACT2022ScalaCases.UnsignedLongintExpression](node, stack))
        }
      case _ => Left("reads failed: seq must be scala.xml.Node")  
    }
    
    def writes(__obj: IPXACT2022ScalaCases.UnsignedLongintExpressionable, __namespace: Option[String], __elementLabel: Option[String],
        __scope: scala.xml.NamespaceBinding, __typeAttribute: Boolean): scala.xml.NodeSeq = __obj match {
      case x: IPXACT2022ScalaCases.RemapAddress => IPXACT2022scalaxb.toXML[IPXACT2022ScalaCases.RemapAddress](x, __namespace, __elementLabel, __scope, true)
      case x: IPXACT2022ScalaCases.UnsignedLongintExpression => IPXACT2022scalaxb.toXML[IPXACT2022ScalaCases.UnsignedLongintExpression](x, __namespace, __elementLabel, __scope, __typeAttribute)
    }
  }
  trait DefaultIPXACT2022ScalaCases_UnsignedLongintExpressionFormat extends IPXACT2022scalaxb.XMLFormat[IPXACT2022ScalaCases.UnsignedLongintExpression] with IPXACT2022scalaxb.CanWriteChildNodes[IPXACT2022ScalaCases.UnsignedLongintExpression] {
    val targetNamespace: Option[String] = Some("http://www.accellera.org/XMLSchema/IPXACT/1685-2022")
    def reads(seq: scala.xml.NodeSeq, stack: List[IPXACT2022scalaxb.ElemName]): Either[String, IPXACT2022ScalaCases.UnsignedLongintExpression] = seq match {
      case node: scala.xml.Node => Right(IPXACT2022ScalaCases.UnsignedLongintExpression(IPXACT2022scalaxb.fromXML[String](node, IPXACT2022scalaxb.ElemName(node) :: stack),
        scala.collection.immutable.ListMap(List(
        (node \ "@minimum").headOption map { x => IPXACT2022scalaxb.DataRecord(x, node, IPXACT2022scalaxb.fromXML[Int](x, IPXACT2022scalaxb.ElemName(node) :: stack)) } map { "@minimum" -> _ },
        (node \ "@maximum").headOption map { x => IPXACT2022scalaxb.DataRecord(x, node, IPXACT2022scalaxb.fromXML[Int](x, IPXACT2022scalaxb.ElemName(node) :: stack)) } map { "@maximum" -> _ }
        ).flatten[(String, IPXACT2022scalaxb.DataRecord[Any])] ::: (node match {
          case elem: scala.xml.Elem =>
            elem.attributes.toList flatMap {
              case scala.xml.UnprefixedAttribute(key, value, _) if key == "minimum" => Nil
              case scala.xml.UnprefixedAttribute(key, value, _) if key == "maximum" => Nil
              case scala.xml.UnprefixedAttribute(key, value, _) =>
                List(("@" + key, IPXACT2022scalaxb.DataRecord(None, Some(key), value.text)))
              case scala.xml.PrefixedAttribute(pre, key, value, _) =>
                val ns = elem.scope.getURI(pre)
                List(("@{" + ns + "}" + key, IPXACT2022scalaxb.DataRecord(Option[String](ns), Some(key), value.text)))
              case _ => Nil
            }
          case _ => Nil
        }): _*)))
      case _ => Left("reads failed: seq must be scala.xml.Node")
    }
    
    override def writesAttribute(__obj: IPXACT2022ScalaCases.UnsignedLongintExpression, __scope: scala.xml.NamespaceBinding): scala.xml.MetaData = {
      var attr: scala.xml.MetaData  = scala.xml.Null
      __obj.attributes.toList map {
        case ("@minimum", _) => __obj.minimum foreach { x => attr = scala.xml.Attribute(null, "minimum", x.toString, attr) }
        case ("@maximum", _) => __obj.maximum foreach { x => attr = scala.xml.Attribute(null, "maximum", x.toString, attr) }
        case (key, x) => attr = scala.xml.Attribute((x.namespace map { __scope.getPrefix(_) }).orNull, x.key.orNull, x.value.toString, attr)
      }
      attr
    }

    def writesChildNodes(__obj: IPXACT2022ScalaCases.UnsignedLongintExpression, __scope: scala.xml.NamespaceBinding): Seq[scala.xml.Node] =
      Seq(scala.xml.Text(__obj.value.toString))

  }

  trait DefaultIPXACT2022ScalaCases_UnsignedPositiveLongintExpressionableFormat extends IPXACT2022scalaxb.XMLFormat[IPXACT2022ScalaCases.UnsignedPositiveLongintExpressionable] {
    def reads(seq: scala.xml.NodeSeq, stack: List[IPXACT2022scalaxb.ElemName]): Either[String, IPXACT2022ScalaCases.UnsignedPositiveLongintExpressionable] = seq match {
      case node: scala.xml.Node =>     
        IPXACT2022scalaxb.Helper.instanceType(node) match {
          
          case _ => Right(IPXACT2022scalaxb.fromXML[IPXACT2022ScalaCases.UnsignedPositiveLongintExpression](node, stack))
        }
      case _ => Left("reads failed: seq must be scala.xml.Node")  
    }
    
    def writes(__obj: IPXACT2022ScalaCases.UnsignedPositiveLongintExpressionable, __namespace: Option[String], __elementLabel: Option[String],
        __scope: scala.xml.NamespaceBinding, __typeAttribute: Boolean): scala.xml.NodeSeq = __obj match {
      case x: IPXACT2022ScalaCases.BitStride => IPXACT2022scalaxb.toXML[IPXACT2022ScalaCases.BitStride](x, __namespace, __elementLabel, __scope, true)
      case x: IPXACT2022ScalaCases.Stride => IPXACT2022scalaxb.toXML[IPXACT2022ScalaCases.Stride](x, __namespace, __elementLabel, __scope, true)
      case x: IPXACT2022ScalaCases.Dim => IPXACT2022scalaxb.toXML[IPXACT2022ScalaCases.Dim](x, __namespace, __elementLabel, __scope, true)
      case x: IPXACT2022ScalaCases.UnsignedPositiveLongintExpression => IPXACT2022scalaxb.toXML[IPXACT2022ScalaCases.UnsignedPositiveLongintExpression](x, __namespace, __elementLabel, __scope, __typeAttribute)
    }
  }

  trait DefaultIPXACT2022ScalaCases_UnsignedPositiveLongintExpressionFormat extends IPXACT2022scalaxb.XMLFormat[IPXACT2022ScalaCases.UnsignedPositiveLongintExpression] with IPXACT2022scalaxb.CanWriteChildNodes[IPXACT2022ScalaCases.UnsignedPositiveLongintExpression] {
    val targetNamespace: Option[String] = Some("http://www.accellera.org/XMLSchema/IPXACT/1685-2022")
    def reads(seq: scala.xml.NodeSeq, stack: List[IPXACT2022scalaxb.ElemName]): Either[String, IPXACT2022ScalaCases.UnsignedPositiveLongintExpression] = seq match {
      case node: scala.xml.Node => Right(IPXACT2022ScalaCases.UnsignedPositiveLongintExpression(IPXACT2022scalaxb.fromXML[String](node, IPXACT2022scalaxb.ElemName(node) :: stack),
        scala.collection.immutable.ListMap(List(
        (node \ "@minimum").headOption map { x => IPXACT2022scalaxb.DataRecord(x, node, IPXACT2022scalaxb.fromXML[Int](x, IPXACT2022scalaxb.ElemName(node) :: stack)) } map { "@minimum" -> _ },
        (node \ "@maximum").headOption map { x => IPXACT2022scalaxb.DataRecord(x, node, IPXACT2022scalaxb.fromXML[Int](x, IPXACT2022scalaxb.ElemName(node) :: stack)) } map { "@maximum" -> _ }
        ).flatten[(String, IPXACT2022scalaxb.DataRecord[Any])] ::: (node match {
          case elem: scala.xml.Elem =>
            elem.attributes.toList flatMap {
              case scala.xml.UnprefixedAttribute(key, value, _) if key == "minimum" => Nil
              case scala.xml.UnprefixedAttribute(key, value, _) if key == "maximum" => Nil
              case scala.xml.UnprefixedAttribute(key, value, _) =>
                List(("@" + key, IPXACT2022scalaxb.DataRecord(None, Some(key), value.text)))
              case scala.xml.PrefixedAttribute(pre, key, value, _) =>
                val ns = elem.scope.getURI(pre)
                List(("@{" + ns + "}" + key, IPXACT2022scalaxb.DataRecord(Option[String](ns), Some(key), value.text)))
              case _ => Nil
            }
          case _ => Nil
        }): _*)))
      case _ => Left("reads failed: seq must be scala.xml.Node")
    }
    
    override def writesAttribute(__obj: IPXACT2022ScalaCases.UnsignedPositiveLongintExpression, __scope: scala.xml.NamespaceBinding): scala.xml.MetaData = {
      var attr: scala.xml.MetaData  = scala.xml.Null
      __obj.attributes.toList map {
        case ("@minimum", _) => __obj.minimum foreach { x => attr = scala.xml.Attribute(null, "minimum", x.toString, attr) }
        case ("@maximum", _) => __obj.maximum foreach { x => attr = scala.xml.Attribute(null, "maximum", x.toString, attr) }
        case (key, x) => attr = scala.xml.Attribute((x.namespace map { __scope.getPrefix(_) }).orNull, x.key.orNull, x.value.toString, attr)
      }
      attr
    }

    def writesChildNodes(__obj: IPXACT2022ScalaCases.UnsignedPositiveLongintExpression, __scope: scala.xml.NamespaceBinding): Seq[scala.xml.Node] =
      Seq(scala.xml.Text(__obj.value.toString))

  }

  trait DefaultIPXACT2022ScalaCases_SignedLongintExpressionFormat extends IPXACT2022scalaxb.XMLFormat[IPXACT2022ScalaCases.SignedLongintExpression] with IPXACT2022scalaxb.CanWriteChildNodes[IPXACT2022ScalaCases.SignedLongintExpression] {
    val targetNamespace: Option[String] = Some("http://www.accellera.org/XMLSchema/IPXACT/1685-2022")
    def reads(seq: scala.xml.NodeSeq, stack: List[IPXACT2022scalaxb.ElemName]): Either[String, IPXACT2022ScalaCases.SignedLongintExpression] = seq match {
      case node: scala.xml.Node => Right(IPXACT2022ScalaCases.SignedLongintExpression(IPXACT2022scalaxb.fromXML[String](node, IPXACT2022scalaxb.ElemName(node) :: stack),
        scala.collection.immutable.ListMap(List(
        (node \ "@minimum").headOption map { x => IPXACT2022scalaxb.DataRecord(x, node, IPXACT2022scalaxb.fromXML[Int](x, IPXACT2022scalaxb.ElemName(node) :: stack)) } map { "@minimum" -> _ },
        (node \ "@maximum").headOption map { x => IPXACT2022scalaxb.DataRecord(x, node, IPXACT2022scalaxb.fromXML[Int](x, IPXACT2022scalaxb.ElemName(node) :: stack)) } map { "@maximum" -> _ }
        ).flatten[(String, IPXACT2022scalaxb.DataRecord[Any])] ::: (node match {
          case elem: scala.xml.Elem =>
            elem.attributes.toList flatMap {
              case scala.xml.UnprefixedAttribute(key, value, _) if key == "minimum" => Nil
              case scala.xml.UnprefixedAttribute(key, value, _) if key == "maximum" => Nil
              case scala.xml.UnprefixedAttribute(key, value, _) =>
                List(("@" + key, IPXACT2022scalaxb.DataRecord(None, Some(key), value.text)))
              case scala.xml.PrefixedAttribute(pre, key, value, _) =>
                val ns = elem.scope.getURI(pre)
                List(("@{" + ns + "}" + key, IPXACT2022scalaxb.DataRecord(Option[String](ns), Some(key), value.text)))
              case _ => Nil
            }
          case _ => Nil
        }): _*)))
      case _ => Left("reads failed: seq must be scala.xml.Node")
    }
    
    override def writesAttribute(__obj: IPXACT2022ScalaCases.SignedLongintExpression, __scope: scala.xml.NamespaceBinding): scala.xml.MetaData = {
      var attr: scala.xml.MetaData  = scala.xml.Null
      __obj.attributes.toList map {
        case ("@minimum", _) => __obj.minimum foreach { x => attr = scala.xml.Attribute(null, "minimum", x.toString, attr) }
        case ("@maximum", _) => __obj.maximum foreach { x => attr = scala.xml.Attribute(null, "maximum", x.toString, attr) }
        case (key, x) => attr = scala.xml.Attribute((x.namespace map { __scope.getPrefix(_) }).orNull, x.key.orNull, x.value.toString, attr)
      }
      attr
    }

    def writesChildNodes(__obj: IPXACT2022ScalaCases.SignedLongintExpression, __scope: scala.xml.NamespaceBinding): Seq[scala.xml.Node] =
      Seq(scala.xml.Text(__obj.value.toString))

  }

  trait DefaultIPXACT2022ScalaCases_UnsignedIntExpressionableFormat extends IPXACT2022scalaxb.XMLFormat[IPXACT2022ScalaCases.UnsignedIntExpressionable] {
    def reads(seq: scala.xml.NodeSeq, stack: List[IPXACT2022scalaxb.ElemName]): Either[String, IPXACT2022ScalaCases.UnsignedIntExpressionable] = seq match {
      case node: scala.xml.Node =>     
        IPXACT2022scalaxb.Helper.instanceType(node) match {
          
          case _ => Right(IPXACT2022scalaxb.fromXML[IPXACT2022ScalaCases.UnsignedIntExpression](node, stack))
        }
      case _ => Left("reads failed: seq must be scala.xml.Node")  
    }
    
    def writes(__obj: IPXACT2022ScalaCases.UnsignedIntExpressionable, __namespace: Option[String], __elementLabel: Option[String],
        __scope: scala.xml.NamespaceBinding, __typeAttribute: Boolean): scala.xml.NodeSeq = __obj match {
      case x: IPXACT2022ScalaCases.Index2 => IPXACT2022scalaxb.toXML[IPXACT2022ScalaCases.Index2](x, __namespace, __elementLabel, __scope, true)
      case x: IPXACT2022ScalaCases.Index => IPXACT2022scalaxb.toXML[IPXACT2022ScalaCases.Index](x, __namespace, __elementLabel, __scope, true)
      case x: IPXACT2022ScalaCases.UnsignedIntExpression => IPXACT2022scalaxb.toXML[IPXACT2022ScalaCases.UnsignedIntExpression](x, __namespace, __elementLabel, __scope, __typeAttribute)
    }
  }

  trait DefaultIPXACT2022ScalaCases_UnsignedIntExpressionFormat extends IPXACT2022scalaxb.XMLFormat[IPXACT2022ScalaCases.UnsignedIntExpression] with IPXACT2022scalaxb.CanWriteChildNodes[IPXACT2022ScalaCases.UnsignedIntExpression] {
    val targetNamespace: Option[String] = Some("http://www.accellera.org/XMLSchema/IPXACT/1685-2022")
    def reads(seq: scala.xml.NodeSeq, stack: List[IPXACT2022scalaxb.ElemName]): Either[String, IPXACT2022ScalaCases.UnsignedIntExpression] = seq match {
      case node: scala.xml.Node => Right(IPXACT2022ScalaCases.UnsignedIntExpression(IPXACT2022scalaxb.fromXML[String](node, IPXACT2022scalaxb.ElemName(node) :: stack),
        scala.collection.immutable.ListMap(List(
        (node \ "@minimum").headOption map { x => IPXACT2022scalaxb.DataRecord(x, node, IPXACT2022scalaxb.fromXML[Int](x, IPXACT2022scalaxb.ElemName(node) :: stack)) } map { "@minimum" -> _ },
        (node \ "@maximum").headOption map { x => IPXACT2022scalaxb.DataRecord(x, node, IPXACT2022scalaxb.fromXML[Int](x, IPXACT2022scalaxb.ElemName(node) :: stack)) } map { "@maximum" -> _ }
        ).flatten[(String, IPXACT2022scalaxb.DataRecord[Any])] ::: (node match {
          case elem: scala.xml.Elem =>
            elem.attributes.toList flatMap {
              case scala.xml.UnprefixedAttribute(key, value, _) if key == "minimum" => Nil
              case scala.xml.UnprefixedAttribute(key, value, _) if key == "maximum" => Nil
              case scala.xml.UnprefixedAttribute(key, value, _) =>
                List(("@" + key, IPXACT2022scalaxb.DataRecord(None, Some(key), value.text)))
              case scala.xml.PrefixedAttribute(pre, key, value, _) =>
                val ns = elem.scope.getURI(pre)
                List(("@{" + ns + "}" + key, IPXACT2022scalaxb.DataRecord(Option[String](ns), Some(key), value.text)))
              case _ => Nil
            }
          case _ => Nil
        }): _*)))
      case _ => Left("reads failed: seq must be scala.xml.Node")
    }
    
    override def writesAttribute(__obj: IPXACT2022ScalaCases.UnsignedIntExpression, __scope: scala.xml.NamespaceBinding): scala.xml.MetaData = {
      var attr: scala.xml.MetaData  = scala.xml.Null
      __obj.attributes.toList map {
        case ("@minimum", _) => __obj.minimum foreach { x => attr = scala.xml.Attribute(null, "minimum", x.toString, attr) }
        case ("@maximum", _) => __obj.maximum foreach { x => attr = scala.xml.Attribute(null, "maximum", x.toString, attr) }
        case (key, x) => attr = scala.xml.Attribute((x.namespace map { __scope.getPrefix(_) }).orNull, x.key.orNull, x.value.toString, attr)
      }
      attr
    }

    def writesChildNodes(__obj: IPXACT2022ScalaCases.UnsignedIntExpression, __scope: scala.xml.NamespaceBinding): Seq[scala.xml.Node] =
      Seq(scala.xml.Text(__obj.value.toString))

  }

  trait DefaultIPXACT2022ScalaCases_UnsignedPositiveIntExpressionableFormat extends IPXACT2022scalaxb.XMLFormat[IPXACT2022ScalaCases.UnsignedPositiveIntExpressionable] {
    def reads(seq: scala.xml.NodeSeq, stack: List[IPXACT2022scalaxb.ElemName]): Either[String, IPXACT2022ScalaCases.UnsignedPositiveIntExpressionable] = seq match {
      case node: scala.xml.Node =>     
        IPXACT2022scalaxb.Helper.instanceType(node) match {
          
          case _ => Right(IPXACT2022scalaxb.fromXML[IPXACT2022ScalaCases.UnsignedPositiveIntExpression](node, stack))
        }
      case _ => Left("reads failed: seq must be scala.xml.Node")  
    }
    
    def writes(__obj: IPXACT2022ScalaCases.UnsignedPositiveIntExpressionable, __namespace: Option[String], __elementLabel: Option[String],
        __scope: scala.xml.NamespaceBinding, __typeAttribute: Boolean): scala.xml.NodeSeq = __obj match {
      case x: IPXACT2022ScalaCases.Width => IPXACT2022scalaxb.toXML[IPXACT2022ScalaCases.Width](x, __namespace, __elementLabel, __scope, true)
      case x: IPXACT2022ScalaCases.UnsignedPositiveIntExpression => IPXACT2022scalaxb.toXML[IPXACT2022ScalaCases.UnsignedPositiveIntExpression](x, __namespace, __elementLabel, __scope, __typeAttribute)
    }
  }
  trait DefaultIPXACT2022ScalaCases_UnsignedPositiveIntExpressionFormat extends IPXACT2022scalaxb.XMLFormat[IPXACT2022ScalaCases.UnsignedPositiveIntExpression] with IPXACT2022scalaxb.CanWriteChildNodes[IPXACT2022ScalaCases.UnsignedPositiveIntExpression] {
    val targetNamespace: Option[String] = Some("http://www.accellera.org/XMLSchema/IPXACT/1685-2022")
    def reads(seq: scala.xml.NodeSeq, stack: List[IPXACT2022scalaxb.ElemName]): Either[String, IPXACT2022ScalaCases.UnsignedPositiveIntExpression] = seq match {
      case node: scala.xml.Node => Right(IPXACT2022ScalaCases.UnsignedPositiveIntExpression(IPXACT2022scalaxb.fromXML[String](node, IPXACT2022scalaxb.ElemName(node) :: stack),
        scala.collection.immutable.ListMap(List(
        (node \ "@minimum").headOption map { x => IPXACT2022scalaxb.DataRecord(x, node, IPXACT2022scalaxb.fromXML[Int](x, IPXACT2022scalaxb.ElemName(node) :: stack)) } map { "@minimum" -> _ },
        (node \ "@maximum").headOption map { x => IPXACT2022scalaxb.DataRecord(x, node, IPXACT2022scalaxb.fromXML[Int](x, IPXACT2022scalaxb.ElemName(node) :: stack)) } map { "@maximum" -> _ }
        ).flatten[(String, IPXACT2022scalaxb.DataRecord[Any])] ::: (node match {
          case elem: scala.xml.Elem =>
            elem.attributes.toList flatMap {
              case scala.xml.UnprefixedAttribute(key, value, _) if key == "minimum" => Nil
              case scala.xml.UnprefixedAttribute(key, value, _) if key == "maximum" => Nil
              case scala.xml.UnprefixedAttribute(key, value, _) =>
                List(("@" + key, IPXACT2022scalaxb.DataRecord(None, Some(key), value.text)))
              case scala.xml.PrefixedAttribute(pre, key, value, _) =>
                val ns = elem.scope.getURI(pre)
                List(("@{" + ns + "}" + key, IPXACT2022scalaxb.DataRecord(Option[String](ns), Some(key), value.text)))
              case _ => Nil
            }
          case _ => Nil
        }): _*)))
      case _ => Left("reads failed: seq must be scala.xml.Node")
    }
    
    override def writesAttribute(__obj: IPXACT2022ScalaCases.UnsignedPositiveIntExpression, __scope: scala.xml.NamespaceBinding): scala.xml.MetaData = {
      var attr: scala.xml.MetaData  = scala.xml.Null
      __obj.attributes.toList map {
        case ("@minimum", _) => __obj.minimum foreach { x => attr = scala.xml.Attribute(null, "minimum", x.toString, attr) }
        case ("@maximum", _) => __obj.maximum foreach { x => attr = scala.xml.Attribute(null, "maximum", x.toString, attr) }
        case (key, x) => attr = scala.xml.Attribute((x.namespace map { __scope.getPrefix(_) }).orNull, x.key.orNull, x.value.toString, attr)
      }
      attr
    }

    def writesChildNodes(__obj: IPXACT2022ScalaCases.UnsignedPositiveIntExpression, __scope: scala.xml.NamespaceBinding): Seq[scala.xml.Node] =
      Seq(scala.xml.Text(__obj.value.toString))

  }

  trait DefaultIPXACT2022ScalaCases_UnresolvedUnsignedPositiveIntExpressionFormat extends IPXACT2022scalaxb.XMLFormat[IPXACT2022ScalaCases.UnresolvedUnsignedPositiveIntExpression] with IPXACT2022scalaxb.CanWriteChildNodes[IPXACT2022ScalaCases.UnresolvedUnsignedPositiveIntExpression] {
    val targetNamespace: Option[String] = Some("http://www.accellera.org/XMLSchema/IPXACT/1685-2022")
    def reads(seq: scala.xml.NodeSeq, stack: List[IPXACT2022scalaxb.ElemName]): Either[String, IPXACT2022ScalaCases.UnresolvedUnsignedPositiveIntExpression] = seq match {
      case node: scala.xml.Node => Right(IPXACT2022ScalaCases.UnresolvedUnsignedPositiveIntExpression(IPXACT2022scalaxb.fromXML[String](node, IPXACT2022scalaxb.ElemName(node) :: stack),
        scala.collection.immutable.ListMap(List(
        (node \ "@minimum").headOption map { x => IPXACT2022scalaxb.DataRecord(x, node, IPXACT2022scalaxb.fromXML[Int](x, IPXACT2022scalaxb.ElemName(node) :: stack)) } map { "@minimum" -> _ },
        (node \ "@maximum").headOption map { x => IPXACT2022scalaxb.DataRecord(x, node, IPXACT2022scalaxb.fromXML[Int](x, IPXACT2022scalaxb.ElemName(node) :: stack)) } map { "@maximum" -> _ }
        ).flatten[(String, IPXACT2022scalaxb.DataRecord[Any])] ::: (node match {
          case elem: scala.xml.Elem =>
            elem.attributes.toList flatMap {
              case scala.xml.UnprefixedAttribute(key, value, _) if key == "minimum" => Nil
              case scala.xml.UnprefixedAttribute(key, value, _) if key == "maximum" => Nil
              case scala.xml.UnprefixedAttribute(key, value, _) =>
                List(("@" + key, IPXACT2022scalaxb.DataRecord(None, Some(key), value.text)))
              case scala.xml.PrefixedAttribute(pre, key, value, _) =>
                val ns = elem.scope.getURI(pre)
                List(("@{" + ns + "}" + key, IPXACT2022scalaxb.DataRecord(Option[String](ns), Some(key), value.text)))
              case _ => Nil
            }
          case _ => Nil
        }): _*)))
      case _ => Left("reads failed: seq must be scala.xml.Node")
    }
    
    override def writesAttribute(__obj: IPXACT2022ScalaCases.UnresolvedUnsignedPositiveIntExpression, __scope: scala.xml.NamespaceBinding): scala.xml.MetaData = {
      var attr: scala.xml.MetaData  = scala.xml.Null
      __obj.attributes.toList map {
        case ("@minimum", _) => __obj.minimum foreach { x => attr = scala.xml.Attribute(null, "minimum", x.toString, attr) }
        case ("@maximum", _) => __obj.maximum foreach { x => attr = scala.xml.Attribute(null, "maximum", x.toString, attr) }
        case (key, x) => attr = scala.xml.Attribute((x.namespace map { __scope.getPrefix(_) }).orNull, x.key.orNull, x.value.toString, attr)
      }
      attr
    }

    def writesChildNodes(__obj: IPXACT2022ScalaCases.UnresolvedUnsignedPositiveIntExpression, __scope: scala.xml.NamespaceBinding): Seq[scala.xml.Node] =
      Seq(scala.xml.Text(__obj.value.toString))

  }

  trait DefaultIPXACT2022ScalaCases_RealExpressionableFormat extends IPXACT2022scalaxb.XMLFormat[IPXACT2022ScalaCases.RealExpressionable] {
    def reads(seq: scala.xml.NodeSeq, stack: List[IPXACT2022scalaxb.ElemName]): Either[String, IPXACT2022ScalaCases.RealExpressionable] = seq match {
      case node: scala.xml.Node =>     
        IPXACT2022scalaxb.Helper.instanceType(node) match {
          
          case _ => Right(IPXACT2022scalaxb.fromXML[IPXACT2022ScalaCases.RealExpression](node, stack))
        }
      case _ => Left("reads failed: seq must be scala.xml.Node")  
    }
    
    def writes(__obj: IPXACT2022ScalaCases.RealExpressionable, __namespace: Option[String], __elementLabel: Option[String],
        __scope: scala.xml.NamespaceBinding, __typeAttribute: Boolean): scala.xml.NodeSeq = __obj match {
      case x: IPXACT2022ScalaCases.ClockPulseDuration => IPXACT2022scalaxb.toXML[IPXACT2022ScalaCases.ClockPulseDuration](x, __namespace, __elementLabel, __scope, true)
      case x: IPXACT2022ScalaCases.ClockPulseOffset => IPXACT2022scalaxb.toXML[IPXACT2022ScalaCases.ClockPulseOffset](x, __namespace, __elementLabel, __scope, true)
      case x: IPXACT2022ScalaCases.ClockPeriod => IPXACT2022scalaxb.toXML[IPXACT2022ScalaCases.ClockPeriod](x, __namespace, __elementLabel, __scope, true)
      case x: IPXACT2022ScalaCases.SingleShotDuration => IPXACT2022scalaxb.toXML[IPXACT2022ScalaCases.SingleShotDuration](x, __namespace, __elementLabel, __scope, true)
      case x: IPXACT2022ScalaCases.SingleShotOffset => IPXACT2022scalaxb.toXML[IPXACT2022ScalaCases.SingleShotOffset](x, __namespace, __elementLabel, __scope, true)
      case x: IPXACT2022ScalaCases.RealExpression => IPXACT2022scalaxb.toXML[IPXACT2022ScalaCases.RealExpression](x, __namespace, __elementLabel, __scope, __typeAttribute)
    }
  }

  trait DefaultIPXACT2022ScalaCases_RealExpressionFormat extends IPXACT2022scalaxb.XMLFormat[IPXACT2022ScalaCases.RealExpression] with IPXACT2022scalaxb.CanWriteChildNodes[IPXACT2022ScalaCases.RealExpression] {
    val targetNamespace: Option[String] = Some("http://www.accellera.org/XMLSchema/IPXACT/1685-2022")
    def reads(seq: scala.xml.NodeSeq, stack: List[IPXACT2022scalaxb.ElemName]): Either[String, IPXACT2022ScalaCases.RealExpression] = seq match {
      case node: scala.xml.Node => Right(IPXACT2022ScalaCases.RealExpression(IPXACT2022scalaxb.fromXML[String](node, IPXACT2022scalaxb.ElemName(node) :: stack),
        scala.collection.immutable.ListMap(List(
        (node \ "@minimum").headOption map { x => IPXACT2022scalaxb.DataRecord(x, node, IPXACT2022scalaxb.fromXML[Double](x, IPXACT2022scalaxb.ElemName(node) :: stack)) } map { "@minimum" -> _ },
        (node \ "@maximum").headOption map { x => IPXACT2022scalaxb.DataRecord(x, node, IPXACT2022scalaxb.fromXML[Double](x, IPXACT2022scalaxb.ElemName(node) :: stack)) } map { "@maximum" -> _ }
        ).flatten[(String, IPXACT2022scalaxb.DataRecord[Any])] ::: (node match {
          case elem: scala.xml.Elem =>
            elem.attributes.toList flatMap {
              case scala.xml.UnprefixedAttribute(key, value, _) if key == "minimum" => Nil
              case scala.xml.UnprefixedAttribute(key, value, _) if key == "maximum" => Nil
              case scala.xml.UnprefixedAttribute(key, value, _) =>
                List(("@" + key, IPXACT2022scalaxb.DataRecord(None, Some(key), value.text)))
              case scala.xml.PrefixedAttribute(pre, key, value, _) =>
                val ns = elem.scope.getURI(pre)
                List(("@{" + ns + "}" + key, IPXACT2022scalaxb.DataRecord(Option[String](ns), Some(key), value.text)))
              case _ => Nil
            }
          case _ => Nil
        }): _*)))
      case _ => Left("reads failed: seq must be scala.xml.Node")
    }
    
    override def writesAttribute(__obj: IPXACT2022ScalaCases.RealExpression, __scope: scala.xml.NamespaceBinding): scala.xml.MetaData = {
      var attr: scala.xml.MetaData  = scala.xml.Null
      __obj.attributes.toList map {
        case ("@minimum", _) => __obj.minimum foreach { x => attr = scala.xml.Attribute(null, "minimum", x.toString, attr) }
        case ("@maximum", _) => __obj.maximum foreach { x => attr = scala.xml.Attribute(null, "maximum", x.toString, attr) }
        case (key, x) => attr = scala.xml.Attribute((x.namespace map { __scope.getPrefix(_) }).orNull, x.key.orNull, x.value.toString, attr)
      }
      attr
    }

    def writesChildNodes(__obj: IPXACT2022ScalaCases.RealExpression, __scope: scala.xml.NamespaceBinding): Seq[scala.xml.Node] =
      Seq(scala.xml.Text(__obj.value.toString))

  }

  trait DefaultIPXACT2022ScalaCases_UnresolvedStringExpressionableFormat extends IPXACT2022scalaxb.XMLFormat[IPXACT2022ScalaCases.UnresolvedStringExpressionable] {
    def reads(seq: scala.xml.NodeSeq, stack: List[IPXACT2022scalaxb.ElemName]): Either[String, IPXACT2022ScalaCases.UnresolvedStringExpressionable] = seq match {
      case node: scala.xml.Node =>     
        IPXACT2022scalaxb.Helper.instanceType(node) match {
          case (Some("http://www.accellera.org/XMLSchema/IPXACT/1685-2022"), Some("pathSegmentType")) => Right(IPXACT2022scalaxb.fromXML[IPXACT2022ScalaCases.PathSegmentType](node, stack))
          case _ => Right(IPXACT2022scalaxb.fromXML[IPXACT2022ScalaCases.UnresolvedStringExpression](node, stack))
        }
      case _ => Left("reads failed: seq must be scala.xml.Node")  
    }
    
    def writes(__obj: IPXACT2022ScalaCases.UnresolvedStringExpressionable, __namespace: Option[String], __elementLabel: Option[String],
        __scope: scala.xml.NamespaceBinding, __typeAttribute: Boolean): scala.xml.NodeSeq = __obj match {
      case x: IPXACT2022ScalaCases.PathSegmentType => IPXACT2022scalaxb.toXML[IPXACT2022ScalaCases.PathSegmentType](x, __namespace, __elementLabel, __scope, true)
      case x: IPXACT2022ScalaCases.UnresolvedStringExpression => IPXACT2022scalaxb.toXML[IPXACT2022ScalaCases.UnresolvedStringExpression](x, __namespace, __elementLabel, __scope, __typeAttribute)
    }
  }
  trait DefaultIPXACT2022ScalaCases_UnresolvedStringExpressionFormat extends IPXACT2022scalaxb.XMLFormat[IPXACT2022ScalaCases.UnresolvedStringExpression] with IPXACT2022scalaxb.CanWriteChildNodes[IPXACT2022ScalaCases.UnresolvedStringExpression] {
    val targetNamespace: Option[String] = Some("http://www.accellera.org/XMLSchema/IPXACT/1685-2022")
    def reads(seq: scala.xml.NodeSeq, stack: List[IPXACT2022scalaxb.ElemName]): Either[String, IPXACT2022ScalaCases.UnresolvedStringExpression] = seq match {
      case node: scala.xml.Node => Right(IPXACT2022ScalaCases.UnresolvedStringExpression(IPXACT2022scalaxb.fromXML[String](node, IPXACT2022scalaxb.ElemName(node) :: stack),
        scala.collection.immutable.ListMap((node match {
          case elem: scala.xml.Elem =>
            elem.attributes.toList flatMap {
              
              case scala.xml.UnprefixedAttribute(key, value, _) =>
                List(("@" + key, IPXACT2022scalaxb.DataRecord(None, Some(key), value.text)))
              case scala.xml.PrefixedAttribute(pre, key, value, _) =>
                val ns = elem.scope.getURI(pre)
                List(("@{" + ns + "}" + key, IPXACT2022scalaxb.DataRecord(Option[String](ns), Some(key), value.text)))
              case _ => Nil
            }
          case _ => Nil
        }): _*)))
      case _ => Left("reads failed: seq must be scala.xml.Node")
    }
    
    override def writesAttribute(__obj: IPXACT2022ScalaCases.UnresolvedStringExpression, __scope: scala.xml.NamespaceBinding): scala.xml.MetaData = {
      var attr: scala.xml.MetaData  = scala.xml.Null
      __obj.attributes.toList map {
        case (key, x) => attr = scala.xml.Attribute((x.namespace map { __scope.getPrefix(_) }).orNull, x.key.orNull, x.value.toString, attr)
      }
      attr
    }
    def writesChildNodes(__obj: IPXACT2022ScalaCases.UnresolvedStringExpression, __scope: scala.xml.NamespaceBinding): Seq[scala.xml.Node] =
      Seq(scala.xml.Text(__obj.value.toString))

  }

  trait DefaultIPXACT2022ScalaCases_StringExpressionableFormat extends IPXACT2022scalaxb.XMLFormat[IPXACT2022ScalaCases.StringExpressionable] {
    def reads(seq: scala.xml.NodeSeq, stack: List[IPXACT2022scalaxb.ElemName]): Either[String, IPXACT2022ScalaCases.StringExpressionable] = seq match {
      case node: scala.xml.Node =>     
        IPXACT2022scalaxb.Helper.instanceType(node) match {
          case (Some("http://www.accellera.org/XMLSchema/IPXACT/1685-2022"), Some("portPathSegmentType")) => Right(IPXACT2022scalaxb.fromXML[IPXACT2022ScalaCases.PortPathSegmentType](node, stack))
          case _ => Right(IPXACT2022scalaxb.fromXML[IPXACT2022ScalaCases.StringExpression](node, stack))
        }
      case _ => Left("reads failed: seq must be scala.xml.Node")  
    }
    
    def writes(__obj: IPXACT2022ScalaCases.StringExpressionable, __namespace: Option[String], __elementLabel: Option[String],
        __scope: scala.xml.NamespaceBinding, __typeAttribute: Boolean): scala.xml.NodeSeq = __obj match {
      case x: IPXACT2022ScalaCases.PortPathSegmentType => IPXACT2022scalaxb.toXML[IPXACT2022ScalaCases.PortPathSegmentType](x, __namespace, __elementLabel, __scope, true)
      case x: IPXACT2022ScalaCases.Flags => IPXACT2022scalaxb.toXML[IPXACT2022ScalaCases.Flags](x, __namespace, __elementLabel, __scope, true)
      case x: IPXACT2022ScalaCases.StringExpression => IPXACT2022scalaxb.toXML[IPXACT2022ScalaCases.StringExpression](x, __namespace, __elementLabel, __scope, __typeAttribute)
    }
  }

  trait DefaultIPXACT2022ScalaCases_StringExpressionFormat extends IPXACT2022scalaxb.XMLFormat[IPXACT2022ScalaCases.StringExpression] with IPXACT2022scalaxb.CanWriteChildNodes[IPXACT2022ScalaCases.StringExpression] {
    val targetNamespace: Option[String] = Some("http://www.accellera.org/XMLSchema/IPXACT/1685-2022")
    def reads(seq: scala.xml.NodeSeq, stack: List[IPXACT2022scalaxb.ElemName]): Either[String, IPXACT2022ScalaCases.StringExpression] = seq match {
      case node: scala.xml.Node => Right(IPXACT2022ScalaCases.StringExpression(IPXACT2022scalaxb.fromXML[String](node, IPXACT2022scalaxb.ElemName(node) :: stack),
        scala.collection.immutable.ListMap((node match {
          case elem: scala.xml.Elem =>
            elem.attributes.toList flatMap {
              
              case scala.xml.UnprefixedAttribute(key, value, _) =>
                List(("@" + key, IPXACT2022scalaxb.DataRecord(None, Some(key), value.text)))
              case scala.xml.PrefixedAttribute(pre, key, value, _) =>
                val ns = elem.scope.getURI(pre)
                List(("@{" + ns + "}" + key, IPXACT2022scalaxb.DataRecord(Option[String](ns), Some(key), value.text)))
              case _ => Nil
            }
          case _ => Nil
        }): _*)))
      case _ => Left("reads failed: seq must be scala.xml.Node")
    }
    
    override def writesAttribute(__obj: IPXACT2022ScalaCases.StringExpression, __scope: scala.xml.NamespaceBinding): scala.xml.MetaData = {
      var attr: scala.xml.MetaData  = scala.xml.Null
      __obj.attributes.toList map {
        case (key, x) => attr = scala.xml.Attribute((x.namespace map { __scope.getPrefix(_) }).orNull, x.key.orNull, x.value.toString, attr)
      }
      attr
    }
    def writesChildNodes(__obj: IPXACT2022ScalaCases.StringExpression, __scope: scala.xml.NamespaceBinding): Seq[scala.xml.Node] =
      Seq(scala.xml.Text(__obj.value.toString))

  }

  trait DefaultIPXACT2022ScalaCases_UnsignedBitExpressionFormat extends IPXACT2022scalaxb.XMLFormat[IPXACT2022ScalaCases.UnsignedBitExpression] with IPXACT2022scalaxb.CanWriteChildNodes[IPXACT2022ScalaCases.UnsignedBitExpression] {
    val targetNamespace: Option[String] = Some("http://www.accellera.org/XMLSchema/IPXACT/1685-2022")
    def reads(seq: scala.xml.NodeSeq, stack: List[IPXACT2022scalaxb.ElemName]): Either[String, IPXACT2022ScalaCases.UnsignedBitExpression] = seq match {
      case node: scala.xml.Node => Right(IPXACT2022ScalaCases.UnsignedBitExpression(IPXACT2022scalaxb.fromXML[String](node, IPXACT2022scalaxb.ElemName(node) :: stack),
        scala.collection.immutable.ListMap((node match {
          case elem: scala.xml.Elem =>
            elem.attributes.toList flatMap {
              
              case scala.xml.UnprefixedAttribute(key, value, _) =>
                List(("@" + key, IPXACT2022scalaxb.DataRecord(None, Some(key), value.text)))
              case scala.xml.PrefixedAttribute(pre, key, value, _) =>
                val ns = elem.scope.getURI(pre)
                List(("@{" + ns + "}" + key, IPXACT2022scalaxb.DataRecord(Option[String](ns), Some(key), value.text)))
              case _ => Nil
            }
          case _ => Nil
        }): _*)))
      case _ => Left("reads failed: seq must be scala.xml.Node")
    }
    
    override def writesAttribute(__obj: IPXACT2022ScalaCases.UnsignedBitExpression, __scope: scala.xml.NamespaceBinding): scala.xml.MetaData = {
      var attr: scala.xml.MetaData  = scala.xml.Null
      __obj.attributes.toList map {
        case (key, x) => attr = scala.xml.Attribute((x.namespace map { __scope.getPrefix(_) }).orNull, x.key.orNull, x.value.toString, attr)
      }
      attr
    }
    def writesChildNodes(__obj: IPXACT2022ScalaCases.UnsignedBitExpression, __scope: scala.xml.NamespaceBinding): Seq[scala.xml.Node] =
      Seq(scala.xml.Text(__obj.value.toString))

  }

  trait DefaultIPXACT2022ScalaCases_QualifiedExpressionFormat extends IPXACT2022scalaxb.XMLFormat[IPXACT2022ScalaCases.QualifiedExpression] with IPXACT2022scalaxb.CanWriteChildNodes[IPXACT2022ScalaCases.QualifiedExpression] {
    val targetNamespace: Option[String] = Some("http://www.accellera.org/XMLSchema/IPXACT/1685-2022")
    def reads(seq: scala.xml.NodeSeq, stack: List[IPXACT2022scalaxb.ElemName]): Either[String, IPXACT2022ScalaCases.QualifiedExpression] = seq match {
      case node: scala.xml.Node => Right(IPXACT2022ScalaCases.QualifiedExpression(IPXACT2022scalaxb.fromXML[String](node, IPXACT2022scalaxb.ElemName(node) :: stack),
        scala.collection.immutable.ListMap((node match {
          case elem: scala.xml.Elem =>
            elem.attributes.toList flatMap {
              
              case scala.xml.UnprefixedAttribute(key, value, _) =>
                List(("@" + key, IPXACT2022scalaxb.DataRecord(None, Some(key), value.text)))
              case scala.xml.PrefixedAttribute(pre, key, value, _) =>
                val ns = elem.scope.getURI(pre)
                List(("@{" + ns + "}" + key, IPXACT2022scalaxb.DataRecord(Option[String](ns), Some(key), value.text)))
              case _ => Nil
            }
          case _ => Nil
        }): _*)))
      case _ => Left("reads failed: seq must be scala.xml.Node")
    }
    
    override def writesAttribute(__obj: IPXACT2022ScalaCases.QualifiedExpression, __scope: scala.xml.NamespaceBinding): scala.xml.MetaData = {
      var attr: scala.xml.MetaData  = scala.xml.Null
      __obj.attributes.toList map {
        case (key, x) => attr = scala.xml.Attribute((x.namespace map { __scope.getPrefix(_) }).orNull, x.key.orNull, x.value.toString, attr)
      }
      attr
    }
    def writesChildNodes(__obj: IPXACT2022ScalaCases.QualifiedExpression, __scope: scala.xml.NamespaceBinding): Seq[scala.xml.Node] =
      Seq(scala.xml.Text(__obj.value.toString))

  }

  trait DefaultIPXACT2022ScalaCases_UnsignedBitVectorExpressionableFormat extends IPXACT2022scalaxb.XMLFormat[IPXACT2022ScalaCases.UnsignedBitVectorExpressionable] {
    def reads(seq: scala.xml.NodeSeq, stack: List[IPXACT2022scalaxb.ElemName]): Either[String, IPXACT2022ScalaCases.UnsignedBitVectorExpressionable] = seq match {
      case node: scala.xml.Node =>     
        IPXACT2022scalaxb.Helper.instanceType(node) match {
          
          case _ => Right(IPXACT2022scalaxb.fromXML[IPXACT2022ScalaCases.UnsignedBitVectorExpression](node, stack))
        }
      case _ => Left("reads failed: seq must be scala.xml.Node")  
    }
    
    def writes(__obj: IPXACT2022ScalaCases.UnsignedBitVectorExpressionable, __namespace: Option[String], __elementLabel: Option[String],
        __scope: scala.xml.NamespaceBinding, __typeAttribute: Boolean): scala.xml.NodeSeq = __obj match {
      case x: IPXACT2022ScalaCases.SingleShotValue => IPXACT2022scalaxb.toXML[IPXACT2022ScalaCases.SingleShotValue](x, __namespace, __elementLabel, __scope, true)
      case x: IPXACT2022ScalaCases.UnsignedBitVectorExpression => IPXACT2022scalaxb.toXML[IPXACT2022ScalaCases.UnsignedBitVectorExpression](x, __namespace, __elementLabel, __scope, __typeAttribute)
    }
  }
  trait DefaultIPXACT2022ScalaCases_UnsignedBitVectorExpressionFormat extends IPXACT2022scalaxb.XMLFormat[IPXACT2022ScalaCases.UnsignedBitVectorExpression] with IPXACT2022scalaxb.CanWriteChildNodes[IPXACT2022ScalaCases.UnsignedBitVectorExpression] {
    val targetNamespace: Option[String] = Some("http://www.accellera.org/XMLSchema/IPXACT/1685-2022")
    def reads(seq: scala.xml.NodeSeq, stack: List[IPXACT2022scalaxb.ElemName]): Either[String, IPXACT2022ScalaCases.UnsignedBitVectorExpression] = seq match {
      case node: scala.xml.Node => Right(IPXACT2022ScalaCases.UnsignedBitVectorExpression(IPXACT2022scalaxb.fromXML[String](node, IPXACT2022scalaxb.ElemName(node) :: stack),
        scala.collection.immutable.ListMap((node match {
          case elem: scala.xml.Elem =>
            elem.attributes.toList flatMap {
              
              case scala.xml.UnprefixedAttribute(key, value, _) =>
                List(("@" + key, IPXACT2022scalaxb.DataRecord(None, Some(key), value.text)))
              case scala.xml.PrefixedAttribute(pre, key, value, _) =>
                val ns = elem.scope.getURI(pre)
                List(("@{" + ns + "}" + key, IPXACT2022scalaxb.DataRecord(Option[String](ns), Some(key), value.text)))
              case _ => Nil
            }
          case _ => Nil
        }): _*)))
      case _ => Left("reads failed: seq must be scala.xml.Node")
    }
    
    override def writesAttribute(__obj: IPXACT2022ScalaCases.UnsignedBitVectorExpression, __scope: scala.xml.NamespaceBinding): scala.xml.MetaData = {
      var attr: scala.xml.MetaData  = scala.xml.Null
      __obj.attributes.toList map {
        case (key, x) => attr = scala.xml.Attribute((x.namespace map { __scope.getPrefix(_) }).orNull, x.key.orNull, x.value.toString, attr)
      }
      attr
    }
    def writesChildNodes(__obj: IPXACT2022ScalaCases.UnsignedBitVectorExpression, __scope: scala.xml.NamespaceBinding): Seq[scala.xml.Node] =
      Seq(scala.xml.Text(__obj.value.toString))

  }

  trait DefaultIPXACT2022ScalaCases_ComplexBaseExpressionableFormat extends IPXACT2022scalaxb.XMLFormat[IPXACT2022ScalaCases.ComplexBaseExpressionable] {
    def reads(seq: scala.xml.NodeSeq, stack: List[IPXACT2022scalaxb.ElemName]): Either[String, IPXACT2022ScalaCases.ComplexBaseExpressionable] = seq match {
      case node: scala.xml.Node =>     
        IPXACT2022scalaxb.Helper.instanceType(node) match {
          case (Some("http://www.accellera.org/XMLSchema/IPXACT/1685-2022"), Some("qualifiedExpression")) => Right(IPXACT2022scalaxb.fromXML[IPXACT2022ScalaCases.QualifiedExpression](node, stack))
          case (Some("http://www.accellera.org/XMLSchema/IPXACT/1685-2022"), Some("stringExpression")) => Right(IPXACT2022scalaxb.fromXML[IPXACT2022ScalaCases.StringExpressionable](node, stack))
          case (Some("http://www.accellera.org/XMLSchema/IPXACT/1685-2022"), Some("portPathSegmentType")) => Right(IPXACT2022scalaxb.fromXML[IPXACT2022ScalaCases.PortPathSegmentType](node, stack))
          case (Some("http://www.accellera.org/XMLSchema/IPXACT/1685-2022"), Some("realExpression")) => Right(IPXACT2022scalaxb.fromXML[IPXACT2022ScalaCases.RealExpressionable](node, stack))
          case (Some("http://www.accellera.org/XMLSchema/IPXACT/1685-2022"), Some("unsignedPositiveIntExpression")) => Right(IPXACT2022scalaxb.fromXML[IPXACT2022ScalaCases.UnsignedPositiveIntExpressionable](node, stack))
          case (Some("http://www.accellera.org/XMLSchema/IPXACT/1685-2022"), Some("signedLongintExpression")) => Right(IPXACT2022scalaxb.fromXML[IPXACT2022ScalaCases.SignedLongintExpression](node, stack))
          case (Some("http://www.accellera.org/XMLSchema/IPXACT/1685-2022"), Some("unsignedLongintExpression")) => Right(IPXACT2022scalaxb.fromXML[IPXACT2022ScalaCases.UnsignedLongintExpressionable](node, stack))
          case (Some("http://www.accellera.org/XMLSchema/IPXACT/1685-2022"), Some("unsignedPositiveLongintExpression")) => Right(IPXACT2022scalaxb.fromXML[IPXACT2022ScalaCases.UnsignedPositiveLongintExpressionable](node, stack))
          case (Some("http://www.accellera.org/XMLSchema/IPXACT/1685-2022"), Some("unsignedIntExpression")) => Right(IPXACT2022scalaxb.fromXML[IPXACT2022ScalaCases.UnsignedIntExpressionable](node, stack))
          case (Some("http://www.accellera.org/XMLSchema/IPXACT/1685-2022"), Some("unresolvedUnsignedPositiveIntExpression")) => Right(IPXACT2022scalaxb.fromXML[IPXACT2022ScalaCases.UnresolvedUnsignedPositiveIntExpression](node, stack))
          case (Some("http://www.accellera.org/XMLSchema/IPXACT/1685-2022"), Some("unresolvedStringExpression")) => Right(IPXACT2022scalaxb.fromXML[IPXACT2022ScalaCases.UnresolvedStringExpressionable](node, stack))
          case (Some("http://www.accellera.org/XMLSchema/IPXACT/1685-2022"), Some("pathSegmentType")) => Right(IPXACT2022scalaxb.fromXML[IPXACT2022ScalaCases.PathSegmentType](node, stack))
          case (Some("http://www.accellera.org/XMLSchema/IPXACT/1685-2022"), Some("unsignedBitExpression")) => Right(IPXACT2022scalaxb.fromXML[IPXACT2022ScalaCases.UnsignedBitExpression](node, stack))
          case (Some("http://www.accellera.org/XMLSchema/IPXACT/1685-2022"), Some("unsignedBitVectorExpression")) => Right(IPXACT2022scalaxb.fromXML[IPXACT2022ScalaCases.UnsignedBitVectorExpressionable](node, stack))
          case (Some("http://www.accellera.org/XMLSchema/IPXACT/1685-2022"), Some("unresolvedUnsignedBitExpression")) => Right(IPXACT2022scalaxb.fromXML[IPXACT2022ScalaCases.UnresolvedUnsignedBitExpression](node, stack))
          case _ => Right(IPXACT2022scalaxb.fromXML[IPXACT2022ScalaCases.ComplexBaseExpression](node, stack))
        }
      case _ => Left("reads failed: seq must be scala.xml.Node")  
    }
    
    def writes(__obj: IPXACT2022ScalaCases.ComplexBaseExpressionable, __namespace: Option[String], __elementLabel: Option[String],
        __scope: scala.xml.NamespaceBinding, __typeAttribute: Boolean): scala.xml.NodeSeq = __obj match {
      case x: IPXACT2022ScalaCases.QualifiedExpression => IPXACT2022scalaxb.toXML[IPXACT2022ScalaCases.QualifiedExpression](x, __namespace, __elementLabel, __scope, true)
      case x: IPXACT2022ScalaCases.StringExpressionable => IPXACT2022scalaxb.toXML[IPXACT2022ScalaCases.StringExpressionable](x, __namespace, __elementLabel, __scope, true)
      case x: IPXACT2022ScalaCases.RealExpressionable => IPXACT2022scalaxb.toXML[IPXACT2022ScalaCases.RealExpressionable](x, __namespace, __elementLabel, __scope, true)
      case x: IPXACT2022ScalaCases.UnsignedPositiveIntExpressionable => IPXACT2022scalaxb.toXML[IPXACT2022ScalaCases.UnsignedPositiveIntExpressionable](x, __namespace, __elementLabel, __scope, true)
      case x: IPXACT2022ScalaCases.SignedLongintExpression => IPXACT2022scalaxb.toXML[IPXACT2022ScalaCases.SignedLongintExpression](x, __namespace, __elementLabel, __scope, true)
      case x: IPXACT2022ScalaCases.UnsignedLongintExpressionable => IPXACT2022scalaxb.toXML[IPXACT2022ScalaCases.UnsignedLongintExpressionable](x, __namespace, __elementLabel, __scope, true)
      case x: IPXACT2022ScalaCases.UnsignedPositiveLongintExpressionable => IPXACT2022scalaxb.toXML[IPXACT2022ScalaCases.UnsignedPositiveLongintExpressionable](x, __namespace, __elementLabel, __scope, true)
      case x: IPXACT2022ScalaCases.UnsignedIntExpressionable => IPXACT2022scalaxb.toXML[IPXACT2022ScalaCases.UnsignedIntExpressionable](x, __namespace, __elementLabel, __scope, true)
      case x: IPXACT2022ScalaCases.UnresolvedUnsignedPositiveIntExpression => IPXACT2022scalaxb.toXML[IPXACT2022ScalaCases.UnresolvedUnsignedPositiveIntExpression](x, __namespace, __elementLabel, __scope, true)
      case x: IPXACT2022ScalaCases.UnresolvedStringExpressionable => IPXACT2022scalaxb.toXML[IPXACT2022ScalaCases.UnresolvedStringExpressionable](x, __namespace, __elementLabel, __scope, true)
      case x: IPXACT2022ScalaCases.UnsignedBitExpression => IPXACT2022scalaxb.toXML[IPXACT2022ScalaCases.UnsignedBitExpression](x, __namespace, __elementLabel, __scope, true)
      case x: IPXACT2022ScalaCases.UnsignedBitVectorExpressionable => IPXACT2022scalaxb.toXML[IPXACT2022ScalaCases.UnsignedBitVectorExpressionable](x, __namespace, __elementLabel, __scope, true)
      case x: IPXACT2022ScalaCases.UnresolvedUnsignedBitExpression => IPXACT2022scalaxb.toXML[IPXACT2022ScalaCases.UnresolvedUnsignedBitExpression](x, __namespace, __elementLabel, __scope, true)
      case x: IPXACT2022ScalaCases.Enumeration => IPXACT2022scalaxb.toXML[IPXACT2022ScalaCases.Enumeration](x, __namespace, __elementLabel, __scope, true)
      case x: IPXACT2022ScalaCases.ConfigurableElementValue => IPXACT2022scalaxb.toXML[IPXACT2022ScalaCases.ConfigurableElementValue](x, __namespace, __elementLabel, __scope, true)
      case x: IPXACT2022ScalaCases.ComplexBaseExpression => IPXACT2022scalaxb.toXML[IPXACT2022ScalaCases.ComplexBaseExpression](x, __namespace, __elementLabel, __scope, __typeAttribute)
    }
  }

  trait DefaultIPXACT2022ScalaCases_ComplexBaseExpressionFormat extends IPXACT2022scalaxb.XMLFormat[IPXACT2022ScalaCases.ComplexBaseExpression] with IPXACT2022scalaxb.CanWriteChildNodes[IPXACT2022ScalaCases.ComplexBaseExpression] {
    val targetNamespace: Option[String] = Some("http://www.accellera.org/XMLSchema/IPXACT/1685-2022")
    def reads(seq: scala.xml.NodeSeq, stack: List[IPXACT2022scalaxb.ElemName]): Either[String, IPXACT2022ScalaCases.ComplexBaseExpression] = seq match {
      case node: scala.xml.Node => Right(IPXACT2022ScalaCases.ComplexBaseExpression(IPXACT2022scalaxb.fromXML[String](node, IPXACT2022scalaxb.ElemName(node) :: stack),
        scala.collection.immutable.ListMap((node match {
          case elem: scala.xml.Elem =>
            elem.attributes.toList flatMap {
              
              case scala.xml.UnprefixedAttribute(key, value, _) =>
                List(("@" + key, IPXACT2022scalaxb.DataRecord(None, Some(key), value.text)))
              case scala.xml.PrefixedAttribute(pre, key, value, _) =>
                val ns = elem.scope.getURI(pre)
                List(("@{" + ns + "}" + key, IPXACT2022scalaxb.DataRecord(Option[String](ns), Some(key), value.text)))
              case _ => Nil
            }
          case _ => Nil
        }): _*)))
      case _ => Left("reads failed: seq must be scala.xml.Node")
    }
    
    override def writesAttribute(__obj: IPXACT2022ScalaCases.ComplexBaseExpression, __scope: scala.xml.NamespaceBinding): scala.xml.MetaData = {
      var attr: scala.xml.MetaData  = scala.xml.Null
      __obj.attributes.toList map {
        case (key, x) => attr = scala.xml.Attribute((x.namespace map { __scope.getPrefix(_) }).orNull, x.key.orNull, x.value.toString, attr)
      }
      attr
    }
    def writesChildNodes(__obj: IPXACT2022ScalaCases.ComplexBaseExpression, __scope: scala.xml.NamespaceBinding): Seq[scala.xml.Node] =
      Seq(scala.xml.Text(__obj.value.toString))

  }

  trait DefaultIPXACT2022ScalaCases_IpxactURIableFormat extends IPXACT2022scalaxb.XMLFormat[IPXACT2022ScalaCases.IpxactURIable] {
    def reads(seq: scala.xml.NodeSeq, stack: List[IPXACT2022scalaxb.ElemName]): Either[String, IPXACT2022ScalaCases.IpxactURIable] = seq match {
      case node: scala.xml.Node =>     
        IPXACT2022scalaxb.Helper.instanceType(node) match {
          
          case _ => Right(IPXACT2022scalaxb.fromXML[IPXACT2022ScalaCases.IpxactURI](node, stack))
        }
      case _ => Left("reads failed: seq must be scala.xml.Node")  
    }
    
    def writes(__obj: IPXACT2022ScalaCases.IpxactURIable, __namespace: Option[String], __elementLabel: Option[String],
        __scope: scala.xml.NamespaceBinding, __typeAttribute: Boolean): scala.xml.NodeSeq = __obj match {
      case x: IPXACT2022ScalaCases.Dependency => IPXACT2022scalaxb.toXML[IPXACT2022ScalaCases.Dependency](x, __namespace, __elementLabel, __scope, true)
      case x: IPXACT2022ScalaCases.IpxactURI => IPXACT2022scalaxb.toXML[IPXACT2022ScalaCases.IpxactURI](x, __namespace, __elementLabel, __scope, __typeAttribute)
    }
  }
  trait DefaultIPXACT2022ScalaCases_IpxactURIFormat extends IPXACT2022scalaxb.XMLFormat[IPXACT2022ScalaCases.IpxactURI] with IPXACT2022scalaxb.CanWriteChildNodes[IPXACT2022ScalaCases.IpxactURI] {
    val targetNamespace: Option[String] = Some("http://www.accellera.org/XMLSchema/IPXACT/1685-2022")
    def reads(seq: scala.xml.NodeSeq, stack: List[IPXACT2022scalaxb.ElemName]): Either[String, IPXACT2022ScalaCases.IpxactURI] = seq match {
      case node: scala.xml.Node => Right(IPXACT2022ScalaCases.IpxactURI(IPXACT2022scalaxb.fromXML[String](node, IPXACT2022scalaxb.ElemName(node) :: stack)))
      case _ => Left("reads failed: seq must be scala.xml.Node")
    }
    
    def writesChildNodes(__obj: IPXACT2022ScalaCases.IpxactURI, __scope: scala.xml.NamespaceBinding): Seq[scala.xml.Node] =
      Seq(scala.xml.Text(__obj.value.toString))

  }
  trait DefaultIPXACT2022ScalaCases_UnresolvedUnsignedBitExpressionFormat extends IPXACT2022scalaxb.XMLFormat[IPXACT2022ScalaCases.UnresolvedUnsignedBitExpression] with IPXACT2022scalaxb.CanWriteChildNodes[IPXACT2022ScalaCases.UnresolvedUnsignedBitExpression] {
    val targetNamespace: Option[String] = Some("http://www.accellera.org/XMLSchema/IPXACT/1685-2022")
    def reads(seq: scala.xml.NodeSeq, stack: List[IPXACT2022scalaxb.ElemName]): Either[String, IPXACT2022ScalaCases.UnresolvedUnsignedBitExpression] = seq match {
      case node: scala.xml.Node => Right(IPXACT2022ScalaCases.UnresolvedUnsignedBitExpression(IPXACT2022scalaxb.fromXML[String](node, IPXACT2022scalaxb.ElemName(node) :: stack),
        scala.collection.immutable.ListMap((node match {
          case elem: scala.xml.Elem =>
            elem.attributes.toList flatMap {
              
              case scala.xml.UnprefixedAttribute(key, value, _) =>
                List(("@" + key, IPXACT2022scalaxb.DataRecord(None, Some(key), value.text)))
              case scala.xml.PrefixedAttribute(pre, key, value, _) =>
                val ns = elem.scope.getURI(pre)
                List(("@{" + ns + "}" + key, IPXACT2022scalaxb.DataRecord(Option[String](ns), Some(key), value.text)))
              case _ => Nil
            }
          case _ => Nil
        }): _*)))
      case _ => Left("reads failed: seq must be scala.xml.Node")
    }
    
    override def writesAttribute(__obj: IPXACT2022ScalaCases.UnresolvedUnsignedBitExpression, __scope: scala.xml.NamespaceBinding): scala.xml.MetaData = {
      var attr: scala.xml.MetaData  = scala.xml.Null
      __obj.attributes.toList map {
        case (key, x) => attr = scala.xml.Attribute((x.namespace map { __scope.getPrefix(_) }).orNull, x.key.orNull, x.value.toString, attr)
      }
      attr
    }
    def writesChildNodes(__obj: IPXACT2022ScalaCases.UnresolvedUnsignedBitExpression, __scope: scala.xml.NamespaceBinding): Seq[scala.xml.Node] =
      Seq(scala.xml.Text(__obj.value.toString))

  }

  trait DefaultIPXACT2022ScalaCases_ComplexTiedValueExpressionFormat extends IPXACT2022scalaxb.XMLFormat[IPXACT2022ScalaCases.ComplexTiedValueExpression] with IPXACT2022scalaxb.CanWriteChildNodes[IPXACT2022ScalaCases.ComplexTiedValueExpression] {
    val targetNamespace: Option[String] = Some("http://www.accellera.org/XMLSchema/IPXACT/1685-2022")
    def reads(seq: scala.xml.NodeSeq, stack: List[IPXACT2022scalaxb.ElemName]): Either[String, IPXACT2022ScalaCases.ComplexTiedValueExpression] = seq match {
      case node: scala.xml.Node => Right(IPXACT2022ScalaCases.ComplexTiedValueExpression(IPXACT2022scalaxb.fromXML[String](node, IPXACT2022scalaxb.ElemName(node) :: stack),
        scala.collection.immutable.ListMap(List(
        (node \ "@minimum").headOption map { x => IPXACT2022scalaxb.DataRecord(x, node, IPXACT2022scalaxb.fromXML[Int](x, IPXACT2022scalaxb.ElemName(node) :: stack)) } map { "@minimum" -> _ },
        (node \ "@maximum").headOption map { x => IPXACT2022scalaxb.DataRecord(x, node, IPXACT2022scalaxb.fromXML[Int](x, IPXACT2022scalaxb.ElemName(node) :: stack)) } map { "@maximum" -> _ }
        ).flatten[(String, IPXACT2022scalaxb.DataRecord[Any])] ::: (node match {
          case elem: scala.xml.Elem =>
            elem.attributes.toList flatMap {
              case scala.xml.UnprefixedAttribute(key, value, _) if key == "minimum" => Nil
              case scala.xml.UnprefixedAttribute(key, value, _) if key == "maximum" => Nil
              case scala.xml.UnprefixedAttribute(key, value, _) =>
                List(("@" + key, IPXACT2022scalaxb.DataRecord(None, Some(key), value.text)))
              case scala.xml.PrefixedAttribute(pre, key, value, _) =>
                val ns = elem.scope.getURI(pre)
                List(("@{" + ns + "}" + key, IPXACT2022scalaxb.DataRecord(Option[String](ns), Some(key), value.text)))
              case _ => Nil
            }
          case _ => Nil
        }): _*)))
      case _ => Left("reads failed: seq must be scala.xml.Node")
    }
    
    override def writesAttribute(__obj: IPXACT2022ScalaCases.ComplexTiedValueExpression, __scope: scala.xml.NamespaceBinding): scala.xml.MetaData = {
      var attr: scala.xml.MetaData  = scala.xml.Null
      __obj.attributes.toList map {
        case ("@minimum", _) => __obj.minimum foreach { x => attr = scala.xml.Attribute(null, "minimum", x.toString, attr) }
        case ("@maximum", _) => __obj.maximum foreach { x => attr = scala.xml.Attribute(null, "maximum", x.toString, attr) }
        case (key, x) => attr = scala.xml.Attribute((x.namespace map { __scope.getPrefix(_) }).orNull, x.key.orNull, x.value.toString, attr)
      }
      attr
    }

    def writesChildNodes(__obj: IPXACT2022ScalaCases.ComplexTiedValueExpression, __scope: scala.xml.NamespaceBinding): Seq[scala.xml.Node] =
      Seq(scala.xml.Text(__obj.value.toString))

  }

  trait DefaultIPXACT2022ScalaCases_ConfigurableElementValuesFormat extends IPXACT2022scalaxb.ElemNameParser[IPXACT2022ScalaCases.ConfigurableElementValues] {
    val targetNamespace: Option[String] = Some("http://www.accellera.org/XMLSchema/IPXACT/1685-2022")
    
    def parser(node: scala.xml.Node, stack: List[IPXACT2022scalaxb.ElemName]): Parser[IPXACT2022ScalaCases.ConfigurableElementValues] =
      phrase(safeRep(((IPXACT2022scalaxb.ElemName(Some("http://www.accellera.org/XMLSchema/IPXACT/1685-2022"), "configurableElementValue"))) ^^
        { case p1 => IPXACT2022ScalaCases.ConfigurableElementValuesSequence1(IPXACT2022scalaxb.fromXML[IPXACT2022ScalaCases.ConfigurableElementValue](p1, IPXACT2022scalaxb.ElemName(node) :: stack)) }) ^^
      { case p1 =>
      IPXACT2022ScalaCases.ConfigurableElementValues(p1) })
    
    def writesChildNodes(__obj: IPXACT2022ScalaCases.ConfigurableElementValues, __scope: scala.xml.NamespaceBinding): Seq[scala.xml.Node] =
      (__obj.configurableelementvaluessequence1 flatMap { IPXACT2022scalaxb.toXML[IPXACT2022ScalaCases.ConfigurableElementValuesSequence1](_, None, Some("configurableelementvaluessequence1"), __scope, false) })
  }

  trait DefaultIPXACT2022ScalaCases_ConfigurableElementValuesSequence1Format extends IPXACT2022scalaxb.XMLFormat[IPXACT2022ScalaCases.ConfigurableElementValuesSequence1] {
    def reads(seq: scala.xml.NodeSeq, stack: List[IPXACT2022scalaxb.ElemName]): Either[String, IPXACT2022ScalaCases.ConfigurableElementValuesSequence1] = Left("don't call me.")
    
    def writes(__obj: IPXACT2022ScalaCases.ConfigurableElementValuesSequence1, __namespace: Option[String], __elementLabel: Option[String],
        __scope: scala.xml.NamespaceBinding, __typeAttribute: Boolean): scala.xml.NodeSeq =
      IPXACT2022scalaxb.toXML[IPXACT2022ScalaCases.ConfigurableElementValue](__obj.configurableElementValue, Some("http://www.accellera.org/XMLSchema/IPXACT/1685-2022"), Some("configurableElementValue"), __scope, false)

  }
  trait DefaultIPXACT2022ScalaCases_ConfigurableElementValueFormat extends IPXACT2022scalaxb.XMLFormat[IPXACT2022ScalaCases.ConfigurableElementValue] with IPXACT2022scalaxb.CanWriteChildNodes[IPXACT2022ScalaCases.ConfigurableElementValue] {
    val targetNamespace: Option[String] = Some("http://www.accellera.org/XMLSchema/IPXACT/1685-2022")
    def reads(seq: scala.xml.NodeSeq, stack: List[IPXACT2022scalaxb.ElemName]): Either[String, IPXACT2022ScalaCases.ConfigurableElementValue] = seq match {
      case node: scala.xml.Node => Right(IPXACT2022ScalaCases.ConfigurableElementValue(IPXACT2022scalaxb.fromXML[String](node, IPXACT2022scalaxb.ElemName(node) :: stack),
        scala.collection.immutable.ListMap(List(
        (node \ "@referenceId").headOption map { x => IPXACT2022scalaxb.DataRecord(x, node, IPXACT2022scalaxb.fromXML[String](x, IPXACT2022scalaxb.ElemName(node) :: stack)) } map { "@referenceId" -> _ },
        (node \ "@{http://www.w3.org/XML/1998/namespace}id").headOption map { x => IPXACT2022scalaxb.DataRecord(x, node, IPXACT2022scalaxb.fromXML[String](x, IPXACT2022scalaxb.ElemName(node) :: stack)) } map { "@{http://www.w3.org/XML/1998/namespace}id" -> _ }
        ).flatten[(String, IPXACT2022scalaxb.DataRecord[Any])] ::: (node match {
          case elem: scala.xml.Elem =>
            elem.attributes.toList flatMap {
              case scala.xml.UnprefixedAttribute(key, value, _) if key == "referenceId" => Nil
              case scala.xml.PrefixedAttribute(pre, key, value, _) if pre == elem.scope.getPrefix("http://www.w3.org/XML/1998/namespace") &&
                key == "id" => Nil
              case scala.xml.UnprefixedAttribute(key, value, _) =>
                List(("@" + key, IPXACT2022scalaxb.DataRecord(None, Some(key), value.text)))
              case scala.xml.PrefixedAttribute(pre, key, value, _) =>
                val ns = elem.scope.getURI(pre)
                List(("@{" + ns + "}" + key, IPXACT2022scalaxb.DataRecord(Option[String](ns), Some(key), value.text)))
              case _ => Nil
            }
          case _ => Nil
        }): _*)))
      case _ => Left("reads failed: seq must be scala.xml.Node")
    }
    
    override def writesAttribute(__obj: IPXACT2022ScalaCases.ConfigurableElementValue, __scope: scala.xml.NamespaceBinding): scala.xml.MetaData = {
      var attr: scala.xml.MetaData  = scala.xml.Null
      __obj.attributes.toList map {
        case ("@referenceId", _) => attr = scala.xml.Attribute(null, "referenceId", __obj.referenceId.toString, attr)
        case ("@{http://www.w3.org/XML/1998/namespace}id", _) => __obj.xmlid foreach { x => attr = scala.xml.Attribute(__scope.getPrefix("http://www.w3.org/XML/1998/namespace"), "id", x.toString, attr) }
        case (key, x) => attr = scala.xml.Attribute((x.namespace map { __scope.getPrefix(_) }).orNull, x.key.orNull, x.value.toString, attr)
      }
      attr
    }

    def writesChildNodes(__obj: IPXACT2022ScalaCases.ConfigurableElementValue, __scope: scala.xml.NamespaceBinding): Seq[scala.xml.Node] =
      Seq(scala.xml.Text(__obj.value.toString))

  }

  trait DefaultIPXACT2022ScalaCases_ComponentInstanceFormat extends IPXACT2022scalaxb.ElemNameParser[IPXACT2022ScalaCases.ComponentInstance] {
    val targetNamespace: Option[String] = Some("http://www.accellera.org/XMLSchema/IPXACT/1685-2022")
    
    def parser(node: scala.xml.Node, stack: List[IPXACT2022scalaxb.ElemName]): Parser[IPXACT2022ScalaCases.ComponentInstance] =
      phrase((IPXACT2022scalaxb.ElemName(Some("http://www.accellera.org/XMLSchema/IPXACT/1685-2022"), "instanceName")) ~
      opt(IPXACT2022scalaxb.ElemName(Some("http://www.accellera.org/XMLSchema/IPXACT/1685-2022"), "displayName")) ~
      opt(IPXACT2022scalaxb.ElemName(Some("http://www.accellera.org/XMLSchema/IPXACT/1685-2022"), "shortDescription")) ~
      opt(IPXACT2022scalaxb.ElemName(Some("http://www.accellera.org/XMLSchema/IPXACT/1685-2022"), "description")) ~
      (IPXACT2022scalaxb.ElemName(Some("http://www.accellera.org/XMLSchema/IPXACT/1685-2022"), "componentRef")) ~
      opt(IPXACT2022scalaxb.ElemName(Some("http://www.accellera.org/XMLSchema/IPXACT/1685-2022"), "powerDomainLinks")) ~
      opt(IPXACT2022scalaxb.ElemName(Some("http://www.accellera.org/XMLSchema/IPXACT/1685-2022"), "vendorExtensions")) ^^
      { case p1 ~ p2 ~ p3 ~ p4 ~ p5 ~ p6 ~ p7 =>
      IPXACT2022ScalaCases.ComponentInstance(IPXACT2022scalaxb.fromXML[String](p1, IPXACT2022scalaxb.ElemName(node) :: stack),
        p2.headOption map { IPXACT2022scalaxb.fromXML[String](_, IPXACT2022scalaxb.ElemName(node) :: stack) },
        p3.headOption map { IPXACT2022scalaxb.fromXML[String](_, IPXACT2022scalaxb.ElemName(node) :: stack) },
        p4.headOption map { IPXACT2022scalaxb.fromXML[String](_, IPXACT2022scalaxb.ElemName(node) :: stack) },
        IPXACT2022scalaxb.fromXML[IPXACT2022ScalaCases.ConfigurableLibraryRefType](p5, IPXACT2022scalaxb.ElemName(node) :: stack),
        p6.headOption map { IPXACT2022scalaxb.fromXML[IPXACT2022ScalaCases.PowerDomainLinks](_, IPXACT2022scalaxb.ElemName(node) :: stack) },
        p7.headOption map { IPXACT2022scalaxb.fromXML[IPXACT2022ScalaCases.VendorExtensions](_, IPXACT2022scalaxb.ElemName(node) :: stack) },
        scala.collection.immutable.ListMap(List(
        (node \ "@{http://www.w3.org/XML/1998/namespace}id").headOption map { x => IPXACT2022scalaxb.DataRecord(x, node, IPXACT2022scalaxb.fromXML[String](x, IPXACT2022scalaxb.ElemName(node) :: stack)) } map { "@{http://www.w3.org/XML/1998/namespace}id" -> _ }
        ).flatten[(String, IPXACT2022scalaxb.DataRecord[Any])]: _*)) })
    
    override def writesAttribute(__obj: IPXACT2022ScalaCases.ComponentInstance, __scope: scala.xml.NamespaceBinding): scala.xml.MetaData = {
      var attr: scala.xml.MetaData  = scala.xml.Null
      __obj.attributes.toList map {
        case ("@{http://www.w3.org/XML/1998/namespace}id", _) => __obj.xmlid foreach { x => attr = scala.xml.Attribute(__scope.getPrefix("http://www.w3.org/XML/1998/namespace"), "id", x.toString, attr) }
        case (key, x) => attr = scala.xml.Attribute((x.namespace map { __scope.getPrefix(_) }).orNull, x.key.orNull, x.value.toString, attr)
      }
      attr
    }

    def writesChildNodes(__obj: IPXACT2022ScalaCases.ComponentInstance, __scope: scala.xml.NamespaceBinding): Seq[scala.xml.Node] =
      Seq.concat(IPXACT2022scalaxb.toXML[String](__obj.instanceName, Some("http://www.accellera.org/XMLSchema/IPXACT/1685-2022"), Some("instanceName"), __scope, false),
        __obj.displayName map { IPXACT2022scalaxb.toXML[String](_, Some("http://www.accellera.org/XMLSchema/IPXACT/1685-2022"), Some("displayName"), __scope, false) } getOrElse {Nil},
        __obj.shortDescription map { IPXACT2022scalaxb.toXML[String](_, Some("http://www.accellera.org/XMLSchema/IPXACT/1685-2022"), Some("shortDescription"), __scope, false) } getOrElse {Nil},
        __obj.description map { IPXACT2022scalaxb.toXML[String](_, Some("http://www.accellera.org/XMLSchema/IPXACT/1685-2022"), Some("description"), __scope, false) } getOrElse {Nil},
        IPXACT2022scalaxb.toXML[IPXACT2022ScalaCases.ConfigurableLibraryRefType](__obj.componentRef, Some("http://www.accellera.org/XMLSchema/IPXACT/1685-2022"), Some("componentRef"), __scope, false),
        __obj.powerDomainLinks map { IPXACT2022scalaxb.toXML[IPXACT2022ScalaCases.PowerDomainLinks](_, Some("http://www.accellera.org/XMLSchema/IPXACT/1685-2022"), Some("powerDomainLinks"), __scope, false) } getOrElse {Nil},
        __obj.vendorExtensions map { IPXACT2022scalaxb.toXML[IPXACT2022ScalaCases.VendorExtensions](_, Some("http://www.accellera.org/XMLSchema/IPXACT/1685-2022"), Some("vendorExtensions"), __scope, false) } getOrElse {Nil})

  }

  trait DefaultIPXACT2022ScalaCases_ComponentInstancesFormat extends IPXACT2022scalaxb.ElemNameParser[IPXACT2022ScalaCases.ComponentInstances] {
    val targetNamespace: Option[String] = Some("http://www.accellera.org/XMLSchema/IPXACT/1685-2022")
    
    def parser(node: scala.xml.Node, stack: List[IPXACT2022scalaxb.ElemName]): Parser[IPXACT2022ScalaCases.ComponentInstances] =
      phrase(safeRep(IPXACT2022scalaxb.ElemName(Some("http://www.accellera.org/XMLSchema/IPXACT/1685-2022"), "componentInstance")) ^^
      { case p1 =>
      IPXACT2022ScalaCases.ComponentInstances(p1 map { IPXACT2022scalaxb.fromXML[IPXACT2022ScalaCases.ComponentInstance](_, IPXACT2022scalaxb.ElemName(node) :: stack) }) })
    
    def writesChildNodes(__obj: IPXACT2022ScalaCases.ComponentInstances, __scope: scala.xml.NamespaceBinding): Seq[scala.xml.Node] =
      (__obj.componentInstance flatMap { IPXACT2022scalaxb.toXML[IPXACT2022ScalaCases.ComponentInstance](_, Some("http://www.accellera.org/XMLSchema/IPXACT/1685-2022"), Some("componentInstance"), __scope, false) })
  }
  trait DefaultIPXACT2022ScalaCases_InternalPortReferenceFormat extends IPXACT2022scalaxb.ElemNameParser[IPXACT2022ScalaCases.InternalPortReference] {
    val targetNamespace: Option[String] = Some("http://www.accellera.org/XMLSchema/IPXACT/1685-2022")
    
    def parser(node: scala.xml.Node, stack: List[IPXACT2022scalaxb.ElemName]): Parser[IPXACT2022ScalaCases.InternalPortReference] =
      phrase(safeRep(IPXACT2022scalaxb.ElemName(Some("http://www.accellera.org/XMLSchema/IPXACT/1685-2022"), "subPortReference")) ~
      opt(IPXACT2022scalaxb.ElemName(Some("http://www.accellera.org/XMLSchema/IPXACT/1685-2022"), "partSelect")) ~
      opt(IPXACT2022scalaxb.ElemName(Some("http://www.accellera.org/XMLSchema/IPXACT/1685-2022"), "vendorExtensions")) ^^
      { case p1 ~ p2 ~ p3 =>
      IPXACT2022ScalaCases.InternalPortReference(p1 map { IPXACT2022scalaxb.fromXML[IPXACT2022ScalaCases.SubPortReference](_, IPXACT2022scalaxb.ElemName(node) :: stack) },
        p2.headOption map { IPXACT2022scalaxb.fromXML[IPXACT2022ScalaCases.PartSelect](_, IPXACT2022scalaxb.ElemName(node) :: stack) },
        p3.headOption map { IPXACT2022scalaxb.fromXML[IPXACT2022ScalaCases.VendorExtensions](_, IPXACT2022scalaxb.ElemName(node) :: stack) },
        scala.collection.immutable.ListMap(List(
        (node \ "@portRef").headOption map { x => IPXACT2022scalaxb.DataRecord(x, node, IPXACT2022scalaxb.fromXML[String](x, IPXACT2022scalaxb.ElemName(node) :: stack)) } map { "@portRef" -> _ },
        (node \ "@componentInstanceRef").headOption map { x => IPXACT2022scalaxb.DataRecord(x, node, IPXACT2022scalaxb.fromXML[String](x, IPXACT2022scalaxb.ElemName(node) :: stack)) } map { "@componentInstanceRef" -> _ },
        (node \ "@{http://www.w3.org/XML/1998/namespace}id").headOption map { x => IPXACT2022scalaxb.DataRecord(x, node, IPXACT2022scalaxb.fromXML[String](x, IPXACT2022scalaxb.ElemName(node) :: stack)) } map { "@{http://www.w3.org/XML/1998/namespace}id" -> _ }
        ).flatten[(String, IPXACT2022scalaxb.DataRecord[Any])]: _*)) })
    
    override def writesAttribute(__obj: IPXACT2022ScalaCases.InternalPortReference, __scope: scala.xml.NamespaceBinding): scala.xml.MetaData = {
      var attr: scala.xml.MetaData  = scala.xml.Null
      __obj.attributes.toList map {
        case ("@portRef", _) => attr = scala.xml.Attribute(null, "portRef", __obj.portRef.toString, attr)
        case ("@componentInstanceRef", _) => attr = scala.xml.Attribute(null, "componentInstanceRef", __obj.componentInstanceRef.toString, attr)
        case ("@{http://www.w3.org/XML/1998/namespace}id", _) => __obj.xmlid foreach { x => attr = scala.xml.Attribute(__scope.getPrefix("http://www.w3.org/XML/1998/namespace"), "id", x.toString, attr) }
        case (key, x) => attr = scala.xml.Attribute((x.namespace map { __scope.getPrefix(_) }).orNull, x.key.orNull, x.value.toString, attr)
      }
      attr
    }

    def writesChildNodes(__obj: IPXACT2022ScalaCases.InternalPortReference, __scope: scala.xml.NamespaceBinding): Seq[scala.xml.Node] =
      Seq.concat(__obj.subPortReference flatMap { IPXACT2022scalaxb.toXML[IPXACT2022ScalaCases.SubPortReference](_, Some("http://www.accellera.org/XMLSchema/IPXACT/1685-2022"), Some("subPortReference"), __scope, false) },
        __obj.partSelect map { IPXACT2022scalaxb.toXML[IPXACT2022ScalaCases.PartSelect](_, Some("http://www.accellera.org/XMLSchema/IPXACT/1685-2022"), Some("partSelect"), __scope, false) } getOrElse {Nil},
        __obj.vendorExtensions map { IPXACT2022scalaxb.toXML[IPXACT2022ScalaCases.VendorExtensions](_, Some("http://www.accellera.org/XMLSchema/IPXACT/1685-2022"), Some("vendorExtensions"), __scope, false) } getOrElse {Nil})

  }

  trait DefaultIPXACT2022ScalaCases_PortReferencesFormat extends IPXACT2022scalaxb.ElemNameParser[IPXACT2022ScalaCases.PortReferences] {
    val targetNamespace: Option[String] = Some("http://www.accellera.org/XMLSchema/IPXACT/1685-2022")
    
    def parser(node: scala.xml.Node, stack: List[IPXACT2022scalaxb.ElemName]): Parser[IPXACT2022ScalaCases.PortReferences] =
      phrase(safeRep(((safeRep(IPXACT2022scalaxb.ElemName(Some("http://www.accellera.org/XMLSchema/IPXACT/1685-2022"), "internalPortReference")) ~
      safeRep(IPXACT2022scalaxb.ElemName(Some("http://www.accellera.org/XMLSchema/IPXACT/1685-2022"), "externalPortReference"))) ^^
        { case p1 ~ p2 => IPXACT2022scalaxb.DataRecord(IPXACT2022ScalaCases.PortReferencesSequence1(p1 map { IPXACT2022scalaxb.fromXML[IPXACT2022ScalaCases.InternalPortReference](_, IPXACT2022scalaxb.ElemName(node) :: stack) },
        p2 map { IPXACT2022scalaxb.fromXML[IPXACT2022ScalaCases.ExternalPortReference](_, IPXACT2022scalaxb.ElemName(node) :: stack) })) }) |||
      ((IPXACT2022scalaxb.ElemName(Some("http://www.accellera.org/XMLSchema/IPXACT/1685-2022"), "externalPortReference")) ^^
      (x => IPXACT2022scalaxb.DataRecord(x.namespace, Some(x.name), IPXACT2022scalaxb.fromXML[IPXACT2022ScalaCases.ExternalPortReference](x, IPXACT2022scalaxb.ElemName(node) :: stack))))) ^^
      { case p1 =>
      IPXACT2022ScalaCases.PortReferences(p1) })
    
    def writesChildNodes(__obj: IPXACT2022ScalaCases.PortReferences, __scope: scala.xml.NamespaceBinding): Seq[scala.xml.Node] =
      (__obj.portreferencesoption flatMap { x => IPXACT2022scalaxb.toXML[IPXACT2022scalaxb.DataRecord[IPXACT2022ScalaCases.PortReferencesOption]](x, x.namespace, x.key, __scope, false) })
  }

  trait DefaultIPXACT2022ScalaCases_PortReferencesSequence1Format extends IPXACT2022scalaxb.XMLFormat[IPXACT2022ScalaCases.PortReferencesSequence1] {
    def reads(seq: scala.xml.NodeSeq, stack: List[IPXACT2022scalaxb.ElemName]): Either[String, IPXACT2022ScalaCases.PortReferencesSequence1] = Left("don't call me.")
    
    def writes(__obj: IPXACT2022ScalaCases.PortReferencesSequence1, __namespace: Option[String], __elementLabel: Option[String],
        __scope: scala.xml.NamespaceBinding, __typeAttribute: Boolean): scala.xml.NodeSeq =
      Seq.concat(__obj.internalPortReference flatMap { IPXACT2022scalaxb.toXML[IPXACT2022ScalaCases.InternalPortReference](_, Some("http://www.accellera.org/XMLSchema/IPXACT/1685-2022"), Some("internalPortReference"), __scope, false) },
        __obj.externalPortReference flatMap { IPXACT2022scalaxb.toXML[IPXACT2022ScalaCases.ExternalPortReference](_, Some("http://www.accellera.org/XMLSchema/IPXACT/1685-2022"), Some("externalPortReference"), __scope, false) })


  }

  trait DefaultIPXACT2022ScalaCases_AdHocConnectionFormat extends IPXACT2022scalaxb.ElemNameParser[IPXACT2022ScalaCases.AdHocConnection] with IPXACT2022ScalaCases_NameGroupPortGroupFormat {
    val targetNamespace: Option[String] = Some("http://www.accellera.org/XMLSchema/IPXACT/1685-2022")
    
    def parser(node: scala.xml.Node, stack: List[IPXACT2022scalaxb.ElemName]): Parser[IPXACT2022ScalaCases.AdHocConnection] =
      phrase((parseNameGroupPortGroup(node, IPXACT2022scalaxb.ElemName(node) :: stack)) ~
      opt(IPXACT2022scalaxb.ElemName(Some("http://www.accellera.org/XMLSchema/IPXACT/1685-2022"), "tiedValue")) ~
      (IPXACT2022scalaxb.ElemName(Some("http://www.accellera.org/XMLSchema/IPXACT/1685-2022"), "portReferences")) ~
      opt(IPXACT2022scalaxb.ElemName(Some("http://www.accellera.org/XMLSchema/IPXACT/1685-2022"), "vendorExtensions")) ^^
      { case p1 ~ p2 ~ p3 ~ p4 =>
      IPXACT2022ScalaCases.AdHocConnection(p1,
        p2.headOption map { IPXACT2022scalaxb.fromXML[IPXACT2022ScalaCases.ComplexTiedValueExpression](_, IPXACT2022scalaxb.ElemName(node) :: stack) },
        IPXACT2022scalaxb.fromXML[IPXACT2022ScalaCases.PortReferences](p3, IPXACT2022scalaxb.ElemName(node) :: stack),
        p4.headOption map { IPXACT2022scalaxb.fromXML[IPXACT2022ScalaCases.VendorExtensions](_, IPXACT2022scalaxb.ElemName(node) :: stack) },
        scala.collection.immutable.ListMap(List(
        (node \ "@{http://www.w3.org/XML/1998/namespace}id").headOption map { x => IPXACT2022scalaxb.DataRecord(x, node, IPXACT2022scalaxb.fromXML[String](x, IPXACT2022scalaxb.ElemName(node) :: stack)) } map { "@{http://www.w3.org/XML/1998/namespace}id" -> _ }
        ).flatten[(String, IPXACT2022scalaxb.DataRecord[Any])]: _*)) })
    
    override def writesAttribute(__obj: IPXACT2022ScalaCases.AdHocConnection, __scope: scala.xml.NamespaceBinding): scala.xml.MetaData = {
      var attr: scala.xml.MetaData  = scala.xml.Null
      __obj.attributes.toList map {
        case ("@{http://www.w3.org/XML/1998/namespace}id", _) => __obj.xmlid foreach { x => attr = scala.xml.Attribute(__scope.getPrefix("http://www.w3.org/XML/1998/namespace"), "id", x.toString, attr) }
        case (key, x) => attr = scala.xml.Attribute((x.namespace map { __scope.getPrefix(_) }).orNull, x.key.orNull, x.value.toString, attr)
      }
      attr
    }

    def writesChildNodes(__obj: IPXACT2022ScalaCases.AdHocConnection, __scope: scala.xml.NamespaceBinding): Seq[scala.xml.Node] =
      Seq.concat(IPXACT2022scalaxb.toXML[IPXACT2022ScalaCases.NameGroupPortSequence](__obj.nameGroupPortSequence1, None, Some("nameGroupPortSequence1"), __scope, false),
        __obj.tiedValue map { IPXACT2022scalaxb.toXML[IPXACT2022ScalaCases.ComplexTiedValueExpression](_, Some("http://www.accellera.org/XMLSchema/IPXACT/1685-2022"), Some("tiedValue"), __scope, false) } getOrElse {Nil},
        IPXACT2022scalaxb.toXML[IPXACT2022ScalaCases.PortReferences](__obj.portReferences, Some("http://www.accellera.org/XMLSchema/IPXACT/1685-2022"), Some("portReferences"), __scope, false),
        __obj.vendorExtensions map { IPXACT2022scalaxb.toXML[IPXACT2022ScalaCases.VendorExtensions](_, Some("http://www.accellera.org/XMLSchema/IPXACT/1685-2022"), Some("vendorExtensions"), __scope, false) } getOrElse {Nil})

  }

  trait DefaultIPXACT2022ScalaCases_AdHocConnectionsFormat extends IPXACT2022scalaxb.ElemNameParser[IPXACT2022ScalaCases.AdHocConnections] {
    val targetNamespace: Option[String] = Some("http://www.accellera.org/XMLSchema/IPXACT/1685-2022")
    
    def parser(node: scala.xml.Node, stack: List[IPXACT2022scalaxb.ElemName]): Parser[IPXACT2022ScalaCases.AdHocConnections] =
      phrase(safeRep(IPXACT2022scalaxb.ElemName(Some("http://www.accellera.org/XMLSchema/IPXACT/1685-2022"), "adHocConnection")) ^^
      { case p1 =>
      IPXACT2022ScalaCases.AdHocConnections(p1 map { IPXACT2022scalaxb.fromXML[IPXACT2022ScalaCases.AdHocConnection](_, IPXACT2022scalaxb.ElemName(node) :: stack) }) })
    
    def writesChildNodes(__obj: IPXACT2022ScalaCases.AdHocConnections, __scope: scala.xml.NamespaceBinding): Seq[scala.xml.Node] =
      (__obj.adHocConnection flatMap { IPXACT2022scalaxb.toXML[IPXACT2022ScalaCases.AdHocConnection](_, Some("http://www.accellera.org/XMLSchema/IPXACT/1685-2022"), Some("adHocConnection"), __scope, false) })
  }
  trait DefaultIPXACT2022ScalaCases_InterconnectionFormat extends IPXACT2022scalaxb.ElemNameParser[IPXACT2022ScalaCases.Interconnection] with IPXACT2022ScalaCases_NameGroupGroupFormat {
    val targetNamespace: Option[String] = Some("http://www.accellera.org/XMLSchema/IPXACT/1685-2022")
    
    def parser(node: scala.xml.Node, stack: List[IPXACT2022scalaxb.ElemName]): Parser[IPXACT2022ScalaCases.Interconnection] =
      phrase((parseNameGroupGroup(node, IPXACT2022scalaxb.ElemName(node) :: stack)) ~
      (IPXACT2022scalaxb.ElemName(Some("http://www.accellera.org/XMLSchema/IPXACT/1685-2022"), "activeInterface")) ~
      safeRep(((safeRep(IPXACT2022scalaxb.ElemName(Some("http://www.accellera.org/XMLSchema/IPXACT/1685-2022"), "activeInterface")) ~
      safeRep(IPXACT2022scalaxb.ElemName(Some("http://www.accellera.org/XMLSchema/IPXACT/1685-2022"), "hierInterface"))) ^^
        { case p1 ~ p2 => IPXACT2022scalaxb.DataRecord(IPXACT2022ScalaCases.InterconnectionSequence1(p1 map { IPXACT2022scalaxb.fromXML[IPXACT2022ScalaCases.ActiveInterface](_, IPXACT2022scalaxb.ElemName(node) :: stack) },
        p2 map { IPXACT2022scalaxb.fromXML[IPXACT2022ScalaCases.HierInterfaceType](_, IPXACT2022scalaxb.ElemName(node) :: stack) })) }) |||
      ((IPXACT2022scalaxb.ElemName(Some("http://www.accellera.org/XMLSchema/IPXACT/1685-2022"), "hierInterface")) ^^
      (x => IPXACT2022scalaxb.DataRecord(x.namespace, Some(x.name), IPXACT2022scalaxb.fromXML[IPXACT2022ScalaCases.HierInterfaceType](x, IPXACT2022scalaxb.ElemName(node) :: stack))))) ~
      opt(IPXACT2022scalaxb.ElemName(Some("http://www.accellera.org/XMLSchema/IPXACT/1685-2022"), "vendorExtensions")) ^^
      { case p1 ~ p2 ~ p3 ~ p4 =>
      IPXACT2022ScalaCases.Interconnection(p1,
        IPXACT2022scalaxb.fromXML[IPXACT2022ScalaCases.ActiveInterface](p2, IPXACT2022scalaxb.ElemName(node) :: stack),
        p3,
        p4.headOption map { IPXACT2022scalaxb.fromXML[IPXACT2022ScalaCases.VendorExtensions](_, IPXACT2022scalaxb.ElemName(node) :: stack) },
        scala.collection.immutable.ListMap(List(
        (node \ "@{http://www.w3.org/XML/1998/namespace}id").headOption map { x => IPXACT2022scalaxb.DataRecord(x, node, IPXACT2022scalaxb.fromXML[String](x, IPXACT2022scalaxb.ElemName(node) :: stack)) } map { "@{http://www.w3.org/XML/1998/namespace}id" -> _ }
        ).flatten[(String, IPXACT2022scalaxb.DataRecord[Any])]: _*)) })
    
    override def writesAttribute(__obj: IPXACT2022ScalaCases.Interconnection, __scope: scala.xml.NamespaceBinding): scala.xml.MetaData = {
      var attr: scala.xml.MetaData  = scala.xml.Null
      __obj.attributes.toList map {
        case ("@{http://www.w3.org/XML/1998/namespace}id", _) => __obj.xmlid foreach { x => attr = scala.xml.Attribute(__scope.getPrefix("http://www.w3.org/XML/1998/namespace"), "id", x.toString, attr) }
        case (key, x) => attr = scala.xml.Attribute((x.namespace map { __scope.getPrefix(_) }).orNull, x.key.orNull, x.value.toString, attr)
      }
      attr
    }

    def writesChildNodes(__obj: IPXACT2022ScalaCases.Interconnection, __scope: scala.xml.NamespaceBinding): Seq[scala.xml.Node] =
      Seq.concat(IPXACT2022scalaxb.toXML[IPXACT2022ScalaCases.NameGroupSequence](__obj.nameGroupSequence1, None, Some("nameGroupSequence1"), __scope, false),
        IPXACT2022scalaxb.toXML[IPXACT2022ScalaCases.ActiveInterface](__obj.activeInterface, Some("http://www.accellera.org/XMLSchema/IPXACT/1685-2022"), Some("activeInterface"), __scope, false),
        __obj.interconnectionoption flatMap { x => IPXACT2022scalaxb.toXML[IPXACT2022scalaxb.DataRecord[IPXACT2022ScalaCases.InterconnectionOption]](x, x.namespace, x.key, __scope, false) },
        __obj.vendorExtensions map { IPXACT2022scalaxb.toXML[IPXACT2022ScalaCases.VendorExtensions](_, Some("http://www.accellera.org/XMLSchema/IPXACT/1685-2022"), Some("vendorExtensions"), __scope, false) } getOrElse {Nil})

  }

  trait DefaultIPXACT2022ScalaCases_InterconnectionSequence1Format extends IPXACT2022scalaxb.XMLFormat[IPXACT2022ScalaCases.InterconnectionSequence1] {
    def reads(seq: scala.xml.NodeSeq, stack: List[IPXACT2022scalaxb.ElemName]): Either[String, IPXACT2022ScalaCases.InterconnectionSequence1] = Left("don't call me.")
    
    def writes(__obj: IPXACT2022ScalaCases.InterconnectionSequence1, __namespace: Option[String], __elementLabel: Option[String],
        __scope: scala.xml.NamespaceBinding, __typeAttribute: Boolean): scala.xml.NodeSeq =
      Seq.concat(__obj.activeInterface flatMap { IPXACT2022scalaxb.toXML[IPXACT2022ScalaCases.ActiveInterface](_, Some("http://www.accellera.org/XMLSchema/IPXACT/1685-2022"), Some("activeInterface"), __scope, false) },
        __obj.hierInterface flatMap { IPXACT2022scalaxb.toXML[IPXACT2022ScalaCases.HierInterfaceType](_, Some("http://www.accellera.org/XMLSchema/IPXACT/1685-2022"), Some("hierInterface"), __scope, false) })


  }

  trait DefaultIPXACT2022ScalaCases_MonitorInterconnectionFormat extends IPXACT2022scalaxb.ElemNameParser[IPXACT2022ScalaCases.MonitorInterconnection] with IPXACT2022ScalaCases_NameGroupGroupFormat {
    val targetNamespace: Option[String] = Some("http://www.accellera.org/XMLSchema/IPXACT/1685-2022")
    
    def parser(node: scala.xml.Node, stack: List[IPXACT2022scalaxb.ElemName]): Parser[IPXACT2022ScalaCases.MonitorInterconnection] =
      phrase((parseNameGroupGroup(node, IPXACT2022scalaxb.ElemName(node) :: stack)) ~
      (IPXACT2022scalaxb.ElemName(Some("http://www.accellera.org/XMLSchema/IPXACT/1685-2022"), "monitoredActiveInterface")) ~
      safeRep(IPXACT2022scalaxb.ElemName(Some("http://www.accellera.org/XMLSchema/IPXACT/1685-2022"), "monitorInterface")) ~
      opt(IPXACT2022scalaxb.ElemName(Some("http://www.accellera.org/XMLSchema/IPXACT/1685-2022"), "vendorExtensions")) ^^
      { case p1 ~ p2 ~ p3 ~ p4 =>
      IPXACT2022ScalaCases.MonitorInterconnection(p1,
        IPXACT2022scalaxb.fromXML[IPXACT2022ScalaCases.MonitorInterfaceType](p2, IPXACT2022scalaxb.ElemName(node) :: stack),
        p3 map { IPXACT2022scalaxb.fromXML[IPXACT2022ScalaCases.MonitorInterfaceType](_, IPXACT2022scalaxb.ElemName(node) :: stack) },
        p4.headOption map { IPXACT2022scalaxb.fromXML[IPXACT2022ScalaCases.VendorExtensions](_, IPXACT2022scalaxb.ElemName(node) :: stack) },
        scala.collection.immutable.ListMap(List(
        (node \ "@{http://www.w3.org/XML/1998/namespace}id").headOption map { x => IPXACT2022scalaxb.DataRecord(x, node, IPXACT2022scalaxb.fromXML[String](x, IPXACT2022scalaxb.ElemName(node) :: stack)) } map { "@{http://www.w3.org/XML/1998/namespace}id" -> _ }
        ).flatten[(String, IPXACT2022scalaxb.DataRecord[Any])]: _*)) })
    
    override def writesAttribute(__obj: IPXACT2022ScalaCases.MonitorInterconnection, __scope: scala.xml.NamespaceBinding): scala.xml.MetaData = {
      var attr: scala.xml.MetaData  = scala.xml.Null
      __obj.attributes.toList map {
        case ("@{http://www.w3.org/XML/1998/namespace}id", _) => __obj.xmlid foreach { x => attr = scala.xml.Attribute(__scope.getPrefix("http://www.w3.org/XML/1998/namespace"), "id", x.toString, attr) }
        case (key, x) => attr = scala.xml.Attribute((x.namespace map { __scope.getPrefix(_) }).orNull, x.key.orNull, x.value.toString, attr)
      }
      attr
    }

    def writesChildNodes(__obj: IPXACT2022ScalaCases.MonitorInterconnection, __scope: scala.xml.NamespaceBinding): Seq[scala.xml.Node] =
      Seq.concat(IPXACT2022scalaxb.toXML[IPXACT2022ScalaCases.NameGroupSequence](__obj.nameGroupSequence1, None, Some("nameGroupSequence1"), __scope, false),
        IPXACT2022scalaxb.toXML[IPXACT2022ScalaCases.MonitorInterfaceType](__obj.monitoredActiveInterface, Some("http://www.accellera.org/XMLSchema/IPXACT/1685-2022"), Some("monitoredActiveInterface"), __scope, false),
        __obj.monitorInterface flatMap { IPXACT2022scalaxb.toXML[IPXACT2022ScalaCases.MonitorInterfaceType](_, Some("http://www.accellera.org/XMLSchema/IPXACT/1685-2022"), Some("monitorInterface"), __scope, false) },
        __obj.vendorExtensions map { IPXACT2022scalaxb.toXML[IPXACT2022ScalaCases.VendorExtensions](_, Some("http://www.accellera.org/XMLSchema/IPXACT/1685-2022"), Some("vendorExtensions"), __scope, false) } getOrElse {Nil})

  }

  trait DefaultIPXACT2022ScalaCases_InterconnectionsFormat extends IPXACT2022scalaxb.ElemNameParser[IPXACT2022ScalaCases.Interconnections] {
    val targetNamespace: Option[String] = Some("http://www.accellera.org/XMLSchema/IPXACT/1685-2022")
    
    def parser(node: scala.xml.Node, stack: List[IPXACT2022scalaxb.ElemName]): Parser[IPXACT2022ScalaCases.Interconnections] =
      phrase(safeRep(((IPXACT2022scalaxb.ElemName(Some("http://www.accellera.org/XMLSchema/IPXACT/1685-2022"), "interconnection")) ^^
      (x => IPXACT2022scalaxb.DataRecord(x.namespace, Some(x.name), IPXACT2022scalaxb.fromXML[IPXACT2022ScalaCases.Interconnection](x, IPXACT2022scalaxb.ElemName(node) :: stack)))) |
      ((IPXACT2022scalaxb.ElemName(Some("http://www.accellera.org/XMLSchema/IPXACT/1685-2022"), "monitorInterconnection")) ^^
      (x => IPXACT2022scalaxb.DataRecord(x.namespace, Some(x.name), IPXACT2022scalaxb.fromXML[IPXACT2022ScalaCases.MonitorInterconnection](x, IPXACT2022scalaxb.ElemName(node) :: stack))))) ^^
      { case p1 =>
      IPXACT2022ScalaCases.Interconnections(p1) })
    
    def writesChildNodes(__obj: IPXACT2022ScalaCases.Interconnections, __scope: scala.xml.NamespaceBinding): Seq[scala.xml.Node] =
      (__obj.interconnectionsoption flatMap { x => IPXACT2022scalaxb.toXML[IPXACT2022scalaxb.DataRecord[IPXACT2022ScalaCases.InterconnectionsOption]](x, x.namespace, x.key, __scope, false) })
  }

  trait DefaultIPXACT2022ScalaCases_InterfaceTypableFormat extends IPXACT2022scalaxb.XMLFormat[IPXACT2022ScalaCases.InterfaceTypable] {
    def reads(seq: scala.xml.NodeSeq, stack: List[IPXACT2022scalaxb.ElemName]): Either[String, IPXACT2022ScalaCases.InterfaceTypable] = seq match {
      case node: scala.xml.Node =>     
        IPXACT2022scalaxb.Helper.instanceType(node) match {
          case (Some("http://www.accellera.org/XMLSchema/IPXACT/1685-2022"), Some("monitorInterfaceType")) => Right(IPXACT2022scalaxb.fromXML[IPXACT2022ScalaCases.MonitorInterfaceType](node, stack))
          case _ => Right(IPXACT2022scalaxb.fromXML[IPXACT2022ScalaCases.InterfaceType](node, stack))
        }
      case _ => Left("reads failed: seq must be scala.xml.Node")  
    }
    
    def writes(__obj: IPXACT2022ScalaCases.InterfaceTypable, __namespace: Option[String], __elementLabel: Option[String],
        __scope: scala.xml.NamespaceBinding, __typeAttribute: Boolean): scala.xml.NodeSeq = __obj match {
      case x: IPXACT2022ScalaCases.MonitorInterfaceType => IPXACT2022scalaxb.toXML[IPXACT2022ScalaCases.MonitorInterfaceType](x, __namespace, __elementLabel, __scope, true)
      case x: IPXACT2022ScalaCases.ActiveInterface => IPXACT2022scalaxb.toXML[IPXACT2022ScalaCases.ActiveInterface](x, __namespace, __elementLabel, __scope, true)
      case x: IPXACT2022ScalaCases.InterfaceType => IPXACT2022scalaxb.toXML[IPXACT2022ScalaCases.InterfaceType](x, __namespace, __elementLabel, __scope, __typeAttribute)
    }
  }

  trait DefaultIPXACT2022ScalaCases_InterfaceTypeFormat extends IPXACT2022scalaxb.XMLFormat[IPXACT2022ScalaCases.InterfaceType] with IPXACT2022scalaxb.CanWriteChildNodes[IPXACT2022ScalaCases.InterfaceType] {
    val targetNamespace: Option[String] = Some("http://www.accellera.org/XMLSchema/IPXACT/1685-2022")
    def reads(seq: scala.xml.NodeSeq, stack: List[IPXACT2022scalaxb.ElemName]): Either[String, IPXACT2022ScalaCases.InterfaceType] = seq match {
      case node: scala.xml.Node => Right(IPXACT2022ScalaCases.InterfaceType(scala.collection.immutable.ListMap(List(
        (node \ "@componentInstanceRef").headOption map { x => IPXACT2022scalaxb.DataRecord(x, node, IPXACT2022scalaxb.fromXML[String](x, IPXACT2022scalaxb.ElemName(node) :: stack)) } map { "@componentInstanceRef" -> _ },
        (node \ "@busRef").headOption map { x => IPXACT2022scalaxb.DataRecord(x, node, IPXACT2022scalaxb.fromXML[String](x, IPXACT2022scalaxb.ElemName(node) :: stack)) } map { "@busRef" -> _ },
        (node \ "@{http://www.w3.org/XML/1998/namespace}id").headOption map { x => IPXACT2022scalaxb.DataRecord(x, node, IPXACT2022scalaxb.fromXML[String](x, IPXACT2022scalaxb.ElemName(node) :: stack)) } map { "@{http://www.w3.org/XML/1998/namespace}id" -> _ }
        ).flatten[(String, IPXACT2022scalaxb.DataRecord[Any])]: _*)))
      case _ => Left("reads failed: seq must be scala.xml.Node")
    }
    
    override def writesAttribute(__obj: IPXACT2022ScalaCases.InterfaceType, __scope: scala.xml.NamespaceBinding): scala.xml.MetaData = {
      var attr: scala.xml.MetaData  = scala.xml.Null
      __obj.attributes.toList map {
        case ("@componentInstanceRef", _) => attr = scala.xml.Attribute(null, "componentInstanceRef", __obj.componentInstanceRef.toString, attr)
        case ("@busRef", _) => attr = scala.xml.Attribute(null, "busRef", __obj.busRef.toString, attr)
        case ("@{http://www.w3.org/XML/1998/namespace}id", _) => __obj.xmlid foreach { x => attr = scala.xml.Attribute(__scope.getPrefix("http://www.w3.org/XML/1998/namespace"), "id", x.toString, attr) }
        case (key, x) => attr = scala.xml.Attribute((x.namespace map { __scope.getPrefix(_) }).orNull, x.key.orNull, x.value.toString, attr)
      }
      attr
    }

    def writesChildNodes(__obj: IPXACT2022ScalaCases.InterfaceType, __scope: scala.xml.NamespaceBinding): Seq[scala.xml.Node] =
      Nil

  }

  trait DefaultIPXACT2022ScalaCases_HierInterfaceTypeFormat extends IPXACT2022scalaxb.ElemNameParser[IPXACT2022ScalaCases.HierInterfaceType] {
    val targetNamespace: Option[String] = Some("http://www.accellera.org/XMLSchema/IPXACT/1685-2022")
    
    override def typeName: Option[String] = Some("hierInterfaceType")

    def parser(node: scala.xml.Node, stack: List[IPXACT2022scalaxb.ElemName]): Parser[IPXACT2022ScalaCases.HierInterfaceType] =
      phrase(opt(IPXACT2022scalaxb.ElemName(Some("http://www.accellera.org/XMLSchema/IPXACT/1685-2022"), "description")) ~
      opt(IPXACT2022scalaxb.ElemName(Some("http://www.accellera.org/XMLSchema/IPXACT/1685-2022"), "vendorExtensions")) ^^
      { case p1 ~ p2 =>
      IPXACT2022ScalaCases.HierInterfaceType(p1.headOption map { IPXACT2022scalaxb.fromXML[String](_, IPXACT2022scalaxb.ElemName(node) :: stack) },
        p2.headOption map { IPXACT2022scalaxb.fromXML[IPXACT2022ScalaCases.VendorExtensions](_, IPXACT2022scalaxb.ElemName(node) :: stack) },
        scala.collection.immutable.ListMap(List(
        (node \ "@busRef").headOption map { x => IPXACT2022scalaxb.DataRecord(x, node, IPXACT2022scalaxb.fromXML[String](x, IPXACT2022scalaxb.ElemName(node) :: stack)) } map { "@busRef" -> _ },
        (node \ "@{http://www.w3.org/XML/1998/namespace}id").headOption map { x => IPXACT2022scalaxb.DataRecord(x, node, IPXACT2022scalaxb.fromXML[String](x, IPXACT2022scalaxb.ElemName(node) :: stack)) } map { "@{http://www.w3.org/XML/1998/namespace}id" -> _ }
        ).flatten[(String, IPXACT2022scalaxb.DataRecord[Any])]: _*)) })
    
    override def writesAttribute(__obj: IPXACT2022ScalaCases.HierInterfaceType, __scope: scala.xml.NamespaceBinding): scala.xml.MetaData = {
      var attr: scala.xml.MetaData  = scala.xml.Null
      __obj.attributes.toList map {
        case ("@busRef", _) => attr = scala.xml.Attribute(null, "busRef", __obj.busRef.toString, attr)
        case ("@{http://www.w3.org/XML/1998/namespace}id", _) => __obj.xmlid foreach { x => attr = scala.xml.Attribute(__scope.getPrefix("http://www.w3.org/XML/1998/namespace"), "id", x.toString, attr) }
        case (key, x) => attr = scala.xml.Attribute((x.namespace map { __scope.getPrefix(_) }).orNull, x.key.orNull, x.value.toString, attr)
      }
      attr
    }

    def writesChildNodes(__obj: IPXACT2022ScalaCases.HierInterfaceType, __scope: scala.xml.NamespaceBinding): Seq[scala.xml.Node] =
      Seq.concat(__obj.description map { IPXACT2022scalaxb.toXML[String](_, Some("http://www.accellera.org/XMLSchema/IPXACT/1685-2022"), Some("description"), __scope, false) } getOrElse {Nil},
        __obj.vendorExtensions map { IPXACT2022scalaxb.toXML[IPXACT2022ScalaCases.VendorExtensions](_, Some("http://www.accellera.org/XMLSchema/IPXACT/1685-2022"), Some("vendorExtensions"), __scope, false) } getOrElse {Nil})

  }

  trait DefaultIPXACT2022ScalaCases_MonitorInterfaceTypeFormat extends IPXACT2022scalaxb.ElemNameParser[IPXACT2022ScalaCases.MonitorInterfaceType] {
    val targetNamespace: Option[String] = Some("http://www.accellera.org/XMLSchema/IPXACT/1685-2022")
    
    override def typeName: Option[String] = Some("monitorInterfaceType")

    def parser(node: scala.xml.Node, stack: List[IPXACT2022scalaxb.ElemName]): Parser[IPXACT2022ScalaCases.MonitorInterfaceType] =
      phrase(opt(IPXACT2022scalaxb.ElemName(Some("http://www.accellera.org/XMLSchema/IPXACT/1685-2022"), "description")) ~
      opt(IPXACT2022scalaxb.ElemName(Some("http://www.accellera.org/XMLSchema/IPXACT/1685-2022"), "vendorExtensions")) ^^
      { case p1 ~ p2 =>
      IPXACT2022ScalaCases.MonitorInterfaceType(p1.headOption map { IPXACT2022scalaxb.fromXML[String](_, IPXACT2022scalaxb.ElemName(node) :: stack) },
        p2.headOption map { IPXACT2022scalaxb.fromXML[IPXACT2022ScalaCases.VendorExtensions](_, IPXACT2022scalaxb.ElemName(node) :: stack) },
        scala.collection.immutable.ListMap(List(
        (node \ "@componentInstanceRef").headOption map { x => IPXACT2022scalaxb.DataRecord(x, node, IPXACT2022scalaxb.fromXML[String](x, IPXACT2022scalaxb.ElemName(node) :: stack)) } map { "@componentInstanceRef" -> _ },
        (node \ "@busRef").headOption map { x => IPXACT2022scalaxb.DataRecord(x, node, IPXACT2022scalaxb.fromXML[String](x, IPXACT2022scalaxb.ElemName(node) :: stack)) } map { "@busRef" -> _ },
        (node \ "@{http://www.w3.org/XML/1998/namespace}id").headOption map { x => IPXACT2022scalaxb.DataRecord(x, node, IPXACT2022scalaxb.fromXML[String](x, IPXACT2022scalaxb.ElemName(node) :: stack)) } map { "@{http://www.w3.org/XML/1998/namespace}id" -> _ },
        (node \ "@path").headOption map { x => IPXACT2022scalaxb.DataRecord(x, node, IPXACT2022scalaxb.fromXML[String](x, IPXACT2022scalaxb.ElemName(node) :: stack)) } map { "@path" -> _ }
        ).flatten[(String, IPXACT2022scalaxb.DataRecord[Any])]: _*)) })
    
    override def writesAttribute(__obj: IPXACT2022ScalaCases.MonitorInterfaceType, __scope: scala.xml.NamespaceBinding): scala.xml.MetaData = {
      var attr: scala.xml.MetaData  = scala.xml.Null
      __obj.attributes.toList map {
        case ("@componentInstanceRef", _) => attr = scala.xml.Attribute(null, "componentInstanceRef", __obj.componentInstanceRef.toString, attr)
        case ("@busRef", _) => attr = scala.xml.Attribute(null, "busRef", __obj.busRef.toString, attr)
        case ("@{http://www.w3.org/XML/1998/namespace}id", _) => __obj.xmlid foreach { x => attr = scala.xml.Attribute(__scope.getPrefix("http://www.w3.org/XML/1998/namespace"), "id", x.toString, attr) }
        case ("@path", _) => __obj.path foreach { x => attr = scala.xml.Attribute(null, "path", x.toString, attr) }
        case (key, x) => attr = scala.xml.Attribute((x.namespace map { __scope.getPrefix(_) }).orNull, x.key.orNull, x.value.toString, attr)
      }
      attr
    }

    def writesChildNodes(__obj: IPXACT2022ScalaCases.MonitorInterfaceType, __scope: scala.xml.NamespaceBinding): Seq[scala.xml.Node] =
      Seq.concat(__obj.description map { IPXACT2022scalaxb.toXML[String](_, Some("http://www.accellera.org/XMLSchema/IPXACT/1685-2022"), Some("description"), __scope, false) } getOrElse {Nil},
        __obj.vendorExtensions map { IPXACT2022scalaxb.toXML[IPXACT2022ScalaCases.VendorExtensions](_, Some("http://www.accellera.org/XMLSchema/IPXACT/1685-2022"), Some("vendorExtensions"), __scope, false) } getOrElse {Nil})

  }

  trait DefaultIPXACT2022ScalaCases_ExternalPortReferenceFormat extends IPXACT2022scalaxb.ElemNameParser[IPXACT2022ScalaCases.ExternalPortReference] {
    val targetNamespace: Option[String] = Some("http://www.accellera.org/XMLSchema/IPXACT/1685-2022")
    
    def parser(node: scala.xml.Node, stack: List[IPXACT2022scalaxb.ElemName]): Parser[IPXACT2022ScalaCases.ExternalPortReference] =
      phrase(safeRep(IPXACT2022scalaxb.ElemName(Some("http://www.accellera.org/XMLSchema/IPXACT/1685-2022"), "subPortReference")) ~
      opt(IPXACT2022scalaxb.ElemName(Some("http://www.accellera.org/XMLSchema/IPXACT/1685-2022"), "partSelect")) ~
      opt(IPXACT2022scalaxb.ElemName(Some("http://www.accellera.org/XMLSchema/IPXACT/1685-2022"), "vendorExtensions")) ^^
      { case p1 ~ p2 ~ p3 =>
      IPXACT2022ScalaCases.ExternalPortReference(p1 map { IPXACT2022scalaxb.fromXML[IPXACT2022ScalaCases.SubPortReference](_, IPXACT2022scalaxb.ElemName(node) :: stack) },
        p2.headOption map { IPXACT2022scalaxb.fromXML[IPXACT2022ScalaCases.PartSelect](_, IPXACT2022scalaxb.ElemName(node) :: stack) },
        p3.headOption map { IPXACT2022scalaxb.fromXML[IPXACT2022ScalaCases.VendorExtensions](_, IPXACT2022scalaxb.ElemName(node) :: stack) },
        scala.collection.immutable.ListMap(List(
        (node \ "@portRef").headOption map { x => IPXACT2022scalaxb.DataRecord(x, node, IPXACT2022scalaxb.fromXML[String](x, IPXACT2022scalaxb.ElemName(node) :: stack)) } map { "@portRef" -> _ },
        (node \ "@{http://www.w3.org/XML/1998/namespace}id").headOption map { x => IPXACT2022scalaxb.DataRecord(x, node, IPXACT2022scalaxb.fromXML[String](x, IPXACT2022scalaxb.ElemName(node) :: stack)) } map { "@{http://www.w3.org/XML/1998/namespace}id" -> _ }
        ).flatten[(String, IPXACT2022scalaxb.DataRecord[Any])]: _*)) })
    
    override def writesAttribute(__obj: IPXACT2022ScalaCases.ExternalPortReference, __scope: scala.xml.NamespaceBinding): scala.xml.MetaData = {
      var attr: scala.xml.MetaData  = scala.xml.Null
      __obj.attributes.toList map {
        case ("@portRef", _) => attr = scala.xml.Attribute(null, "portRef", __obj.portRef.toString, attr)
        case ("@{http://www.w3.org/XML/1998/namespace}id", _) => __obj.xmlid foreach { x => attr = scala.xml.Attribute(__scope.getPrefix("http://www.w3.org/XML/1998/namespace"), "id", x.toString, attr) }
        case (key, x) => attr = scala.xml.Attribute((x.namespace map { __scope.getPrefix(_) }).orNull, x.key.orNull, x.value.toString, attr)
      }
      attr
    }

    def writesChildNodes(__obj: IPXACT2022ScalaCases.ExternalPortReference, __scope: scala.xml.NamespaceBinding): Seq[scala.xml.Node] =
      Seq.concat(__obj.subPortReference flatMap { IPXACT2022scalaxb.toXML[IPXACT2022ScalaCases.SubPortReference](_, Some("http://www.accellera.org/XMLSchema/IPXACT/1685-2022"), Some("subPortReference"), __scope, false) },
        __obj.partSelect map { IPXACT2022scalaxb.toXML[IPXACT2022ScalaCases.PartSelect](_, Some("http://www.accellera.org/XMLSchema/IPXACT/1685-2022"), Some("partSelect"), __scope, false) } getOrElse {Nil},
        __obj.vendorExtensions map { IPXACT2022scalaxb.toXML[IPXACT2022ScalaCases.VendorExtensions](_, Some("http://www.accellera.org/XMLSchema/IPXACT/1685-2022"), Some("vendorExtensions"), __scope, false) } getOrElse {Nil})

  }

  trait DefaultIPXACT2022ScalaCases_ExcludePortFormat extends IPXACT2022scalaxb.XMLFormat[IPXACT2022ScalaCases.ExcludePort] with IPXACT2022scalaxb.CanWriteChildNodes[IPXACT2022ScalaCases.ExcludePort] {
    val targetNamespace: Option[String] = Some("http://www.accellera.org/XMLSchema/IPXACT/1685-2022")
    def reads(seq: scala.xml.NodeSeq, stack: List[IPXACT2022scalaxb.ElemName]): Either[String, IPXACT2022ScalaCases.ExcludePort] = seq match {
      case node: scala.xml.Node => Right(IPXACT2022ScalaCases.ExcludePort(IPXACT2022scalaxb.fromXML[String](node, IPXACT2022scalaxb.ElemName(node) :: stack),
        scala.collection.immutable.ListMap(List(
        (node \ "@{http://www.w3.org/XML/1998/namespace}id").headOption map { x => IPXACT2022scalaxb.DataRecord(x, node, IPXACT2022scalaxb.fromXML[String](x, IPXACT2022scalaxb.ElemName(node) :: stack)) } map { "@{http://www.w3.org/XML/1998/namespace}id" -> _ }
        ).flatten[(String, IPXACT2022scalaxb.DataRecord[Any])]: _*)))
      case _ => Left("reads failed: seq must be scala.xml.Node")
    }
    
    override def writesAttribute(__obj: IPXACT2022ScalaCases.ExcludePort, __scope: scala.xml.NamespaceBinding): scala.xml.MetaData = {
      var attr: scala.xml.MetaData  = scala.xml.Null
      __obj.attributes.toList map {
        case ("@{http://www.w3.org/XML/1998/namespace}id", _) => __obj.xmlid foreach { x => attr = scala.xml.Attribute(__scope.getPrefix("http://www.w3.org/XML/1998/namespace"), "id", x.toString, attr) }
        case (key, x) => attr = scala.xml.Attribute((x.namespace map { __scope.getPrefix(_) }).orNull, x.key.orNull, x.value.toString, attr)
      }
      attr
    }

    def writesChildNodes(__obj: IPXACT2022ScalaCases.ExcludePort, __scope: scala.xml.NamespaceBinding): Seq[scala.xml.Node] =
      Seq(scala.xml.Text(__obj.value.toString))

  }

  trait DefaultIPXACT2022ScalaCases_ExcludePortsFormat extends IPXACT2022scalaxb.ElemNameParser[IPXACT2022ScalaCases.ExcludePorts] {
    val targetNamespace: Option[String] = Some("http://www.accellera.org/XMLSchema/IPXACT/1685-2022")
    
    def parser(node: scala.xml.Node, stack: List[IPXACT2022scalaxb.ElemName]): Parser[IPXACT2022ScalaCases.ExcludePorts] =
      phrase(safeRep(IPXACT2022scalaxb.ElemName(Some("http://www.accellera.org/XMLSchema/IPXACT/1685-2022"), "excludePort")) ^^
      { case p1 =>
      IPXACT2022ScalaCases.ExcludePorts(p1 map { IPXACT2022scalaxb.fromXML[IPXACT2022ScalaCases.ExcludePort](_, IPXACT2022scalaxb.ElemName(node) :: stack) }) })
    
    def writesChildNodes(__obj: IPXACT2022ScalaCases.ExcludePorts, __scope: scala.xml.NamespaceBinding): Seq[scala.xml.Node] =
      (__obj.excludePort flatMap { IPXACT2022scalaxb.toXML[IPXACT2022ScalaCases.ExcludePort](_, Some("http://www.accellera.org/XMLSchema/IPXACT/1685-2022"), Some("excludePort"), __scope, false) })
  }
  trait DefaultIPXACT2022ScalaCases_ActiveInterfaceFormat extends IPXACT2022scalaxb.ElemNameParser[IPXACT2022ScalaCases.ActiveInterface] {
    val targetNamespace: Option[String] = Some("http://www.accellera.org/XMLSchema/IPXACT/1685-2022")
    
    def parser(node: scala.xml.Node, stack: List[IPXACT2022scalaxb.ElemName]): Parser[IPXACT2022ScalaCases.ActiveInterface] =
      phrase(opt(IPXACT2022scalaxb.ElemName(Some("http://www.accellera.org/XMLSchema/IPXACT/1685-2022"), "description")) ~
      opt(IPXACT2022scalaxb.ElemName(Some("http://www.accellera.org/XMLSchema/IPXACT/1685-2022"), "excludePorts")) ~
      opt(IPXACT2022scalaxb.ElemName(Some("http://www.accellera.org/XMLSchema/IPXACT/1685-2022"), "vendorExtensions")) ^^
      { case p1 ~ p2 ~ p3 =>
      IPXACT2022ScalaCases.ActiveInterface(p1.headOption map { IPXACT2022scalaxb.fromXML[String](_, IPXACT2022scalaxb.ElemName(node) :: stack) },
        p2.headOption map { IPXACT2022scalaxb.fromXML[IPXACT2022ScalaCases.ExcludePorts](_, IPXACT2022scalaxb.ElemName(node) :: stack) },
        p3.headOption map { IPXACT2022scalaxb.fromXML[IPXACT2022ScalaCases.VendorExtensions](_, IPXACT2022scalaxb.ElemName(node) :: stack) },
        scala.collection.immutable.ListMap(List(
        (node \ "@componentInstanceRef").headOption map { x => IPXACT2022scalaxb.DataRecord(x, node, IPXACT2022scalaxb.fromXML[String](x, IPXACT2022scalaxb.ElemName(node) :: stack)) } map { "@componentInstanceRef" -> _ },
        (node \ "@busRef").headOption map { x => IPXACT2022scalaxb.DataRecord(x, node, IPXACT2022scalaxb.fromXML[String](x, IPXACT2022scalaxb.ElemName(node) :: stack)) } map { "@busRef" -> _ },
        (node \ "@{http://www.w3.org/XML/1998/namespace}id").headOption map { x => IPXACT2022scalaxb.DataRecord(x, node, IPXACT2022scalaxb.fromXML[String](x, IPXACT2022scalaxb.ElemName(node) :: stack)) } map { "@{http://www.w3.org/XML/1998/namespace}id" -> _ }
        ).flatten[(String, IPXACT2022scalaxb.DataRecord[Any])]: _*)) })
    
    override def writesAttribute(__obj: IPXACT2022ScalaCases.ActiveInterface, __scope: scala.xml.NamespaceBinding): scala.xml.MetaData = {
      var attr: scala.xml.MetaData  = scala.xml.Null
      __obj.attributes.toList map {
        case ("@componentInstanceRef", _) => attr = scala.xml.Attribute(null, "componentInstanceRef", __obj.componentInstanceRef.toString, attr)
        case ("@busRef", _) => attr = scala.xml.Attribute(null, "busRef", __obj.busRef.toString, attr)
        case ("@{http://www.w3.org/XML/1998/namespace}id", _) => __obj.xmlid foreach { x => attr = scala.xml.Attribute(__scope.getPrefix("http://www.w3.org/XML/1998/namespace"), "id", x.toString, attr) }
        case (key, x) => attr = scala.xml.Attribute((x.namespace map { __scope.getPrefix(_) }).orNull, x.key.orNull, x.value.toString, attr)
      }
      attr
    }

    def writesChildNodes(__obj: IPXACT2022ScalaCases.ActiveInterface, __scope: scala.xml.NamespaceBinding): Seq[scala.xml.Node] =
      Seq.concat(__obj.description map { IPXACT2022scalaxb.toXML[String](_, Some("http://www.accellera.org/XMLSchema/IPXACT/1685-2022"), Some("description"), __scope, false) } getOrElse {Nil},
        __obj.excludePorts map { IPXACT2022scalaxb.toXML[IPXACT2022ScalaCases.ExcludePorts](_, Some("http://www.accellera.org/XMLSchema/IPXACT/1685-2022"), Some("excludePorts"), __scope, false) } getOrElse {Nil},
        __obj.vendorExtensions map { IPXACT2022scalaxb.toXML[IPXACT2022ScalaCases.VendorExtensions](_, Some("http://www.accellera.org/XMLSchema/IPXACT/1685-2022"), Some("vendorExtensions"), __scope, false) } getOrElse {Nil})

  }

  trait DefaultIPXACT2022ScalaCases_InternalPowerDomainReferenceFormat extends IPXACT2022scalaxb.XMLFormat[IPXACT2022ScalaCases.InternalPowerDomainReference] with IPXACT2022scalaxb.CanWriteChildNodes[IPXACT2022ScalaCases.InternalPowerDomainReference] {
    val targetNamespace: Option[String] = Some("http://www.accellera.org/XMLSchema/IPXACT/1685-2022")
    def reads(seq: scala.xml.NodeSeq, stack: List[IPXACT2022scalaxb.ElemName]): Either[String, IPXACT2022ScalaCases.InternalPowerDomainReference] = seq match {
      case node: scala.xml.Node => Right(IPXACT2022ScalaCases.InternalPowerDomainReference(IPXACT2022scalaxb.fromXML[String](node, IPXACT2022scalaxb.ElemName(node) :: stack),
        scala.collection.immutable.ListMap(List(
        (node \ "@{http://www.w3.org/XML/1998/namespace}id").headOption map { x => IPXACT2022scalaxb.DataRecord(x, node, IPXACT2022scalaxb.fromXML[String](x, IPXACT2022scalaxb.ElemName(node) :: stack)) } map { "@{http://www.w3.org/XML/1998/namespace}id" -> _ }
        ).flatten[(String, IPXACT2022scalaxb.DataRecord[Any])]: _*)))
      case _ => Left("reads failed: seq must be scala.xml.Node")
    }
    
    override def writesAttribute(__obj: IPXACT2022ScalaCases.InternalPowerDomainReference, __scope: scala.xml.NamespaceBinding): scala.xml.MetaData = {
      var attr: scala.xml.MetaData  = scala.xml.Null
      __obj.attributes.toList map {
        case ("@{http://www.w3.org/XML/1998/namespace}id", _) => __obj.xmlid foreach { x => attr = scala.xml.Attribute(__scope.getPrefix("http://www.w3.org/XML/1998/namespace"), "id", x.toString, attr) }
        case (key, x) => attr = scala.xml.Attribute((x.namespace map { __scope.getPrefix(_) }).orNull, x.key.orNull, x.value.toString, attr)
      }
      attr
    }

    def writesChildNodes(__obj: IPXACT2022ScalaCases.InternalPowerDomainReference, __scope: scala.xml.NamespaceBinding): Seq[scala.xml.Node] =
      Seq(scala.xml.Text(__obj.value.toString))

  }

  trait DefaultIPXACT2022ScalaCases_PowerDomainLinkFormat extends IPXACT2022scalaxb.ElemNameParser[IPXACT2022ScalaCases.PowerDomainLink] {
    val targetNamespace: Option[String] = Some("http://www.accellera.org/XMLSchema/IPXACT/1685-2022")
    
    def parser(node: scala.xml.Node, stack: List[IPXACT2022scalaxb.ElemName]): Parser[IPXACT2022ScalaCases.PowerDomainLink] =
      phrase((IPXACT2022scalaxb.ElemName(Some("http://www.accellera.org/XMLSchema/IPXACT/1685-2022"), "externalPowerDomainReference")) ~
      safeRep(IPXACT2022scalaxb.ElemName(Some("http://www.accellera.org/XMLSchema/IPXACT/1685-2022"), "internalPowerDomainReference")) ^^
      { case p1 ~ p2 =>
      IPXACT2022ScalaCases.PowerDomainLink(IPXACT2022scalaxb.fromXML[IPXACT2022ScalaCases.StringExpressionable](p1, IPXACT2022scalaxb.ElemName(node) :: stack),
        p2 map { IPXACT2022scalaxb.fromXML[IPXACT2022ScalaCases.InternalPowerDomainReference](_, IPXACT2022scalaxb.ElemName(node) :: stack) },
        scala.collection.immutable.ListMap(List(
        (node \ "@{http://www.w3.org/XML/1998/namespace}id").headOption map { x => IPXACT2022scalaxb.DataRecord(x, node, IPXACT2022scalaxb.fromXML[String](x, IPXACT2022scalaxb.ElemName(node) :: stack)) } map { "@{http://www.w3.org/XML/1998/namespace}id" -> _ }
        ).flatten[(String, IPXACT2022scalaxb.DataRecord[Any])]: _*)) })
    
    override def writesAttribute(__obj: IPXACT2022ScalaCases.PowerDomainLink, __scope: scala.xml.NamespaceBinding): scala.xml.MetaData = {
      var attr: scala.xml.MetaData  = scala.xml.Null
      __obj.attributes.toList map {
        case ("@{http://www.w3.org/XML/1998/namespace}id", _) => __obj.xmlid foreach { x => attr = scala.xml.Attribute(__scope.getPrefix("http://www.w3.org/XML/1998/namespace"), "id", x.toString, attr) }
        case (key, x) => attr = scala.xml.Attribute((x.namespace map { __scope.getPrefix(_) }).orNull, x.key.orNull, x.value.toString, attr)
      }
      attr
    }

    def writesChildNodes(__obj: IPXACT2022ScalaCases.PowerDomainLink, __scope: scala.xml.NamespaceBinding): Seq[scala.xml.Node] =
      Seq.concat(IPXACT2022scalaxb.toXML[IPXACT2022ScalaCases.StringExpressionable](__obj.externalPowerDomainReference, Some("http://www.accellera.org/XMLSchema/IPXACT/1685-2022"), Some("externalPowerDomainReference"), __scope, false),
        __obj.internalPowerDomainReference flatMap { IPXACT2022scalaxb.toXML[IPXACT2022ScalaCases.InternalPowerDomainReference](_, Some("http://www.accellera.org/XMLSchema/IPXACT/1685-2022"), Some("internalPowerDomainReference"), __scope, false) })

  }

  trait DefaultIPXACT2022ScalaCases_PowerDomainLinksFormat extends IPXACT2022scalaxb.ElemNameParser[IPXACT2022ScalaCases.PowerDomainLinks] {
    val targetNamespace: Option[String] = Some("http://www.accellera.org/XMLSchema/IPXACT/1685-2022")
    
    def parser(node: scala.xml.Node, stack: List[IPXACT2022scalaxb.ElemName]): Parser[IPXACT2022ScalaCases.PowerDomainLinks] =
      phrase(safeRep(IPXACT2022scalaxb.ElemName(Some("http://www.accellera.org/XMLSchema/IPXACT/1685-2022"), "powerDomainLink")) ^^
      { case p1 =>
      IPXACT2022ScalaCases.PowerDomainLinks(p1 map { IPXACT2022scalaxb.fromXML[IPXACT2022ScalaCases.PowerDomainLink](_, IPXACT2022scalaxb.ElemName(node) :: stack) }) })
    
    def writesChildNodes(__obj: IPXACT2022ScalaCases.PowerDomainLinks, __scope: scala.xml.NamespaceBinding): Seq[scala.xml.Node] =
      (__obj.powerDomainLink flatMap { IPXACT2022scalaxb.toXML[IPXACT2022ScalaCases.PowerDomainLink](_, Some("http://www.accellera.org/XMLSchema/IPXACT/1685-2022"), Some("powerDomainLink"), __scope, false) })
  }
  trait DefaultIPXACT2022ScalaCases_Mode2Format extends IPXACT2022scalaxb.ElemNameParser[IPXACT2022ScalaCases.Mode2] with IPXACT2022ScalaCases_NameGroupGroupFormat {
    val targetNamespace: Option[String] = Some("http://www.accellera.org/XMLSchema/IPXACT/1685-2022")
    
    def parser(node: scala.xml.Node, stack: List[IPXACT2022scalaxb.ElemName]): Parser[IPXACT2022ScalaCases.Mode2] =
      phrase((parseNameGroupGroup(node, IPXACT2022scalaxb.ElemName(node) :: stack)) ~
      opt(IPXACT2022scalaxb.ElemName(Some("http://www.accellera.org/XMLSchema/IPXACT/1685-2022"), "vendorExtensions")) ^^
      { case p1 ~ p2 =>
      IPXACT2022ScalaCases.Mode2(p1,
        p2.headOption map { IPXACT2022scalaxb.fromXML[IPXACT2022ScalaCases.VendorExtensions](_, IPXACT2022scalaxb.ElemName(node) :: stack) },
        scala.collection.immutable.ListMap(List(
        (node \ "@{http://www.w3.org/XML/1998/namespace}id").headOption map { x => IPXACT2022scalaxb.DataRecord(x, node, IPXACT2022scalaxb.fromXML[String](x, IPXACT2022scalaxb.ElemName(node) :: stack)) } map { "@{http://www.w3.org/XML/1998/namespace}id" -> _ }
        ).flatten[(String, IPXACT2022scalaxb.DataRecord[Any])]: _*)) })
    
    override def writesAttribute(__obj: IPXACT2022ScalaCases.Mode2, __scope: scala.xml.NamespaceBinding): scala.xml.MetaData = {
      var attr: scala.xml.MetaData  = scala.xml.Null
      __obj.attributes.toList map {
        case ("@{http://www.w3.org/XML/1998/namespace}id", _) => __obj.xmlid foreach { x => attr = scala.xml.Attribute(__scope.getPrefix("http://www.w3.org/XML/1998/namespace"), "id", x.toString, attr) }
        case (key, x) => attr = scala.xml.Attribute((x.namespace map { __scope.getPrefix(_) }).orNull, x.key.orNull, x.value.toString, attr)
      }
      attr
    }

    def writesChildNodes(__obj: IPXACT2022ScalaCases.Mode2, __scope: scala.xml.NamespaceBinding): Seq[scala.xml.Node] =
      Seq.concat(IPXACT2022scalaxb.toXML[IPXACT2022ScalaCases.NameGroupSequence](__obj.nameGroupSequence1, None, Some("nameGroupSequence1"), __scope, false),
        __obj.vendorExtensions map { IPXACT2022scalaxb.toXML[IPXACT2022ScalaCases.VendorExtensions](_, Some("http://www.accellera.org/XMLSchema/IPXACT/1685-2022"), Some("vendorExtensions"), __scope, false) } getOrElse {Nil})

  }

  trait DefaultIPXACT2022ScalaCases_Modes2Format extends IPXACT2022scalaxb.ElemNameParser[IPXACT2022ScalaCases.Modes2] {
    val targetNamespace: Option[String] = Some("http://www.accellera.org/XMLSchema/IPXACT/1685-2022")
    
    def parser(node: scala.xml.Node, stack: List[IPXACT2022scalaxb.ElemName]): Parser[IPXACT2022ScalaCases.Modes2] =
      phrase(safeRep(IPXACT2022scalaxb.ElemName(Some("http://www.accellera.org/XMLSchema/IPXACT/1685-2022"), "mode")) ^^
      { case p1 =>
      IPXACT2022ScalaCases.Modes2(p1 map { IPXACT2022scalaxb.fromXML[IPXACT2022ScalaCases.Mode2](_, IPXACT2022scalaxb.ElemName(node) :: stack) }) })
    
    def writesChildNodes(__obj: IPXACT2022ScalaCases.Modes2, __scope: scala.xml.NamespaceBinding): Seq[scala.xml.Node] =
      (__obj.mode flatMap { IPXACT2022scalaxb.toXML[IPXACT2022ScalaCases.Mode2](_, Some("http://www.accellera.org/XMLSchema/IPXACT/1685-2022"), Some("mode"), __scope, false) })
  }
  trait DefaultIPXACT2022ScalaCases_View4Format extends IPXACT2022scalaxb.ElemNameParser[IPXACT2022ScalaCases.View4] with IPXACT2022ScalaCases_NameGroupGroupFormat {
    val targetNamespace: Option[String] = Some("http://www.accellera.org/XMLSchema/IPXACT/1685-2022")
    
    def parser(node: scala.xml.Node, stack: List[IPXACT2022scalaxb.ElemName]): Parser[IPXACT2022ScalaCases.View4] =
      phrase((parseNameGroupGroup(node, IPXACT2022scalaxb.ElemName(node) :: stack)) ~
      opt(IPXACT2022scalaxb.ElemName(Some("http://www.accellera.org/XMLSchema/IPXACT/1685-2022"), "vendorExtensions")) ^^
      { case p1 ~ p2 =>
      IPXACT2022ScalaCases.View4(p1,
        p2.headOption map { IPXACT2022scalaxb.fromXML[IPXACT2022ScalaCases.VendorExtensions](_, IPXACT2022scalaxb.ElemName(node) :: stack) },
        scala.collection.immutable.ListMap(List(
        (node \ "@{http://www.w3.org/XML/1998/namespace}id").headOption map { x => IPXACT2022scalaxb.DataRecord(x, node, IPXACT2022scalaxb.fromXML[String](x, IPXACT2022scalaxb.ElemName(node) :: stack)) } map { "@{http://www.w3.org/XML/1998/namespace}id" -> _ }
        ).flatten[(String, IPXACT2022scalaxb.DataRecord[Any])]: _*)) })
    
    override def writesAttribute(__obj: IPXACT2022ScalaCases.View4, __scope: scala.xml.NamespaceBinding): scala.xml.MetaData = {
      var attr: scala.xml.MetaData  = scala.xml.Null
      __obj.attributes.toList map {
        case ("@{http://www.w3.org/XML/1998/namespace}id", _) => __obj.xmlid foreach { x => attr = scala.xml.Attribute(__scope.getPrefix("http://www.w3.org/XML/1998/namespace"), "id", x.toString, attr) }
        case (key, x) => attr = scala.xml.Attribute((x.namespace map { __scope.getPrefix(_) }).orNull, x.key.orNull, x.value.toString, attr)
      }
      attr
    }

    def writesChildNodes(__obj: IPXACT2022ScalaCases.View4, __scope: scala.xml.NamespaceBinding): Seq[scala.xml.Node] =
      Seq.concat(IPXACT2022scalaxb.toXML[IPXACT2022ScalaCases.NameGroupSequence](__obj.nameGroupSequence1, None, Some("nameGroupSequence1"), __scope, false),
        __obj.vendorExtensions map { IPXACT2022scalaxb.toXML[IPXACT2022ScalaCases.VendorExtensions](_, Some("http://www.accellera.org/XMLSchema/IPXACT/1685-2022"), Some("vendorExtensions"), __scope, false) } getOrElse {Nil})

  }

  trait DefaultIPXACT2022ScalaCases_Views3Format extends IPXACT2022scalaxb.ElemNameParser[IPXACT2022ScalaCases.Views3] {
    val targetNamespace: Option[String] = Some("http://www.accellera.org/XMLSchema/IPXACT/1685-2022")
    
    def parser(node: scala.xml.Node, stack: List[IPXACT2022scalaxb.ElemName]): Parser[IPXACT2022ScalaCases.Views3] =
      phrase(safeRep(IPXACT2022scalaxb.ElemName(Some("http://www.accellera.org/XMLSchema/IPXACT/1685-2022"), "view")) ^^
      { case p1 =>
      IPXACT2022ScalaCases.Views3(p1 map { IPXACT2022scalaxb.fromXML[IPXACT2022ScalaCases.View4](_, IPXACT2022scalaxb.ElemName(node) :: stack) }) })
    
    def writesChildNodes(__obj: IPXACT2022ScalaCases.Views3, __scope: scala.xml.NamespaceBinding): Seq[scala.xml.Node] =
      (__obj.view flatMap { IPXACT2022scalaxb.toXML[IPXACT2022ScalaCases.View4](_, Some("http://www.accellera.org/XMLSchema/IPXACT/1685-2022"), Some("view"), __scope, false) })
  }
  trait DefaultIPXACT2022ScalaCases_ResetType2Format extends IPXACT2022scalaxb.ElemNameParser[IPXACT2022ScalaCases.ResetType2] with IPXACT2022ScalaCases_NameGroupGroupFormat {
    val targetNamespace: Option[String] = Some("http://www.accellera.org/XMLSchema/IPXACT/1685-2022")
    
    def parser(node: scala.xml.Node, stack: List[IPXACT2022scalaxb.ElemName]): Parser[IPXACT2022ScalaCases.ResetType2] =
      phrase((parseNameGroupGroup(node, IPXACT2022scalaxb.ElemName(node) :: stack)) ~
      opt(IPXACT2022scalaxb.ElemName(Some("http://www.accellera.org/XMLSchema/IPXACT/1685-2022"), "vendorExtensions")) ^^
      { case p1 ~ p2 =>
      IPXACT2022ScalaCases.ResetType2(p1,
        p2.headOption map { IPXACT2022scalaxb.fromXML[IPXACT2022ScalaCases.VendorExtensions](_, IPXACT2022scalaxb.ElemName(node) :: stack) },
        scala.collection.immutable.ListMap(List(
        (node \ "@{http://www.w3.org/XML/1998/namespace}id").headOption map { x => IPXACT2022scalaxb.DataRecord(x, node, IPXACT2022scalaxb.fromXML[String](x, IPXACT2022scalaxb.ElemName(node) :: stack)) } map { "@{http://www.w3.org/XML/1998/namespace}id" -> _ }
        ).flatten[(String, IPXACT2022scalaxb.DataRecord[Any])]: _*)) })
    
    override def writesAttribute(__obj: IPXACT2022ScalaCases.ResetType2, __scope: scala.xml.NamespaceBinding): scala.xml.MetaData = {
      var attr: scala.xml.MetaData  = scala.xml.Null
      __obj.attributes.toList map {
        case ("@{http://www.w3.org/XML/1998/namespace}id", _) => __obj.xmlid foreach { x => attr = scala.xml.Attribute(__scope.getPrefix("http://www.w3.org/XML/1998/namespace"), "id", x.toString, attr) }
        case (key, x) => attr = scala.xml.Attribute((x.namespace map { __scope.getPrefix(_) }).orNull, x.key.orNull, x.value.toString, attr)
      }
      attr
    }

    def writesChildNodes(__obj: IPXACT2022ScalaCases.ResetType2, __scope: scala.xml.NamespaceBinding): Seq[scala.xml.Node] =
      Seq.concat(IPXACT2022scalaxb.toXML[IPXACT2022ScalaCases.NameGroupSequence](__obj.nameGroupSequence1, None, Some("nameGroupSequence1"), __scope, false),
        __obj.vendorExtensions map { IPXACT2022scalaxb.toXML[IPXACT2022ScalaCases.VendorExtensions](_, Some("http://www.accellera.org/XMLSchema/IPXACT/1685-2022"), Some("vendorExtensions"), __scope, false) } getOrElse {Nil})

  }

  trait DefaultIPXACT2022ScalaCases_ResetTypes2Format extends IPXACT2022scalaxb.ElemNameParser[IPXACT2022ScalaCases.ResetTypes2] {
    val targetNamespace: Option[String] = Some("http://www.accellera.org/XMLSchema/IPXACT/1685-2022")
    
    def parser(node: scala.xml.Node, stack: List[IPXACT2022scalaxb.ElemName]): Parser[IPXACT2022ScalaCases.ResetTypes2] =
      phrase(safeRep(IPXACT2022scalaxb.ElemName(Some("http://www.accellera.org/XMLSchema/IPXACT/1685-2022"), "resetType")) ^^
      { case p1 =>
      IPXACT2022ScalaCases.ResetTypes2(p1 map { IPXACT2022scalaxb.fromXML[IPXACT2022ScalaCases.ResetType2](_, IPXACT2022scalaxb.ElemName(node) :: stack) }) })
    
    def writesChildNodes(__obj: IPXACT2022ScalaCases.ResetTypes2, __scope: scala.xml.NamespaceBinding): Seq[scala.xml.Node] =
      (__obj.resetType flatMap { IPXACT2022scalaxb.toXML[IPXACT2022ScalaCases.ResetType2](_, Some("http://www.accellera.org/XMLSchema/IPXACT/1685-2022"), Some("resetType"), __scope, false) })
  }
  trait DefaultIPXACT2022ScalaCases_TypeDefinitions2Format extends IPXACT2022scalaxb.ElemNameParser[IPXACT2022ScalaCases.TypeDefinitions2] with IPXACT2022ScalaCases_DocumentNameGroupGroupFormat {
    val targetNamespace: Option[String] = Some("http://www.accellera.org/XMLSchema/IPXACT/1685-2022")
    
    def parser(node: scala.xml.Node, stack: List[IPXACT2022scalaxb.ElemName]): Parser[IPXACT2022ScalaCases.TypeDefinitions2] =
      phrase(opt(((parseDocumentNameGroupGroup(node, IPXACT2022scalaxb.ElemName(node) :: stack)) ~
      safeRep(IPXACT2022scalaxb.ElemName(Some("http://www.accellera.org/XMLSchema/IPXACT/1685-2022"), "externalTypeDefinitions")) ~
      opt(IPXACT2022scalaxb.ElemName(Some("http://www.accellera.org/XMLSchema/IPXACT/1685-2022"), "modes")) ~
      opt(IPXACT2022scalaxb.ElemName(Some("http://www.accellera.org/XMLSchema/IPXACT/1685-2022"), "views")) ~
      opt(IPXACT2022scalaxb.ElemName(Some("http://www.accellera.org/XMLSchema/IPXACT/1685-2022"), "fieldAccessPolicyDefinitions")) ~
      opt(IPXACT2022scalaxb.ElemName(Some("http://www.accellera.org/XMLSchema/IPXACT/1685-2022"), "enumerationDefinitions")) ~
      opt(IPXACT2022scalaxb.ElemName(Some("http://www.accellera.org/XMLSchema/IPXACT/1685-2022"), "fieldDefinitions")) ~
      opt(IPXACT2022scalaxb.ElemName(Some("http://www.accellera.org/XMLSchema/IPXACT/1685-2022"), "registerDefinitions")) ~
      opt(IPXACT2022scalaxb.ElemName(Some("http://www.accellera.org/XMLSchema/IPXACT/1685-2022"), "registerFileDefinitions")) ~
      opt(IPXACT2022scalaxb.ElemName(Some("http://www.accellera.org/XMLSchema/IPXACT/1685-2022"), "addressBlockDefinitions")) ~
      opt(IPXACT2022scalaxb.ElemName(Some("http://www.accellera.org/XMLSchema/IPXACT/1685-2022"), "bankDefinitions")) ~
      opt(IPXACT2022scalaxb.ElemName(Some("http://www.accellera.org/XMLSchema/IPXACT/1685-2022"), "memoryMapDefinitions")) ~
      opt(IPXACT2022scalaxb.ElemName(Some("http://www.accellera.org/XMLSchema/IPXACT/1685-2022"), "memoryRemapDefinitions")) ~
      opt(IPXACT2022scalaxb.ElemName(Some("http://www.accellera.org/XMLSchema/IPXACT/1685-2022"), "resetTypes")) ~
      opt(IPXACT2022scalaxb.ElemName(Some("http://www.accellera.org/XMLSchema/IPXACT/1685-2022"), "choices")) ~
      opt(IPXACT2022scalaxb.ElemName(Some("http://www.accellera.org/XMLSchema/IPXACT/1685-2022"), "parameters")) ~
      opt(IPXACT2022scalaxb.ElemName(Some("http://www.accellera.org/XMLSchema/IPXACT/1685-2022"), "assertions")) ~
      opt(IPXACT2022scalaxb.ElemName(Some("http://www.accellera.org/XMLSchema/IPXACT/1685-2022"), "vendorExtensions"))) ^^
        { case p1 ~ p2 ~ p3 ~ p4 ~ p5 ~ p6 ~ p7 ~ p8 ~ p9 ~ p10 ~ p11 ~ p12 ~ p13 ~ p14 ~ p15 ~ p16 ~ p17 ~ p18 => IPXACT2022ScalaCases.TypeDefinitions2Sequence1(p1,
        p2 map { IPXACT2022scalaxb.fromXML[IPXACT2022ScalaCases.ExternalTypeDefinitions](_, IPXACT2022scalaxb.ElemName(node) :: stack) },
        p3.headOption map { IPXACT2022scalaxb.fromXML[IPXACT2022ScalaCases.Modes2](_, IPXACT2022scalaxb.ElemName(node) :: stack) },
        p4.headOption map { IPXACT2022scalaxb.fromXML[IPXACT2022ScalaCases.Views3](_, IPXACT2022scalaxb.ElemName(node) :: stack) },
        p5.headOption map { IPXACT2022scalaxb.fromXML[IPXACT2022ScalaCases.FieldAccessPolicyDefinitions](_, IPXACT2022scalaxb.ElemName(node) :: stack) },
        p6.headOption map { IPXACT2022scalaxb.fromXML[IPXACT2022ScalaCases.EnumerationDefinitions](_, IPXACT2022scalaxb.ElemName(node) :: stack) },
        p7.headOption map { IPXACT2022scalaxb.fromXML[IPXACT2022ScalaCases.FieldDefinitions](_, IPXACT2022scalaxb.ElemName(node) :: stack) },
        p8.headOption map { IPXACT2022scalaxb.fromXML[IPXACT2022ScalaCases.RegisterDefinitions](_, IPXACT2022scalaxb.ElemName(node) :: stack) },
        p9.headOption map { IPXACT2022scalaxb.fromXML[IPXACT2022ScalaCases.RegisterFileDefinitions](_, IPXACT2022scalaxb.ElemName(node) :: stack) },
        p10.headOption map { IPXACT2022scalaxb.fromXML[IPXACT2022ScalaCases.AddressBlockDefinitions](_, IPXACT2022scalaxb.ElemName(node) :: stack) },
        p11.headOption map { IPXACT2022scalaxb.fromXML[IPXACT2022ScalaCases.BankDefinitions](_, IPXACT2022scalaxb.ElemName(node) :: stack) },
        p12.headOption map { IPXACT2022scalaxb.fromXML[IPXACT2022ScalaCases.MemoryMapDefinitions](_, IPXACT2022scalaxb.ElemName(node) :: stack) },
        p13.headOption map { IPXACT2022scalaxb.fromXML[IPXACT2022ScalaCases.MemoryRemapDefinitions](_, IPXACT2022scalaxb.ElemName(node) :: stack) },
        p14.headOption map { IPXACT2022scalaxb.fromXML[IPXACT2022ScalaCases.ResetTypes2](_, IPXACT2022scalaxb.ElemName(node) :: stack) },
        p15.headOption map { IPXACT2022scalaxb.fromXML[IPXACT2022ScalaCases.Choices](_, IPXACT2022scalaxb.ElemName(node) :: stack) },
        p16.headOption map { IPXACT2022scalaxb.fromXML[IPXACT2022ScalaCases.Parameters](_, IPXACT2022scalaxb.ElemName(node) :: stack) },
        p17.headOption map { IPXACT2022scalaxb.fromXML[IPXACT2022ScalaCases.Assertions](_, IPXACT2022scalaxb.ElemName(node) :: stack) },
        p18.headOption map { IPXACT2022scalaxb.fromXML[IPXACT2022ScalaCases.VendorExtensions](_, IPXACT2022scalaxb.ElemName(node) :: stack) }) }) ^^
      { case p1 =>
      IPXACT2022ScalaCases.TypeDefinitions2(p1,
        scala.collection.immutable.ListMap(List(
        (node \ "@{http://www.w3.org/XML/1998/namespace}id").headOption map { x => IPXACT2022scalaxb.DataRecord(x, node, IPXACT2022scalaxb.fromXML[String](x, IPXACT2022scalaxb.ElemName(node) :: stack)) } map { "@{http://www.w3.org/XML/1998/namespace}id" -> _ }
        ).flatten[(String, IPXACT2022scalaxb.DataRecord[Any])]: _*)) })
    
    override def writesAttribute(__obj: IPXACT2022ScalaCases.TypeDefinitions2, __scope: scala.xml.NamespaceBinding): scala.xml.MetaData = {
      var attr: scala.xml.MetaData  = scala.xml.Null
      __obj.attributes.toList map {
        case ("@{http://www.w3.org/XML/1998/namespace}id", _) => __obj.xmlid foreach { x => attr = scala.xml.Attribute(__scope.getPrefix("http://www.w3.org/XML/1998/namespace"), "id", x.toString, attr) }
        case (key, x) => attr = scala.xml.Attribute((x.namespace map { __scope.getPrefix(_) }).orNull, x.key.orNull, x.value.toString, attr)
      }
      attr
    }

    def writesChildNodes(__obj: IPXACT2022ScalaCases.TypeDefinitions2, __scope: scala.xml.NamespaceBinding): Seq[scala.xml.Node] =
      (__obj.typedefinitions2sequence1 map { IPXACT2022scalaxb.toXML[IPXACT2022ScalaCases.TypeDefinitions2Sequence1](_, None, Some("typedefinitions2sequence1"), __scope, false) } getOrElse {Nil})
  }

  trait DefaultIPXACT2022ScalaCases_TypeDefinitions2Sequence1Format extends IPXACT2022scalaxb.XMLFormat[IPXACT2022ScalaCases.TypeDefinitions2Sequence1] {
    def reads(seq: scala.xml.NodeSeq, stack: List[IPXACT2022scalaxb.ElemName]): Either[String, IPXACT2022ScalaCases.TypeDefinitions2Sequence1] = Left("don't call me.")
    
    def writes(__obj: IPXACT2022ScalaCases.TypeDefinitions2Sequence1, __namespace: Option[String], __elementLabel: Option[String],
        __scope: scala.xml.NamespaceBinding, __typeAttribute: Boolean): scala.xml.NodeSeq =
      Seq.concat(IPXACT2022scalaxb.toXML[IPXACT2022ScalaCases.DocumentNameGroupSequence](__obj.documentNameGroupSequence1, None, Some("documentNameGroupSequence1"), __scope, false),
        __obj.externalTypeDefinitions flatMap { IPXACT2022scalaxb.toXML[IPXACT2022ScalaCases.ExternalTypeDefinitions](_, Some("http://www.accellera.org/XMLSchema/IPXACT/1685-2022"), Some("externalTypeDefinitions"), __scope, false) },
        __obj.modes map { IPXACT2022scalaxb.toXML[IPXACT2022ScalaCases.Modes2](_, Some("http://www.accellera.org/XMLSchema/IPXACT/1685-2022"), Some("modes"), __scope, false) } getOrElse {Nil},
        __obj.views map { IPXACT2022scalaxb.toXML[IPXACT2022ScalaCases.Views3](_, Some("http://www.accellera.org/XMLSchema/IPXACT/1685-2022"), Some("views"), __scope, false) } getOrElse {Nil},
        __obj.fieldAccessPolicyDefinitions map { IPXACT2022scalaxb.toXML[IPXACT2022ScalaCases.FieldAccessPolicyDefinitions](_, Some("http://www.accellera.org/XMLSchema/IPXACT/1685-2022"), Some("fieldAccessPolicyDefinitions"), __scope, false) } getOrElse {Nil},
        __obj.enumerationDefinitions map { IPXACT2022scalaxb.toXML[IPXACT2022ScalaCases.EnumerationDefinitions](_, Some("http://www.accellera.org/XMLSchema/IPXACT/1685-2022"), Some("enumerationDefinitions"), __scope, false) } getOrElse {Nil},
        __obj.fieldDefinitions map { IPXACT2022scalaxb.toXML[IPXACT2022ScalaCases.FieldDefinitions](_, Some("http://www.accellera.org/XMLSchema/IPXACT/1685-2022"), Some("fieldDefinitions"), __scope, false) } getOrElse {Nil},
        __obj.registerDefinitions map { IPXACT2022scalaxb.toXML[IPXACT2022ScalaCases.RegisterDefinitions](_, Some("http://www.accellera.org/XMLSchema/IPXACT/1685-2022"), Some("registerDefinitions"), __scope, false) } getOrElse {Nil},
        __obj.registerFileDefinitions map { IPXACT2022scalaxb.toXML[IPXACT2022ScalaCases.RegisterFileDefinitions](_, Some("http://www.accellera.org/XMLSchema/IPXACT/1685-2022"), Some("registerFileDefinitions"), __scope, false) } getOrElse {Nil},
        __obj.addressBlockDefinitions map { IPXACT2022scalaxb.toXML[IPXACT2022ScalaCases.AddressBlockDefinitions](_, Some("http://www.accellera.org/XMLSchema/IPXACT/1685-2022"), Some("addressBlockDefinitions"), __scope, false) } getOrElse {Nil},
        __obj.bankDefinitions map { IPXACT2022scalaxb.toXML[IPXACT2022ScalaCases.BankDefinitions](_, Some("http://www.accellera.org/XMLSchema/IPXACT/1685-2022"), Some("bankDefinitions"), __scope, false) } getOrElse {Nil},
        __obj.memoryMapDefinitions map { IPXACT2022scalaxb.toXML[IPXACT2022ScalaCases.MemoryMapDefinitions](_, Some("http://www.accellera.org/XMLSchema/IPXACT/1685-2022"), Some("memoryMapDefinitions"), __scope, false) } getOrElse {Nil},
        __obj.memoryRemapDefinitions map { IPXACT2022scalaxb.toXML[IPXACT2022ScalaCases.MemoryRemapDefinitions](_, Some("http://www.accellera.org/XMLSchema/IPXACT/1685-2022"), Some("memoryRemapDefinitions"), __scope, false) } getOrElse {Nil},
        __obj.resetTypes map { IPXACT2022scalaxb.toXML[IPXACT2022ScalaCases.ResetTypes2](_, Some("http://www.accellera.org/XMLSchema/IPXACT/1685-2022"), Some("resetTypes"), __scope, false) } getOrElse {Nil},
        __obj.choices map { IPXACT2022scalaxb.toXML[IPXACT2022ScalaCases.Choices](_, Some("http://www.accellera.org/XMLSchema/IPXACT/1685-2022"), Some("choices"), __scope, false) } getOrElse {Nil},
        __obj.parameters map { IPXACT2022scalaxb.toXML[IPXACT2022ScalaCases.Parameters](_, Some("http://www.accellera.org/XMLSchema/IPXACT/1685-2022"), Some("parameters"), __scope, false) } getOrElse {Nil},
        __obj.assertions map { IPXACT2022scalaxb.toXML[IPXACT2022ScalaCases.Assertions](_, Some("http://www.accellera.org/XMLSchema/IPXACT/1685-2022"), Some("assertions"), __scope, false) } getOrElse {Nil},
        __obj.vendorExtensions map { IPXACT2022scalaxb.toXML[IPXACT2022ScalaCases.VendorExtensions](_, Some("http://www.accellera.org/XMLSchema/IPXACT/1685-2022"), Some("vendorExtensions"), __scope, false) } getOrElse {Nil})


  }


}


package IPXACT2009ScalaCases

// Generated by <a href="http://IPXACT2009scalaxb.org/">IPXACT2009scalaxb</a>.


import scala.concurrent.{ExecutionContext, Future}


/**
usage:
val obj = IPXACT2009scalaxb.fromXML[.Foo](node)
val document = IPXACT2009scalaxb.toXML[.Foo](obj, "foo", .defaultScope)
**/
object `package` extends XMLProtocol { }

trait XMLProtocol extends IPXACT2009scalaxb.XMLStandardTypes {
  val defaultScope = IPXACT2009scalaxb.toScope(Some("spirit") -> "http://www.spiritconsortium.org/XMLSchema/SPIRIT/1685-2009",
    Some("spirit") -> "http://www.spiritconsortium.org/XMLSchema/SPIRIT/1685-2009",
    Some("xs") -> "http://www.w3.org/2001/XMLSchema",
    Some("xsi") -> "http://www.w3.org/2001/XMLSchema-instance")
  implicit lazy val _PresenceFormat: IPXACT2009scalaxb.XMLFormat[Presence] = new Default_PresenceFormat {}
  implicit lazy val _InitiativeFormat: IPXACT2009scalaxb.XMLFormat[Initiative] = new Default_InitiativeFormat {}
  implicit lazy val _TypeNameFormat: IPXACT2009scalaxb.XMLFormat[TypeName] = new Default_TypeNameFormat {}
  implicit lazy val _ServiceTypeFormat: IPXACT2009scalaxb.XMLFormat[ServiceType] = new Default_ServiceTypeFormat {}
  implicit lazy val _DirectionFormat: IPXACT2009scalaxb.XMLFormat[Direction] = new Default_DirectionFormat {}
  implicit lazy val _QualifierFormat: IPXACT2009scalaxb.XMLFormat[Qualifier] = new Default_QualifierFormat {}
  implicit lazy val _QualifierSequence1Format: IPXACT2009scalaxb.XMLFormat[QualifierSequence1] = new Default_QualifierSequence1Format {}
  implicit lazy val _OnSystemFormat: IPXACT2009scalaxb.XMLFormat[OnSystem] = new Default_OnSystemFormat {}
  implicit lazy val _OnMasterFormat: IPXACT2009scalaxb.XMLFormat[OnMaster] = new Default_OnMasterFormat {}
  implicit lazy val _OnSlaveFormat: IPXACT2009scalaxb.XMLFormat[OnSlave] = new Default_OnSlaveFormat {}
  implicit lazy val _WireFormat: IPXACT2009scalaxb.XMLFormat[Wire] = new Default_WireFormat {}
  implicit lazy val _Qualifier2Format: IPXACT2009scalaxb.XMLFormat[Qualifier2] = new Default_Qualifier2Format {}
  implicit lazy val _OnSystem2Format: IPXACT2009scalaxb.XMLFormat[OnSystem2] = new Default_OnSystem2Format {}
  implicit lazy val _OnMaster2Format: IPXACT2009scalaxb.XMLFormat[OnMaster2] = new Default_OnMaster2Format {}
  implicit lazy val _OnSlave2Format: IPXACT2009scalaxb.XMLFormat[OnSlave2] = new Default_OnSlave2Format {}
  implicit lazy val _TransactionalFormat: IPXACT2009scalaxb.XMLFormat[Transactional] = new Default_TransactionalFormat {}
  implicit lazy val _PortFormat: IPXACT2009scalaxb.XMLFormat[Port] = new Default_PortFormat {}
  implicit lazy val _Ports3Format: IPXACT2009scalaxb.XMLFormat[Ports3] = new Default_Ports3Format {}
  implicit lazy val _AbstractionDefinitionFormat: IPXACT2009scalaxb.XMLFormat[AbstractionDefinition] = new Default_AbstractionDefinitionFormat {}
  implicit lazy val _WirePortSequenceFormat: IPXACT2009scalaxb.XMLFormat[WirePortSequence] = new Default_WirePortSequenceFormat {}
  implicit lazy val _WirePortSequence2Format: IPXACT2009scalaxb.XMLFormat[WirePortSequence2] = new Default_WirePortSequence2Format {}
  implicit lazy val _TransactionalPortSequenceFormat: IPXACT2009scalaxb.XMLFormat[TransactionalPortSequence] = new Default_TransactionalPortSequenceFormat {}
  implicit lazy val _AbstractorModeFormat: IPXACT2009scalaxb.XMLFormat[AbstractorMode] = new Default_AbstractorModeFormat {}
  implicit lazy val _AbstractorInterfacesFormat: IPXACT2009scalaxb.XMLFormat[AbstractorInterfaces] = new Default_AbstractorInterfacesFormat {}
  implicit lazy val _AbstractorTypeFormat: IPXACT2009scalaxb.XMLFormat[AbstractorType] = new Default_AbstractorTypeFormat {}
  implicit lazy val _AbstractorModeTypeFormat: IPXACT2009scalaxb.XMLFormat[AbstractorModeType] = new Default_AbstractorModeTypeFormat {}
  implicit lazy val _FormatTypeFormat: IPXACT2009scalaxb.XMLFormat[FormatType] = new Default_FormatTypeFormat {}
  implicit lazy val _RangeTypeTypeFormat: IPXACT2009scalaxb.XMLFormat[RangeTypeType] = new Default_RangeTypeTypeFormat {}
  implicit lazy val _DelayValueUnitTypeFormat: IPXACT2009scalaxb.XMLFormat[DelayValueUnitType] = new Default_DelayValueUnitTypeFormat {}
  implicit lazy val _EnumerationFormat: IPXACT2009scalaxb.XMLFormat[Enumeration] = new Default_EnumerationFormat {}
  implicit lazy val _ChoiceFormat: IPXACT2009scalaxb.XMLFormat[Choice] = new Default_ChoiceFormat {}
  implicit lazy val _ChoicesFormat: IPXACT2009scalaxb.XMLFormat[Choices] = new Default_ChoicesFormat {}
  implicit lazy val _Commonu46attFormat: IPXACT2009scalaxb.AttributeGroupFormat[Commonu46att] = new Default_Commonu46attFormat {}
  implicit lazy val _Stringu46attFormat: IPXACT2009scalaxb.AttributeGroupFormat[Stringu46att] = new Default_Stringu46attFormat {}
  implicit lazy val _Longu46attFormat: IPXACT2009scalaxb.AttributeGroupFormat[Longu46att] = new Default_Longu46attFormat {}
  implicit lazy val _Floatu46attFormat: IPXACT2009scalaxb.AttributeGroupFormat[Floatu46att] = new Default_Floatu46attFormat {}
  implicit lazy val _Boolu46attFormat: IPXACT2009scalaxb.AttributeGroupFormat[Boolu46att] = new Default_Boolu46attFormat {}
  implicit lazy val _Boolu46promptu46attFormat: IPXACT2009scalaxb.AttributeGroupFormat[Boolu46promptu46att] = new Default_Boolu46promptu46attFormat {}
  implicit lazy val _Floatu46promptu46attFormat: IPXACT2009scalaxb.AttributeGroupFormat[Floatu46promptu46att] = new Default_Floatu46promptu46attFormat {}
  implicit lazy val _Longu46promptu46attFormat: IPXACT2009scalaxb.AttributeGroupFormat[Longu46promptu46att] = new Default_Longu46promptu46attFormat {}
  implicit lazy val _Stringu46promptu46attFormat: IPXACT2009scalaxb.AttributeGroupFormat[Stringu46promptu46att] = new Default_Stringu46promptu46attFormat {}
  implicit lazy val _SystemGroupNamesFormat: IPXACT2009scalaxb.XMLFormat[SystemGroupNames] = new Default_SystemGroupNamesFormat {}
  implicit lazy val _BusDefinitionFormat: IPXACT2009scalaxb.XMLFormat[BusDefinition] = new Default_BusDefinitionFormat {}
  implicit lazy val _BitSteeringTypeFormat: IPXACT2009scalaxb.XMLFormat[BitSteeringType] = new Default_BitSteeringTypeFormat {}
  implicit lazy val _EndianessTypeFormat: IPXACT2009scalaxb.XMLFormat[EndianessType] = new Default_EndianessTypeFormat {}
  implicit lazy val _BusInterfacesFormat: IPXACT2009scalaxb.XMLFormat[BusInterfaces] = new Default_BusInterfacesFormat {}
  implicit lazy val _LeftTypeFormat: IPXACT2009scalaxb.XMLFormat[LeftType] = new Default_LeftTypeFormat {}
  implicit lazy val _RightTypeFormat: IPXACT2009scalaxb.XMLFormat[RightType] = new Default_RightTypeFormat {}
  implicit lazy val _VectorFormat: IPXACT2009scalaxb.XMLFormat[Vector] = new Default_VectorFormat {}
  implicit lazy val _LogicalPortFormat: IPXACT2009scalaxb.XMLFormat[LogicalPort] = new Default_LogicalPortFormat {}
  implicit lazy val _PhysicalPortFormat: IPXACT2009scalaxb.XMLFormat[PhysicalPort] = new Default_PhysicalPortFormat {}
  implicit lazy val _PortMapFormat: IPXACT2009scalaxb.XMLFormat[PortMap] = new Default_PortMapFormat {}
  implicit lazy val _PortMapsFormat: IPXACT2009scalaxb.XMLFormat[PortMaps] = new Default_PortMapsFormat {}
  implicit lazy val _BitSteeringFormat: IPXACT2009scalaxb.XMLFormat[BitSteering] = new Default_BitSteeringFormat {}
  implicit lazy val _BusInterfaceTypeFormat: IPXACT2009scalaxb.XMLFormat[BusInterfaceType] = new Default_BusInterfaceTypeFormat {}
  implicit lazy val _ChannelFormat: IPXACT2009scalaxb.XMLFormat[Channel] = new Default_ChannelFormat {}
  implicit lazy val _ChannelsFormat: IPXACT2009scalaxb.XMLFormat[Channels] = new Default_ChannelsFormat {}
  implicit lazy val _RemapPortFormat: IPXACT2009scalaxb.XMLFormat[RemapPort] = new Default_RemapPortFormat {}
  implicit lazy val _RemapPortsFormat: IPXACT2009scalaxb.XMLFormat[RemapPorts] = new Default_RemapPortsFormat {}
  implicit lazy val _RemapStateFormat: IPXACT2009scalaxb.XMLFormat[RemapState] = new Default_RemapStateFormat {}
  implicit lazy val _RemapStatesFormat: IPXACT2009scalaxb.XMLFormat[RemapStates] = new Default_RemapStatesFormat {}
  implicit lazy val _BaseAddressFormat: IPXACT2009scalaxb.XMLFormat[BaseAddress] = new Default_BaseAddressFormat {}
  implicit lazy val _AddressSpaceRefFormat: IPXACT2009scalaxb.XMLFormat[AddressSpaceRef] = new Default_AddressSpaceRefFormat {}
  implicit lazy val _MasterFormat: IPXACT2009scalaxb.XMLFormat[Master] = new Default_MasterFormat {}
  implicit lazy val _BridgeFormat: IPXACT2009scalaxb.XMLFormat[Bridge] = new Default_BridgeFormat {}
  implicit lazy val _FileSetRefGroup2Format: IPXACT2009scalaxb.XMLFormat[FileSetRefGroup2] = new Default_FileSetRefGroup2Format {}
  implicit lazy val _SlaveFormat: IPXACT2009scalaxb.XMLFormat[Slave] = new Default_SlaveFormat {}
  implicit lazy val _SystemFormat: IPXACT2009scalaxb.XMLFormat[System] = new Default_SystemFormat {}
  implicit lazy val _RemapAddressFormat: IPXACT2009scalaxb.XMLFormat[RemapAddress] = new Default_RemapAddressFormat {}
  implicit lazy val _RangeTypeFormat: IPXACT2009scalaxb.XMLFormat[RangeType] = new Default_RangeTypeFormat {}
  implicit lazy val _BaseAddressesFormat: IPXACT2009scalaxb.XMLFormat[BaseAddresses] = new Default_BaseAddressesFormat {}
  implicit lazy val _MirroredSlaveFormat: IPXACT2009scalaxb.XMLFormat[MirroredSlave] = new Default_MirroredSlaveFormat {}
  implicit lazy val _MirroredSlaveSequence1Format: IPXACT2009scalaxb.XMLFormat[MirroredSlaveSequence1] = new Default_MirroredSlaveSequence1Format {}
  implicit lazy val _MirroredMasterFormat: IPXACT2009scalaxb.XMLFormat[MirroredMaster] = new Default_MirroredMasterFormat {}
  implicit lazy val _MirroredSystemFormat: IPXACT2009scalaxb.XMLFormat[MirroredSystem] = new Default_MirroredSystemFormat {}
  implicit lazy val _InterfaceModeFormat: IPXACT2009scalaxb.XMLFormat[InterfaceMode] = new Default_InterfaceModeFormat {}
  implicit lazy val _MonitorFormat: IPXACT2009scalaxb.XMLFormat[Monitor] = new Default_MonitorFormat {}
  implicit lazy val _Master2Format: IPXACT2009scalaxb.XMLFormat[Master2] = new Default_Master2Format {}
  implicit lazy val _Slave2Format: IPXACT2009scalaxb.XMLFormat[Slave2] = new Default_Slave2Format {}
  implicit lazy val _System2Format: IPXACT2009scalaxb.XMLFormat[System2] = new Default_System2Format {}
  implicit lazy val _MirroredSlave2Format: IPXACT2009scalaxb.XMLFormat[MirroredSlave2] = new Default_MirroredSlave2Format {}
  implicit lazy val _MirroredMaster2Format: IPXACT2009scalaxb.XMLFormat[MirroredMaster2] = new Default_MirroredMaster2Format {}
  implicit lazy val _MirroredSystem2Format: IPXACT2009scalaxb.XMLFormat[MirroredSystem2] = new Default_MirroredSystem2Format {}
  implicit lazy val _LeftType2Format: IPXACT2009scalaxb.XMLFormat[LeftType2] = new Default_LeftType2Format {}
  implicit lazy val _RightType2Format: IPXACT2009scalaxb.XMLFormat[RightType2] = new Default_RightType2Format {}
  implicit lazy val _Vector2Format: IPXACT2009scalaxb.XMLFormat[Vector2] = new Default_Vector2Format {}
  implicit lazy val _LogicalPort2Format: IPXACT2009scalaxb.XMLFormat[LogicalPort2] = new Default_LogicalPort2Format {}
  implicit lazy val _PhysicalPort2Format: IPXACT2009scalaxb.XMLFormat[PhysicalPort2] = new Default_PhysicalPort2Format {}
  implicit lazy val _PortMap2Format: IPXACT2009scalaxb.XMLFormat[PortMap2] = new Default_PortMap2Format {}
  implicit lazy val _PortMaps2Format: IPXACT2009scalaxb.XMLFormat[PortMaps2] = new Default_PortMaps2Format {}
  implicit lazy val _AbstractorBusInterfaceTypeFormat: IPXACT2009scalaxb.XMLFormat[AbstractorBusInterfaceType] = new Default_AbstractorBusInterfaceTypeFormat {}
  implicit lazy val _UsageTypeTypeFormat: IPXACT2009scalaxb.XMLFormat[UsageTypeType] = new Default_UsageTypeTypeFormat {}
  implicit lazy val _NameValueTypeTypeFormat: IPXACT2009scalaxb.XMLFormat[NameValueTypeType] = new Default_NameValueTypeTypeFormat {}
  implicit lazy val _ParametersFormat: IPXACT2009scalaxb.XMLFormat[Parameters] = new Default_ParametersFormat {}
  implicit lazy val _VendorExtensionsFormat: IPXACT2009scalaxb.XMLFormat[VendorExtensions] = new Default_VendorExtensionsFormat {}
  implicit lazy val _ValueFormat: IPXACT2009scalaxb.XMLFormat[Value] = new Default_ValueFormat {}
  implicit lazy val _NameValuePairTypableFormat: IPXACT2009scalaxb.XMLFormat[NameValuePairTypable] = new Default_NameValuePairTypableFormat {}
  implicit lazy val _NameValuePairTypeFormat: IPXACT2009scalaxb.XMLFormat[NameValuePairType] = new Default_NameValuePairTypeFormat {}
  implicit lazy val _NameGroupStringSequenceFormat: IPXACT2009scalaxb.XMLFormat[NameGroupStringSequence] = new Default_NameGroupStringSequenceFormat {}
  implicit lazy val _NameGroupNMTOKENSequenceFormat: IPXACT2009scalaxb.XMLFormat[NameGroupNMTOKENSequence] = new Default_NameGroupNMTOKENSequenceFormat {}
  implicit lazy val _NameGroupSequenceFormat: IPXACT2009scalaxb.XMLFormat[NameGroupSequence] = new Default_NameGroupSequenceFormat {}
  implicit lazy val _NameGroupOptionalSequenceFormat: IPXACT2009scalaxb.XMLFormat[NameGroupOptionalSequence] = new Default_NameGroupOptionalSequenceFormat {}
  implicit lazy val _NameGroupPortSequenceFormat: IPXACT2009scalaxb.XMLFormat[NameGroupPortSequence] = new Default_NameGroupPortSequenceFormat {}
  implicit lazy val _WhiteboxElementsFormat: IPXACT2009scalaxb.XMLFormat[WhiteboxElements] = new Default_WhiteboxElementsFormat {}
  implicit lazy val _CpuFormat: IPXACT2009scalaxb.XMLFormat[Cpu] = new Default_CpuFormat {}
  implicit lazy val _CpusFormat: IPXACT2009scalaxb.XMLFormat[Cpus] = new Default_CpusFormat {}
  implicit lazy val _ComponentTypeFormat: IPXACT2009scalaxb.XMLFormat[ComponentType] = new Default_ComponentTypeFormat {}
  implicit lazy val _WhiteboxTypeFormat: IPXACT2009scalaxb.XMLFormat[WhiteboxType] = new Default_WhiteboxTypeFormat {}
  implicit lazy val _WhiteboxElementTypeFormat: IPXACT2009scalaxb.XMLFormat[WhiteboxElementType] = new Default_WhiteboxElementTypeFormat {}
  implicit lazy val _ResolveTypeFormat: IPXACT2009scalaxb.XMLFormat[ResolveType] = new Default_ResolveTypeFormat {}
  implicit lazy val _ConfigurableFormat: IPXACT2009scalaxb.AttributeGroupFormat[Configurable] = new Default_ConfigurableFormat {}
  implicit lazy val _CellFunctionValueTypeFormat: IPXACT2009scalaxb.XMLFormat[CellFunctionValueType] = new Default_CellFunctionValueTypeFormat {}
  implicit lazy val _CellClassValueTypeFormat: IPXACT2009scalaxb.XMLFormat[CellClassValueType] = new Default_CellClassValueTypeFormat {}
  implicit lazy val _CellStrengthValueTypeFormat: IPXACT2009scalaxb.XMLFormat[CellStrengthValueType] = new Default_CellStrengthValueTypeFormat {}
  implicit lazy val _EdgeValueTypeFormat: IPXACT2009scalaxb.XMLFormat[EdgeValueType] = new Default_EdgeValueTypeFormat {}
  implicit lazy val _DelayValueTypeFormat: IPXACT2009scalaxb.XMLFormat[DelayValueType] = new Default_DelayValueTypeFormat {}
  implicit lazy val _OtherClocksFormat: IPXACT2009scalaxb.XMLFormat[OtherClocks] = new Default_OtherClocksFormat {}
  implicit lazy val _CellFunctionFormat: IPXACT2009scalaxb.XMLFormat[CellFunction] = new Default_CellFunctionFormat {}
  implicit lazy val _CellClassFormat: IPXACT2009scalaxb.XMLFormat[CellClass] = new Default_CellClassFormat {}
  implicit lazy val _CellSpecificationFormat: IPXACT2009scalaxb.XMLFormat[CellSpecification] = new Default_CellSpecificationFormat {}
  implicit lazy val _TimingConstraintFormat: IPXACT2009scalaxb.XMLFormat[TimingConstraint] = new Default_TimingConstraintFormat {}
  implicit lazy val _DriveConstraintFormat: IPXACT2009scalaxb.XMLFormat[DriveConstraint] = new Default_DriveConstraintFormat {}
  implicit lazy val _LoadConstraintFormat: IPXACT2009scalaxb.XMLFormat[LoadConstraint] = new Default_LoadConstraintFormat {}
  implicit lazy val _LeftType3Format: IPXACT2009scalaxb.XMLFormat[LeftType3] = new Default_LeftType3Format {}
  implicit lazy val _RightType3Format: IPXACT2009scalaxb.XMLFormat[RightType3] = new Default_RightType3Format {}
  implicit lazy val _Vector3Format: IPXACT2009scalaxb.XMLFormat[Vector3] = new Default_Vector3Format {}
  implicit lazy val _ConstraintSetFormat: IPXACT2009scalaxb.XMLFormat[ConstraintSet] = new Default_ConstraintSetFormat {}
  implicit lazy val _ConstraintSetsFormat: IPXACT2009scalaxb.XMLFormat[ConstraintSets] = new Default_ConstraintSetsFormat {}
  implicit lazy val _AbstractionDefPortConstraintsTypeFormat: IPXACT2009scalaxb.XMLFormat[AbstractionDefPortConstraintsType] = new Default_AbstractionDefPortConstraintsTypeFormat {}
  implicit lazy val _AbstractionDefPortConstraintsTypeSequence3Format: IPXACT2009scalaxb.XMLFormat[AbstractionDefPortConstraintsTypeSequence3] = new Default_AbstractionDefPortConstraintsTypeSequence3Format {}
  implicit lazy val _AbstractionDefPortConstraintsTypeSequence2Format: IPXACT2009scalaxb.XMLFormat[AbstractionDefPortConstraintsTypeSequence2] = new Default_AbstractionDefPortConstraintsTypeSequence2Format {}
  implicit lazy val _AbstractionDefPortConstraintsTypeSequence1Format: IPXACT2009scalaxb.XMLFormat[AbstractionDefPortConstraintsTypeSequence1] = new Default_AbstractionDefPortConstraintsTypeSequence1Format {}
  implicit lazy val _HierConnectionFormat: IPXACT2009scalaxb.XMLFormat[HierConnection] = new Default_HierConnectionFormat {}
  implicit lazy val _HierConnectionsFormat: IPXACT2009scalaxb.XMLFormat[HierConnections] = new Default_HierConnectionsFormat {}
  implicit lazy val _DesignFormat: IPXACT2009scalaxb.XMLFormat[Design] = new Default_DesignFormat {}
  implicit lazy val _GeneratorChainConfigurationFormat: IPXACT2009scalaxb.XMLFormat[GeneratorChainConfiguration] = new Default_GeneratorChainConfigurationFormat {}
  implicit lazy val _AbstractorFormat: IPXACT2009scalaxb.XMLFormat[Abstractor] = new Default_AbstractorFormat {}
  implicit lazy val _AbstractorsFormat: IPXACT2009scalaxb.XMLFormat[Abstractors] = new Default_AbstractorsFormat {}
  implicit lazy val _InterconnectionConfigurationFormat: IPXACT2009scalaxb.XMLFormat[InterconnectionConfiguration] = new Default_InterconnectionConfigurationFormat {}
  implicit lazy val _ViewConfigurationFormat: IPXACT2009scalaxb.XMLFormat[ViewConfiguration] = new Default_ViewConfigurationFormat {}
  implicit lazy val _DesignConfigurationFormat: IPXACT2009scalaxb.XMLFormat[DesignConfiguration] = new Default_DesignConfigurationFormat {}
  implicit lazy val _NameFormat: IPXACT2009scalaxb.XMLFormat[Name] = new Default_NameFormat {}
  implicit lazy val _IsIncludeFileFormat: IPXACT2009scalaxb.XMLFormat[IsIncludeFile] = new Default_IsIncludeFileFormat {}
  implicit lazy val _LogicalNameFormat: IPXACT2009scalaxb.XMLFormat[LogicalName] = new Default_LogicalNameFormat {}
  implicit lazy val _CommandFormat: IPXACT2009scalaxb.XMLFormat[Command] = new Default_CommandFormat {}
  implicit lazy val _FlagsFormat: IPXACT2009scalaxb.XMLFormat[Flags] = new Default_FlagsFormat {}
  implicit lazy val _ReplaceDefaultFlagsFormat: IPXACT2009scalaxb.XMLFormat[ReplaceDefaultFlags] = new Default_ReplaceDefaultFlagsFormat {}
  implicit lazy val _TargetNameFormat: IPXACT2009scalaxb.XMLFormat[TargetName] = new Default_TargetNameFormat {}
  implicit lazy val _BuildCommandFormat: IPXACT2009scalaxb.XMLFormat[BuildCommand] = new Default_BuildCommandFormat {}
  implicit lazy val _FileFormat: IPXACT2009scalaxb.XMLFormat[File] = new Default_FileFormat {}
  implicit lazy val _FileSequence1Format: IPXACT2009scalaxb.XMLFormat[FileSequence1] = new Default_FileSequence1Format {}
  implicit lazy val _Name2Format: IPXACT2009scalaxb.XMLFormat[Name2] = new Default_Name2Format {}
  implicit lazy val _Command2Format: IPXACT2009scalaxb.XMLFormat[Command2] = new Default_Command2Format {}
  implicit lazy val _Flags2Format: IPXACT2009scalaxb.XMLFormat[Flags2] = new Default_Flags2Format {}
  implicit lazy val _ReplaceDefaultFlags2Format: IPXACT2009scalaxb.XMLFormat[ReplaceDefaultFlags2] = new Default_ReplaceDefaultFlags2Format {}
  implicit lazy val _FileBuilderFormat: IPXACT2009scalaxb.XMLFormat[FileBuilder] = new Default_FileBuilderFormat {}
  implicit lazy val _LinkerFormat: IPXACT2009scalaxb.XMLFormat[Linker] = new Default_LinkerFormat {}
  implicit lazy val _LinkerFlagsFormat: IPXACT2009scalaxb.XMLFormat[LinkerFlags] = new Default_LinkerFlagsFormat {}
  implicit lazy val _Name3Format: IPXACT2009scalaxb.XMLFormat[Name3] = new Default_Name3Format {}
  implicit lazy val _CommandLineSwitchFormat: IPXACT2009scalaxb.XMLFormat[CommandLineSwitch] = new Default_CommandLineSwitchFormat {}
  implicit lazy val _EnableFormat: IPXACT2009scalaxb.XMLFormat[Enable] = new Default_EnableFormat {}
  implicit lazy val _LinkerCommandFileFormat: IPXACT2009scalaxb.XMLFormat[LinkerCommandFile] = new Default_LinkerCommandFileFormat {}
  implicit lazy val _LanguageToolsFormat: IPXACT2009scalaxb.XMLFormat[LanguageTools] = new Default_LanguageToolsFormat {}
  implicit lazy val _FileSetRefGroupFormat: IPXACT2009scalaxb.XMLFormat[FileSetRefGroup] = new Default_FileSetRefGroupFormat {}
  implicit lazy val _ExecutableImageFormat: IPXACT2009scalaxb.XMLFormat[ExecutableImage] = new Default_ExecutableImageFormat {}
  implicit lazy val _FileSetRefFormat: IPXACT2009scalaxb.XMLFormat[FileSetRef] = new Default_FileSetRefFormat {}
  implicit lazy val _FileSetsFormat: IPXACT2009scalaxb.XMLFormat[FileSets] = new Default_FileSetsFormat {}
  implicit lazy val _Command3Format: IPXACT2009scalaxb.XMLFormat[Command3] = new Default_Command3Format {}
  implicit lazy val _Flags3Format: IPXACT2009scalaxb.XMLFormat[Flags3] = new Default_Flags3Format {}
  implicit lazy val _ReplaceDefaultFlags3Format: IPXACT2009scalaxb.XMLFormat[ReplaceDefaultFlags3] = new Default_ReplaceDefaultFlags3Format {}
  implicit lazy val _FileBuilderTypeFormat: IPXACT2009scalaxb.XMLFormat[FileBuilderType] = new Default_FileBuilderTypeFormat {}
  implicit lazy val _ReturnTypeFormat: IPXACT2009scalaxb.XMLFormat[ReturnType] = new Default_ReturnTypeFormat {}
  implicit lazy val _ArgumentFormat: IPXACT2009scalaxb.XMLFormat[Argument] = new Default_ArgumentFormat {}
  implicit lazy val _DisabledFormat: IPXACT2009scalaxb.XMLFormat[Disabled] = new Default_DisabledFormat {}
  implicit lazy val _SourceNameFormat: IPXACT2009scalaxb.XMLFormat[SourceName] = new Default_SourceNameFormat {}
  implicit lazy val _SourceFileFormat: IPXACT2009scalaxb.XMLFormat[SourceFile] = new Default_SourceFileFormat {}
  implicit lazy val _FunctionTypeFormat: IPXACT2009scalaxb.XMLFormat[FunctionType] = new Default_FunctionTypeFormat {}
  implicit lazy val _FileSetTypeFormat: IPXACT2009scalaxb.XMLFormat[FileSetType] = new Default_FileSetTypeFormat {}
  implicit lazy val _DataTypeTypeFormat: IPXACT2009scalaxb.XMLFormat[DataTypeType] = new Default_DataTypeTypeFormat {}
  implicit lazy val _FileTypeFormat: IPXACT2009scalaxb.XMLFormat[FileType] = new Default_FileTypeFormat {}
  implicit lazy val _GeneratorChainSelectorFormat: IPXACT2009scalaxb.XMLFormat[GeneratorChainSelector] = new Default_GeneratorChainSelectorFormat {}
  implicit lazy val _GeneratorChainFormat: IPXACT2009scalaxb.XMLFormat[GeneratorChain] = new Default_GeneratorChainFormat {}
  implicit lazy val _GeneratorFormat: IPXACT2009scalaxb.XMLFormat[Generator] = new Default_GeneratorFormat {}
  implicit lazy val _ComponentGeneratorFormat: IPXACT2009scalaxb.XMLFormat[ComponentGenerator] = new Default_ComponentGeneratorFormat {}
  implicit lazy val _MultipleGroupSelectionOperatorFormat: IPXACT2009scalaxb.XMLFormat[MultipleGroupSelectionOperator] = new Default_MultipleGroupSelectionOperatorFormat {}
  implicit lazy val _GroupSelectorFormat: IPXACT2009scalaxb.XMLFormat[GroupSelector] = new Default_GroupSelectorFormat {}
  implicit lazy val _PhaseFormat: IPXACT2009scalaxb.XMLFormat[Phase] = new Default_PhaseFormat {}
  implicit lazy val _ScopeFormat: IPXACT2009scalaxb.XMLFormat[Scope] = new Default_ScopeFormat {}
  implicit lazy val _InstanceGeneratorTypableFormat: IPXACT2009scalaxb.XMLFormat[InstanceGeneratorTypable] = new Default_InstanceGeneratorTypableFormat {}
  implicit lazy val _InstanceGeneratorTypeFormat: IPXACT2009scalaxb.XMLFormat[InstanceGeneratorType] = new Default_InstanceGeneratorTypeFormat {}
  implicit lazy val _GeneratorSelectorTypeFormat: IPXACT2009scalaxb.XMLFormat[GeneratorSelectorType] = new Default_GeneratorSelectorTypeFormat {}
  implicit lazy val _ComponentGeneratorsFormat: IPXACT2009scalaxb.XMLFormat[ComponentGenerators] = new Default_ComponentGeneratorsFormat {}
  implicit lazy val _AbstractorGeneratorsFormat: IPXACT2009scalaxb.XMLFormat[AbstractorGenerators] = new Default_AbstractorGeneratorsFormat {}
  implicit lazy val _ApiTypeFormat: IPXACT2009scalaxb.XMLFormat[ApiType] = new Default_ApiTypeFormat {}
  implicit lazy val _TransportMethodFormat: IPXACT2009scalaxb.XMLFormat[TransportMethod] = new Default_TransportMethodFormat {}
  implicit lazy val _TransportMethodsFormat: IPXACT2009scalaxb.XMLFormat[TransportMethods] = new Default_TransportMethodsFormat {}
  implicit lazy val _GeneratorTypableFormat: IPXACT2009scalaxb.XMLFormat[GeneratorTypable] = new Default_GeneratorTypableFormat {}
  implicit lazy val _GeneratorTypeFormat: IPXACT2009scalaxb.XMLFormat[GeneratorType] = new Default_GeneratorTypeFormat {}
  implicit lazy val _LibraryRefTypeFormat: IPXACT2009scalaxb.XMLFormat[LibraryRefType] = new Default_LibraryRefTypeFormat {}
  implicit lazy val _ResolvedLibraryRefTypeFormat: IPXACT2009scalaxb.XMLFormat[ResolvedLibraryRefType] = new Default_ResolvedLibraryRefTypeFormat {}
  implicit lazy val _VersionedIdentifierSequenceFormat: IPXACT2009scalaxb.XMLFormat[VersionedIdentifierSequence] = new Default_VersionedIdentifierSequenceFormat {}
  implicit lazy val _BaseIdentifierSequenceFormat: IPXACT2009scalaxb.XMLFormat[BaseIdentifierSequence] = new Default_BaseIdentifierSequenceFormat {}
  implicit lazy val _LibraryRefGroupFormat: IPXACT2009scalaxb.AttributeGroupFormat[LibraryRefGroup] = new Default_LibraryRefGroupFormat {}
  implicit lazy val _AccessTypeFormat: IPXACT2009scalaxb.XMLFormat[AccessType] = new Default_AccessTypeFormat {}
  implicit lazy val _BankAlignmentTypeFormat: IPXACT2009scalaxb.XMLFormat[BankAlignmentType] = new Default_BankAlignmentTypeFormat {}
  implicit lazy val _UsageTypeFormat: IPXACT2009scalaxb.XMLFormat[UsageType] = new Default_UsageTypeFormat {}
  implicit lazy val _AddressBankTypeFormat: IPXACT2009scalaxb.XMLFormat[AddressBankType] = new Default_AddressBankTypeFormat {}
  implicit lazy val _AddressBlockTypeFormat: IPXACT2009scalaxb.XMLFormat[AddressBlockType] = new Default_AddressBlockTypeFormat {}
  implicit lazy val _AddrSpaceRefTypableFormat: IPXACT2009scalaxb.XMLFormat[AddrSpaceRefTypable] = new Default_AddrSpaceRefTypableFormat {}
  implicit lazy val _AddrSpaceRefTypeFormat: IPXACT2009scalaxb.XMLFormat[AddrSpaceRefType] = new Default_AddrSpaceRefTypeFormat {}
  implicit lazy val _MemoryMapRefTypeFormat: IPXACT2009scalaxb.XMLFormat[MemoryMapRefType] = new Default_MemoryMapRefTypeFormat {}
  implicit lazy val _BankedBankTypeFormat: IPXACT2009scalaxb.XMLFormat[BankedBankType] = new Default_BankedBankTypeFormat {}
  implicit lazy val _BankedBlockTypeFormat: IPXACT2009scalaxb.XMLFormat[BankedBlockType] = new Default_BankedBlockTypeFormat {}
  implicit lazy val _BankedSubspaceTypeFormat: IPXACT2009scalaxb.XMLFormat[BankedSubspaceType] = new Default_BankedSubspaceTypeFormat {}
  implicit lazy val _FieldTypeFormat: IPXACT2009scalaxb.XMLFormat[FieldType] = new Default_FieldTypeFormat {}
  implicit lazy val _MemoryMapTypeFormat: IPXACT2009scalaxb.XMLFormat[MemoryMapType] = new Default_MemoryMapTypeFormat {}
  implicit lazy val _MemoryRemapTypeFormat: IPXACT2009scalaxb.XMLFormat[MemoryRemapType] = new Default_MemoryRemapTypeFormat {}
  implicit lazy val _LocalMemoryMapTypeFormat: IPXACT2009scalaxb.XMLFormat[LocalMemoryMapType] = new Default_LocalMemoryMapTypeFormat {}
  implicit lazy val _SubspaceRefTypeFormat: IPXACT2009scalaxb.XMLFormat[SubspaceRefType] = new Default_SubspaceRefTypeFormat {}
  implicit lazy val _AddressOffsetFormat: IPXACT2009scalaxb.XMLFormat[AddressOffset] = new Default_AddressOffsetFormat {}
  implicit lazy val _RangeType2Format: IPXACT2009scalaxb.XMLFormat[RangeType2] = new Default_RangeType2Format {}
  implicit lazy val _SegmentFormat: IPXACT2009scalaxb.XMLFormat[Segment] = new Default_SegmentFormat {}
  implicit lazy val _SegmentsFormat: IPXACT2009scalaxb.XMLFormat[Segments] = new Default_SegmentsFormat {}
  implicit lazy val _AddressSpaceFormat: IPXACT2009scalaxb.XMLFormat[AddressSpace] = new Default_AddressSpaceFormat {}
  implicit lazy val _AddressSpacesFormat: IPXACT2009scalaxb.XMLFormat[AddressSpaces] = new Default_AddressSpacesFormat {}
  implicit lazy val _MemoryMapsFormat: IPXACT2009scalaxb.XMLFormat[MemoryMaps] = new Default_MemoryMapsFormat {}
  implicit lazy val _BaseAddress2Format: IPXACT2009scalaxb.XMLFormat[BaseAddress2] = new Default_BaseAddress2Format {}
  implicit lazy val _RangeType3Format: IPXACT2009scalaxb.XMLFormat[RangeType3] = new Default_RangeType3Format {}
  implicit lazy val _WidthFormat: IPXACT2009scalaxb.XMLFormat[Width] = new Default_WidthFormat {}
  implicit lazy val _AlternateGroupsFormat: IPXACT2009scalaxb.XMLFormat[AlternateGroups] = new Default_AlternateGroupsFormat {}
  implicit lazy val _AlternateRegisterFormat: IPXACT2009scalaxb.XMLFormat[AlternateRegister] = new Default_AlternateRegisterFormat {}
  implicit lazy val _AlternateRegistersFormat: IPXACT2009scalaxb.XMLFormat[AlternateRegisters] = new Default_AlternateRegistersFormat {}
  implicit lazy val _RegisterFormat: IPXACT2009scalaxb.XMLFormat[Register] = new Default_RegisterFormat {}
  implicit lazy val _UsageFormat: IPXACT2009scalaxb.XMLFormat[Usage] = new Default_UsageFormat {}
  implicit lazy val _EnumeratedValueFormat: IPXACT2009scalaxb.XMLFormat[EnumeratedValue] = new Default_EnumeratedValueFormat {}
  implicit lazy val _EnumeratedValuesFormat: IPXACT2009scalaxb.XMLFormat[EnumeratedValues] = new Default_EnumeratedValuesFormat {}
  implicit lazy val _ValueMaskConfigTypeFormat: IPXACT2009scalaxb.XMLFormat[ValueMaskConfigType] = new Default_ValueMaskConfigTypeFormat {}
  implicit lazy val _ModifiedWriteValueFormat: IPXACT2009scalaxb.XMLFormat[ModifiedWriteValue] = new Default_ModifiedWriteValueFormat {}
  implicit lazy val _ReadActionFormat: IPXACT2009scalaxb.XMLFormat[ReadAction] = new Default_ReadActionFormat {}
  implicit lazy val _TestConstraintFormat: IPXACT2009scalaxb.XMLFormat[TestConstraint] = new Default_TestConstraintFormat {}
  implicit lazy val _TestableFormat: IPXACT2009scalaxb.XMLFormat[Testable] = new Default_TestableFormat {}
  implicit lazy val _MinimumFormat: IPXACT2009scalaxb.XMLFormat[Minimum] = new Default_MinimumFormat {}
  implicit lazy val _MaximumFormat: IPXACT2009scalaxb.XMLFormat[Maximum] = new Default_MaximumFormat {}
  implicit lazy val _WriteValueConstraintTypeFormat: IPXACT2009scalaxb.XMLFormat[WriteValueConstraintType] = new Default_WriteValueConstraintTypeFormat {}
  implicit lazy val _WriteValueConstraintTypeSequence1Format: IPXACT2009scalaxb.XMLFormat[WriteValueConstraintTypeSequence1] = new Default_WriteValueConstraintTypeSequence1Format {}
  implicit lazy val _RegisterFileFormat: IPXACT2009scalaxb.XMLFormat[RegisterFile] = new Default_RegisterFileFormat {}
  implicit lazy val _BitWidthFormat: IPXACT2009scalaxb.XMLFormat[BitWidth] = new Default_BitWidthFormat {}
  implicit lazy val _RangeType4Format: IPXACT2009scalaxb.XMLFormat[RangeType4] = new Default_RangeType4Format {}
  implicit lazy val _SizeFormat: IPXACT2009scalaxb.XMLFormat[Size] = new Default_SizeFormat {}
  implicit lazy val _Value2Format: IPXACT2009scalaxb.XMLFormat[Value2] = new Default_Value2Format {}
  implicit lazy val _MaskFormat: IPXACT2009scalaxb.XMLFormat[Mask] = new Default_MaskFormat {}
  implicit lazy val _ResetFormat: IPXACT2009scalaxb.XMLFormat[Reset] = new Default_ResetFormat {}
  implicit lazy val _Value3Format: IPXACT2009scalaxb.XMLFormat[Value3] = new Default_Value3Format {}
  implicit lazy val _Mask2Format: IPXACT2009scalaxb.XMLFormat[Mask2] = new Default_Mask2Format {}
  implicit lazy val _Reset2Format: IPXACT2009scalaxb.XMLFormat[Reset2] = new Default_Reset2Format {}
  implicit lazy val _AlternateRegisterDefinitionGroupSequenceFormat: IPXACT2009scalaxb.XMLFormat[AlternateRegisterDefinitionGroupSequence] = new Default_AlternateRegisterDefinitionGroupSequenceFormat {}
  implicit lazy val _AddressBlockDefinitionGroupSequenceFormat: IPXACT2009scalaxb.XMLFormat[AddressBlockDefinitionGroupSequence] = new Default_AddressBlockDefinitionGroupSequenceFormat {}
  implicit lazy val _FieldDefinitionGroupSequenceFormat: IPXACT2009scalaxb.XMLFormat[FieldDefinitionGroupSequence] = new Default_FieldDefinitionGroupSequenceFormat {}
  implicit lazy val _RegisterDataSequenceFormat: IPXACT2009scalaxb.XMLFormat[RegisterDataSequence] = new Default_RegisterDataSequenceFormat {}
  implicit lazy val _BlockSizeSequenceFormat: IPXACT2009scalaxb.XMLFormat[BlockSizeSequence] = new Default_BlockSizeSequenceFormat {}
  implicit lazy val _AddressSpecifierSequenceFormat: IPXACT2009scalaxb.XMLFormat[AddressSpecifierSequence] = new Default_AddressSpecifierSequenceFormat {}
  implicit lazy val _AddressBlockExtensionsSequenceFormat: IPXACT2009scalaxb.XMLFormat[AddressBlockExtensionsSequence] = new Default_AddressBlockExtensionsSequenceFormat {}
  implicit lazy val _BankBaseSequenceFormat: IPXACT2009scalaxb.XMLFormat[BankBaseSequence] = new Default_BankBaseSequenceFormat {}
  implicit lazy val _MemoryBlockDataSequenceFormat: IPXACT2009scalaxb.XMLFormat[MemoryBlockDataSequence] = new Default_MemoryBlockDataSequenceFormat {}
  implicit lazy val _FieldDataSequenceFormat: IPXACT2009scalaxb.XMLFormat[FieldDataSequence] = new Default_FieldDataSequenceFormat {}
  implicit lazy val _RegisterFileDefinitionGroupSequenceFormat: IPXACT2009scalaxb.XMLFormat[RegisterFileDefinitionGroupSequence] = new Default_RegisterFileDefinitionGroupSequenceFormat {}
  implicit lazy val _RegisterDefinitionGroupSequenceFormat: IPXACT2009scalaxb.XMLFormat[RegisterDefinitionGroupSequence] = new Default_RegisterDefinitionGroupSequenceFormat {}
  implicit lazy val _LanguageFormat: IPXACT2009scalaxb.XMLFormat[Language] = new Default_LanguageFormat {}
  implicit lazy val _WhiteboxElementRefsFormat: IPXACT2009scalaxb.XMLFormat[WhiteboxElementRefs] = new Default_WhiteboxElementRefsFormat {}
  implicit lazy val _ViewTypeFormat: IPXACT2009scalaxb.XMLFormat[ViewType] = new Default_ViewTypeFormat {}
  implicit lazy val _ViewTypeSequence1Format: IPXACT2009scalaxb.XMLFormat[ViewTypeSequence1] = new Default_ViewTypeSequence1Format {}
  implicit lazy val _Language2Format: IPXACT2009scalaxb.XMLFormat[Language2] = new Default_Language2Format {}
  implicit lazy val _AbstractorViewTypeFormat: IPXACT2009scalaxb.XMLFormat[AbstractorViewType] = new Default_AbstractorViewTypeFormat {}
  implicit lazy val _ViewsFormat: IPXACT2009scalaxb.XMLFormat[Views] = new Default_ViewsFormat {}
  implicit lazy val _PortsFormat: IPXACT2009scalaxb.XMLFormat[Ports] = new Default_PortsFormat {}
  implicit lazy val _ModelParametersFormat: IPXACT2009scalaxb.XMLFormat[ModelParameters] = new Default_ModelParametersFormat {}
  implicit lazy val _ModelTypeFormat: IPXACT2009scalaxb.XMLFormat[ModelType] = new Default_ModelTypeFormat {}
  implicit lazy val _Views2Format: IPXACT2009scalaxb.XMLFormat[Views2] = new Default_Views2Format {}
  implicit lazy val _Ports2Format: IPXACT2009scalaxb.XMLFormat[Ports2] = new Default_Ports2Format {}
  implicit lazy val _ModelParameters2Format: IPXACT2009scalaxb.XMLFormat[ModelParameters2] = new Default_ModelParameters2Format {}
  implicit lazy val _AbstractorModelTypeFormat: IPXACT2009scalaxb.XMLFormat[AbstractorModelType] = new Default_AbstractorModelTypeFormat {}
  implicit lazy val _WhiteboxPathFormat: IPXACT2009scalaxb.XMLFormat[WhiteboxPath] = new Default_WhiteboxPathFormat {}
  implicit lazy val _WhiteboxPathSequence1Format: IPXACT2009scalaxb.XMLFormat[WhiteboxPathSequence1] = new Default_WhiteboxPathSequence1Format {}
  implicit lazy val _WhiteboxElementRefTypeFormat: IPXACT2009scalaxb.XMLFormat[WhiteboxElementRefType] = new Default_WhiteboxElementRefTypeFormat {}
  implicit lazy val _ComponentPortDirectionTypeFormat: IPXACT2009scalaxb.XMLFormat[ComponentPortDirectionType] = new Default_ComponentPortDirectionTypeFormat {}
  implicit lazy val _LeftType4Format: IPXACT2009scalaxb.XMLFormat[LeftType4] = new Default_LeftType4Format {}
  implicit lazy val _RightType4Format: IPXACT2009scalaxb.XMLFormat[RightType4] = new Default_RightType4Format {}
  implicit lazy val _Vector4Format: IPXACT2009scalaxb.XMLFormat[Vector4] = new Default_Vector4Format {}
  implicit lazy val _PortDeclarationTypableFormat: IPXACT2009scalaxb.XMLFormat[PortDeclarationTypable] = new Default_PortDeclarationTypableFormat {}
  implicit lazy val _PortDeclarationTypeFormat: IPXACT2009scalaxb.XMLFormat[PortDeclarationType] = new Default_PortDeclarationTypeFormat {}
  implicit lazy val _PortDeclarationTypableSequence1Format: IPXACT2009scalaxb.XMLFormat[PortDeclarationTypableSequence1] = new Default_PortDeclarationTypableSequence1Format {}
  implicit lazy val _PortTypableFormat: IPXACT2009scalaxb.XMLFormat[PortTypable] = new Default_PortTypableFormat {}
  implicit lazy val _PortTypeFormat: IPXACT2009scalaxb.XMLFormat[PortType] = new Default_PortTypeFormat {}
  implicit lazy val _AbstractorPortTypeFormat: IPXACT2009scalaxb.XMLFormat[AbstractorPortType] = new Default_AbstractorPortTypeFormat {}
  implicit lazy val _AbstractorPortTypeSequence3Format: IPXACT2009scalaxb.XMLFormat[AbstractorPortTypeSequence3] = new Default_AbstractorPortTypeSequence3Format {}
  implicit lazy val _AbstractorPortTypeSequence1Format: IPXACT2009scalaxb.XMLFormat[AbstractorPortTypeSequence1] = new Default_AbstractorPortTypeSequence1Format {}
  implicit lazy val _AbstractorPortTypeSequence2Format: IPXACT2009scalaxb.XMLFormat[AbstractorPortTypeSequence2] = new Default_AbstractorPortTypeSequence2Format {}
  implicit lazy val _InitiativeTypeFormat: IPXACT2009scalaxb.XMLFormat[InitiativeType] = new Default_InitiativeTypeFormat {}
  implicit lazy val _PortAccessTypeTypeFormat: IPXACT2009scalaxb.XMLFormat[PortAccessTypeType] = new Default_PortAccessTypeTypeFormat {}
  implicit lazy val _TypeName2Format: IPXACT2009scalaxb.XMLFormat[TypeName2] = new Default_TypeName2Format {}
  implicit lazy val _TransTypeDefFormat: IPXACT2009scalaxb.XMLFormat[TransTypeDef] = new Default_TransTypeDefFormat {}
  implicit lazy val _TypeName3Format: IPXACT2009scalaxb.XMLFormat[TypeName3] = new Default_TypeName3Format {}
  implicit lazy val _Parameters2Format: IPXACT2009scalaxb.XMLFormat[Parameters2] = new Default_Parameters2Format {}
  implicit lazy val _ServiceTypeDefFormat: IPXACT2009scalaxb.XMLFormat[ServiceTypeDef] = new Default_ServiceTypeDefFormat {}
  implicit lazy val _TypeName4Format: IPXACT2009scalaxb.XMLFormat[TypeName4] = new Default_TypeName4Format {}
  implicit lazy val _WireTypeDefFormat: IPXACT2009scalaxb.XMLFormat[WireTypeDef] = new Default_WireTypeDefFormat {}
  implicit lazy val _ServiceTypeDefsFormat: IPXACT2009scalaxb.XMLFormat[ServiceTypeDefs] = new Default_ServiceTypeDefsFormat {}
  implicit lazy val _WireTypeDefsFormat: IPXACT2009scalaxb.XMLFormat[WireTypeDefs] = new Default_WireTypeDefsFormat {}
  implicit lazy val _PortWireTypableFormat: IPXACT2009scalaxb.XMLFormat[PortWireTypable] = new Default_PortWireTypableFormat {}
  implicit lazy val _PortWireTypeFormat: IPXACT2009scalaxb.XMLFormat[PortWireType] = new Default_PortWireTypeFormat {}
  implicit lazy val _ServiceFormat: IPXACT2009scalaxb.XMLFormat[Service] = new Default_ServiceFormat {}
  implicit lazy val _ConnectionFormat: IPXACT2009scalaxb.XMLFormat[Connection] = new Default_ConnectionFormat {}
  implicit lazy val _PortTransactionalTypeFormat: IPXACT2009scalaxb.XMLFormat[PortTransactionalType] = new Default_PortTransactionalTypeFormat {}
  implicit lazy val _AbstractorPortWireTypeFormat: IPXACT2009scalaxb.XMLFormat[AbstractorPortWireType] = new Default_AbstractorPortWireTypeFormat {}
  implicit lazy val _PortAccessTypeFormat: IPXACT2009scalaxb.XMLFormat[PortAccessType] = new Default_PortAccessTypeFormat {}
  implicit lazy val _DefaultValueFormat: IPXACT2009scalaxb.XMLFormat[DefaultValue] = new Default_DefaultValueFormat {}
  implicit lazy val _ClockDriverFormat: IPXACT2009scalaxb.XMLFormat[ClockDriver] = new Default_ClockDriverFormat {}
  implicit lazy val _SingleShotOffsetFormat: IPXACT2009scalaxb.XMLFormat[SingleShotOffset] = new Default_SingleShotOffsetFormat {}
  implicit lazy val _SingleShotValueFormat: IPXACT2009scalaxb.XMLFormat[SingleShotValue] = new Default_SingleShotValueFormat {}
  implicit lazy val _SingleShotDurationFormat: IPXACT2009scalaxb.XMLFormat[SingleShotDuration] = new Default_SingleShotDurationFormat {}
  implicit lazy val _SingleShotDriverFormat: IPXACT2009scalaxb.XMLFormat[SingleShotDriver] = new Default_SingleShotDriverFormat {}
  implicit lazy val _DriverTypeTypeFormat: IPXACT2009scalaxb.XMLFormat[DriverTypeType] = new Default_DriverTypeTypeFormat {}
  implicit lazy val _RequiresDriverFormat: IPXACT2009scalaxb.XMLFormat[RequiresDriver] = new Default_RequiresDriverFormat {}
  implicit lazy val _DriverTypeFormat: IPXACT2009scalaxb.XMLFormat[DriverType] = new Default_DriverTypeFormat {}
  implicit lazy val _ClockPeriodFormat: IPXACT2009scalaxb.XMLFormat[ClockPeriod] = new Default_ClockPeriodFormat {}
  implicit lazy val _ClockPulseOffsetFormat: IPXACT2009scalaxb.XMLFormat[ClockPulseOffset] = new Default_ClockPulseOffsetFormat {}
  implicit lazy val _ClockPulseValueFormat: IPXACT2009scalaxb.XMLFormat[ClockPulseValue] = new Default_ClockPulseValueFormat {}
  implicit lazy val _ClockPulseDurationFormat: IPXACT2009scalaxb.XMLFormat[ClockPulseDuration] = new Default_ClockPulseDurationFormat {}
  implicit lazy val _ClockDriverTypableFormat: IPXACT2009scalaxb.XMLFormat[ClockDriverTypable] = new Default_ClockDriverTypableFormat {}
  implicit lazy val _ClockDriverTypeFormat: IPXACT2009scalaxb.XMLFormat[ClockDriverType] = new Default_ClockDriverTypeFormat {}
  implicit lazy val _OtherClockDriverFormat: IPXACT2009scalaxb.XMLFormat[OtherClockDriver] = new Default_OtherClockDriverFormat {}
  implicit lazy val _ConfigurableElementValuesFormat: IPXACT2009scalaxb.XMLFormat[ConfigurableElementValues] = new Default_ConfigurableElementValuesFormat {}
  implicit lazy val _ConfigurableElementValueFormat: IPXACT2009scalaxb.XMLFormat[ConfigurableElementValue] = new Default_ConfigurableElementValueFormat {}
  implicit lazy val _ComponentInstanceFormat: IPXACT2009scalaxb.XMLFormat[ComponentInstance] = new Default_ComponentInstanceFormat {}
  implicit lazy val _ComponentInstancesFormat: IPXACT2009scalaxb.XMLFormat[ComponentInstances] = new Default_ComponentInstancesFormat {}
  implicit lazy val _InternalPortReferenceFormat: IPXACT2009scalaxb.XMLFormat[InternalPortReference] = new Default_InternalPortReferenceFormat {}
  implicit lazy val _ExternalPortReferenceFormat: IPXACT2009scalaxb.XMLFormat[ExternalPortReference] = new Default_ExternalPortReferenceFormat {}
  implicit lazy val _AdHocConnectionFormat: IPXACT2009scalaxb.XMLFormat[AdHocConnection] = new Default_AdHocConnectionFormat {}
  implicit lazy val _AdHocConnectionsFormat: IPXACT2009scalaxb.XMLFormat[AdHocConnections] = new Default_AdHocConnectionsFormat {}
  implicit lazy val _InterconnectionFormat: IPXACT2009scalaxb.XMLFormat[Interconnection] = new Default_InterconnectionFormat {}
  implicit lazy val _InterconnectionsFormat: IPXACT2009scalaxb.XMLFormat[Interconnections] = new Default_InterconnectionsFormat {}
  implicit lazy val _InterfacableFormat: IPXACT2009scalaxb.XMLFormat[Interfacable] = new Default_InterfacableFormat {}
  implicit lazy val _InterfaceTypeFormat: IPXACT2009scalaxb.XMLFormat[InterfaceType] = new Default_InterfaceTypeFormat {}
  implicit lazy val _MonitorInterconnectionFormat: IPXACT2009scalaxb.XMLFormat[MonitorInterconnection] = new Default_MonitorInterconnectionFormat {}
  implicit lazy val _HierInterfaceFormat: IPXACT2009scalaxb.XMLFormat[HierInterface] = new Default_HierInterfaceFormat {}


  implicit val fromAnySchemaType: scala.xml.Elem => Option[IPXACT2009scalaxb.DataRecord[Any]] = {elem =>
    import IPXACT2009scalaxb.{Helper, DataRecord, fromXML}

    val ns = Helper.nullOrEmpty(elem.scope.getURI(elem.prefix))
    val key = Some(elem.label)
    val (xsns, xstype) = Helper.instanceType(elem)

    (key, ns) match {
      case (Some("abstractionDefinition"), Some("http://www.spiritconsortium.org/XMLSchema/SPIRIT/1685-2009") | None) => Some(DataRecord(ns, key, xsns, xstype, fromXML[AbstractionDefinition](elem)))
      case (Some("presence"), Some("http://www.spiritconsortium.org/XMLSchema/SPIRIT/1685-2009") | None) => Some(DataRecord(ns, key, xsns, xstype, fromXML[Presence](elem)))
      case (Some("abstractor"), Some("http://www.spiritconsortium.org/XMLSchema/SPIRIT/1685-2009") | None) => Some(DataRecord(ns, key, xsns, xstype, fromXML[AbstractorType](elem)))
      case (Some("choices"), Some("http://www.spiritconsortium.org/XMLSchema/SPIRIT/1685-2009") | None) => Some(DataRecord(ns, key, xsns, xstype, fromXML[Choices](elem)))
      case (Some("busDefinition"), Some("http://www.spiritconsortium.org/XMLSchema/SPIRIT/1685-2009") | None) => Some(DataRecord(ns, key, xsns, xstype, fromXML[BusDefinition](elem)))
      case (Some("remapStates"), Some("http://www.spiritconsortium.org/XMLSchema/SPIRIT/1685-2009") | None) => Some(DataRecord(ns, key, xsns, xstype, fromXML[RemapStates](elem)))
      case (Some("group"), Some("http://www.spiritconsortium.org/XMLSchema/SPIRIT/1685-2009") | None) => Some(DataRecord(ns, key, xsns, xstype, fromXML[String](elem)))
      case (Some("busInterface"), Some("http://www.spiritconsortium.org/XMLSchema/SPIRIT/1685-2009") | None) => Some(DataRecord(ns, key, xsns, xstype, fromXML[BusInterfaceType](elem)))
      case (Some("bitsInLau"), Some("http://www.spiritconsortium.org/XMLSchema/SPIRIT/1685-2009") | None) => Some(DataRecord(ns, key, xsns, xstype, fromXML[BigInt](elem)))
      case (Some("busInterfaces"), Some("http://www.spiritconsortium.org/XMLSchema/SPIRIT/1685-2009") | None) => Some(DataRecord(ns, key, xsns, xstype, fromXML[BusInterfaces](elem)))
      case (Some("channels"), Some("http://www.spiritconsortium.org/XMLSchema/SPIRIT/1685-2009") | None) => Some(DataRecord(ns, key, xsns, xstype, fromXML[Channels](elem)))
      case (Some("description"), Some("http://www.spiritconsortium.org/XMLSchema/SPIRIT/1685-2009") | None) => Some(DataRecord(ns, key, xsns, xstype, fromXML[String](elem)))
      case (Some("vendorExtensions"), Some("http://www.spiritconsortium.org/XMLSchema/SPIRIT/1685-2009") | None) => Some(DataRecord(ns, key, xsns, xstype, fromXML[VendorExtensions](elem)))
      case (Some("parameter"), Some("http://www.spiritconsortium.org/XMLSchema/SPIRIT/1685-2009") | None) => Some(DataRecord(ns, key, xsns, xstype, fromXML[NameValuePairTypable](elem)))
      case (Some("parameters"), Some("http://www.spiritconsortium.org/XMLSchema/SPIRIT/1685-2009") | None) => Some(DataRecord(ns, key, xsns, xstype, fromXML[Parameters](elem)))
      case (Some("displayName"), Some("http://www.spiritconsortium.org/XMLSchema/SPIRIT/1685-2009") | None) => Some(DataRecord(ns, key, xsns, xstype, fromXML[String](elem)))
      case (Some("component"), Some("http://www.spiritconsortium.org/XMLSchema/SPIRIT/1685-2009") | None) => Some(DataRecord(ns, key, xsns, xstype, fromXML[ComponentType](elem)))
      case (Some("constraintSetRef"), Some("http://www.spiritconsortium.org/XMLSchema/SPIRIT/1685-2009") | None) => Some(DataRecord(ns, key, xsns, xstype, fromXML[String](elem)))
      case (Some("constraintSet"), Some("http://www.spiritconsortium.org/XMLSchema/SPIRIT/1685-2009") | None) => Some(DataRecord(ns, key, xsns, xstype, fromXML[ConstraintSet](elem)))
      case (Some("driveConstraint"), Some("http://www.spiritconsortium.org/XMLSchema/SPIRIT/1685-2009") | None) => Some(DataRecord(ns, key, xsns, xstype, fromXML[DriveConstraint](elem)))
      case (Some("cellSpecification"), Some("http://www.spiritconsortium.org/XMLSchema/SPIRIT/1685-2009") | None) => Some(DataRecord(ns, key, xsns, xstype, fromXML[CellSpecification](elem)))
      case (Some("timingConstraint"), Some("http://www.spiritconsortium.org/XMLSchema/SPIRIT/1685-2009") | None) => Some(DataRecord(ns, key, xsns, xstype, fromXML[TimingConstraint](elem)))
      case (Some("loadConstraint"), Some("http://www.spiritconsortium.org/XMLSchema/SPIRIT/1685-2009") | None) => Some(DataRecord(ns, key, xsns, xstype, fromXML[LoadConstraint](elem)))
      case (Some("constraintSets"), Some("http://www.spiritconsortium.org/XMLSchema/SPIRIT/1685-2009") | None) => Some(DataRecord(ns, key, xsns, xstype, fromXML[ConstraintSets](elem)))
      case (Some("design"), Some("http://www.spiritconsortium.org/XMLSchema/SPIRIT/1685-2009") | None) => Some(DataRecord(ns, key, xsns, xstype, fromXML[Design](elem)))
      case (Some("designConfiguration"), Some("http://www.spiritconsortium.org/XMLSchema/SPIRIT/1685-2009") | None) => Some(DataRecord(ns, key, xsns, xstype, fromXML[DesignConfiguration](elem)))
      case (Some("generatorRef"), Some("http://www.spiritconsortium.org/XMLSchema/SPIRIT/1685-2009") | None) => Some(DataRecord(ns, key, xsns, xstype, fromXML[String](elem)))
      case (Some("dependency"), Some("http://www.spiritconsortium.org/XMLSchema/SPIRIT/1685-2009") | None) => Some(DataRecord(ns, key, xsns, xstype, fromXML[String](elem)))
      case (Some("executableImage"), Some("http://www.spiritconsortium.org/XMLSchema/SPIRIT/1685-2009") | None) => Some(DataRecord(ns, key, xsns, xstype, fromXML[ExecutableImage](elem)))
      case (Some("file"), Some("http://www.spiritconsortium.org/XMLSchema/SPIRIT/1685-2009") | None) => Some(DataRecord(ns, key, xsns, xstype, fromXML[File](elem)))
      case (Some("fileSet"), Some("http://www.spiritconsortium.org/XMLSchema/SPIRIT/1685-2009") | None) => Some(DataRecord(ns, key, xsns, xstype, fromXML[FileSetType](elem)))
      case (Some("fileSetRef"), Some("http://www.spiritconsortium.org/XMLSchema/SPIRIT/1685-2009") | None) => Some(DataRecord(ns, key, xsns, xstype, fromXML[FileSetRef](elem)))
      case (Some("fileSets"), Some("http://www.spiritconsortium.org/XMLSchema/SPIRIT/1685-2009") | None) => Some(DataRecord(ns, key, xsns, xstype, fromXML[FileSets](elem)))
      case (Some("abstractorGenerators"), Some("http://www.spiritconsortium.org/XMLSchema/SPIRIT/1685-2009") | None) => Some(DataRecord(ns, key, xsns, xstype, fromXML[AbstractorGenerators](elem)))
      case (Some("phase"), Some("http://www.spiritconsortium.org/XMLSchema/SPIRIT/1685-2009") | None) => Some(DataRecord(ns, key, xsns, xstype, fromXML[Phase](elem)))
      case (Some("abstractorGenerator"), Some("http://www.spiritconsortium.org/XMLSchema/SPIRIT/1685-2009") | None) => Some(DataRecord(ns, key, xsns, xstype, fromXML[InstanceGeneratorTypable](elem)))
      case (Some("generator"), Some("http://www.spiritconsortium.org/XMLSchema/SPIRIT/1685-2009") | None) => Some(DataRecord(ns, key, xsns, xstype, fromXML[Generator](elem)))
      case (Some("generatorChain"), Some("http://www.spiritconsortium.org/XMLSchema/SPIRIT/1685-2009") | None) => Some(DataRecord(ns, key, xsns, xstype, fromXML[GeneratorChain](elem)))
      case (Some("componentGenerator"), Some("http://www.spiritconsortium.org/XMLSchema/SPIRIT/1685-2009") | None) => Some(DataRecord(ns, key, xsns, xstype, fromXML[ComponentGenerator](elem)))
      case (Some("groupSelector"), Some("http://www.spiritconsortium.org/XMLSchema/SPIRIT/1685-2009") | None) => Some(DataRecord(ns, key, xsns, xstype, fromXML[GroupSelector](elem)))
      case (Some("componentGenerators"), Some("http://www.spiritconsortium.org/XMLSchema/SPIRIT/1685-2009") | None) => Some(DataRecord(ns, key, xsns, xstype, fromXML[ComponentGenerators](elem)))
      case (Some("registerFile"), Some("http://www.spiritconsortium.org/XMLSchema/SPIRIT/1685-2009") | None) => Some(DataRecord(ns, key, xsns, xstype, fromXML[RegisterFile](elem)))
      case (Some("addressUnitBits"), Some("http://www.spiritconsortium.org/XMLSchema/SPIRIT/1685-2009") | None) => Some(DataRecord(ns, key, xsns, xstype, fromXML[BigInt](elem)))
      case (Some("bank"), Some("http://www.spiritconsortium.org/XMLSchema/SPIRIT/1685-2009") | None) => Some(DataRecord(ns, key, xsns, xstype, fromXML[AddressBankType](elem)))
      case (Some("memoryMapRef"), Some("http://www.spiritconsortium.org/XMLSchema/SPIRIT/1685-2009") | None) => Some(DataRecord(ns, key, xsns, xstype, fromXML[MemoryMapRefType](elem)))
      case (Some("addressSpaceRef"), Some("http://www.spiritconsortium.org/XMLSchema/SPIRIT/1685-2009") | None) => Some(DataRecord(ns, key, xsns, xstype, fromXML[AddrSpaceRefTypable](elem)))
      case (Some("access"), Some("http://www.spiritconsortium.org/XMLSchema/SPIRIT/1685-2009") | None) => Some(DataRecord(ns, key, xsns, xstype, fromXML[AccessType](elem)))
      case (Some("volatile"), Some("http://www.spiritconsortium.org/XMLSchema/SPIRIT/1685-2009") | None) => Some(DataRecord(ns, key, xsns, xstype, fromXML[Boolean](elem)))
      case (Some("addressBlock"), Some("http://www.spiritconsortium.org/XMLSchema/SPIRIT/1685-2009") | None) => Some(DataRecord(ns, key, xsns, xstype, fromXML[AddressBlockType](elem)))
      case (Some("addressSpaces"), Some("http://www.spiritconsortium.org/XMLSchema/SPIRIT/1685-2009") | None) => Some(DataRecord(ns, key, xsns, xstype, fromXML[AddressSpaces](elem)))
      case (Some("memoryMaps"), Some("http://www.spiritconsortium.org/XMLSchema/SPIRIT/1685-2009") | None) => Some(DataRecord(ns, key, xsns, xstype, fromXML[MemoryMaps](elem)))
      case (Some("baseAddress"), Some("http://www.spiritconsortium.org/XMLSchema/SPIRIT/1685-2009") | None) => Some(DataRecord(ns, key, xsns, xstype, fromXML[BaseAddress2](elem)))
      case (Some("enumeratedValues"), Some("http://www.spiritconsortium.org/XMLSchema/SPIRIT/1685-2009") | None) => Some(DataRecord(ns, key, xsns, xstype, fromXML[EnumeratedValues](elem)))
      case (Some("model"), Some("http://www.spiritconsortium.org/XMLSchema/SPIRIT/1685-2009") | None) => Some(DataRecord(ns, key, xsns, xstype, fromXML[ModelType](elem)))
      case (Some("port"), Some("http://www.spiritconsortium.org/XMLSchema/SPIRIT/1685-2009") | None) => Some(DataRecord(ns, key, xsns, xstype, fromXML[PortTypable](elem)))
      case (Some("wireTypeDefs"), Some("http://www.spiritconsortium.org/XMLSchema/SPIRIT/1685-2009") | None) => Some(DataRecord(ns, key, xsns, xstype, fromXML[WireTypeDefs](elem)))
      case (Some("wireTypeDef"), Some("http://www.spiritconsortium.org/XMLSchema/SPIRIT/1685-2009") | None) => Some(DataRecord(ns, key, xsns, xstype, fromXML[WireTypeDef](elem)))
      case (Some("transTypeDef"), Some("http://www.spiritconsortium.org/XMLSchema/SPIRIT/1685-2009") | None) => Some(DataRecord(ns, key, xsns, xstype, fromXML[TransTypeDef](elem)))
      case (Some("initiative"), Some("http://www.spiritconsortium.org/XMLSchema/SPIRIT/1685-2009") | None) => Some(DataRecord(ns, key, xsns, xstype, fromXML[InitiativeType](elem)))
      case (Some("vector"), Some("http://www.spiritconsortium.org/XMLSchema/SPIRIT/1685-2009") | None) => Some(DataRecord(ns, key, xsns, xstype, fromXML[Vector4](elem)))
      case (Some("portAccessType"), Some("http://www.spiritconsortium.org/XMLSchema/SPIRIT/1685-2009") | None) => Some(DataRecord(ns, key, xsns, xstype, fromXML[PortAccessTypeType](elem)))
      case (Some("serviceTypeDef"), Some("http://www.spiritconsortium.org/XMLSchema/SPIRIT/1685-2009") | None) => Some(DataRecord(ns, key, xsns, xstype, fromXML[ServiceTypeDef](elem)))
      case (Some("serviceTypeDefs"), Some("http://www.spiritconsortium.org/XMLSchema/SPIRIT/1685-2009") | None) => Some(DataRecord(ns, key, xsns, xstype, fromXML[ServiceTypeDefs](elem)))
      case (Some("portAccessHandle"), Some("http://www.spiritconsortium.org/XMLSchema/SPIRIT/1685-2009") | None) => Some(DataRecord(ns, key, xsns, xstype, fromXML[String](elem)))
      case (Some("otherClockDriver"), Some("http://www.spiritconsortium.org/XMLSchema/SPIRIT/1685-2009") | None) => Some(DataRecord(ns, key, xsns, xstype, fromXML[OtherClockDriver](elem)))
      case (Some("requiresDriver"), Some("http://www.spiritconsortium.org/XMLSchema/SPIRIT/1685-2009") | None) => Some(DataRecord(ns, key, xsns, xstype, fromXML[RequiresDriver](elem)))
      case (Some("clockDriver"), Some("http://www.spiritconsortium.org/XMLSchema/SPIRIT/1685-2009") | None) => Some(DataRecord(ns, key, xsns, xstype, fromXML[ClockDriver](elem)))
      case (Some("defaultValue"), Some("http://www.spiritconsortium.org/XMLSchema/SPIRIT/1685-2009") | None) => Some(DataRecord(ns, key, xsns, xstype, fromXML[DefaultValue](elem)))
      case (Some("singleShotDriver"), Some("http://www.spiritconsortium.org/XMLSchema/SPIRIT/1685-2009") | None) => Some(DataRecord(ns, key, xsns, xstype, fromXML[SingleShotDriver](elem)))
      case (Some("driver"), Some("http://www.spiritconsortium.org/XMLSchema/SPIRIT/1685-2009") | None) => Some(DataRecord(ns, key, xsns, xstype, fromXML[DriverType](elem)))
      case (Some("monitorInterconnection"), Some("http://www.spiritconsortium.org/XMLSchema/SPIRIT/1685-2009") | None) => Some(DataRecord(ns, key, xsns, xstype, fromXML[MonitorInterconnection](elem)))
      case (Some("interconnection"), Some("http://www.spiritconsortium.org/XMLSchema/SPIRIT/1685-2009") | None) => Some(DataRecord(ns, key, xsns, xstype, fromXML[Interconnection](elem)))
      case (Some("adHocConnection"), Some("http://www.spiritconsortium.org/XMLSchema/SPIRIT/1685-2009") | None) => Some(DataRecord(ns, key, xsns, xstype, fromXML[AdHocConnection](elem)))
      case (Some("componentInstance"), Some("http://www.spiritconsortium.org/XMLSchema/SPIRIT/1685-2009") | None) => Some(DataRecord(ns, key, xsns, xstype, fromXML[ComponentInstance](elem)))
      case (Some("configurableElementValue"), Some("http://www.spiritconsortium.org/XMLSchema/SPIRIT/1685-2009") | None) => Some(DataRecord(ns, key, xsns, xstype, fromXML[ConfigurableElementValue](elem)))
      case (Some("configurableElementValues"), Some("http://www.spiritconsortium.org/XMLSchema/SPIRIT/1685-2009") | None) => Some(DataRecord(ns, key, xsns, xstype, fromXML[ConfigurableElementValues](elem)))
      case (Some("instanceName"), Some("http://www.spiritconsortium.org/XMLSchema/SPIRIT/1685-2009") | None) => Some(DataRecord(ns, key, xsns, xstype, fromXML[String](elem)))
      case (Some("componentInstances"), Some("http://www.spiritconsortium.org/XMLSchema/SPIRIT/1685-2009") | None) => Some(DataRecord(ns, key, xsns, xstype, fromXML[ComponentInstances](elem)))
      case (Some("adHocConnections"), Some("http://www.spiritconsortium.org/XMLSchema/SPIRIT/1685-2009") | None) => Some(DataRecord(ns, key, xsns, xstype, fromXML[AdHocConnections](elem)))
      case (Some("interconnections"), Some("http://www.spiritconsortium.org/XMLSchema/SPIRIT/1685-2009") | None) => Some(DataRecord(ns, key, xsns, xstype, fromXML[Interconnections](elem)))

      case _ => None
    }

  }

  def build_PresenceFormat = new Default_PresenceFormat {}
  trait Default_PresenceFormat extends IPXACT2009scalaxb.XMLFormat[Presence] {
    val targetNamespace: Option[String] = Some("http://www.spiritconsortium.org/XMLSchema/SPIRIT/1685-2009")
    
    def fromString(value: String, scope: scala.xml.NamespaceBinding): Presence =
        (fromString0(value, scope)).apply(IPXACT2009scalaxb.fromXML[String](scala.xml.Text(value)))

    private def fromString0(value: String, scope: scala.xml.NamespaceBinding): PartialFunction[Any, Presence] = {
      case x: String if x == IPXACT2009scalaxb.fromXML[String](scala.xml.Text("required")) => Required
      case x: String if x == IPXACT2009scalaxb.fromXML[String](scala.xml.Text("illegal")) => Illegal
      case x: String if x == IPXACT2009scalaxb.fromXML[String](scala.xml.Text("optional")) => Optional

    }



    def reads(seq: scala.xml.NodeSeq, stack: List[IPXACT2009scalaxb.ElemName]): Either[String, Presence] = seq match {
      case elem: scala.xml.Elem => Right(fromString(elem.text, elem.scope))
      case _ => Right(fromString(seq.text, scala.xml.TopScope))
    }
    
    def writes(__obj: Presence, __namespace: Option[String], __elementLabel: Option[String],
        __scope: scala.xml.NamespaceBinding, __typeAttribute: Boolean): scala.xml.NodeSeq =
      scala.xml.Elem(IPXACT2009scalaxb.Helper.getPrefix(__namespace, __scope).orNull,
        __elementLabel getOrElse { sys.error("missing element label.") },
        scala.xml.Null, __scope, true, scala.xml.Text(__obj.toString))
  }
  def build_InitiativeFormat = new Default_InitiativeFormat {}
  trait Default_InitiativeFormat extends IPXACT2009scalaxb.XMLFormat[Initiative] {
    val targetNamespace: Option[String] = Some("http://www.spiritconsortium.org/XMLSchema/SPIRIT/1685-2009")
    
    def fromString(value: String, scope: scala.xml.NamespaceBinding): Initiative =
        (fromString0(value, scope)).apply(IPXACT2009scalaxb.fromXML[String](scala.xml.Text(value)))

    private def fromString0(value: String, scope: scala.xml.NamespaceBinding): PartialFunction[Any, Initiative] = {
      case x: String if x == IPXACT2009scalaxb.fromXML[String](scala.xml.Text("requires")) => Requires
      case x: String if x == IPXACT2009scalaxb.fromXML[String](scala.xml.Text("provides")) => Provides
      case x: String if x == IPXACT2009scalaxb.fromXML[String](scala.xml.Text("both")) => Both

    }



    def reads(seq: scala.xml.NodeSeq, stack: List[IPXACT2009scalaxb.ElemName]): Either[String, Initiative] = seq match {
      case elem: scala.xml.Elem => Right(fromString(elem.text, elem.scope))
      case _ => Right(fromString(seq.text, scala.xml.TopScope))
    }
    
    def writes(__obj: Initiative, __namespace: Option[String], __elementLabel: Option[String],
        __scope: scala.xml.NamespaceBinding, __typeAttribute: Boolean): scala.xml.NodeSeq =
      scala.xml.Elem(IPXACT2009scalaxb.Helper.getPrefix(__namespace, __scope).orNull,
        __elementLabel getOrElse { sys.error("missing element label.") },
        scala.xml.Null, __scope, true, scala.xml.Text(__obj.toString))
  }
  trait Default_TypeNameFormat extends IPXACT2009scalaxb.XMLFormat[TypeName] with IPXACT2009scalaxb.CanWriteChildNodes[TypeName] {
    val targetNamespace: Option[String] = Some("http://www.spiritconsortium.org/XMLSchema/SPIRIT/1685-2009")
    def reads(seq: scala.xml.NodeSeq, stack: List[IPXACT2009scalaxb.ElemName]): Either[String, TypeName] = seq match {
      case node: scala.xml.Node => Right(TypeName(IPXACT2009scalaxb.fromXML[String](node, IPXACT2009scalaxb.ElemName(node) :: stack),
        scala.collection.immutable.ListMap(List(
        (node \ "@{http://www.spiritconsortium.org/XMLSchema/SPIRIT/1685-2009}implicit").headOption map { x => IPXACT2009scalaxb.DataRecord(x, node, IPXACT2009scalaxb.fromXML[Boolean](x, IPXACT2009scalaxb.ElemName(node) :: stack)) } orElse Some(IPXACT2009scalaxb.DataRecord(None, None, IPXACT2009scalaxb.fromXML[Boolean](scala.xml.Text("false"), IPXACT2009scalaxb.ElemName(node) :: stack))) map { "@implicit" -> _ }
        ).flatten[(String, IPXACT2009scalaxb.DataRecord[Any])]: _*)))
      case _ => Left("reads failed: seq must be scala.xml.Node")
    }
    
    override def writesAttribute(__obj: TypeName, __scope: scala.xml.NamespaceBinding): scala.xml.MetaData = {
      var attr: scala.xml.MetaData  = scala.xml.Null
      __obj.attributes.toList map {
        case ("@implicit", _) => if (__obj.implicitValue.toString != "false") attr = scala.xml.Attribute(__scope.getPrefix("http://www.spiritconsortium.org/XMLSchema/SPIRIT/1685-2009"), "implicit", __obj.implicitValue.toString, attr)
        case (key, x) => attr = scala.xml.Attribute((x.namespace map { __scope.getPrefix(_) }).orNull, x.key.orNull, x.value.toString, attr)
      }
      attr
    }

    def writesChildNodes(__obj: TypeName, __scope: scala.xml.NamespaceBinding): Seq[scala.xml.Node] =
      Seq(scala.xml.Text(__obj.value.toString))

  }

  trait Default_ServiceTypeFormat extends IPXACT2009scalaxb.ElemNameParser[ServiceType] {
    val targetNamespace: Option[String] = Some("http://www.spiritconsortium.org/XMLSchema/SPIRIT/1685-2009")
    
    override def typeName: Option[String] = Some("serviceType")

    def parser(node: scala.xml.Node, stack: List[IPXACT2009scalaxb.ElemName]): Parser[ServiceType] =
      phrase((IPXACT2009scalaxb.ElemName(Some("http://www.spiritconsortium.org/XMLSchema/SPIRIT/1685-2009"), "initiative")) ~
      safeRep(IPXACT2009scalaxb.ElemName(Some("http://www.spiritconsortium.org/XMLSchema/SPIRIT/1685-2009"), "typeName")) ~
      opt(IPXACT2009scalaxb.ElemName(Some("http://www.spiritconsortium.org/XMLSchema/SPIRIT/1685-2009"), "vendorExtensions")) ^^
      { case p1 ~ p2 ~ p3 =>
      ServiceType(p1.headOption map { IPXACT2009scalaxb.fromXML[Initiative](_, IPXACT2009scalaxb.ElemName(node) :: stack) } getOrElse { IPXACT2009scalaxb.fromXML[Initiative](scala.xml.Text("requires"), IPXACT2009scalaxb.ElemName(node) :: stack) },
        p2 map { IPXACT2009scalaxb.fromXML[TypeName](_, IPXACT2009scalaxb.ElemName(node) :: stack) },
        p3.headOption map { IPXACT2009scalaxb.fromXML[VendorExtensions](_, IPXACT2009scalaxb.ElemName(node) :: stack) }) })
    
    def writesChildNodes(__obj: ServiceType, __scope: scala.xml.NamespaceBinding): Seq[scala.xml.Node] =
      Seq.concat(IPXACT2009scalaxb.toXML[Initiative](__obj.initiative, Some("http://www.spiritconsortium.org/XMLSchema/SPIRIT/1685-2009"), Some("initiative"), __scope, false),
        __obj.typeName flatMap { IPXACT2009scalaxb.toXML[TypeName](_, Some("http://www.spiritconsortium.org/XMLSchema/SPIRIT/1685-2009"), Some("typeName"), __scope, false) },
        __obj.vendorExtensions map { IPXACT2009scalaxb.toXML[VendorExtensions](_, Some("http://www.spiritconsortium.org/XMLSchema/SPIRIT/1685-2009"), Some("vendorExtensions"), __scope, false) } getOrElse {Nil})

  }

  def build_DirectionFormat = new Default_DirectionFormat {}
  trait Default_DirectionFormat extends IPXACT2009scalaxb.XMLFormat[Direction] {
    val targetNamespace: Option[String] = Some("http://www.spiritconsortium.org/XMLSchema/SPIRIT/1685-2009")
    
    def fromString(value: String, scope: scala.xml.NamespaceBinding): Direction =
        (fromString0(value, scope)).apply(IPXACT2009scalaxb.fromXML[String](scala.xml.Text(value)))

    private def fromString0(value: String, scope: scala.xml.NamespaceBinding): PartialFunction[Any, Direction] = {
      case x: String if x == IPXACT2009scalaxb.fromXML[String](scala.xml.Text("in")) => InValue
      case x: String if x == IPXACT2009scalaxb.fromXML[String](scala.xml.Text("out")) => OutValue
      case x: String if x == IPXACT2009scalaxb.fromXML[String](scala.xml.Text("inout")) => InoutValue

    }



    def reads(seq: scala.xml.NodeSeq, stack: List[IPXACT2009scalaxb.ElemName]): Either[String, Direction] = seq match {
      case elem: scala.xml.Elem => Right(fromString(elem.text, elem.scope))
      case _ => Right(fromString(seq.text, scala.xml.TopScope))
    }
    
    def writes(__obj: Direction, __namespace: Option[String], __elementLabel: Option[String],
        __scope: scala.xml.NamespaceBinding, __typeAttribute: Boolean): scala.xml.NodeSeq =
      scala.xml.Elem(IPXACT2009scalaxb.Helper.getPrefix(__namespace, __scope).orNull,
        __elementLabel getOrElse { sys.error("missing element label.") },
        scala.xml.Null, __scope, true, scala.xml.Text(__obj.toString))
  }
  trait Default_QualifierFormat extends IPXACT2009scalaxb.ElemNameParser[Qualifier] {
    val targetNamespace: Option[String] = Some("http://www.spiritconsortium.org/XMLSchema/SPIRIT/1685-2009")
    
    def parser(node: scala.xml.Node, stack: List[IPXACT2009scalaxb.ElemName]): Parser[Qualifier] =
      phrase(opt(((opt(IPXACT2009scalaxb.ElemName(Some("http://www.spiritconsortium.org/XMLSchema/SPIRIT/1685-2009"), "isAddress")) ~
      opt(IPXACT2009scalaxb.ElemName(Some("http://www.spiritconsortium.org/XMLSchema/SPIRIT/1685-2009"), "isData"))) ^^
        { case p1 ~ p2 => IPXACT2009scalaxb.DataRecord(QualifierSequence1(p1.headOption map { IPXACT2009scalaxb.fromXML[Boolean](_, IPXACT2009scalaxb.ElemName(node) :: stack) },
        p2.headOption map { IPXACT2009scalaxb.fromXML[Boolean](_, IPXACT2009scalaxb.ElemName(node) :: stack) })) }) |||
      ((IPXACT2009scalaxb.ElemName(Some("http://www.spiritconsortium.org/XMLSchema/SPIRIT/1685-2009"), "isClock")) ^^
      (x => IPXACT2009scalaxb.DataRecord(x.namespace, Some(x.name), IPXACT2009scalaxb.fromXML[Boolean](x, IPXACT2009scalaxb.ElemName(node) :: stack)))) |||
      ((IPXACT2009scalaxb.ElemName(Some("http://www.spiritconsortium.org/XMLSchema/SPIRIT/1685-2009"), "isReset")) ^^
      (x => IPXACT2009scalaxb.DataRecord(x.namespace, Some(x.name), IPXACT2009scalaxb.fromXML[Boolean](x, IPXACT2009scalaxb.ElemName(node) :: stack))))) ^^
      { case p1 =>
      Qualifier(p1) })
    
    def writesChildNodes(__obj: Qualifier, __scope: scala.xml.NamespaceBinding): Seq[scala.xml.Node] =
      (__obj.qualifieroption map { x => IPXACT2009scalaxb.toXML[IPXACT2009scalaxb.DataRecord[Any]](x, x.namespace, x.key, __scope, false) } getOrElse {Nil})
  }

  trait Default_QualifierSequence1Format extends IPXACT2009scalaxb.XMLFormat[QualifierSequence1] {
    def reads(seq: scala.xml.NodeSeq, stack: List[IPXACT2009scalaxb.ElemName]): Either[String, QualifierSequence1] = Left("don't call me.")
    
    def writes(__obj: QualifierSequence1, __namespace: Option[String], __elementLabel: Option[String], 
        __scope: scala.xml.NamespaceBinding, __typeAttribute: Boolean): scala.xml.NodeSeq =
      Seq.concat(__obj.isAddress map { IPXACT2009scalaxb.toXML[Boolean](_, Some("http://www.spiritconsortium.org/XMLSchema/SPIRIT/1685-2009"), Some("isAddress"), __scope, false) } getOrElse {Nil},
        __obj.isData map { IPXACT2009scalaxb.toXML[Boolean](_, Some("http://www.spiritconsortium.org/XMLSchema/SPIRIT/1685-2009"), Some("isData"), __scope, false) } getOrElse {Nil})


  }

  trait Default_OnSystemFormat extends IPXACT2009scalaxb.ElemNameParser[OnSystem] with _WirePortGroupFormat {
    val targetNamespace: Option[String] = Some("http://www.spiritconsortium.org/XMLSchema/SPIRIT/1685-2009")
    
    def parser(node: scala.xml.Node, stack: List[IPXACT2009scalaxb.ElemName]): Parser[OnSystem] =
      phrase((IPXACT2009scalaxb.ElemName(Some("http://www.spiritconsortium.org/XMLSchema/SPIRIT/1685-2009"), "group")) ~
      (parseWirePortGroup(node, IPXACT2009scalaxb.ElemName(node) :: stack)) ^^
      { case p1 ~ p2 =>
      OnSystem(IPXACT2009scalaxb.fromXML[String](p1, IPXACT2009scalaxb.ElemName(node) :: stack),
        p2) })
    
    def writesChildNodes(__obj: OnSystem, __scope: scala.xml.NamespaceBinding): Seq[scala.xml.Node] =
      Seq.concat(IPXACT2009scalaxb.toXML[String](__obj.group, Some("http://www.spiritconsortium.org/XMLSchema/SPIRIT/1685-2009"), Some("group"), __scope, false),
        IPXACT2009scalaxb.toXML[WirePortSequence](__obj.wirePortSequence2, None, Some("wirePortSequence2"), __scope, false))

  }

  trait Default_OnMasterFormat extends IPXACT2009scalaxb.ElemNameParser[OnMaster] with _WirePortGroupFormat {
    val targetNamespace: Option[String] = Some("http://www.spiritconsortium.org/XMLSchema/SPIRIT/1685-2009")
    
    def parser(node: scala.xml.Node, stack: List[IPXACT2009scalaxb.ElemName]): Parser[OnMaster] =
      phrase((parseWirePortGroup(node, IPXACT2009scalaxb.ElemName(node) :: stack)) ^^
      { case p1 =>
      OnMaster(p1) })
    
    def writesChildNodes(__obj: OnMaster, __scope: scala.xml.NamespaceBinding): Seq[scala.xml.Node] =
      (IPXACT2009scalaxb.toXML[WirePortSequence](__obj.wirePortSequence1, None, Some("wirePortSequence1"), __scope, false))
  }
  trait Default_OnSlaveFormat extends IPXACT2009scalaxb.ElemNameParser[OnSlave] with _WirePortGroupFormat {
    val targetNamespace: Option[String] = Some("http://www.spiritconsortium.org/XMLSchema/SPIRIT/1685-2009")
    
    def parser(node: scala.xml.Node, stack: List[IPXACT2009scalaxb.ElemName]): Parser[OnSlave] =
      phrase((parseWirePortGroup(node, IPXACT2009scalaxb.ElemName(node) :: stack)) ^^
      { case p1 =>
      OnSlave(p1) })
    
    def writesChildNodes(__obj: OnSlave, __scope: scala.xml.NamespaceBinding): Seq[scala.xml.Node] =
      (IPXACT2009scalaxb.toXML[WirePortSequence](__obj.wirePortSequence1, None, Some("wirePortSequence1"), __scope, false))
  }
  trait Default_WireFormat extends IPXACT2009scalaxb.ElemNameParser[Wire] {
    val targetNamespace: Option[String] = Some("http://www.spiritconsortium.org/XMLSchema/SPIRIT/1685-2009")
    
    def parser(node: scala.xml.Node, stack: List[IPXACT2009scalaxb.ElemName]): Parser[Wire] =
      phrase(opt(IPXACT2009scalaxb.ElemName(Some("http://www.spiritconsortium.org/XMLSchema/SPIRIT/1685-2009"), "qualifier")) ~
      safeRep(IPXACT2009scalaxb.ElemName(Some("http://www.spiritconsortium.org/XMLSchema/SPIRIT/1685-2009"), "onSystem")) ~
      opt(IPXACT2009scalaxb.ElemName(Some("http://www.spiritconsortium.org/XMLSchema/SPIRIT/1685-2009"), "onMaster")) ~
      opt(IPXACT2009scalaxb.ElemName(Some("http://www.spiritconsortium.org/XMLSchema/SPIRIT/1685-2009"), "onSlave")) ~
      opt(((IPXACT2009scalaxb.ElemName(Some("http://www.spiritconsortium.org/XMLSchema/SPIRIT/1685-2009"), "defaultValue")) ^^
      (x => IPXACT2009scalaxb.DataRecord(x.namespace, Some(x.name), IPXACT2009scalaxb.fromXML[String](x, IPXACT2009scalaxb.ElemName(node) :: stack)))) |
      ((IPXACT2009scalaxb.ElemName(Some("http://www.spiritconsortium.org/XMLSchema/SPIRIT/1685-2009"), "requiresDriver")) ^^
      (x => IPXACT2009scalaxb.DataRecord(x.namespace, Some(x.name), IPXACT2009scalaxb.fromXML[RequiresDriver](x, IPXACT2009scalaxb.ElemName(node) :: stack))))) ^^
      { case p1 ~ p2 ~ p3 ~ p4 ~ p5 =>
      Wire(p1.headOption map { IPXACT2009scalaxb.fromXML[Qualifier](_, IPXACT2009scalaxb.ElemName(node) :: stack) },
        p2 map { IPXACT2009scalaxb.fromXML[OnSystem](_, IPXACT2009scalaxb.ElemName(node) :: stack) },
        p3.headOption map { IPXACT2009scalaxb.fromXML[OnMaster](_, IPXACT2009scalaxb.ElemName(node) :: stack) },
        p4.headOption map { IPXACT2009scalaxb.fromXML[OnSlave](_, IPXACT2009scalaxb.ElemName(node) :: stack) },
        p5) })
    
    def writesChildNodes(__obj: Wire, __scope: scala.xml.NamespaceBinding): Seq[scala.xml.Node] =
      Seq.concat(__obj.qualifier map { IPXACT2009scalaxb.toXML[Qualifier](_, Some("http://www.spiritconsortium.org/XMLSchema/SPIRIT/1685-2009"), Some("qualifier"), __scope, false) } getOrElse {Nil},
        __obj.onSystem flatMap { IPXACT2009scalaxb.toXML[OnSystem](_, Some("http://www.spiritconsortium.org/XMLSchema/SPIRIT/1685-2009"), Some("onSystem"), __scope, false) },
        __obj.onMaster map { IPXACT2009scalaxb.toXML[OnMaster](_, Some("http://www.spiritconsortium.org/XMLSchema/SPIRIT/1685-2009"), Some("onMaster"), __scope, false) } getOrElse {Nil},
        __obj.onSlave map { IPXACT2009scalaxb.toXML[OnSlave](_, Some("http://www.spiritconsortium.org/XMLSchema/SPIRIT/1685-2009"), Some("onSlave"), __scope, false) } getOrElse {Nil},
        __obj.wireoption map { x => IPXACT2009scalaxb.toXML[IPXACT2009scalaxb.DataRecord[Any]](x, x.namespace, x.key, __scope, false) } getOrElse {Nil})

  }

  trait Default_Qualifier2Format extends IPXACT2009scalaxb.ElemNameParser[Qualifier2] {
    val targetNamespace: Option[String] = Some("http://www.spiritconsortium.org/XMLSchema/SPIRIT/1685-2009")
    
    def parser(node: scala.xml.Node, stack: List[IPXACT2009scalaxb.ElemName]): Parser[Qualifier2] =
      phrase(opt(IPXACT2009scalaxb.ElemName(Some("http://www.spiritconsortium.org/XMLSchema/SPIRIT/1685-2009"), "isAddress")) ~
      opt(IPXACT2009scalaxb.ElemName(Some("http://www.spiritconsortium.org/XMLSchema/SPIRIT/1685-2009"), "isData")) ^^
      { case p1 ~ p2 =>
      Qualifier2(p1.headOption map { IPXACT2009scalaxb.fromXML[Boolean](_, IPXACT2009scalaxb.ElemName(node) :: stack) },
        p2.headOption map { IPXACT2009scalaxb.fromXML[Boolean](_, IPXACT2009scalaxb.ElemName(node) :: stack) }) })
    
    def writesChildNodes(__obj: Qualifier2, __scope: scala.xml.NamespaceBinding): Seq[scala.xml.Node] =
      Seq.concat(__obj.isAddress map { IPXACT2009scalaxb.toXML[Boolean](_, Some("http://www.spiritconsortium.org/XMLSchema/SPIRIT/1685-2009"), Some("isAddress"), __scope, false) } getOrElse {Nil},
        __obj.isData map { IPXACT2009scalaxb.toXML[Boolean](_, Some("http://www.spiritconsortium.org/XMLSchema/SPIRIT/1685-2009"), Some("isData"), __scope, false) } getOrElse {Nil})

  }

  trait Default_OnSystem2Format extends IPXACT2009scalaxb.ElemNameParser[OnSystem2] with _TransactionalPortGroupFormat {
    val targetNamespace: Option[String] = Some("http://www.spiritconsortium.org/XMLSchema/SPIRIT/1685-2009")
    
    def parser(node: scala.xml.Node, stack: List[IPXACT2009scalaxb.ElemName]): Parser[OnSystem2] =
      phrase((IPXACT2009scalaxb.ElemName(Some("http://www.spiritconsortium.org/XMLSchema/SPIRIT/1685-2009"), "group")) ~
      (parseTransactionalPortGroup(node, IPXACT2009scalaxb.ElemName(node) :: stack)) ^^
      { case p1 ~ p2 =>
      OnSystem2(IPXACT2009scalaxb.fromXML[String](p1, IPXACT2009scalaxb.ElemName(node) :: stack),
        p2) })
    
    def writesChildNodes(__obj: OnSystem2, __scope: scala.xml.NamespaceBinding): Seq[scala.xml.Node] =
      Seq.concat(IPXACT2009scalaxb.toXML[String](__obj.group, Some("http://www.spiritconsortium.org/XMLSchema/SPIRIT/1685-2009"), Some("group"), __scope, false),
        IPXACT2009scalaxb.toXML[TransactionalPortSequence](__obj.transactionalPortSequence2, None, Some("transactionalPortSequence2"), __scope, false))

  }

  trait Default_OnMaster2Format extends IPXACT2009scalaxb.ElemNameParser[OnMaster2] with _TransactionalPortGroupFormat {
    val targetNamespace: Option[String] = Some("http://www.spiritconsortium.org/XMLSchema/SPIRIT/1685-2009")
    
    def parser(node: scala.xml.Node, stack: List[IPXACT2009scalaxb.ElemName]): Parser[OnMaster2] =
      phrase((parseTransactionalPortGroup(node, IPXACT2009scalaxb.ElemName(node) :: stack)) ^^
      { case p1 =>
      OnMaster2(p1) })
    
    def writesChildNodes(__obj: OnMaster2, __scope: scala.xml.NamespaceBinding): Seq[scala.xml.Node] =
      (IPXACT2009scalaxb.toXML[TransactionalPortSequence](__obj.transactionalPortSequence1, None, Some("transactionalPortSequence1"), __scope, false))
  }
  trait Default_OnSlave2Format extends IPXACT2009scalaxb.ElemNameParser[OnSlave2] with _TransactionalPortGroupFormat {
    val targetNamespace: Option[String] = Some("http://www.spiritconsortium.org/XMLSchema/SPIRIT/1685-2009")
    
    def parser(node: scala.xml.Node, stack: List[IPXACT2009scalaxb.ElemName]): Parser[OnSlave2] =
      phrase((parseTransactionalPortGroup(node, IPXACT2009scalaxb.ElemName(node) :: stack)) ^^
      { case p1 =>
      OnSlave2(p1) })
    
    def writesChildNodes(__obj: OnSlave2, __scope: scala.xml.NamespaceBinding): Seq[scala.xml.Node] =
      (IPXACT2009scalaxb.toXML[TransactionalPortSequence](__obj.transactionalPortSequence1, None, Some("transactionalPortSequence1"), __scope, false))
  }
  trait Default_TransactionalFormat extends IPXACT2009scalaxb.ElemNameParser[Transactional] {
    val targetNamespace: Option[String] = Some("http://www.spiritconsortium.org/XMLSchema/SPIRIT/1685-2009")
    
    def parser(node: scala.xml.Node, stack: List[IPXACT2009scalaxb.ElemName]): Parser[Transactional] =
      phrase(opt(IPXACT2009scalaxb.ElemName(Some("http://www.spiritconsortium.org/XMLSchema/SPIRIT/1685-2009"), "qualifier")) ~
      safeRep(IPXACT2009scalaxb.ElemName(Some("http://www.spiritconsortium.org/XMLSchema/SPIRIT/1685-2009"), "onSystem")) ~
      opt(IPXACT2009scalaxb.ElemName(Some("http://www.spiritconsortium.org/XMLSchema/SPIRIT/1685-2009"), "onMaster")) ~
      opt(IPXACT2009scalaxb.ElemName(Some("http://www.spiritconsortium.org/XMLSchema/SPIRIT/1685-2009"), "onSlave")) ^^
      { case p1 ~ p2 ~ p3 ~ p4 =>
      Transactional(p1.headOption map { IPXACT2009scalaxb.fromXML[Qualifier2](_, IPXACT2009scalaxb.ElemName(node) :: stack) },
        p2 map { IPXACT2009scalaxb.fromXML[OnSystem2](_, IPXACT2009scalaxb.ElemName(node) :: stack) },
        p3.headOption map { IPXACT2009scalaxb.fromXML[OnMaster2](_, IPXACT2009scalaxb.ElemName(node) :: stack) },
        p4.headOption map { IPXACT2009scalaxb.fromXML[OnSlave2](_, IPXACT2009scalaxb.ElemName(node) :: stack) }) })
    
    def writesChildNodes(__obj: Transactional, __scope: scala.xml.NamespaceBinding): Seq[scala.xml.Node] =
      Seq.concat(__obj.qualifier map { IPXACT2009scalaxb.toXML[Qualifier2](_, Some("http://www.spiritconsortium.org/XMLSchema/SPIRIT/1685-2009"), Some("qualifier"), __scope, false) } getOrElse {Nil},
        __obj.onSystem flatMap { IPXACT2009scalaxb.toXML[OnSystem2](_, Some("http://www.spiritconsortium.org/XMLSchema/SPIRIT/1685-2009"), Some("onSystem"), __scope, false) },
        __obj.onMaster map { IPXACT2009scalaxb.toXML[OnMaster2](_, Some("http://www.spiritconsortium.org/XMLSchema/SPIRIT/1685-2009"), Some("onMaster"), __scope, false) } getOrElse {Nil},
        __obj.onSlave map { IPXACT2009scalaxb.toXML[OnSlave2](_, Some("http://www.spiritconsortium.org/XMLSchema/SPIRIT/1685-2009"), Some("onSlave"), __scope, false) } getOrElse {Nil})

  }

  trait Default_PortFormat extends IPXACT2009scalaxb.ElemNameParser[Port] {
    val targetNamespace: Option[String] = Some("http://www.spiritconsortium.org/XMLSchema/SPIRIT/1685-2009")
    
    def parser(node: scala.xml.Node, stack: List[IPXACT2009scalaxb.ElemName]): Parser[Port] =
      phrase((IPXACT2009scalaxb.ElemName(Some("http://www.spiritconsortium.org/XMLSchema/SPIRIT/1685-2009"), "logicalName")) ~
      opt(IPXACT2009scalaxb.ElemName(Some("http://www.spiritconsortium.org/XMLSchema/SPIRIT/1685-2009"), "displayName")) ~
      opt(IPXACT2009scalaxb.ElemName(Some("http://www.spiritconsortium.org/XMLSchema/SPIRIT/1685-2009"), "description")) ~
      (((IPXACT2009scalaxb.ElemName(Some("http://www.spiritconsortium.org/XMLSchema/SPIRIT/1685-2009"), "wire")) ^^
      (x => IPXACT2009scalaxb.DataRecord(x.namespace, Some(x.name), IPXACT2009scalaxb.fromXML[Wire](x, IPXACT2009scalaxb.ElemName(node) :: stack)))) |
      ((IPXACT2009scalaxb.ElemName(Some("http://www.spiritconsortium.org/XMLSchema/SPIRIT/1685-2009"), "transactional")) ^^
      (x => IPXACT2009scalaxb.DataRecord(x.namespace, Some(x.name), IPXACT2009scalaxb.fromXML[Transactional](x, IPXACT2009scalaxb.ElemName(node) :: stack))))) ~
      opt(IPXACT2009scalaxb.ElemName(Some("http://www.spiritconsortium.org/XMLSchema/SPIRIT/1685-2009"), "vendorExtensions")) ^^
      { case p1 ~ p2 ~ p3 ~ p4 ~ p5 =>
      Port(IPXACT2009scalaxb.fromXML[String](p1, IPXACT2009scalaxb.ElemName(node) :: stack),
        p2.headOption map { IPXACT2009scalaxb.fromXML[String](_, IPXACT2009scalaxb.ElemName(node) :: stack) },
        p3.headOption map { IPXACT2009scalaxb.fromXML[String](_, IPXACT2009scalaxb.ElemName(node) :: stack) },
        p4,
        p5.headOption map { IPXACT2009scalaxb.fromXML[VendorExtensions](_, IPXACT2009scalaxb.ElemName(node) :: stack) }) })
    
    def writesChildNodes(__obj: Port, __scope: scala.xml.NamespaceBinding): Seq[scala.xml.Node] =
      Seq.concat(IPXACT2009scalaxb.toXML[String](__obj.logicalName, Some("http://www.spiritconsortium.org/XMLSchema/SPIRIT/1685-2009"), Some("logicalName"), __scope, false),
        __obj.displayName map { IPXACT2009scalaxb.toXML[String](_, Some("http://www.spiritconsortium.org/XMLSchema/SPIRIT/1685-2009"), Some("displayName"), __scope, false) } getOrElse {Nil},
        __obj.description map { IPXACT2009scalaxb.toXML[String](_, Some("http://www.spiritconsortium.org/XMLSchema/SPIRIT/1685-2009"), Some("description"), __scope, false) } getOrElse {Nil},
        (Some(__obj.portoption) map {x => IPXACT2009scalaxb.toXML[IPXACT2009scalaxb.DataRecord[PortOption]](x, x.namespace, x.key, __scope, false)}).get,
        __obj.vendorExtensions map { IPXACT2009scalaxb.toXML[VendorExtensions](_, Some("http://www.spiritconsortium.org/XMLSchema/SPIRIT/1685-2009"), Some("vendorExtensions"), __scope, false) } getOrElse {Nil})

  }

  trait Default_Ports3Format extends IPXACT2009scalaxb.ElemNameParser[Ports3] {
    val targetNamespace: Option[String] = Some("http://www.spiritconsortium.org/XMLSchema/SPIRIT/1685-2009")
    
    def parser(node: scala.xml.Node, stack: List[IPXACT2009scalaxb.ElemName]): Parser[Ports3] =
      phrase(safeRep(IPXACT2009scalaxb.ElemName(Some("http://www.spiritconsortium.org/XMLSchema/SPIRIT/1685-2009"), "port")) ^^
      { case p1 =>
      Ports3(p1 map { IPXACT2009scalaxb.fromXML[Port](_, IPXACT2009scalaxb.ElemName(node) :: stack) }) })
    
    def writesChildNodes(__obj: Ports3, __scope: scala.xml.NamespaceBinding): Seq[scala.xml.Node] =
      (__obj.port flatMap { IPXACT2009scalaxb.toXML[Port](_, Some("http://www.spiritconsortium.org/XMLSchema/SPIRIT/1685-2009"), Some("port"), __scope, false) })
  }
  trait Default_AbstractionDefinitionFormat extends IPXACT2009scalaxb.ElemNameParser[AbstractionDefinition] with _VersionedIdentifierGroupFormat {
    val targetNamespace: Option[String] = Some("http://www.spiritconsortium.org/XMLSchema/SPIRIT/1685-2009")
    
    def parser(node: scala.xml.Node, stack: List[IPXACT2009scalaxb.ElemName]): Parser[AbstractionDefinition] =
      phrase((parseVersionedIdentifierGroup(node, IPXACT2009scalaxb.ElemName(node) :: stack)) ~
      (IPXACT2009scalaxb.ElemName(Some("http://www.spiritconsortium.org/XMLSchema/SPIRIT/1685-2009"), "busType")) ~
      opt(IPXACT2009scalaxb.ElemName(Some("http://www.spiritconsortium.org/XMLSchema/SPIRIT/1685-2009"), "extends")) ~
      (IPXACT2009scalaxb.ElemName(Some("http://www.spiritconsortium.org/XMLSchema/SPIRIT/1685-2009"), "ports")) ~
      opt(IPXACT2009scalaxb.ElemName(Some("http://www.spiritconsortium.org/XMLSchema/SPIRIT/1685-2009"), "description")) ~
      opt(IPXACT2009scalaxb.ElemName(Some("http://www.spiritconsortium.org/XMLSchema/SPIRIT/1685-2009"), "vendorExtensions")) ^^
      { case p1 ~ p2 ~ p3 ~ p4 ~ p5 ~ p6 =>
      AbstractionDefinition(p1,
        IPXACT2009scalaxb.fromXML[LibraryRefType](p2, IPXACT2009scalaxb.ElemName(node) :: stack),
        p3.headOption map { IPXACT2009scalaxb.fromXML[LibraryRefType](_, IPXACT2009scalaxb.ElemName(node) :: stack) },
        IPXACT2009scalaxb.fromXML[Ports3](p4, IPXACT2009scalaxb.ElemName(node) :: stack),
        p5.headOption map { IPXACT2009scalaxb.fromXML[String](_, IPXACT2009scalaxb.ElemName(node) :: stack) },
        p6.headOption map { IPXACT2009scalaxb.fromXML[VendorExtensions](_, IPXACT2009scalaxb.ElemName(node) :: stack) }) })
    
    def writesChildNodes(__obj: AbstractionDefinition, __scope: scala.xml.NamespaceBinding): Seq[scala.xml.Node] =
      Seq.concat(IPXACT2009scalaxb.toXML[VersionedIdentifierSequence](__obj.versionedIdentifierSequence1, None, Some("versionedIdentifierSequence1"), __scope, false),
        IPXACT2009scalaxb.toXML[LibraryRefType](__obj.busType, Some("http://www.spiritconsortium.org/XMLSchema/SPIRIT/1685-2009"), Some("busType"), __scope, false),
        __obj.extendsValue map { IPXACT2009scalaxb.toXML[LibraryRefType](_, Some("http://www.spiritconsortium.org/XMLSchema/SPIRIT/1685-2009"), Some("extends"), __scope, false) } getOrElse {Nil},
        IPXACT2009scalaxb.toXML[Ports3](__obj.ports, Some("http://www.spiritconsortium.org/XMLSchema/SPIRIT/1685-2009"), Some("ports"), __scope, false),
        __obj.description map { IPXACT2009scalaxb.toXML[String](_, Some("http://www.spiritconsortium.org/XMLSchema/SPIRIT/1685-2009"), Some("description"), __scope, false) } getOrElse {Nil},
        __obj.vendorExtensions map { IPXACT2009scalaxb.toXML[VendorExtensions](_, Some("http://www.spiritconsortium.org/XMLSchema/SPIRIT/1685-2009"), Some("vendorExtensions"), __scope, false) } getOrElse {Nil})

  }


/** Group of elements used in a wire port.
*/
  trait _WirePortGroupFormat extends IPXACT2009scalaxb.AnyElemNameParser {
    def parseWirePortGroup(node: scala.xml.Node, stack: List[IPXACT2009scalaxb.ElemName]): Parser[WirePortSequence] =
      ((opt(IPXACT2009scalaxb.ElemName(Some("http://www.spiritconsortium.org/XMLSchema/SPIRIT/1685-2009"), "presence")) ~
      opt(IPXACT2009scalaxb.ElemName(Some("http://www.spiritconsortium.org/XMLSchema/SPIRIT/1685-2009"), "width")) ~
      opt(IPXACT2009scalaxb.ElemName(Some("http://www.spiritconsortium.org/XMLSchema/SPIRIT/1685-2009"), "direction")) ~
      opt(((IPXACT2009scalaxb.ElemName(Some("http://www.spiritconsortium.org/XMLSchema/SPIRIT/1685-2009"), "modeConstraints")) ~
      opt(IPXACT2009scalaxb.ElemName(Some("http://www.spiritconsortium.org/XMLSchema/SPIRIT/1685-2009"), "mirroredModeConstraints"))) ^^
        { case p1 ~ p2 => WirePortSequence2(IPXACT2009scalaxb.fromXML[AbstractionDefPortConstraintsType](p1, IPXACT2009scalaxb.ElemName(node) :: stack),
        p2.headOption map { IPXACT2009scalaxb.fromXML[AbstractionDefPortConstraintsType](_, IPXACT2009scalaxb.ElemName(node) :: stack) }) })) ^^
        { case p1 ~ p2 ~ p3 ~ p4 => WirePortSequence(p1.headOption map { IPXACT2009scalaxb.fromXML[Presence](_, IPXACT2009scalaxb.ElemName(node) :: stack) },
        p2.headOption map { IPXACT2009scalaxb.fromXML[BigInt](_, IPXACT2009scalaxb.ElemName(node) :: stack) },
        p3.headOption map { IPXACT2009scalaxb.fromXML[Direction](_, IPXACT2009scalaxb.ElemName(node) :: stack) },
        p4) })
  
    def parseWirePortGroup(node: scala.xml.Node, stack: List[IPXACT2009scalaxb.ElemName], wrap: Boolean): Parser[IPXACT2009scalaxb.DataRecord[Any]] =
      ((opt(IPXACT2009scalaxb.ElemName(Some("http://www.spiritconsortium.org/XMLSchema/SPIRIT/1685-2009"), "presence")) ~
      opt(IPXACT2009scalaxb.ElemName(Some("http://www.spiritconsortium.org/XMLSchema/SPIRIT/1685-2009"), "width")) ~
      opt(IPXACT2009scalaxb.ElemName(Some("http://www.spiritconsortium.org/XMLSchema/SPIRIT/1685-2009"), "direction")) ~
      opt(((IPXACT2009scalaxb.ElemName(Some("http://www.spiritconsortium.org/XMLSchema/SPIRIT/1685-2009"), "modeConstraints")) ~
      opt(IPXACT2009scalaxb.ElemName(Some("http://www.spiritconsortium.org/XMLSchema/SPIRIT/1685-2009"), "mirroredModeConstraints"))) ^^
        { case p1 ~ p2 => WirePortSequence2(IPXACT2009scalaxb.fromXML[AbstractionDefPortConstraintsType](p1, IPXACT2009scalaxb.ElemName(node) :: stack),
        p2.headOption map { IPXACT2009scalaxb.fromXML[AbstractionDefPortConstraintsType](_, IPXACT2009scalaxb.ElemName(node) :: stack) }) })) ^^
        { case p1 ~ p2 ~ p3 ~ p4 => IPXACT2009scalaxb.DataRecord(WirePortSequence(p1.headOption map { IPXACT2009scalaxb.fromXML[Presence](_, IPXACT2009scalaxb.ElemName(node) :: stack) },
        p2.headOption map { IPXACT2009scalaxb.fromXML[BigInt](_, IPXACT2009scalaxb.ElemName(node) :: stack) },
        p3.headOption map { IPXACT2009scalaxb.fromXML[Direction](_, IPXACT2009scalaxb.ElemName(node) :: stack) },
        p4)) })
    
    def parsemixedWirePortGroup(node: scala.xml.Node, stack: List[IPXACT2009scalaxb.ElemName]): Parser[Seq[IPXACT2009scalaxb.DataRecord[Any]]] =
      (((opt(IPXACT2009scalaxb.ElemName(Some("http://www.spiritconsortium.org/XMLSchema/SPIRIT/1685-2009"), "presence")) ^^
      (_ map { x => IPXACT2009scalaxb.DataRecord(x.namespace, Some(x.name), IPXACT2009scalaxb.fromXML[String](x, IPXACT2009scalaxb.ElemName(node) :: stack)) })) ~
      optTextRecord ~ 
      (opt(IPXACT2009scalaxb.ElemName(Some("http://www.spiritconsortium.org/XMLSchema/SPIRIT/1685-2009"), "width")) ^^
      (_ map { x => IPXACT2009scalaxb.DataRecord(x.namespace, Some(x.name), IPXACT2009scalaxb.fromXML[BigInt](x, IPXACT2009scalaxb.ElemName(node) :: stack)) })) ~
      optTextRecord ~ 
      (opt(IPXACT2009scalaxb.ElemName(Some("http://www.spiritconsortium.org/XMLSchema/SPIRIT/1685-2009"), "direction")) ^^
      (_ map { x => IPXACT2009scalaxb.DataRecord(x.namespace, Some(x.name), IPXACT2009scalaxb.fromXML[String](x, IPXACT2009scalaxb.ElemName(node) :: stack)) })) ~
      optTextRecord ~ 
      opt((((IPXACT2009scalaxb.ElemName(Some("http://www.spiritconsortium.org/XMLSchema/SPIRIT/1685-2009"), "modeConstraints")) ^^
      (x => IPXACT2009scalaxb.DataRecord(x.namespace, Some(x.name), IPXACT2009scalaxb.fromXML[AbstractionDefPortConstraintsType](x, IPXACT2009scalaxb.ElemName(node) :: stack)))) ~
      optTextRecord ~ 
      (opt(IPXACT2009scalaxb.ElemName(Some("http://www.spiritconsortium.org/XMLSchema/SPIRIT/1685-2009"), "mirroredModeConstraints")) ^^
      (_ map { x => IPXACT2009scalaxb.DataRecord(x.namespace, Some(x.name), IPXACT2009scalaxb.fromXML[AbstractionDefPortConstraintsType](x, IPXACT2009scalaxb.ElemName(node) :: stack)) })) ~
      optTextRecord) ^^ 
        { case p1 ~ p2 ~ p3 ~ p4 => Seq.concat(Seq(p1),
        p2.toList,
        p3.toList,
        p4.toList) }) ~ 
      optTextRecord) ^^ 
        { case p1 ~ p2 ~ p3 ~ p4 ~ p5 ~ p6 ~ p7 ~ p8 => Seq.concat(p1.toList,
        p2.toList,
        p3.toList,
        p4.toList,
        p5.toList,
        p6.toList,
        p7 getOrElse {Nil},
        p8.toList) })
  }

  trait Default_WirePortSequenceFormat extends IPXACT2009scalaxb.XMLFormat[WirePortSequence] {
    def reads(seq: scala.xml.NodeSeq, stack: List[IPXACT2009scalaxb.ElemName]): Either[String, WirePortSequence] = Left("don't call me.")
    
    def writes(__obj: WirePortSequence, __namespace: Option[String], __elementLabel: Option[String], 
        __scope: scala.xml.NamespaceBinding, __typeAttribute: Boolean): scala.xml.NodeSeq =
      Seq.concat(__obj.presence map { IPXACT2009scalaxb.toXML[Presence](_, Some("http://www.spiritconsortium.org/XMLSchema/SPIRIT/1685-2009"), Some("presence"), __scope, false) } getOrElse {Nil},
        __obj.width map { IPXACT2009scalaxb.toXML[BigInt](_, Some("http://www.spiritconsortium.org/XMLSchema/SPIRIT/1685-2009"), Some("width"), __scope, false) } getOrElse {Nil},
        __obj.direction map { IPXACT2009scalaxb.toXML[Direction](_, Some("http://www.spiritconsortium.org/XMLSchema/SPIRIT/1685-2009"), Some("direction"), __scope, false) } getOrElse {Nil},
        __obj.wireportsequence2 map { IPXACT2009scalaxb.toXML[WirePortSequence2](_, None, Some("wireportsequence2"), __scope, false) } getOrElse {Nil})


  }

  trait Default_WirePortSequence2Format extends IPXACT2009scalaxb.XMLFormat[WirePortSequence2] {
    def reads(seq: scala.xml.NodeSeq, stack: List[IPXACT2009scalaxb.ElemName]): Either[String, WirePortSequence2] = Left("don't call me.")
    
    def writes(__obj: WirePortSequence2, __namespace: Option[String], __elementLabel: Option[String], 
        __scope: scala.xml.NamespaceBinding, __typeAttribute: Boolean): scala.xml.NodeSeq =
      Seq.concat(IPXACT2009scalaxb.toXML[AbstractionDefPortConstraintsType](__obj.modeConstraints, Some("http://www.spiritconsortium.org/XMLSchema/SPIRIT/1685-2009"), Some("modeConstraints"), __scope, false),
        __obj.mirroredModeConstraints map { IPXACT2009scalaxb.toXML[AbstractionDefPortConstraintsType](_, Some("http://www.spiritconsortium.org/XMLSchema/SPIRIT/1685-2009"), Some("mirroredModeConstraints"), __scope, false) } getOrElse {Nil})


  }


/** Group of elements used in a transactional port.
*/
  trait _TransactionalPortGroupFormat extends IPXACT2009scalaxb.AnyElemNameParser {
    def parseTransactionalPortGroup(node: scala.xml.Node, stack: List[IPXACT2009scalaxb.ElemName]): Parser[TransactionalPortSequence] =
      ((opt(IPXACT2009scalaxb.ElemName(Some("http://www.spiritconsortium.org/XMLSchema/SPIRIT/1685-2009"), "presence")) ~
      (IPXACT2009scalaxb.ElemName(Some("http://www.spiritconsortium.org/XMLSchema/SPIRIT/1685-2009"), "service"))) ^^
        { case p1 ~ p2 => TransactionalPortSequence(p1.headOption map { IPXACT2009scalaxb.fromXML[Presence](_, IPXACT2009scalaxb.ElemName(node) :: stack) },
        IPXACT2009scalaxb.fromXML[ServiceType](p2, IPXACT2009scalaxb.ElemName(node) :: stack)) })
  
    def parseTransactionalPortGroup(node: scala.xml.Node, stack: List[IPXACT2009scalaxb.ElemName], wrap: Boolean): Parser[IPXACT2009scalaxb.DataRecord[Any]] =
      ((opt(IPXACT2009scalaxb.ElemName(Some("http://www.spiritconsortium.org/XMLSchema/SPIRIT/1685-2009"), "presence")) ~
      (IPXACT2009scalaxb.ElemName(Some("http://www.spiritconsortium.org/XMLSchema/SPIRIT/1685-2009"), "service"))) ^^
        { case p1 ~ p2 => IPXACT2009scalaxb.DataRecord(TransactionalPortSequence(p1.headOption map { IPXACT2009scalaxb.fromXML[Presence](_, IPXACT2009scalaxb.ElemName(node) :: stack) },
        IPXACT2009scalaxb.fromXML[ServiceType](p2, IPXACT2009scalaxb.ElemName(node) :: stack))) })
    
    def parsemixedTransactionalPortGroup(node: scala.xml.Node, stack: List[IPXACT2009scalaxb.ElemName]): Parser[Seq[IPXACT2009scalaxb.DataRecord[Any]]] =
      (((opt(IPXACT2009scalaxb.ElemName(Some("http://www.spiritconsortium.org/XMLSchema/SPIRIT/1685-2009"), "presence")) ^^
      (_ map { x => IPXACT2009scalaxb.DataRecord(x.namespace, Some(x.name), IPXACT2009scalaxb.fromXML[String](x, IPXACT2009scalaxb.ElemName(node) :: stack)) })) ~
      optTextRecord ~ 
      ((IPXACT2009scalaxb.ElemName(Some("http://www.spiritconsortium.org/XMLSchema/SPIRIT/1685-2009"), "service")) ^^
      (x => IPXACT2009scalaxb.DataRecord(x.namespace, Some(x.name), IPXACT2009scalaxb.fromXML[ServiceType](x, IPXACT2009scalaxb.ElemName(node) :: stack)))) ~
      optTextRecord) ^^ 
        { case p1 ~ p2 ~ p3 ~ p4 => Seq.concat(p1.toList,
        p2.toList,
        Seq(p3),
        p4.toList) })
  }

  trait Default_TransactionalPortSequenceFormat extends IPXACT2009scalaxb.XMLFormat[TransactionalPortSequence] {
    def reads(seq: scala.xml.NodeSeq, stack: List[IPXACT2009scalaxb.ElemName]): Either[String, TransactionalPortSequence] = Left("don't call me.")
    
    def writes(__obj: TransactionalPortSequence, __namespace: Option[String], __elementLabel: Option[String], 
        __scope: scala.xml.NamespaceBinding, __typeAttribute: Boolean): scala.xml.NodeSeq =
      Seq.concat(__obj.presence map { IPXACT2009scalaxb.toXML[Presence](_, Some("http://www.spiritconsortium.org/XMLSchema/SPIRIT/1685-2009"), Some("presence"), __scope, false) } getOrElse {Nil},
        IPXACT2009scalaxb.toXML[ServiceType](__obj.service, Some("http://www.spiritconsortium.org/XMLSchema/SPIRIT/1685-2009"), Some("service"), __scope, false))


  }

  trait Default_AbstractorModeFormat extends IPXACT2009scalaxb.XMLFormat[AbstractorMode] with IPXACT2009scalaxb.CanWriteChildNodes[AbstractorMode] {
    val targetNamespace: Option[String] = Some("http://www.spiritconsortium.org/XMLSchema/SPIRIT/1685-2009")
    def reads(seq: scala.xml.NodeSeq, stack: List[IPXACT2009scalaxb.ElemName]): Either[String, AbstractorMode] = seq match {
      case node: scala.xml.Node => Right(AbstractorMode(IPXACT2009scalaxb.fromXML[AbstractorModeType](node, IPXACT2009scalaxb.ElemName(node) :: stack),
        scala.collection.immutable.ListMap(List(
        (node \ "@{http://www.spiritconsortium.org/XMLSchema/SPIRIT/1685-2009}group").headOption map { x => IPXACT2009scalaxb.DataRecord(x, node, IPXACT2009scalaxb.fromXML[String](x, IPXACT2009scalaxb.ElemName(node) :: stack)) } map { "@group" -> _ }
        ).flatten[(String, IPXACT2009scalaxb.DataRecord[Any])]: _*)))
      case _ => Left("reads failed: seq must be scala.xml.Node")
    }
    
    override def writesAttribute(__obj: AbstractorMode, __scope: scala.xml.NamespaceBinding): scala.xml.MetaData = {
      var attr: scala.xml.MetaData  = scala.xml.Null
      __obj.attributes.toList map {
        case ("@group", _) => __obj.group foreach { x => attr = scala.xml.Attribute(__scope.getPrefix("http://www.spiritconsortium.org/XMLSchema/SPIRIT/1685-2009"), "group", x.toString, attr) }
        case (key, x) => attr = scala.xml.Attribute((x.namespace map { __scope.getPrefix(_) }).orNull, x.key.orNull, x.value.toString, attr)
      }
      attr
    }

    def writesChildNodes(__obj: AbstractorMode, __scope: scala.xml.NamespaceBinding): Seq[scala.xml.Node] =
      Seq(scala.xml.Text(__obj.value.toString))

  }

  trait Default_AbstractorInterfacesFormat extends IPXACT2009scalaxb.ElemNameParser[AbstractorInterfaces] {
    val targetNamespace: Option[String] = Some("http://www.spiritconsortium.org/XMLSchema/SPIRIT/1685-2009")
    
    def parser(node: scala.xml.Node, stack: List[IPXACT2009scalaxb.ElemName]): Parser[AbstractorInterfaces] =
      phrase(safeRep(IPXACT2009scalaxb.ElemName(Some("http://www.spiritconsortium.org/XMLSchema/SPIRIT/1685-2009"), "abstractorInterface")) ^^
      { case p1 =>
      AbstractorInterfaces(p1 map { IPXACT2009scalaxb.fromXML[AbstractorBusInterfaceType](_, IPXACT2009scalaxb.ElemName(node) :: stack) }) })
    
    def writesChildNodes(__obj: AbstractorInterfaces, __scope: scala.xml.NamespaceBinding): Seq[scala.xml.Node] =
      (__obj.abstractorInterface flatMap { IPXACT2009scalaxb.toXML[AbstractorBusInterfaceType](_, Some("http://www.spiritconsortium.org/XMLSchema/SPIRIT/1685-2009"), Some("abstractorInterface"), __scope, false) })
  }
  trait Default_AbstractorTypeFormat extends IPXACT2009scalaxb.ElemNameParser[AbstractorType] with _VersionedIdentifierGroupFormat {
    val targetNamespace: Option[String] = Some("http://www.spiritconsortium.org/XMLSchema/SPIRIT/1685-2009")
    
    override def typeName: Option[String] = Some("abstractorType")

    def parser(node: scala.xml.Node, stack: List[IPXACT2009scalaxb.ElemName]): Parser[AbstractorType] =
      phrase((parseVersionedIdentifierGroup(node, IPXACT2009scalaxb.ElemName(node) :: stack)) ~
      (IPXACT2009scalaxb.ElemName(Some("http://www.spiritconsortium.org/XMLSchema/SPIRIT/1685-2009"), "abstractorMode")) ~
      (IPXACT2009scalaxb.ElemName(Some("http://www.spiritconsortium.org/XMLSchema/SPIRIT/1685-2009"), "busType")) ~
      (IPXACT2009scalaxb.ElemName(Some("http://www.spiritconsortium.org/XMLSchema/SPIRIT/1685-2009"), "abstractorInterfaces")) ~
      opt(IPXACT2009scalaxb.ElemName(Some("http://www.spiritconsortium.org/XMLSchema/SPIRIT/1685-2009"), "model")) ~
      opt(IPXACT2009scalaxb.ElemName(Some("http://www.spiritconsortium.org/XMLSchema/SPIRIT/1685-2009"), "abstractorGenerators")) ~
      opt(IPXACT2009scalaxb.ElemName(Some("http://www.spiritconsortium.org/XMLSchema/SPIRIT/1685-2009"), "choices")) ~
      opt(IPXACT2009scalaxb.ElemName(Some("http://www.spiritconsortium.org/XMLSchema/SPIRIT/1685-2009"), "fileSets")) ~
      opt(IPXACT2009scalaxb.ElemName(Some("http://www.spiritconsortium.org/XMLSchema/SPIRIT/1685-2009"), "description")) ~
      opt(IPXACT2009scalaxb.ElemName(Some("http://www.spiritconsortium.org/XMLSchema/SPIRIT/1685-2009"), "parameters")) ~
      opt(IPXACT2009scalaxb.ElemName(Some("http://www.spiritconsortium.org/XMLSchema/SPIRIT/1685-2009"), "vendorExtensions")) ^^
      { case p1 ~ p2 ~ p3 ~ p4 ~ p5 ~ p6 ~ p7 ~ p8 ~ p9 ~ p10 ~ p11 =>
      AbstractorType(p1,
        IPXACT2009scalaxb.fromXML[AbstractorMode](p2, IPXACT2009scalaxb.ElemName(node) :: stack),
        IPXACT2009scalaxb.fromXML[LibraryRefType](p3, IPXACT2009scalaxb.ElemName(node) :: stack),
        IPXACT2009scalaxb.fromXML[AbstractorInterfaces](p4, IPXACT2009scalaxb.ElemName(node) :: stack),
        p5.headOption map { IPXACT2009scalaxb.fromXML[AbstractorModelType](_, IPXACT2009scalaxb.ElemName(node) :: stack) },
        p6.headOption map { IPXACT2009scalaxb.fromXML[AbstractorGenerators](_, IPXACT2009scalaxb.ElemName(node) :: stack) },
        p7.headOption map { IPXACT2009scalaxb.fromXML[Choices](_, IPXACT2009scalaxb.ElemName(node) :: stack) },
        p8.headOption map { IPXACT2009scalaxb.fromXML[FileSets](_, IPXACT2009scalaxb.ElemName(node) :: stack) },
        p9.headOption map { IPXACT2009scalaxb.fromXML[String](_, IPXACT2009scalaxb.ElemName(node) :: stack) },
        p10.headOption map { IPXACT2009scalaxb.fromXML[Parameters](_, IPXACT2009scalaxb.ElemName(node) :: stack) },
        p11.headOption map { IPXACT2009scalaxb.fromXML[VendorExtensions](_, IPXACT2009scalaxb.ElemName(node) :: stack) }) })
    
    def writesChildNodes(__obj: AbstractorType, __scope: scala.xml.NamespaceBinding): Seq[scala.xml.Node] =
      Seq.concat(IPXACT2009scalaxb.toXML[VersionedIdentifierSequence](__obj.versionedIdentifierSequence1, None, Some("versionedIdentifierSequence1"), __scope, false),
        IPXACT2009scalaxb.toXML[AbstractorMode](__obj.abstractorMode, Some("http://www.spiritconsortium.org/XMLSchema/SPIRIT/1685-2009"), Some("abstractorMode"), __scope, false),
        IPXACT2009scalaxb.toXML[LibraryRefType](__obj.busType, Some("http://www.spiritconsortium.org/XMLSchema/SPIRIT/1685-2009"), Some("busType"), __scope, false),
        IPXACT2009scalaxb.toXML[AbstractorInterfaces](__obj.abstractorInterfaces, Some("http://www.spiritconsortium.org/XMLSchema/SPIRIT/1685-2009"), Some("abstractorInterfaces"), __scope, false),
        __obj.model map { IPXACT2009scalaxb.toXML[AbstractorModelType](_, Some("http://www.spiritconsortium.org/XMLSchema/SPIRIT/1685-2009"), Some("model"), __scope, false) } getOrElse {Nil},
        __obj.abstractorGenerators map { IPXACT2009scalaxb.toXML[AbstractorGenerators](_, Some("http://www.spiritconsortium.org/XMLSchema/SPIRIT/1685-2009"), Some("abstractorGenerators"), __scope, false) } getOrElse {Nil},
        __obj.choices map { IPXACT2009scalaxb.toXML[Choices](_, Some("http://www.spiritconsortium.org/XMLSchema/SPIRIT/1685-2009"), Some("choices"), __scope, false) } getOrElse {Nil},
        __obj.fileSets map { IPXACT2009scalaxb.toXML[FileSets](_, Some("http://www.spiritconsortium.org/XMLSchema/SPIRIT/1685-2009"), Some("fileSets"), __scope, false) } getOrElse {Nil},
        __obj.description map { IPXACT2009scalaxb.toXML[String](_, Some("http://www.spiritconsortium.org/XMLSchema/SPIRIT/1685-2009"), Some("description"), __scope, false) } getOrElse {Nil},
        __obj.parameters map { IPXACT2009scalaxb.toXML[Parameters](_, Some("http://www.spiritconsortium.org/XMLSchema/SPIRIT/1685-2009"), Some("parameters"), __scope, false) } getOrElse {Nil},
        __obj.vendorExtensions map { IPXACT2009scalaxb.toXML[VendorExtensions](_, Some("http://www.spiritconsortium.org/XMLSchema/SPIRIT/1685-2009"), Some("vendorExtensions"), __scope, false) } getOrElse {Nil})

  }

  def build_AbstractorModeTypeFormat = new Default_AbstractorModeTypeFormat {}
  trait Default_AbstractorModeTypeFormat extends IPXACT2009scalaxb.XMLFormat[AbstractorModeType] {
    val targetNamespace: Option[String] = Some("http://www.spiritconsortium.org/XMLSchema/SPIRIT/1685-2009")
    
    def fromString(value: String, scope: scala.xml.NamespaceBinding): AbstractorModeType =
        (fromString0(value, scope)).apply(IPXACT2009scalaxb.fromXML[String](scala.xml.Text(value)))

    private def fromString0(value: String, scope: scala.xml.NamespaceBinding): PartialFunction[Any, AbstractorModeType] = {
      case x: String if x == IPXACT2009scalaxb.fromXML[String](scala.xml.Text("master")) => MasterValue
      case x: String if x == IPXACT2009scalaxb.fromXML[String](scala.xml.Text("slave")) => SlaveValue
      case x: String if x == IPXACT2009scalaxb.fromXML[String](scala.xml.Text("direct")) => Direct
      case x: String if x == IPXACT2009scalaxb.fromXML[String](scala.xml.Text("system")) => SystemValue

    }



    def reads(seq: scala.xml.NodeSeq, stack: List[IPXACT2009scalaxb.ElemName]): Either[String, AbstractorModeType] = seq match {
      case elem: scala.xml.Elem => Right(fromString(elem.text, elem.scope))
      case _ => Right(fromString(seq.text, scala.xml.TopScope))
    }
    
    def writes(__obj: AbstractorModeType, __namespace: Option[String], __elementLabel: Option[String],
        __scope: scala.xml.NamespaceBinding, __typeAttribute: Boolean): scala.xml.NodeSeq =
      scala.xml.Elem(IPXACT2009scalaxb.Helper.getPrefix(__namespace, __scope).orNull,
        __elementLabel getOrElse { sys.error("missing element label.") },
        scala.xml.Null, __scope, true, scala.xml.Text(__obj.toString))
  }
  def build_FormatTypeFormat = new Default_FormatTypeFormat {}
  trait Default_FormatTypeFormat extends IPXACT2009scalaxb.XMLFormat[FormatType] {
    val targetNamespace: Option[String] = Some("http://www.spiritconsortium.org/XMLSchema/SPIRIT/1685-2009")
    
    def fromString(value: String, scope: scala.xml.NamespaceBinding): FormatType =
        (fromString0(value, scope)).apply(IPXACT2009scalaxb.fromXML[String](scala.xml.Text(value)))

    private def fromString0(value: String, scope: scala.xml.NamespaceBinding): PartialFunction[Any, FormatType] = {
      case x: String if x == IPXACT2009scalaxb.fromXML[String](scala.xml.Text("bitString")) => BitString
      case x: String if x == IPXACT2009scalaxb.fromXML[String](scala.xml.Text("bool")) => Bool
      case x: String if x == IPXACT2009scalaxb.fromXML[String](scala.xml.Text("float")) => FloatTypeValue
      case x: String if x == IPXACT2009scalaxb.fromXML[String](scala.xml.Text("long")) => LongTypeValue
      case x: String if x == IPXACT2009scalaxb.fromXML[String](scala.xml.Text("string")) => StringType

    }



    def reads(seq: scala.xml.NodeSeq, stack: List[IPXACT2009scalaxb.ElemName]): Either[String, FormatType] = seq match {
      case elem: scala.xml.Elem => Right(fromString(elem.text, elem.scope))
      case _ => Right(fromString(seq.text, scala.xml.TopScope))
    }
    
    def writes(__obj: FormatType, __namespace: Option[String], __elementLabel: Option[String],
        __scope: scala.xml.NamespaceBinding, __typeAttribute: Boolean): scala.xml.NodeSeq =
      scala.xml.Elem(IPXACT2009scalaxb.Helper.getPrefix(__namespace, __scope).orNull,
        __elementLabel getOrElse { sys.error("missing element label.") },
        scala.xml.Null, __scope, true, scala.xml.Text(__obj.toString))
  }
  def build_RangeTypeTypeFormat = new Default_RangeTypeTypeFormat {}
  trait Default_RangeTypeTypeFormat extends IPXACT2009scalaxb.XMLFormat[RangeTypeType] {
    val targetNamespace: Option[String] = Some("http://www.spiritconsortium.org/XMLSchema/SPIRIT/1685-2009")
    
    def fromString(value: String, scope: scala.xml.NamespaceBinding): RangeTypeType =
        (fromString0(value, scope)).apply(IPXACT2009scalaxb.fromXML[String](scala.xml.Text(value)))

    private def fromString0(value: String, scope: scala.xml.NamespaceBinding): PartialFunction[Any, RangeTypeType] = {
      case x: String if x == IPXACT2009scalaxb.fromXML[String](scala.xml.Text("float")) => FloatTypeValue2
      case x: String if x == IPXACT2009scalaxb.fromXML[String](scala.xml.Text("int")) => IntTypeValue
      case x: String if x == IPXACT2009scalaxb.fromXML[String](scala.xml.Text("unsigned int")) => UnsignedintValue
      case x: String if x == IPXACT2009scalaxb.fromXML[String](scala.xml.Text("long")) => LongTypeValue2
      case x: String if x == IPXACT2009scalaxb.fromXML[String](scala.xml.Text("unsigned long")) => UnsignedlongValue

    }



    def reads(seq: scala.xml.NodeSeq, stack: List[IPXACT2009scalaxb.ElemName]): Either[String, RangeTypeType] = seq match {
      case elem: scala.xml.Elem => Right(fromString(elem.text, elem.scope))
      case _ => Right(fromString(seq.text, scala.xml.TopScope))
    }
    
    def writes(__obj: RangeTypeType, __namespace: Option[String], __elementLabel: Option[String],
        __scope: scala.xml.NamespaceBinding, __typeAttribute: Boolean): scala.xml.NodeSeq =
      scala.xml.Elem(IPXACT2009scalaxb.Helper.getPrefix(__namespace, __scope).orNull,
        __elementLabel getOrElse { sys.error("missing element label.") },
        scala.xml.Null, __scope, true, scala.xml.Text(__obj.toString))
  }
  def build_DelayValueUnitTypeFormat = new Default_DelayValueUnitTypeFormat {}
  trait Default_DelayValueUnitTypeFormat extends IPXACT2009scalaxb.XMLFormat[DelayValueUnitType] {
    val targetNamespace: Option[String] = Some("http://www.spiritconsortium.org/XMLSchema/SPIRIT/1685-2009")
    
    def fromString(value: String, scope: scala.xml.NamespaceBinding): DelayValueUnitType =
        (fromString0(value, scope)).apply(IPXACT2009scalaxb.fromXML[String](scala.xml.Text(value)))

    private def fromString0(value: String, scope: scala.xml.NamespaceBinding): PartialFunction[Any, DelayValueUnitType] = {
      case x: String if x == IPXACT2009scalaxb.fromXML[String](scala.xml.Text("ps")) => Ps
      case x: String if x == IPXACT2009scalaxb.fromXML[String](scala.xml.Text("ns")) => Ns

    }



    def reads(seq: scala.xml.NodeSeq, stack: List[IPXACT2009scalaxb.ElemName]): Either[String, DelayValueUnitType] = seq match {
      case elem: scala.xml.Elem => Right(fromString(elem.text, elem.scope))
      case _ => Right(fromString(seq.text, scala.xml.TopScope))
    }
    
    def writes(__obj: DelayValueUnitType, __namespace: Option[String], __elementLabel: Option[String],
        __scope: scala.xml.NamespaceBinding, __typeAttribute: Boolean): scala.xml.NodeSeq =
      scala.xml.Elem(IPXACT2009scalaxb.Helper.getPrefix(__namespace, __scope).orNull,
        __elementLabel getOrElse { sys.error("missing element label.") },
        scala.xml.Null, __scope, true, scala.xml.Text(__obj.toString))
  }
  trait Default_EnumerationFormat extends IPXACT2009scalaxb.XMLFormat[Enumeration] with IPXACT2009scalaxb.CanWriteChildNodes[Enumeration] {
    val targetNamespace: Option[String] = Some("http://www.spiritconsortium.org/XMLSchema/SPIRIT/1685-2009")
    def reads(seq: scala.xml.NodeSeq, stack: List[IPXACT2009scalaxb.ElemName]): Either[String, Enumeration] = seq match {
      case node: scala.xml.Node => Right(Enumeration(IPXACT2009scalaxb.fromXML[String](node, IPXACT2009scalaxb.ElemName(node) :: stack),
        scala.collection.immutable.ListMap(List(
        (node \ "@{http://www.spiritconsortium.org/XMLSchema/SPIRIT/1685-2009}text").headOption map { x => IPXACT2009scalaxb.DataRecord(x, node, IPXACT2009scalaxb.fromXML[String](x, IPXACT2009scalaxb.ElemName(node) :: stack)) } map { "@text" -> _ },
        (node \ "@{http://www.spiritconsortium.org/XMLSchema/SPIRIT/1685-2009}help").headOption map { x => IPXACT2009scalaxb.DataRecord(x, node, IPXACT2009scalaxb.fromXML[String](x, IPXACT2009scalaxb.ElemName(node) :: stack)) } map { "@help" -> _ }
        ).flatten[(String, IPXACT2009scalaxb.DataRecord[Any])]: _*)))
      case _ => Left("reads failed: seq must be scala.xml.Node")
    }
    
    override def writesAttribute(__obj: Enumeration, __scope: scala.xml.NamespaceBinding): scala.xml.MetaData = {
      var attr: scala.xml.MetaData  = scala.xml.Null
      __obj.attributes.toList map {
        case ("@text", _) => __obj.text foreach { x => attr = scala.xml.Attribute(__scope.getPrefix("http://www.spiritconsortium.org/XMLSchema/SPIRIT/1685-2009"), "text", x.toString, attr) }
        case ("@help", _) => __obj.help foreach { x => attr = scala.xml.Attribute(__scope.getPrefix("http://www.spiritconsortium.org/XMLSchema/SPIRIT/1685-2009"), "help", x.toString, attr) }
        case (key, x) => attr = scala.xml.Attribute((x.namespace map { __scope.getPrefix(_) }).orNull, x.key.orNull, x.value.toString, attr)
      }
      attr
    }

    def writesChildNodes(__obj: Enumeration, __scope: scala.xml.NamespaceBinding): Seq[scala.xml.Node] =
      Seq(scala.xml.Text(__obj.value.toString))

  }

  trait Default_ChoiceFormat extends IPXACT2009scalaxb.ElemNameParser[Choice] {
    val targetNamespace: Option[String] = Some("http://www.spiritconsortium.org/XMLSchema/SPIRIT/1685-2009")
    
    def parser(node: scala.xml.Node, stack: List[IPXACT2009scalaxb.ElemName]): Parser[Choice] =
      phrase((IPXACT2009scalaxb.ElemName(Some("http://www.spiritconsortium.org/XMLSchema/SPIRIT/1685-2009"), "name")) ~
      safeRep(IPXACT2009scalaxb.ElemName(Some("http://www.spiritconsortium.org/XMLSchema/SPIRIT/1685-2009"), "enumeration")) ^^
      { case p1 ~ p2 =>
      Choice(IPXACT2009scalaxb.fromXML[String](p1, IPXACT2009scalaxb.ElemName(node) :: stack),
        p2 map { IPXACT2009scalaxb.fromXML[Enumeration](_, IPXACT2009scalaxb.ElemName(node) :: stack) }) })
    
    def writesChildNodes(__obj: Choice, __scope: scala.xml.NamespaceBinding): Seq[scala.xml.Node] =
      Seq.concat(IPXACT2009scalaxb.toXML[String](__obj.name, Some("http://www.spiritconsortium.org/XMLSchema/SPIRIT/1685-2009"), Some("name"), __scope, false),
        __obj.enumeration flatMap { IPXACT2009scalaxb.toXML[Enumeration](_, Some("http://www.spiritconsortium.org/XMLSchema/SPIRIT/1685-2009"), Some("enumeration"), __scope, false) })

  }

  trait Default_ChoicesFormat extends IPXACT2009scalaxb.ElemNameParser[Choices] {
    val targetNamespace: Option[String] = Some("http://www.spiritconsortium.org/XMLSchema/SPIRIT/1685-2009")
    
    def parser(node: scala.xml.Node, stack: List[IPXACT2009scalaxb.ElemName]): Parser[Choices] =
      phrase(safeRep(IPXACT2009scalaxb.ElemName(Some("http://www.spiritconsortium.org/XMLSchema/SPIRIT/1685-2009"), "choice")) ^^
      { case p1 =>
      Choices(p1 map { IPXACT2009scalaxb.fromXML[Choice](_, IPXACT2009scalaxb.ElemName(node) :: stack) }) })
    
    def writesChildNodes(__obj: Choices, __scope: scala.xml.NamespaceBinding): Seq[scala.xml.Node] =
      (__obj.choice flatMap { IPXACT2009scalaxb.toXML[Choice](_, Some("http://www.spiritconsortium.org/XMLSchema/SPIRIT/1685-2009"), Some("choice"), __scope, false) })
  }
  trait Default_Commonu46attFormat extends IPXACT2009scalaxb.AttributeGroupFormat[Commonu46att] {
    val targetNamespace: Option[String] = Some("http://www.spiritconsortium.org/XMLSchema/SPIRIT/1685-2009")
    
    def reads(seq: scala.xml.NodeSeq, stack: List[IPXACT2009scalaxb.ElemName]): Either[String, Commonu46att] = seq match {
      case node: scala.xml.Node => Right(Commonu46att((node \ "@{http://www.spiritconsortium.org/XMLSchema/SPIRIT/1685-2009}resolve").headOption map { IPXACT2009scalaxb.fromXML[ResolveType](_, IPXACT2009scalaxb.ElemName(node) :: stack) },
      (node \ "@{http://www.spiritconsortium.org/XMLSchema/SPIRIT/1685-2009}id").headOption map { IPXACT2009scalaxb.fromXML[String](_, IPXACT2009scalaxb.ElemName(node) :: stack) },
      (node \ "@{http://www.spiritconsortium.org/XMLSchema/SPIRIT/1685-2009}dependency").headOption map { IPXACT2009scalaxb.fromXML[String](_, IPXACT2009scalaxb.ElemName(node) :: stack) },
      scala.collection.immutable.ListMap((node match {
          case elem: scala.xml.Elem =>
            elem.attributes.toList flatMap {
              case scala.xml.PrefixedAttribute(pre, key, value, _) if pre == elem.scope.getPrefix("http://www.spiritconsortium.org/XMLSchema/SPIRIT/1685-2009") &&
                key == "resolve" => Nil
              case scala.xml.PrefixedAttribute(pre, key, value, _) if pre == elem.scope.getPrefix("http://www.spiritconsortium.org/XMLSchema/SPIRIT/1685-2009") &&
                key == "id" => Nil
              case scala.xml.PrefixedAttribute(pre, key, value, _) if pre == elem.scope.getPrefix("http://www.spiritconsortium.org/XMLSchema/SPIRIT/1685-2009") &&
                key == "dependency" => Nil
              case scala.xml.PrefixedAttribute(pre, key, value, _) if pre == elem.scope.getPrefix("http://www.spiritconsortium.org/XMLSchema/SPIRIT/1685-2009") &&
                key == "choiceRef" => Nil
              case scala.xml.PrefixedAttribute(pre, key, value, _) if pre == elem.scope.getPrefix("http://www.spiritconsortium.org/XMLSchema/SPIRIT/1685-2009") &&
                key == "order" => Nil
              case scala.xml.PrefixedAttribute(pre, key, value, _) if pre == elem.scope.getPrefix("http://www.spiritconsortium.org/XMLSchema/SPIRIT/1685-2009") &&
                key == "configGroups" => Nil
              case scala.xml.PrefixedAttribute(pre, key, value, _) if pre == elem.scope.getPrefix("http://www.spiritconsortium.org/XMLSchema/SPIRIT/1685-2009") &&
                key == "bitStringLength" => Nil
              case scala.xml.PrefixedAttribute(pre, key, value, _) if pre == elem.scope.getPrefix("http://www.spiritconsortium.org/XMLSchema/SPIRIT/1685-2009") &&
                key == "minimum" => Nil
              case scala.xml.PrefixedAttribute(pre, key, value, _) if pre == elem.scope.getPrefix("http://www.spiritconsortium.org/XMLSchema/SPIRIT/1685-2009") &&
                key == "maximum" => Nil
              case scala.xml.UnprefixedAttribute(key, value, _) =>
                List(("@" + key, IPXACT2009scalaxb.DataRecord(None, Some(key), value.text)))
              case scala.xml.PrefixedAttribute(pre, key, value, _) =>
                val ns = elem.scope.getURI(pre)
                List(("@{" + ns + "}" + key, IPXACT2009scalaxb.DataRecord(Option[String](ns), Some(key), value.text)))
              case _ => Nil
            }
          case _ => Nil
        }): _*),
      (node \ "@{http://www.spiritconsortium.org/XMLSchema/SPIRIT/1685-2009}choiceRef").headOption map { IPXACT2009scalaxb.fromXML[String](_, IPXACT2009scalaxb.ElemName(node) :: stack) },
      (node \ "@{http://www.spiritconsortium.org/XMLSchema/SPIRIT/1685-2009}order").headOption map { IPXACT2009scalaxb.fromXML[Float](_, IPXACT2009scalaxb.ElemName(node) :: stack) },
      (node \ "@{http://www.spiritconsortium.org/XMLSchema/SPIRIT/1685-2009}configGroups").headOption map { IPXACT2009scalaxb.fromXML[Seq[String]](_, IPXACT2009scalaxb.ElemName(node) :: stack) },
      (node \ "@{http://www.spiritconsortium.org/XMLSchema/SPIRIT/1685-2009}bitStringLength").headOption map { IPXACT2009scalaxb.fromXML[BigInt](_, IPXACT2009scalaxb.ElemName(node) :: stack) },
      (node \ "@{http://www.spiritconsortium.org/XMLSchema/SPIRIT/1685-2009}minimum").headOption map { IPXACT2009scalaxb.fromXML[String](_, IPXACT2009scalaxb.ElemName(node) :: stack) },
      (node \ "@{http://www.spiritconsortium.org/XMLSchema/SPIRIT/1685-2009}maximum").headOption map { IPXACT2009scalaxb.fromXML[String](_, IPXACT2009scalaxb.ElemName(node) :: stack) }))
      case _ => Left("reads failed: seq must be scala.xml.Node")
    }
    
    def toAttribute(__obj: Commonu46att, __attr: scala.xml.MetaData, __scope: scala.xml.NamespaceBinding): scala.xml.MetaData = {
      var attr: scala.xml.MetaData  = __attr
      __obj.spiritresolve foreach { x => attr = scala.xml.Attribute(__scope.getPrefix("http://www.spiritconsortium.org/XMLSchema/SPIRIT/1685-2009"), "resolve", x.toString, attr) }
    __obj.spiritid foreach { x => attr = scala.xml.Attribute(__scope.getPrefix("http://www.spiritconsortium.org/XMLSchema/SPIRIT/1685-2009"), "id", x.toString, attr) }
    __obj.spiritdependency foreach { x => attr = scala.xml.Attribute(__scope.getPrefix("http://www.spiritconsortium.org/XMLSchema/SPIRIT/1685-2009"), "dependency", x.toString, attr) }
    __obj.attributes.toList map {
        case (key, x) => attr = scala.xml.Attribute((x.namespace map { __scope.getPrefix(_) }).orNull, x.key.orNull, x.value.toString, attr) }
    __obj.spiritchoiceRef foreach { x => attr = scala.xml.Attribute(__scope.getPrefix("http://www.spiritconsortium.org/XMLSchema/SPIRIT/1685-2009"), "choiceRef", x.toString, attr) }
    __obj.spiritorder foreach { x => attr = scala.xml.Attribute(__scope.getPrefix("http://www.spiritconsortium.org/XMLSchema/SPIRIT/1685-2009"), "order", x.toString, attr) }
    __obj.spiritconfigGroups foreach { x => attr = scala.xml.Attribute(__scope.getPrefix("http://www.spiritconsortium.org/XMLSchema/SPIRIT/1685-2009"), "configGroups", x.toString, attr) }
    __obj.spiritbitStringLength foreach { x => attr = scala.xml.Attribute(__scope.getPrefix("http://www.spiritconsortium.org/XMLSchema/SPIRIT/1685-2009"), "bitStringLength", x.toString, attr) }
    __obj.spiritminimum foreach { x => attr = scala.xml.Attribute(__scope.getPrefix("http://www.spiritconsortium.org/XMLSchema/SPIRIT/1685-2009"), "minimum", x.toString, attr) }
    __obj.spiritmaximum foreach { x => attr = scala.xml.Attribute(__scope.getPrefix("http://www.spiritconsortium.org/XMLSchema/SPIRIT/1685-2009"), "maximum", x.toString, attr) }
      attr
    }
  }

  trait Default_Stringu46attFormat extends IPXACT2009scalaxb.AttributeGroupFormat[Stringu46att] {
    val targetNamespace: Option[String] = Some("http://www.spiritconsortium.org/XMLSchema/SPIRIT/1685-2009")
    
    def reads(seq: scala.xml.NodeSeq, stack: List[IPXACT2009scalaxb.ElemName]): Either[String, Stringu46att] = seq match {
      case node: scala.xml.Node => Right(Stringu46att((node \ "@{http://www.spiritconsortium.org/XMLSchema/SPIRIT/1685-2009}format").headOption map { IPXACT2009scalaxb.fromXML[FormatType](_, IPXACT2009scalaxb.ElemName(node) :: stack) } getOrElse { IPXACT2009scalaxb.fromXML[FormatType](scala.xml.Text("string"), IPXACT2009scalaxb.ElemName(node) :: stack) },
      (node \ "@{http://www.spiritconsortium.org/XMLSchema/SPIRIT/1685-2009}resolve").headOption map { IPXACT2009scalaxb.fromXML[ResolveType](_, IPXACT2009scalaxb.ElemName(node) :: stack) },
      (node \ "@{http://www.spiritconsortium.org/XMLSchema/SPIRIT/1685-2009}id").headOption map { IPXACT2009scalaxb.fromXML[String](_, IPXACT2009scalaxb.ElemName(node) :: stack) },
      (node \ "@{http://www.spiritconsortium.org/XMLSchema/SPIRIT/1685-2009}dependency").headOption map { IPXACT2009scalaxb.fromXML[String](_, IPXACT2009scalaxb.ElemName(node) :: stack) },
      scala.collection.immutable.ListMap((node match {
          case elem: scala.xml.Elem =>
            elem.attributes.toList flatMap {
              case scala.xml.PrefixedAttribute(pre, key, value, _) if pre == elem.scope.getPrefix("http://www.spiritconsortium.org/XMLSchema/SPIRIT/1685-2009") &&
                key == "format" => Nil
              case scala.xml.PrefixedAttribute(pre, key, value, _) if pre == elem.scope.getPrefix("http://www.spiritconsortium.org/XMLSchema/SPIRIT/1685-2009") &&
                key == "resolve" => Nil
              case scala.xml.PrefixedAttribute(pre, key, value, _) if pre == elem.scope.getPrefix("http://www.spiritconsortium.org/XMLSchema/SPIRIT/1685-2009") &&
                key == "id" => Nil
              case scala.xml.PrefixedAttribute(pre, key, value, _) if pre == elem.scope.getPrefix("http://www.spiritconsortium.org/XMLSchema/SPIRIT/1685-2009") &&
                key == "dependency" => Nil
              case scala.xml.PrefixedAttribute(pre, key, value, _) if pre == elem.scope.getPrefix("http://www.spiritconsortium.org/XMLSchema/SPIRIT/1685-2009") &&
                key == "choiceRef" => Nil
              case scala.xml.PrefixedAttribute(pre, key, value, _) if pre == elem.scope.getPrefix("http://www.spiritconsortium.org/XMLSchema/SPIRIT/1685-2009") &&
                key == "order" => Nil
              case scala.xml.PrefixedAttribute(pre, key, value, _) if pre == elem.scope.getPrefix("http://www.spiritconsortium.org/XMLSchema/SPIRIT/1685-2009") &&
                key == "configGroups" => Nil
              case scala.xml.PrefixedAttribute(pre, key, value, _) if pre == elem.scope.getPrefix("http://www.spiritconsortium.org/XMLSchema/SPIRIT/1685-2009") &&
                key == "bitStringLength" => Nil
              case scala.xml.PrefixedAttribute(pre, key, value, _) if pre == elem.scope.getPrefix("http://www.spiritconsortium.org/XMLSchema/SPIRIT/1685-2009") &&
                key == "minimum" => Nil
              case scala.xml.PrefixedAttribute(pre, key, value, _) if pre == elem.scope.getPrefix("http://www.spiritconsortium.org/XMLSchema/SPIRIT/1685-2009") &&
                key == "maximum" => Nil
              case scala.xml.PrefixedAttribute(pre, key, value, _) if pre == elem.scope.getPrefix("http://www.spiritconsortium.org/XMLSchema/SPIRIT/1685-2009") &&
                key == "rangeType" => Nil
              case scala.xml.UnprefixedAttribute(key, value, _) =>
                List(("@" + key, IPXACT2009scalaxb.DataRecord(None, Some(key), value.text)))
              case scala.xml.PrefixedAttribute(pre, key, value, _) =>
                val ns = elem.scope.getURI(pre)
                List(("@{" + ns + "}" + key, IPXACT2009scalaxb.DataRecord(Option[String](ns), Some(key), value.text)))
              case _ => Nil
            }
          case _ => Nil
        }): _*),
      (node \ "@{http://www.spiritconsortium.org/XMLSchema/SPIRIT/1685-2009}choiceRef").headOption map { IPXACT2009scalaxb.fromXML[String](_, IPXACT2009scalaxb.ElemName(node) :: stack) },
      (node \ "@{http://www.spiritconsortium.org/XMLSchema/SPIRIT/1685-2009}order").headOption map { IPXACT2009scalaxb.fromXML[Float](_, IPXACT2009scalaxb.ElemName(node) :: stack) },
      (node \ "@{http://www.spiritconsortium.org/XMLSchema/SPIRIT/1685-2009}configGroups").headOption map { IPXACT2009scalaxb.fromXML[Seq[String]](_, IPXACT2009scalaxb.ElemName(node) :: stack) },
      (node \ "@{http://www.spiritconsortium.org/XMLSchema/SPIRIT/1685-2009}bitStringLength").headOption map { IPXACT2009scalaxb.fromXML[BigInt](_, IPXACT2009scalaxb.ElemName(node) :: stack) },
      (node \ "@{http://www.spiritconsortium.org/XMLSchema/SPIRIT/1685-2009}minimum").headOption map { IPXACT2009scalaxb.fromXML[String](_, IPXACT2009scalaxb.ElemName(node) :: stack) },
      (node \ "@{http://www.spiritconsortium.org/XMLSchema/SPIRIT/1685-2009}maximum").headOption map { IPXACT2009scalaxb.fromXML[String](_, IPXACT2009scalaxb.ElemName(node) :: stack) },
      (node \ "@{http://www.spiritconsortium.org/XMLSchema/SPIRIT/1685-2009}rangeType").headOption map { IPXACT2009scalaxb.fromXML[RangeTypeType](_, IPXACT2009scalaxb.ElemName(node) :: stack) }))
      case _ => Left("reads failed: seq must be scala.xml.Node")
    }
    
    def toAttribute(__obj: Stringu46att, __attr: scala.xml.MetaData, __scope: scala.xml.NamespaceBinding): scala.xml.MetaData = {
      var attr: scala.xml.MetaData  = __attr
      if (__obj.spiritformat.toString != "string") attr = scala.xml.Attribute(__scope.getPrefix("http://www.spiritconsortium.org/XMLSchema/SPIRIT/1685-2009"), "format", __obj.spiritformat.toString, attr)
    __obj.spiritresolve foreach { x => attr = scala.xml.Attribute(__scope.getPrefix("http://www.spiritconsortium.org/XMLSchema/SPIRIT/1685-2009"), "resolve", x.toString, attr) }
    __obj.spiritid foreach { x => attr = scala.xml.Attribute(__scope.getPrefix("http://www.spiritconsortium.org/XMLSchema/SPIRIT/1685-2009"), "id", x.toString, attr) }
    __obj.spiritdependency foreach { x => attr = scala.xml.Attribute(__scope.getPrefix("http://www.spiritconsortium.org/XMLSchema/SPIRIT/1685-2009"), "dependency", x.toString, attr) }
    __obj.attributes.toList map {
        case (key, x) => attr = scala.xml.Attribute((x.namespace map { __scope.getPrefix(_) }).orNull, x.key.orNull, x.value.toString, attr) }
    __obj.spiritchoiceRef foreach { x => attr = scala.xml.Attribute(__scope.getPrefix("http://www.spiritconsortium.org/XMLSchema/SPIRIT/1685-2009"), "choiceRef", x.toString, attr) }
    __obj.spiritorder foreach { x => attr = scala.xml.Attribute(__scope.getPrefix("http://www.spiritconsortium.org/XMLSchema/SPIRIT/1685-2009"), "order", x.toString, attr) }
    __obj.spiritconfigGroups foreach { x => attr = scala.xml.Attribute(__scope.getPrefix("http://www.spiritconsortium.org/XMLSchema/SPIRIT/1685-2009"), "configGroups", x.toString, attr) }
    __obj.spiritbitStringLength foreach { x => attr = scala.xml.Attribute(__scope.getPrefix("http://www.spiritconsortium.org/XMLSchema/SPIRIT/1685-2009"), "bitStringLength", x.toString, attr) }
    __obj.spiritminimum foreach { x => attr = scala.xml.Attribute(__scope.getPrefix("http://www.spiritconsortium.org/XMLSchema/SPIRIT/1685-2009"), "minimum", x.toString, attr) }
    __obj.spiritmaximum foreach { x => attr = scala.xml.Attribute(__scope.getPrefix("http://www.spiritconsortium.org/XMLSchema/SPIRIT/1685-2009"), "maximum", x.toString, attr) }
    __obj.spiritrangeType foreach { x => attr = scala.xml.Attribute(__scope.getPrefix("http://www.spiritconsortium.org/XMLSchema/SPIRIT/1685-2009"), "rangeType", x.toString, attr) }
      attr
    }
  }

  trait Default_Longu46attFormat extends IPXACT2009scalaxb.AttributeGroupFormat[Longu46att] {
    val targetNamespace: Option[String] = Some("http://www.spiritconsortium.org/XMLSchema/SPIRIT/1685-2009")
    
    def reads(seq: scala.xml.NodeSeq, stack: List[IPXACT2009scalaxb.ElemName]): Either[String, Longu46att] = seq match {
      case node: scala.xml.Node => Right(Longu46att((node \ "@{http://www.spiritconsortium.org/XMLSchema/SPIRIT/1685-2009}format").headOption map { IPXACT2009scalaxb.fromXML[FormatType](_, IPXACT2009scalaxb.ElemName(node) :: stack) } getOrElse { IPXACT2009scalaxb.fromXML[FormatType](scala.xml.Text("long"), IPXACT2009scalaxb.ElemName(node) :: stack) },
      (node \ "@{http://www.spiritconsortium.org/XMLSchema/SPIRIT/1685-2009}resolve").headOption map { IPXACT2009scalaxb.fromXML[ResolveType](_, IPXACT2009scalaxb.ElemName(node) :: stack) },
      (node \ "@{http://www.spiritconsortium.org/XMLSchema/SPIRIT/1685-2009}id").headOption map { IPXACT2009scalaxb.fromXML[String](_, IPXACT2009scalaxb.ElemName(node) :: stack) },
      (node \ "@{http://www.spiritconsortium.org/XMLSchema/SPIRIT/1685-2009}dependency").headOption map { IPXACT2009scalaxb.fromXML[String](_, IPXACT2009scalaxb.ElemName(node) :: stack) },
      scala.collection.immutable.ListMap((node match {
          case elem: scala.xml.Elem =>
            elem.attributes.toList flatMap {
              case scala.xml.PrefixedAttribute(pre, key, value, _) if pre == elem.scope.getPrefix("http://www.spiritconsortium.org/XMLSchema/SPIRIT/1685-2009") &&
                key == "format" => Nil
              case scala.xml.PrefixedAttribute(pre, key, value, _) if pre == elem.scope.getPrefix("http://www.spiritconsortium.org/XMLSchema/SPIRIT/1685-2009") &&
                key == "resolve" => Nil
              case scala.xml.PrefixedAttribute(pre, key, value, _) if pre == elem.scope.getPrefix("http://www.spiritconsortium.org/XMLSchema/SPIRIT/1685-2009") &&
                key == "id" => Nil
              case scala.xml.PrefixedAttribute(pre, key, value, _) if pre == elem.scope.getPrefix("http://www.spiritconsortium.org/XMLSchema/SPIRIT/1685-2009") &&
                key == "dependency" => Nil
              case scala.xml.PrefixedAttribute(pre, key, value, _) if pre == elem.scope.getPrefix("http://www.spiritconsortium.org/XMLSchema/SPIRIT/1685-2009") &&
                key == "choiceRef" => Nil
              case scala.xml.PrefixedAttribute(pre, key, value, _) if pre == elem.scope.getPrefix("http://www.spiritconsortium.org/XMLSchema/SPIRIT/1685-2009") &&
                key == "order" => Nil
              case scala.xml.PrefixedAttribute(pre, key, value, _) if pre == elem.scope.getPrefix("http://www.spiritconsortium.org/XMLSchema/SPIRIT/1685-2009") &&
                key == "configGroups" => Nil
              case scala.xml.PrefixedAttribute(pre, key, value, _) if pre == elem.scope.getPrefix("http://www.spiritconsortium.org/XMLSchema/SPIRIT/1685-2009") &&
                key == "bitStringLength" => Nil
              case scala.xml.PrefixedAttribute(pre, key, value, _) if pre == elem.scope.getPrefix("http://www.spiritconsortium.org/XMLSchema/SPIRIT/1685-2009") &&
                key == "minimum" => Nil
              case scala.xml.PrefixedAttribute(pre, key, value, _) if pre == elem.scope.getPrefix("http://www.spiritconsortium.org/XMLSchema/SPIRIT/1685-2009") &&
                key == "maximum" => Nil
              case scala.xml.PrefixedAttribute(pre, key, value, _) if pre == elem.scope.getPrefix("http://www.spiritconsortium.org/XMLSchema/SPIRIT/1685-2009") &&
                key == "rangeType" => Nil
              case scala.xml.UnprefixedAttribute(key, value, _) =>
                List(("@" + key, IPXACT2009scalaxb.DataRecord(None, Some(key), value.text)))
              case scala.xml.PrefixedAttribute(pre, key, value, _) =>
                val ns = elem.scope.getURI(pre)
                List(("@{" + ns + "}" + key, IPXACT2009scalaxb.DataRecord(Option[String](ns), Some(key), value.text)))
              case _ => Nil
            }
          case _ => Nil
        }): _*),
      (node \ "@{http://www.spiritconsortium.org/XMLSchema/SPIRIT/1685-2009}choiceRef").headOption map { IPXACT2009scalaxb.fromXML[String](_, IPXACT2009scalaxb.ElemName(node) :: stack) },
      (node \ "@{http://www.spiritconsortium.org/XMLSchema/SPIRIT/1685-2009}order").headOption map { IPXACT2009scalaxb.fromXML[Float](_, IPXACT2009scalaxb.ElemName(node) :: stack) },
      (node \ "@{http://www.spiritconsortium.org/XMLSchema/SPIRIT/1685-2009}configGroups").headOption map { IPXACT2009scalaxb.fromXML[Seq[String]](_, IPXACT2009scalaxb.ElemName(node) :: stack) },
      (node \ "@{http://www.spiritconsortium.org/XMLSchema/SPIRIT/1685-2009}bitStringLength").headOption map { IPXACT2009scalaxb.fromXML[BigInt](_, IPXACT2009scalaxb.ElemName(node) :: stack) },
      (node \ "@{http://www.spiritconsortium.org/XMLSchema/SPIRIT/1685-2009}minimum").headOption map { IPXACT2009scalaxb.fromXML[String](_, IPXACT2009scalaxb.ElemName(node) :: stack) },
      (node \ "@{http://www.spiritconsortium.org/XMLSchema/SPIRIT/1685-2009}maximum").headOption map { IPXACT2009scalaxb.fromXML[String](_, IPXACT2009scalaxb.ElemName(node) :: stack) },
      (node \ "@{http://www.spiritconsortium.org/XMLSchema/SPIRIT/1685-2009}rangeType").headOption map { IPXACT2009scalaxb.fromXML[RangeTypeType](_, IPXACT2009scalaxb.ElemName(node) :: stack) } getOrElse { IPXACT2009scalaxb.fromXML[RangeTypeType](scala.xml.Text("float"), IPXACT2009scalaxb.ElemName(node) :: stack) }))
      case _ => Left("reads failed: seq must be scala.xml.Node")
    }
    
    def toAttribute(__obj: Longu46att, __attr: scala.xml.MetaData, __scope: scala.xml.NamespaceBinding): scala.xml.MetaData = {
      var attr: scala.xml.MetaData  = __attr
      if (__obj.spiritformat.toString != "long") attr = scala.xml.Attribute(__scope.getPrefix("http://www.spiritconsortium.org/XMLSchema/SPIRIT/1685-2009"), "format", __obj.spiritformat.toString, attr)
    __obj.spiritresolve foreach { x => attr = scala.xml.Attribute(__scope.getPrefix("http://www.spiritconsortium.org/XMLSchema/SPIRIT/1685-2009"), "resolve", x.toString, attr) }
    __obj.spiritid foreach { x => attr = scala.xml.Attribute(__scope.getPrefix("http://www.spiritconsortium.org/XMLSchema/SPIRIT/1685-2009"), "id", x.toString, attr) }
    __obj.spiritdependency foreach { x => attr = scala.xml.Attribute(__scope.getPrefix("http://www.spiritconsortium.org/XMLSchema/SPIRIT/1685-2009"), "dependency", x.toString, attr) }
    __obj.attributes.toList map {
        case (key, x) => attr = scala.xml.Attribute((x.namespace map { __scope.getPrefix(_) }).orNull, x.key.orNull, x.value.toString, attr) }
    __obj.spiritchoiceRef foreach { x => attr = scala.xml.Attribute(__scope.getPrefix("http://www.spiritconsortium.org/XMLSchema/SPIRIT/1685-2009"), "choiceRef", x.toString, attr) }
    __obj.spiritorder foreach { x => attr = scala.xml.Attribute(__scope.getPrefix("http://www.spiritconsortium.org/XMLSchema/SPIRIT/1685-2009"), "order", x.toString, attr) }
    __obj.spiritconfigGroups foreach { x => attr = scala.xml.Attribute(__scope.getPrefix("http://www.spiritconsortium.org/XMLSchema/SPIRIT/1685-2009"), "configGroups", x.toString, attr) }
    __obj.spiritbitStringLength foreach { x => attr = scala.xml.Attribute(__scope.getPrefix("http://www.spiritconsortium.org/XMLSchema/SPIRIT/1685-2009"), "bitStringLength", x.toString, attr) }
    __obj.spiritminimum foreach { x => attr = scala.xml.Attribute(__scope.getPrefix("http://www.spiritconsortium.org/XMLSchema/SPIRIT/1685-2009"), "minimum", x.toString, attr) }
    __obj.spiritmaximum foreach { x => attr = scala.xml.Attribute(__scope.getPrefix("http://www.spiritconsortium.org/XMLSchema/SPIRIT/1685-2009"), "maximum", x.toString, attr) }
    if (__obj.spiritrangeType.toString != "float") attr = scala.xml.Attribute(__scope.getPrefix("http://www.spiritconsortium.org/XMLSchema/SPIRIT/1685-2009"), "rangeType", __obj.spiritrangeType.toString, attr)
      attr
    }
  }

  trait Default_Floatu46attFormat extends IPXACT2009scalaxb.AttributeGroupFormat[Floatu46att] {
    val targetNamespace: Option[String] = Some("http://www.spiritconsortium.org/XMLSchema/SPIRIT/1685-2009")
    
    def reads(seq: scala.xml.NodeSeq, stack: List[IPXACT2009scalaxb.ElemName]): Either[String, Floatu46att] = seq match {
      case node: scala.xml.Node => Right(Floatu46att((node \ "@{http://www.spiritconsortium.org/XMLSchema/SPIRIT/1685-2009}format").headOption map { IPXACT2009scalaxb.fromXML[FormatType](_, IPXACT2009scalaxb.ElemName(node) :: stack) } getOrElse { IPXACT2009scalaxb.fromXML[FormatType](scala.xml.Text("float"), IPXACT2009scalaxb.ElemName(node) :: stack) },
      (node \ "@{http://www.spiritconsortium.org/XMLSchema/SPIRIT/1685-2009}resolve").headOption map { IPXACT2009scalaxb.fromXML[ResolveType](_, IPXACT2009scalaxb.ElemName(node) :: stack) },
      (node \ "@{http://www.spiritconsortium.org/XMLSchema/SPIRIT/1685-2009}id").headOption map { IPXACT2009scalaxb.fromXML[String](_, IPXACT2009scalaxb.ElemName(node) :: stack) },
      (node \ "@{http://www.spiritconsortium.org/XMLSchema/SPIRIT/1685-2009}dependency").headOption map { IPXACT2009scalaxb.fromXML[String](_, IPXACT2009scalaxb.ElemName(node) :: stack) },
      scala.collection.immutable.ListMap((node match {
          case elem: scala.xml.Elem =>
            elem.attributes.toList flatMap {
              case scala.xml.PrefixedAttribute(pre, key, value, _) if pre == elem.scope.getPrefix("http://www.spiritconsortium.org/XMLSchema/SPIRIT/1685-2009") &&
                key == "format" => Nil
              case scala.xml.PrefixedAttribute(pre, key, value, _) if pre == elem.scope.getPrefix("http://www.spiritconsortium.org/XMLSchema/SPIRIT/1685-2009") &&
                key == "resolve" => Nil
              case scala.xml.PrefixedAttribute(pre, key, value, _) if pre == elem.scope.getPrefix("http://www.spiritconsortium.org/XMLSchema/SPIRIT/1685-2009") &&
                key == "id" => Nil
              case scala.xml.PrefixedAttribute(pre, key, value, _) if pre == elem.scope.getPrefix("http://www.spiritconsortium.org/XMLSchema/SPIRIT/1685-2009") &&
                key == "dependency" => Nil
              case scala.xml.PrefixedAttribute(pre, key, value, _) if pre == elem.scope.getPrefix("http://www.spiritconsortium.org/XMLSchema/SPIRIT/1685-2009") &&
                key == "choiceRef" => Nil
              case scala.xml.PrefixedAttribute(pre, key, value, _) if pre == elem.scope.getPrefix("http://www.spiritconsortium.org/XMLSchema/SPIRIT/1685-2009") &&
                key == "order" => Nil
              case scala.xml.PrefixedAttribute(pre, key, value, _) if pre == elem.scope.getPrefix("http://www.spiritconsortium.org/XMLSchema/SPIRIT/1685-2009") &&
                key == "configGroups" => Nil
              case scala.xml.PrefixedAttribute(pre, key, value, _) if pre == elem.scope.getPrefix("http://www.spiritconsortium.org/XMLSchema/SPIRIT/1685-2009") &&
                key == "bitStringLength" => Nil
              case scala.xml.PrefixedAttribute(pre, key, value, _) if pre == elem.scope.getPrefix("http://www.spiritconsortium.org/XMLSchema/SPIRIT/1685-2009") &&
                key == "minimum" => Nil
              case scala.xml.PrefixedAttribute(pre, key, value, _) if pre == elem.scope.getPrefix("http://www.spiritconsortium.org/XMLSchema/SPIRIT/1685-2009") &&
                key == "maximum" => Nil
              case scala.xml.PrefixedAttribute(pre, key, value, _) if pre == elem.scope.getPrefix("http://www.spiritconsortium.org/XMLSchema/SPIRIT/1685-2009") &&
                key == "rangeType" => Nil
              case scala.xml.UnprefixedAttribute(key, value, _) =>
                List(("@" + key, IPXACT2009scalaxb.DataRecord(None, Some(key), value.text)))
              case scala.xml.PrefixedAttribute(pre, key, value, _) =>
                val ns = elem.scope.getURI(pre)
                List(("@{" + ns + "}" + key, IPXACT2009scalaxb.DataRecord(Option[String](ns), Some(key), value.text)))
              case _ => Nil
            }
          case _ => Nil
        }): _*),
      (node \ "@{http://www.spiritconsortium.org/XMLSchema/SPIRIT/1685-2009}choiceRef").headOption map { IPXACT2009scalaxb.fromXML[String](_, IPXACT2009scalaxb.ElemName(node) :: stack) },
      (node \ "@{http://www.spiritconsortium.org/XMLSchema/SPIRIT/1685-2009}order").headOption map { IPXACT2009scalaxb.fromXML[Float](_, IPXACT2009scalaxb.ElemName(node) :: stack) },
      (node \ "@{http://www.spiritconsortium.org/XMLSchema/SPIRIT/1685-2009}configGroups").headOption map { IPXACT2009scalaxb.fromXML[Seq[String]](_, IPXACT2009scalaxb.ElemName(node) :: stack) },
      (node \ "@{http://www.spiritconsortium.org/XMLSchema/SPIRIT/1685-2009}bitStringLength").headOption map { IPXACT2009scalaxb.fromXML[BigInt](_, IPXACT2009scalaxb.ElemName(node) :: stack) },
      (node \ "@{http://www.spiritconsortium.org/XMLSchema/SPIRIT/1685-2009}minimum").headOption map { IPXACT2009scalaxb.fromXML[String](_, IPXACT2009scalaxb.ElemName(node) :: stack) },
      (node \ "@{http://www.spiritconsortium.org/XMLSchema/SPIRIT/1685-2009}maximum").headOption map { IPXACT2009scalaxb.fromXML[String](_, IPXACT2009scalaxb.ElemName(node) :: stack) },
      (node \ "@{http://www.spiritconsortium.org/XMLSchema/SPIRIT/1685-2009}rangeType").headOption map { IPXACT2009scalaxb.fromXML[RangeTypeType](_, IPXACT2009scalaxb.ElemName(node) :: stack) } getOrElse { IPXACT2009scalaxb.fromXML[RangeTypeType](scala.xml.Text("float"), IPXACT2009scalaxb.ElemName(node) :: stack) }))
      case _ => Left("reads failed: seq must be scala.xml.Node")
    }
    
    def toAttribute(__obj: Floatu46att, __attr: scala.xml.MetaData, __scope: scala.xml.NamespaceBinding): scala.xml.MetaData = {
      var attr: scala.xml.MetaData  = __attr
      if (__obj.spiritformat.toString != "float") attr = scala.xml.Attribute(__scope.getPrefix("http://www.spiritconsortium.org/XMLSchema/SPIRIT/1685-2009"), "format", __obj.spiritformat.toString, attr)
    __obj.spiritresolve foreach { x => attr = scala.xml.Attribute(__scope.getPrefix("http://www.spiritconsortium.org/XMLSchema/SPIRIT/1685-2009"), "resolve", x.toString, attr) }
    __obj.spiritid foreach { x => attr = scala.xml.Attribute(__scope.getPrefix("http://www.spiritconsortium.org/XMLSchema/SPIRIT/1685-2009"), "id", x.toString, attr) }
    __obj.spiritdependency foreach { x => attr = scala.xml.Attribute(__scope.getPrefix("http://www.spiritconsortium.org/XMLSchema/SPIRIT/1685-2009"), "dependency", x.toString, attr) }
    __obj.attributes.toList map {
        case (key, x) => attr = scala.xml.Attribute((x.namespace map { __scope.getPrefix(_) }).orNull, x.key.orNull, x.value.toString, attr) }
    __obj.spiritchoiceRef foreach { x => attr = scala.xml.Attribute(__scope.getPrefix("http://www.spiritconsortium.org/XMLSchema/SPIRIT/1685-2009"), "choiceRef", x.toString, attr) }
    __obj.spiritorder foreach { x => attr = scala.xml.Attribute(__scope.getPrefix("http://www.spiritconsortium.org/XMLSchema/SPIRIT/1685-2009"), "order", x.toString, attr) }
    __obj.spiritconfigGroups foreach { x => attr = scala.xml.Attribute(__scope.getPrefix("http://www.spiritconsortium.org/XMLSchema/SPIRIT/1685-2009"), "configGroups", x.toString, attr) }
    __obj.spiritbitStringLength foreach { x => attr = scala.xml.Attribute(__scope.getPrefix("http://www.spiritconsortium.org/XMLSchema/SPIRIT/1685-2009"), "bitStringLength", x.toString, attr) }
    __obj.spiritminimum foreach { x => attr = scala.xml.Attribute(__scope.getPrefix("http://www.spiritconsortium.org/XMLSchema/SPIRIT/1685-2009"), "minimum", x.toString, attr) }
    __obj.spiritmaximum foreach { x => attr = scala.xml.Attribute(__scope.getPrefix("http://www.spiritconsortium.org/XMLSchema/SPIRIT/1685-2009"), "maximum", x.toString, attr) }
    if (__obj.spiritrangeType.toString != "float") attr = scala.xml.Attribute(__scope.getPrefix("http://www.spiritconsortium.org/XMLSchema/SPIRIT/1685-2009"), "rangeType", __obj.spiritrangeType.toString, attr)
      attr
    }
  }

  trait Default_Boolu46attFormat extends IPXACT2009scalaxb.AttributeGroupFormat[Boolu46att] {
    val targetNamespace: Option[String] = Some("http://www.spiritconsortium.org/XMLSchema/SPIRIT/1685-2009")
    
    def reads(seq: scala.xml.NodeSeq, stack: List[IPXACT2009scalaxb.ElemName]): Either[String, Boolu46att] = seq match {
      case node: scala.xml.Node => Right(Boolu46att((node \ "@{http://www.spiritconsortium.org/XMLSchema/SPIRIT/1685-2009}format").headOption map { IPXACT2009scalaxb.fromXML[FormatType](_, IPXACT2009scalaxb.ElemName(node) :: stack) } getOrElse { IPXACT2009scalaxb.fromXML[FormatType](scala.xml.Text("bool"), IPXACT2009scalaxb.ElemName(node) :: stack) },
      (node \ "@{http://www.spiritconsortium.org/XMLSchema/SPIRIT/1685-2009}resolve").headOption map { IPXACT2009scalaxb.fromXML[ResolveType](_, IPXACT2009scalaxb.ElemName(node) :: stack) },
      (node \ "@{http://www.spiritconsortium.org/XMLSchema/SPIRIT/1685-2009}id").headOption map { IPXACT2009scalaxb.fromXML[String](_, IPXACT2009scalaxb.ElemName(node) :: stack) },
      (node \ "@{http://www.spiritconsortium.org/XMLSchema/SPIRIT/1685-2009}dependency").headOption map { IPXACT2009scalaxb.fromXML[String](_, IPXACT2009scalaxb.ElemName(node) :: stack) },
      scala.collection.immutable.ListMap((node match {
          case elem: scala.xml.Elem =>
            elem.attributes.toList flatMap {
              case scala.xml.PrefixedAttribute(pre, key, value, _) if pre == elem.scope.getPrefix("http://www.spiritconsortium.org/XMLSchema/SPIRIT/1685-2009") &&
                key == "format" => Nil
              case scala.xml.PrefixedAttribute(pre, key, value, _) if pre == elem.scope.getPrefix("http://www.spiritconsortium.org/XMLSchema/SPIRIT/1685-2009") &&
                key == "resolve" => Nil
              case scala.xml.PrefixedAttribute(pre, key, value, _) if pre == elem.scope.getPrefix("http://www.spiritconsortium.org/XMLSchema/SPIRIT/1685-2009") &&
                key == "id" => Nil
              case scala.xml.PrefixedAttribute(pre, key, value, _) if pre == elem.scope.getPrefix("http://www.spiritconsortium.org/XMLSchema/SPIRIT/1685-2009") &&
                key == "dependency" => Nil
              case scala.xml.PrefixedAttribute(pre, key, value, _) if pre == elem.scope.getPrefix("http://www.spiritconsortium.org/XMLSchema/SPIRIT/1685-2009") &&
                key == "choiceRef" => Nil
              case scala.xml.PrefixedAttribute(pre, key, value, _) if pre == elem.scope.getPrefix("http://www.spiritconsortium.org/XMLSchema/SPIRIT/1685-2009") &&
                key == "order" => Nil
              case scala.xml.PrefixedAttribute(pre, key, value, _) if pre == elem.scope.getPrefix("http://www.spiritconsortium.org/XMLSchema/SPIRIT/1685-2009") &&
                key == "configGroups" => Nil
              case scala.xml.PrefixedAttribute(pre, key, value, _) if pre == elem.scope.getPrefix("http://www.spiritconsortium.org/XMLSchema/SPIRIT/1685-2009") &&
                key == "bitStringLength" => Nil
              case scala.xml.PrefixedAttribute(pre, key, value, _) if pre == elem.scope.getPrefix("http://www.spiritconsortium.org/XMLSchema/SPIRIT/1685-2009") &&
                key == "minimum" => Nil
              case scala.xml.PrefixedAttribute(pre, key, value, _) if pre == elem.scope.getPrefix("http://www.spiritconsortium.org/XMLSchema/SPIRIT/1685-2009") &&
                key == "maximum" => Nil
              case scala.xml.PrefixedAttribute(pre, key, value, _) if pre == elem.scope.getPrefix("http://www.spiritconsortium.org/XMLSchema/SPIRIT/1685-2009") &&
                key == "rangeType" => Nil
              case scala.xml.UnprefixedAttribute(key, value, _) =>
                List(("@" + key, IPXACT2009scalaxb.DataRecord(None, Some(key), value.text)))
              case scala.xml.PrefixedAttribute(pre, key, value, _) =>
                val ns = elem.scope.getURI(pre)
                List(("@{" + ns + "}" + key, IPXACT2009scalaxb.DataRecord(Option[String](ns), Some(key), value.text)))
              case _ => Nil
            }
          case _ => Nil
        }): _*),
      (node \ "@{http://www.spiritconsortium.org/XMLSchema/SPIRIT/1685-2009}choiceRef").headOption map { IPXACT2009scalaxb.fromXML[String](_, IPXACT2009scalaxb.ElemName(node) :: stack) },
      (node \ "@{http://www.spiritconsortium.org/XMLSchema/SPIRIT/1685-2009}order").headOption map { IPXACT2009scalaxb.fromXML[Float](_, IPXACT2009scalaxb.ElemName(node) :: stack) },
      (node \ "@{http://www.spiritconsortium.org/XMLSchema/SPIRIT/1685-2009}configGroups").headOption map { IPXACT2009scalaxb.fromXML[Seq[String]](_, IPXACT2009scalaxb.ElemName(node) :: stack) },
      (node \ "@{http://www.spiritconsortium.org/XMLSchema/SPIRIT/1685-2009}bitStringLength").headOption map { IPXACT2009scalaxb.fromXML[BigInt](_, IPXACT2009scalaxb.ElemName(node) :: stack) },
      (node \ "@{http://www.spiritconsortium.org/XMLSchema/SPIRIT/1685-2009}minimum").headOption map { IPXACT2009scalaxb.fromXML[String](_, IPXACT2009scalaxb.ElemName(node) :: stack) },
      (node \ "@{http://www.spiritconsortium.org/XMLSchema/SPIRIT/1685-2009}maximum").headOption map { IPXACT2009scalaxb.fromXML[String](_, IPXACT2009scalaxb.ElemName(node) :: stack) },
      (node \ "@{http://www.spiritconsortium.org/XMLSchema/SPIRIT/1685-2009}rangeType").headOption map { IPXACT2009scalaxb.fromXML[RangeTypeType](_, IPXACT2009scalaxb.ElemName(node) :: stack) } getOrElse { IPXACT2009scalaxb.fromXML[RangeTypeType](scala.xml.Text("int"), IPXACT2009scalaxb.ElemName(node) :: stack) }))
      case _ => Left("reads failed: seq must be scala.xml.Node")
    }
    
    def toAttribute(__obj: Boolu46att, __attr: scala.xml.MetaData, __scope: scala.xml.NamespaceBinding): scala.xml.MetaData = {
      var attr: scala.xml.MetaData  = __attr
      if (__obj.spiritformat.toString != "bool") attr = scala.xml.Attribute(__scope.getPrefix("http://www.spiritconsortium.org/XMLSchema/SPIRIT/1685-2009"), "format", __obj.spiritformat.toString, attr)
    __obj.spiritresolve foreach { x => attr = scala.xml.Attribute(__scope.getPrefix("http://www.spiritconsortium.org/XMLSchema/SPIRIT/1685-2009"), "resolve", x.toString, attr) }
    __obj.spiritid foreach { x => attr = scala.xml.Attribute(__scope.getPrefix("http://www.spiritconsortium.org/XMLSchema/SPIRIT/1685-2009"), "id", x.toString, attr) }
    __obj.spiritdependency foreach { x => attr = scala.xml.Attribute(__scope.getPrefix("http://www.spiritconsortium.org/XMLSchema/SPIRIT/1685-2009"), "dependency", x.toString, attr) }
    __obj.attributes.toList map {
        case (key, x) => attr = scala.xml.Attribute((x.namespace map { __scope.getPrefix(_) }).orNull, x.key.orNull, x.value.toString, attr) }
    __obj.spiritchoiceRef foreach { x => attr = scala.xml.Attribute(__scope.getPrefix("http://www.spiritconsortium.org/XMLSchema/SPIRIT/1685-2009"), "choiceRef", x.toString, attr) }
    __obj.spiritorder foreach { x => attr = scala.xml.Attribute(__scope.getPrefix("http://www.spiritconsortium.org/XMLSchema/SPIRIT/1685-2009"), "order", x.toString, attr) }
    __obj.spiritconfigGroups foreach { x => attr = scala.xml.Attribute(__scope.getPrefix("http://www.spiritconsortium.org/XMLSchema/SPIRIT/1685-2009"), "configGroups", x.toString, attr) }
    __obj.spiritbitStringLength foreach { x => attr = scala.xml.Attribute(__scope.getPrefix("http://www.spiritconsortium.org/XMLSchema/SPIRIT/1685-2009"), "bitStringLength", x.toString, attr) }
    __obj.spiritminimum foreach { x => attr = scala.xml.Attribute(__scope.getPrefix("http://www.spiritconsortium.org/XMLSchema/SPIRIT/1685-2009"), "minimum", x.toString, attr) }
    __obj.spiritmaximum foreach { x => attr = scala.xml.Attribute(__scope.getPrefix("http://www.spiritconsortium.org/XMLSchema/SPIRIT/1685-2009"), "maximum", x.toString, attr) }
    if (__obj.spiritrangeType.toString != "int") attr = scala.xml.Attribute(__scope.getPrefix("http://www.spiritconsortium.org/XMLSchema/SPIRIT/1685-2009"), "rangeType", __obj.spiritrangeType.toString, attr)
      attr
    }
  }

  trait Default_Boolu46promptu46attFormat extends IPXACT2009scalaxb.AttributeGroupFormat[Boolu46promptu46att] {
    val targetNamespace: Option[String] = Some("http://www.spiritconsortium.org/XMLSchema/SPIRIT/1685-2009")
    
    def reads(seq: scala.xml.NodeSeq, stack: List[IPXACT2009scalaxb.ElemName]): Either[String, Boolu46promptu46att] = seq match {
      case node: scala.xml.Node => Right(Boolu46promptu46att((node \ "@{http://www.spiritconsortium.org/XMLSchema/SPIRIT/1685-2009}format").headOption map { IPXACT2009scalaxb.fromXML[FormatType](_, IPXACT2009scalaxb.ElemName(node) :: stack) } getOrElse { IPXACT2009scalaxb.fromXML[FormatType](scala.xml.Text("bool"), IPXACT2009scalaxb.ElemName(node) :: stack) },
      (node \ "@{http://www.spiritconsortium.org/XMLSchema/SPIRIT/1685-2009}resolve").headOption map { IPXACT2009scalaxb.fromXML[ResolveType](_, IPXACT2009scalaxb.ElemName(node) :: stack) },
      (node \ "@{http://www.spiritconsortium.org/XMLSchema/SPIRIT/1685-2009}id").headOption map { IPXACT2009scalaxb.fromXML[String](_, IPXACT2009scalaxb.ElemName(node) :: stack) },
      (node \ "@{http://www.spiritconsortium.org/XMLSchema/SPIRIT/1685-2009}dependency").headOption map { IPXACT2009scalaxb.fromXML[String](_, IPXACT2009scalaxb.ElemName(node) :: stack) },
      scala.collection.immutable.ListMap((node match {
          case elem: scala.xml.Elem =>
            elem.attributes.toList flatMap {
              case scala.xml.PrefixedAttribute(pre, key, value, _) if pre == elem.scope.getPrefix("http://www.spiritconsortium.org/XMLSchema/SPIRIT/1685-2009") &&
                key == "format" => Nil
              case scala.xml.PrefixedAttribute(pre, key, value, _) if pre == elem.scope.getPrefix("http://www.spiritconsortium.org/XMLSchema/SPIRIT/1685-2009") &&
                key == "resolve" => Nil
              case scala.xml.PrefixedAttribute(pre, key, value, _) if pre == elem.scope.getPrefix("http://www.spiritconsortium.org/XMLSchema/SPIRIT/1685-2009") &&
                key == "id" => Nil
              case scala.xml.PrefixedAttribute(pre, key, value, _) if pre == elem.scope.getPrefix("http://www.spiritconsortium.org/XMLSchema/SPIRIT/1685-2009") &&
                key == "dependency" => Nil
              case scala.xml.PrefixedAttribute(pre, key, value, _) if pre == elem.scope.getPrefix("http://www.spiritconsortium.org/XMLSchema/SPIRIT/1685-2009") &&
                key == "choiceRef" => Nil
              case scala.xml.PrefixedAttribute(pre, key, value, _) if pre == elem.scope.getPrefix("http://www.spiritconsortium.org/XMLSchema/SPIRIT/1685-2009") &&
                key == "order" => Nil
              case scala.xml.PrefixedAttribute(pre, key, value, _) if pre == elem.scope.getPrefix("http://www.spiritconsortium.org/XMLSchema/SPIRIT/1685-2009") &&
                key == "configGroups" => Nil
              case scala.xml.PrefixedAttribute(pre, key, value, _) if pre == elem.scope.getPrefix("http://www.spiritconsortium.org/XMLSchema/SPIRIT/1685-2009") &&
                key == "bitStringLength" => Nil
              case scala.xml.PrefixedAttribute(pre, key, value, _) if pre == elem.scope.getPrefix("http://www.spiritconsortium.org/XMLSchema/SPIRIT/1685-2009") &&
                key == "minimum" => Nil
              case scala.xml.PrefixedAttribute(pre, key, value, _) if pre == elem.scope.getPrefix("http://www.spiritconsortium.org/XMLSchema/SPIRIT/1685-2009") &&
                key == "maximum" => Nil
              case scala.xml.PrefixedAttribute(pre, key, value, _) if pre == elem.scope.getPrefix("http://www.spiritconsortium.org/XMLSchema/SPIRIT/1685-2009") &&
                key == "rangeType" => Nil
              case scala.xml.PrefixedAttribute(pre, key, value, _) if pre == elem.scope.getPrefix("http://www.spiritconsortium.org/XMLSchema/SPIRIT/1685-2009") &&
                key == "prompt" => Nil
              case scala.xml.UnprefixedAttribute(key, value, _) =>
                List(("@" + key, IPXACT2009scalaxb.DataRecord(None, Some(key), value.text)))
              case scala.xml.PrefixedAttribute(pre, key, value, _) =>
                val ns = elem.scope.getURI(pre)
                List(("@{" + ns + "}" + key, IPXACT2009scalaxb.DataRecord(Option[String](ns), Some(key), value.text)))
              case _ => Nil
            }
          case _ => Nil
        }): _*),
      (node \ "@{http://www.spiritconsortium.org/XMLSchema/SPIRIT/1685-2009}choiceRef").headOption map { IPXACT2009scalaxb.fromXML[String](_, IPXACT2009scalaxb.ElemName(node) :: stack) },
      (node \ "@{http://www.spiritconsortium.org/XMLSchema/SPIRIT/1685-2009}order").headOption map { IPXACT2009scalaxb.fromXML[Float](_, IPXACT2009scalaxb.ElemName(node) :: stack) },
      (node \ "@{http://www.spiritconsortium.org/XMLSchema/SPIRIT/1685-2009}configGroups").headOption map { IPXACT2009scalaxb.fromXML[Seq[String]](_, IPXACT2009scalaxb.ElemName(node) :: stack) },
      (node \ "@{http://www.spiritconsortium.org/XMLSchema/SPIRIT/1685-2009}bitStringLength").headOption map { IPXACT2009scalaxb.fromXML[BigInt](_, IPXACT2009scalaxb.ElemName(node) :: stack) },
      (node \ "@{http://www.spiritconsortium.org/XMLSchema/SPIRIT/1685-2009}minimum").headOption map { IPXACT2009scalaxb.fromXML[String](_, IPXACT2009scalaxb.ElemName(node) :: stack) },
      (node \ "@{http://www.spiritconsortium.org/XMLSchema/SPIRIT/1685-2009}maximum").headOption map { IPXACT2009scalaxb.fromXML[String](_, IPXACT2009scalaxb.ElemName(node) :: stack) },
      (node \ "@{http://www.spiritconsortium.org/XMLSchema/SPIRIT/1685-2009}rangeType").headOption map { IPXACT2009scalaxb.fromXML[RangeTypeType](_, IPXACT2009scalaxb.ElemName(node) :: stack) } getOrElse { IPXACT2009scalaxb.fromXML[RangeTypeType](scala.xml.Text("int"), IPXACT2009scalaxb.ElemName(node) :: stack) },
      (node \ "@{http://www.spiritconsortium.org/XMLSchema/SPIRIT/1685-2009}prompt").headOption map { IPXACT2009scalaxb.fromXML[String](_, IPXACT2009scalaxb.ElemName(node) :: stack) }))
      case _ => Left("reads failed: seq must be scala.xml.Node")
    }
    
    def toAttribute(__obj: Boolu46promptu46att, __attr: scala.xml.MetaData, __scope: scala.xml.NamespaceBinding): scala.xml.MetaData = {
      var attr: scala.xml.MetaData  = __attr
      if (__obj.spiritformat.toString != "bool") attr = scala.xml.Attribute(__scope.getPrefix("http://www.spiritconsortium.org/XMLSchema/SPIRIT/1685-2009"), "format", __obj.spiritformat.toString, attr)
    __obj.spiritresolve foreach { x => attr = scala.xml.Attribute(__scope.getPrefix("http://www.spiritconsortium.org/XMLSchema/SPIRIT/1685-2009"), "resolve", x.toString, attr) }
    __obj.spiritid foreach { x => attr = scala.xml.Attribute(__scope.getPrefix("http://www.spiritconsortium.org/XMLSchema/SPIRIT/1685-2009"), "id", x.toString, attr) }
    __obj.spiritdependency foreach { x => attr = scala.xml.Attribute(__scope.getPrefix("http://www.spiritconsortium.org/XMLSchema/SPIRIT/1685-2009"), "dependency", x.toString, attr) }
    __obj.attributes.toList map {
        case (key, x) => attr = scala.xml.Attribute((x.namespace map { __scope.getPrefix(_) }).orNull, x.key.orNull, x.value.toString, attr) }
    __obj.spiritchoiceRef foreach { x => attr = scala.xml.Attribute(__scope.getPrefix("http://www.spiritconsortium.org/XMLSchema/SPIRIT/1685-2009"), "choiceRef", x.toString, attr) }
    __obj.spiritorder foreach { x => attr = scala.xml.Attribute(__scope.getPrefix("http://www.spiritconsortium.org/XMLSchema/SPIRIT/1685-2009"), "order", x.toString, attr) }
    __obj.spiritconfigGroups foreach { x => attr = scala.xml.Attribute(__scope.getPrefix("http://www.spiritconsortium.org/XMLSchema/SPIRIT/1685-2009"), "configGroups", x.toString, attr) }
    __obj.spiritbitStringLength foreach { x => attr = scala.xml.Attribute(__scope.getPrefix("http://www.spiritconsortium.org/XMLSchema/SPIRIT/1685-2009"), "bitStringLength", x.toString, attr) }
    __obj.spiritminimum foreach { x => attr = scala.xml.Attribute(__scope.getPrefix("http://www.spiritconsortium.org/XMLSchema/SPIRIT/1685-2009"), "minimum", x.toString, attr) }
    __obj.spiritmaximum foreach { x => attr = scala.xml.Attribute(__scope.getPrefix("http://www.spiritconsortium.org/XMLSchema/SPIRIT/1685-2009"), "maximum", x.toString, attr) }
    if (__obj.spiritrangeType.toString != "int") attr = scala.xml.Attribute(__scope.getPrefix("http://www.spiritconsortium.org/XMLSchema/SPIRIT/1685-2009"), "rangeType", __obj.spiritrangeType.toString, attr)
    __obj.spiritprompt foreach { x => attr = scala.xml.Attribute(__scope.getPrefix("http://www.spiritconsortium.org/XMLSchema/SPIRIT/1685-2009"), "prompt", x.toString, attr) }
      attr
    }
  }

  trait Default_Floatu46promptu46attFormat extends IPXACT2009scalaxb.AttributeGroupFormat[Floatu46promptu46att] {
    val targetNamespace: Option[String] = Some("http://www.spiritconsortium.org/XMLSchema/SPIRIT/1685-2009")
    
    def reads(seq: scala.xml.NodeSeq, stack: List[IPXACT2009scalaxb.ElemName]): Either[String, Floatu46promptu46att] = seq match {
      case node: scala.xml.Node => Right(Floatu46promptu46att((node \ "@{http://www.spiritconsortium.org/XMLSchema/SPIRIT/1685-2009}format").headOption map { IPXACT2009scalaxb.fromXML[FormatType](_, IPXACT2009scalaxb.ElemName(node) :: stack) } getOrElse { IPXACT2009scalaxb.fromXML[FormatType](scala.xml.Text("float"), IPXACT2009scalaxb.ElemName(node) :: stack) },
      (node \ "@{http://www.spiritconsortium.org/XMLSchema/SPIRIT/1685-2009}resolve").headOption map { IPXACT2009scalaxb.fromXML[ResolveType](_, IPXACT2009scalaxb.ElemName(node) :: stack) },
      (node \ "@{http://www.spiritconsortium.org/XMLSchema/SPIRIT/1685-2009}id").headOption map { IPXACT2009scalaxb.fromXML[String](_, IPXACT2009scalaxb.ElemName(node) :: stack) },
      (node \ "@{http://www.spiritconsortium.org/XMLSchema/SPIRIT/1685-2009}dependency").headOption map { IPXACT2009scalaxb.fromXML[String](_, IPXACT2009scalaxb.ElemName(node) :: stack) },
      scala.collection.immutable.ListMap((node match {
          case elem: scala.xml.Elem =>
            elem.attributes.toList flatMap {
              case scala.xml.PrefixedAttribute(pre, key, value, _) if pre == elem.scope.getPrefix("http://www.spiritconsortium.org/XMLSchema/SPIRIT/1685-2009") &&
                key == "format" => Nil
              case scala.xml.PrefixedAttribute(pre, key, value, _) if pre == elem.scope.getPrefix("http://www.spiritconsortium.org/XMLSchema/SPIRIT/1685-2009") &&
                key == "resolve" => Nil
              case scala.xml.PrefixedAttribute(pre, key, value, _) if pre == elem.scope.getPrefix("http://www.spiritconsortium.org/XMLSchema/SPIRIT/1685-2009") &&
                key == "id" => Nil
              case scala.xml.PrefixedAttribute(pre, key, value, _) if pre == elem.scope.getPrefix("http://www.spiritconsortium.org/XMLSchema/SPIRIT/1685-2009") &&
                key == "dependency" => Nil
              case scala.xml.PrefixedAttribute(pre, key, value, _) if pre == elem.scope.getPrefix("http://www.spiritconsortium.org/XMLSchema/SPIRIT/1685-2009") &&
                key == "choiceRef" => Nil
              case scala.xml.PrefixedAttribute(pre, key, value, _) if pre == elem.scope.getPrefix("http://www.spiritconsortium.org/XMLSchema/SPIRIT/1685-2009") &&
                key == "order" => Nil
              case scala.xml.PrefixedAttribute(pre, key, value, _) if pre == elem.scope.getPrefix("http://www.spiritconsortium.org/XMLSchema/SPIRIT/1685-2009") &&
                key == "configGroups" => Nil
              case scala.xml.PrefixedAttribute(pre, key, value, _) if pre == elem.scope.getPrefix("http://www.spiritconsortium.org/XMLSchema/SPIRIT/1685-2009") &&
                key == "bitStringLength" => Nil
              case scala.xml.PrefixedAttribute(pre, key, value, _) if pre == elem.scope.getPrefix("http://www.spiritconsortium.org/XMLSchema/SPIRIT/1685-2009") &&
                key == "minimum" => Nil
              case scala.xml.PrefixedAttribute(pre, key, value, _) if pre == elem.scope.getPrefix("http://www.spiritconsortium.org/XMLSchema/SPIRIT/1685-2009") &&
                key == "maximum" => Nil
              case scala.xml.PrefixedAttribute(pre, key, value, _) if pre == elem.scope.getPrefix("http://www.spiritconsortium.org/XMLSchema/SPIRIT/1685-2009") &&
                key == "rangeType" => Nil
              case scala.xml.PrefixedAttribute(pre, key, value, _) if pre == elem.scope.getPrefix("http://www.spiritconsortium.org/XMLSchema/SPIRIT/1685-2009") &&
                key == "prompt" => Nil
              case scala.xml.UnprefixedAttribute(key, value, _) =>
                List(("@" + key, IPXACT2009scalaxb.DataRecord(None, Some(key), value.text)))
              case scala.xml.PrefixedAttribute(pre, key, value, _) =>
                val ns = elem.scope.getURI(pre)
                List(("@{" + ns + "}" + key, IPXACT2009scalaxb.DataRecord(Option[String](ns), Some(key), value.text)))
              case _ => Nil
            }
          case _ => Nil
        }): _*),
      (node \ "@{http://www.spiritconsortium.org/XMLSchema/SPIRIT/1685-2009}choiceRef").headOption map { IPXACT2009scalaxb.fromXML[String](_, IPXACT2009scalaxb.ElemName(node) :: stack) },
      (node \ "@{http://www.spiritconsortium.org/XMLSchema/SPIRIT/1685-2009}order").headOption map { IPXACT2009scalaxb.fromXML[Float](_, IPXACT2009scalaxb.ElemName(node) :: stack) },
      (node \ "@{http://www.spiritconsortium.org/XMLSchema/SPIRIT/1685-2009}configGroups").headOption map { IPXACT2009scalaxb.fromXML[Seq[String]](_, IPXACT2009scalaxb.ElemName(node) :: stack) },
      (node \ "@{http://www.spiritconsortium.org/XMLSchema/SPIRIT/1685-2009}bitStringLength").headOption map { IPXACT2009scalaxb.fromXML[BigInt](_, IPXACT2009scalaxb.ElemName(node) :: stack) },
      (node \ "@{http://www.spiritconsortium.org/XMLSchema/SPIRIT/1685-2009}minimum").headOption map { IPXACT2009scalaxb.fromXML[String](_, IPXACT2009scalaxb.ElemName(node) :: stack) },
      (node \ "@{http://www.spiritconsortium.org/XMLSchema/SPIRIT/1685-2009}maximum").headOption map { IPXACT2009scalaxb.fromXML[String](_, IPXACT2009scalaxb.ElemName(node) :: stack) },
      (node \ "@{http://www.spiritconsortium.org/XMLSchema/SPIRIT/1685-2009}rangeType").headOption map { IPXACT2009scalaxb.fromXML[RangeTypeType](_, IPXACT2009scalaxb.ElemName(node) :: stack) } getOrElse { IPXACT2009scalaxb.fromXML[RangeTypeType](scala.xml.Text("float"), IPXACT2009scalaxb.ElemName(node) :: stack) },
      (node \ "@{http://www.spiritconsortium.org/XMLSchema/SPIRIT/1685-2009}prompt").headOption map { IPXACT2009scalaxb.fromXML[String](_, IPXACT2009scalaxb.ElemName(node) :: stack) }))
      case _ => Left("reads failed: seq must be scala.xml.Node")
    }
    
    def toAttribute(__obj: Floatu46promptu46att, __attr: scala.xml.MetaData, __scope: scala.xml.NamespaceBinding): scala.xml.MetaData = {
      var attr: scala.xml.MetaData  = __attr
      if (__obj.spiritformat.toString != "float") attr = scala.xml.Attribute(__scope.getPrefix("http://www.spiritconsortium.org/XMLSchema/SPIRIT/1685-2009"), "format", __obj.spiritformat.toString, attr)
    __obj.spiritresolve foreach { x => attr = scala.xml.Attribute(__scope.getPrefix("http://www.spiritconsortium.org/XMLSchema/SPIRIT/1685-2009"), "resolve", x.toString, attr) }
    __obj.spiritid foreach { x => attr = scala.xml.Attribute(__scope.getPrefix("http://www.spiritconsortium.org/XMLSchema/SPIRIT/1685-2009"), "id", x.toString, attr) }
    __obj.spiritdependency foreach { x => attr = scala.xml.Attribute(__scope.getPrefix("http://www.spiritconsortium.org/XMLSchema/SPIRIT/1685-2009"), "dependency", x.toString, attr) }
    __obj.attributes.toList map {
        case (key, x) => attr = scala.xml.Attribute((x.namespace map { __scope.getPrefix(_) }).orNull, x.key.orNull, x.value.toString, attr) }
    __obj.spiritchoiceRef foreach { x => attr = scala.xml.Attribute(__scope.getPrefix("http://www.spiritconsortium.org/XMLSchema/SPIRIT/1685-2009"), "choiceRef", x.toString, attr) }
    __obj.spiritorder foreach { x => attr = scala.xml.Attribute(__scope.getPrefix("http://www.spiritconsortium.org/XMLSchema/SPIRIT/1685-2009"), "order", x.toString, attr) }
    __obj.spiritconfigGroups foreach { x => attr = scala.xml.Attribute(__scope.getPrefix("http://www.spiritconsortium.org/XMLSchema/SPIRIT/1685-2009"), "configGroups", x.toString, attr) }
    __obj.spiritbitStringLength foreach { x => attr = scala.xml.Attribute(__scope.getPrefix("http://www.spiritconsortium.org/XMLSchema/SPIRIT/1685-2009"), "bitStringLength", x.toString, attr) }
    __obj.spiritminimum foreach { x => attr = scala.xml.Attribute(__scope.getPrefix("http://www.spiritconsortium.org/XMLSchema/SPIRIT/1685-2009"), "minimum", x.toString, attr) }
    __obj.spiritmaximum foreach { x => attr = scala.xml.Attribute(__scope.getPrefix("http://www.spiritconsortium.org/XMLSchema/SPIRIT/1685-2009"), "maximum", x.toString, attr) }
    if (__obj.spiritrangeType.toString != "float") attr = scala.xml.Attribute(__scope.getPrefix("http://www.spiritconsortium.org/XMLSchema/SPIRIT/1685-2009"), "rangeType", __obj.spiritrangeType.toString, attr)
    __obj.spiritprompt foreach { x => attr = scala.xml.Attribute(__scope.getPrefix("http://www.spiritconsortium.org/XMLSchema/SPIRIT/1685-2009"), "prompt", x.toString, attr) }
      attr
    }
  }

  trait Default_Longu46promptu46attFormat extends IPXACT2009scalaxb.AttributeGroupFormat[Longu46promptu46att] {
    val targetNamespace: Option[String] = Some("http://www.spiritconsortium.org/XMLSchema/SPIRIT/1685-2009")
    
    def reads(seq: scala.xml.NodeSeq, stack: List[IPXACT2009scalaxb.ElemName]): Either[String, Longu46promptu46att] = seq match {
      case node: scala.xml.Node => Right(Longu46promptu46att((node \ "@{http://www.spiritconsortium.org/XMLSchema/SPIRIT/1685-2009}format").headOption map { IPXACT2009scalaxb.fromXML[FormatType](_, IPXACT2009scalaxb.ElemName(node) :: stack) } getOrElse { IPXACT2009scalaxb.fromXML[FormatType](scala.xml.Text("long"), IPXACT2009scalaxb.ElemName(node) :: stack) },
      (node \ "@{http://www.spiritconsortium.org/XMLSchema/SPIRIT/1685-2009}resolve").headOption map { IPXACT2009scalaxb.fromXML[ResolveType](_, IPXACT2009scalaxb.ElemName(node) :: stack) },
      (node \ "@{http://www.spiritconsortium.org/XMLSchema/SPIRIT/1685-2009}id").headOption map { IPXACT2009scalaxb.fromXML[String](_, IPXACT2009scalaxb.ElemName(node) :: stack) },
      (node \ "@{http://www.spiritconsortium.org/XMLSchema/SPIRIT/1685-2009}dependency").headOption map { IPXACT2009scalaxb.fromXML[String](_, IPXACT2009scalaxb.ElemName(node) :: stack) },
      scala.collection.immutable.ListMap((node match {
          case elem: scala.xml.Elem =>
            elem.attributes.toList flatMap {
              case scala.xml.PrefixedAttribute(pre, key, value, _) if pre == elem.scope.getPrefix("http://www.spiritconsortium.org/XMLSchema/SPIRIT/1685-2009") &&
                key == "format" => Nil
              case scala.xml.PrefixedAttribute(pre, key, value, _) if pre == elem.scope.getPrefix("http://www.spiritconsortium.org/XMLSchema/SPIRIT/1685-2009") &&
                key == "resolve" => Nil
              case scala.xml.PrefixedAttribute(pre, key, value, _) if pre == elem.scope.getPrefix("http://www.spiritconsortium.org/XMLSchema/SPIRIT/1685-2009") &&
                key == "id" => Nil
              case scala.xml.PrefixedAttribute(pre, key, value, _) if pre == elem.scope.getPrefix("http://www.spiritconsortium.org/XMLSchema/SPIRIT/1685-2009") &&
                key == "dependency" => Nil
              case scala.xml.PrefixedAttribute(pre, key, value, _) if pre == elem.scope.getPrefix("http://www.spiritconsortium.org/XMLSchema/SPIRIT/1685-2009") &&
                key == "choiceRef" => Nil
              case scala.xml.PrefixedAttribute(pre, key, value, _) if pre == elem.scope.getPrefix("http://www.spiritconsortium.org/XMLSchema/SPIRIT/1685-2009") &&
                key == "order" => Nil
              case scala.xml.PrefixedAttribute(pre, key, value, _) if pre == elem.scope.getPrefix("http://www.spiritconsortium.org/XMLSchema/SPIRIT/1685-2009") &&
                key == "configGroups" => Nil
              case scala.xml.PrefixedAttribute(pre, key, value, _) if pre == elem.scope.getPrefix("http://www.spiritconsortium.org/XMLSchema/SPIRIT/1685-2009") &&
                key == "bitStringLength" => Nil
              case scala.xml.PrefixedAttribute(pre, key, value, _) if pre == elem.scope.getPrefix("http://www.spiritconsortium.org/XMLSchema/SPIRIT/1685-2009") &&
                key == "minimum" => Nil
              case scala.xml.PrefixedAttribute(pre, key, value, _) if pre == elem.scope.getPrefix("http://www.spiritconsortium.org/XMLSchema/SPIRIT/1685-2009") &&
                key == "maximum" => Nil
              case scala.xml.PrefixedAttribute(pre, key, value, _) if pre == elem.scope.getPrefix("http://www.spiritconsortium.org/XMLSchema/SPIRIT/1685-2009") &&
                key == "rangeType" => Nil
              case scala.xml.PrefixedAttribute(pre, key, value, _) if pre == elem.scope.getPrefix("http://www.spiritconsortium.org/XMLSchema/SPIRIT/1685-2009") &&
                key == "prompt" => Nil
              case scala.xml.UnprefixedAttribute(key, value, _) =>
                List(("@" + key, IPXACT2009scalaxb.DataRecord(None, Some(key), value.text)))
              case scala.xml.PrefixedAttribute(pre, key, value, _) =>
                val ns = elem.scope.getURI(pre)
                List(("@{" + ns + "}" + key, IPXACT2009scalaxb.DataRecord(Option[String](ns), Some(key), value.text)))
              case _ => Nil
            }
          case _ => Nil
        }): _*),
      (node \ "@{http://www.spiritconsortium.org/XMLSchema/SPIRIT/1685-2009}choiceRef").headOption map { IPXACT2009scalaxb.fromXML[String](_, IPXACT2009scalaxb.ElemName(node) :: stack) },
      (node \ "@{http://www.spiritconsortium.org/XMLSchema/SPIRIT/1685-2009}order").headOption map { IPXACT2009scalaxb.fromXML[Float](_, IPXACT2009scalaxb.ElemName(node) :: stack) },
      (node \ "@{http://www.spiritconsortium.org/XMLSchema/SPIRIT/1685-2009}configGroups").headOption map { IPXACT2009scalaxb.fromXML[Seq[String]](_, IPXACT2009scalaxb.ElemName(node) :: stack) },
      (node \ "@{http://www.spiritconsortium.org/XMLSchema/SPIRIT/1685-2009}bitStringLength").headOption map { IPXACT2009scalaxb.fromXML[BigInt](_, IPXACT2009scalaxb.ElemName(node) :: stack) },
      (node \ "@{http://www.spiritconsortium.org/XMLSchema/SPIRIT/1685-2009}minimum").headOption map { IPXACT2009scalaxb.fromXML[String](_, IPXACT2009scalaxb.ElemName(node) :: stack) },
      (node \ "@{http://www.spiritconsortium.org/XMLSchema/SPIRIT/1685-2009}maximum").headOption map { IPXACT2009scalaxb.fromXML[String](_, IPXACT2009scalaxb.ElemName(node) :: stack) },
      (node \ "@{http://www.spiritconsortium.org/XMLSchema/SPIRIT/1685-2009}rangeType").headOption map { IPXACT2009scalaxb.fromXML[RangeTypeType](_, IPXACT2009scalaxb.ElemName(node) :: stack) } getOrElse { IPXACT2009scalaxb.fromXML[RangeTypeType](scala.xml.Text("float"), IPXACT2009scalaxb.ElemName(node) :: stack) },
      (node \ "@{http://www.spiritconsortium.org/XMLSchema/SPIRIT/1685-2009}prompt").headOption map { IPXACT2009scalaxb.fromXML[String](_, IPXACT2009scalaxb.ElemName(node) :: stack) }))
      case _ => Left("reads failed: seq must be scala.xml.Node")
    }
    
    def toAttribute(__obj: Longu46promptu46att, __attr: scala.xml.MetaData, __scope: scala.xml.NamespaceBinding): scala.xml.MetaData = {
      var attr: scala.xml.MetaData  = __attr
      if (__obj.spiritformat.toString != "long") attr = scala.xml.Attribute(__scope.getPrefix("http://www.spiritconsortium.org/XMLSchema/SPIRIT/1685-2009"), "format", __obj.spiritformat.toString, attr)
    __obj.spiritresolve foreach { x => attr = scala.xml.Attribute(__scope.getPrefix("http://www.spiritconsortium.org/XMLSchema/SPIRIT/1685-2009"), "resolve", x.toString, attr) }
    __obj.spiritid foreach { x => attr = scala.xml.Attribute(__scope.getPrefix("http://www.spiritconsortium.org/XMLSchema/SPIRIT/1685-2009"), "id", x.toString, attr) }
    __obj.spiritdependency foreach { x => attr = scala.xml.Attribute(__scope.getPrefix("http://www.spiritconsortium.org/XMLSchema/SPIRIT/1685-2009"), "dependency", x.toString, attr) }
    __obj.attributes.toList map {
        case (key, x) => attr = scala.xml.Attribute((x.namespace map { __scope.getPrefix(_) }).orNull, x.key.orNull, x.value.toString, attr) }
    __obj.spiritchoiceRef foreach { x => attr = scala.xml.Attribute(__scope.getPrefix("http://www.spiritconsortium.org/XMLSchema/SPIRIT/1685-2009"), "choiceRef", x.toString, attr) }
    __obj.spiritorder foreach { x => attr = scala.xml.Attribute(__scope.getPrefix("http://www.spiritconsortium.org/XMLSchema/SPIRIT/1685-2009"), "order", x.toString, attr) }
    __obj.spiritconfigGroups foreach { x => attr = scala.xml.Attribute(__scope.getPrefix("http://www.spiritconsortium.org/XMLSchema/SPIRIT/1685-2009"), "configGroups", x.toString, attr) }
    __obj.spiritbitStringLength foreach { x => attr = scala.xml.Attribute(__scope.getPrefix("http://www.spiritconsortium.org/XMLSchema/SPIRIT/1685-2009"), "bitStringLength", x.toString, attr) }
    __obj.spiritminimum foreach { x => attr = scala.xml.Attribute(__scope.getPrefix("http://www.spiritconsortium.org/XMLSchema/SPIRIT/1685-2009"), "minimum", x.toString, attr) }
    __obj.spiritmaximum foreach { x => attr = scala.xml.Attribute(__scope.getPrefix("http://www.spiritconsortium.org/XMLSchema/SPIRIT/1685-2009"), "maximum", x.toString, attr) }
    if (__obj.spiritrangeType.toString != "float") attr = scala.xml.Attribute(__scope.getPrefix("http://www.spiritconsortium.org/XMLSchema/SPIRIT/1685-2009"), "rangeType", __obj.spiritrangeType.toString, attr)
    __obj.spiritprompt foreach { x => attr = scala.xml.Attribute(__scope.getPrefix("http://www.spiritconsortium.org/XMLSchema/SPIRIT/1685-2009"), "prompt", x.toString, attr) }
      attr
    }
  }

  trait Default_Stringu46promptu46attFormat extends IPXACT2009scalaxb.AttributeGroupFormat[Stringu46promptu46att] {
    val targetNamespace: Option[String] = Some("http://www.spiritconsortium.org/XMLSchema/SPIRIT/1685-2009")
    
    def reads(seq: scala.xml.NodeSeq, stack: List[IPXACT2009scalaxb.ElemName]): Either[String, Stringu46promptu46att] = seq match {
      case node: scala.xml.Node => Right(Stringu46promptu46att((node \ "@{http://www.spiritconsortium.org/XMLSchema/SPIRIT/1685-2009}format").headOption map { IPXACT2009scalaxb.fromXML[FormatType](_, IPXACT2009scalaxb.ElemName(node) :: stack) } getOrElse { IPXACT2009scalaxb.fromXML[FormatType](scala.xml.Text("string"), IPXACT2009scalaxb.ElemName(node) :: stack) },
      (node \ "@{http://www.spiritconsortium.org/XMLSchema/SPIRIT/1685-2009}resolve").headOption map { IPXACT2009scalaxb.fromXML[ResolveType](_, IPXACT2009scalaxb.ElemName(node) :: stack) },
      (node \ "@{http://www.spiritconsortium.org/XMLSchema/SPIRIT/1685-2009}id").headOption map { IPXACT2009scalaxb.fromXML[String](_, IPXACT2009scalaxb.ElemName(node) :: stack) },
      (node \ "@{http://www.spiritconsortium.org/XMLSchema/SPIRIT/1685-2009}dependency").headOption map { IPXACT2009scalaxb.fromXML[String](_, IPXACT2009scalaxb.ElemName(node) :: stack) },
      scala.collection.immutable.ListMap((node match {
          case elem: scala.xml.Elem =>
            elem.attributes.toList flatMap {
              case scala.xml.PrefixedAttribute(pre, key, value, _) if pre == elem.scope.getPrefix("http://www.spiritconsortium.org/XMLSchema/SPIRIT/1685-2009") &&
                key == "format" => Nil
              case scala.xml.PrefixedAttribute(pre, key, value, _) if pre == elem.scope.getPrefix("http://www.spiritconsortium.org/XMLSchema/SPIRIT/1685-2009") &&
                key == "resolve" => Nil
              case scala.xml.PrefixedAttribute(pre, key, value, _) if pre == elem.scope.getPrefix("http://www.spiritconsortium.org/XMLSchema/SPIRIT/1685-2009") &&
                key == "id" => Nil
              case scala.xml.PrefixedAttribute(pre, key, value, _) if pre == elem.scope.getPrefix("http://www.spiritconsortium.org/XMLSchema/SPIRIT/1685-2009") &&
                key == "dependency" => Nil
              case scala.xml.PrefixedAttribute(pre, key, value, _) if pre == elem.scope.getPrefix("http://www.spiritconsortium.org/XMLSchema/SPIRIT/1685-2009") &&
                key == "choiceRef" => Nil
              case scala.xml.PrefixedAttribute(pre, key, value, _) if pre == elem.scope.getPrefix("http://www.spiritconsortium.org/XMLSchema/SPIRIT/1685-2009") &&
                key == "order" => Nil
              case scala.xml.PrefixedAttribute(pre, key, value, _) if pre == elem.scope.getPrefix("http://www.spiritconsortium.org/XMLSchema/SPIRIT/1685-2009") &&
                key == "configGroups" => Nil
              case scala.xml.PrefixedAttribute(pre, key, value, _) if pre == elem.scope.getPrefix("http://www.spiritconsortium.org/XMLSchema/SPIRIT/1685-2009") &&
                key == "bitStringLength" => Nil
              case scala.xml.PrefixedAttribute(pre, key, value, _) if pre == elem.scope.getPrefix("http://www.spiritconsortium.org/XMLSchema/SPIRIT/1685-2009") &&
                key == "minimum" => Nil
              case scala.xml.PrefixedAttribute(pre, key, value, _) if pre == elem.scope.getPrefix("http://www.spiritconsortium.org/XMLSchema/SPIRIT/1685-2009") &&
                key == "maximum" => Nil
              case scala.xml.PrefixedAttribute(pre, key, value, _) if pre == elem.scope.getPrefix("http://www.spiritconsortium.org/XMLSchema/SPIRIT/1685-2009") &&
                key == "rangeType" => Nil
              case scala.xml.PrefixedAttribute(pre, key, value, _) if pre == elem.scope.getPrefix("http://www.spiritconsortium.org/XMLSchema/SPIRIT/1685-2009") &&
                key == "prompt" => Nil
              case scala.xml.UnprefixedAttribute(key, value, _) =>
                List(("@" + key, IPXACT2009scalaxb.DataRecord(None, Some(key), value.text)))
              case scala.xml.PrefixedAttribute(pre, key, value, _) =>
                val ns = elem.scope.getURI(pre)
                List(("@{" + ns + "}" + key, IPXACT2009scalaxb.DataRecord(Option[String](ns), Some(key), value.text)))
              case _ => Nil
            }
          case _ => Nil
        }): _*),
      (node \ "@{http://www.spiritconsortium.org/XMLSchema/SPIRIT/1685-2009}choiceRef").headOption map { IPXACT2009scalaxb.fromXML[String](_, IPXACT2009scalaxb.ElemName(node) :: stack) },
      (node \ "@{http://www.spiritconsortium.org/XMLSchema/SPIRIT/1685-2009}order").headOption map { IPXACT2009scalaxb.fromXML[Float](_, IPXACT2009scalaxb.ElemName(node) :: stack) },
      (node \ "@{http://www.spiritconsortium.org/XMLSchema/SPIRIT/1685-2009}configGroups").headOption map { IPXACT2009scalaxb.fromXML[Seq[String]](_, IPXACT2009scalaxb.ElemName(node) :: stack) },
      (node \ "@{http://www.spiritconsortium.org/XMLSchema/SPIRIT/1685-2009}bitStringLength").headOption map { IPXACT2009scalaxb.fromXML[BigInt](_, IPXACT2009scalaxb.ElemName(node) :: stack) },
      (node \ "@{http://www.spiritconsortium.org/XMLSchema/SPIRIT/1685-2009}minimum").headOption map { IPXACT2009scalaxb.fromXML[String](_, IPXACT2009scalaxb.ElemName(node) :: stack) },
      (node \ "@{http://www.spiritconsortium.org/XMLSchema/SPIRIT/1685-2009}maximum").headOption map { IPXACT2009scalaxb.fromXML[String](_, IPXACT2009scalaxb.ElemName(node) :: stack) },
      (node \ "@{http://www.spiritconsortium.org/XMLSchema/SPIRIT/1685-2009}rangeType").headOption map { IPXACT2009scalaxb.fromXML[RangeTypeType](_, IPXACT2009scalaxb.ElemName(node) :: stack) },
      (node \ "@{http://www.spiritconsortium.org/XMLSchema/SPIRIT/1685-2009}prompt").headOption map { IPXACT2009scalaxb.fromXML[String](_, IPXACT2009scalaxb.ElemName(node) :: stack) }))
      case _ => Left("reads failed: seq must be scala.xml.Node")
    }
    
    def toAttribute(__obj: Stringu46promptu46att, __attr: scala.xml.MetaData, __scope: scala.xml.NamespaceBinding): scala.xml.MetaData = {
      var attr: scala.xml.MetaData  = __attr
      if (__obj.spiritformat.toString != "string") attr = scala.xml.Attribute(__scope.getPrefix("http://www.spiritconsortium.org/XMLSchema/SPIRIT/1685-2009"), "format", __obj.spiritformat.toString, attr)
    __obj.spiritresolve foreach { x => attr = scala.xml.Attribute(__scope.getPrefix("http://www.spiritconsortium.org/XMLSchema/SPIRIT/1685-2009"), "resolve", x.toString, attr) }
    __obj.spiritid foreach { x => attr = scala.xml.Attribute(__scope.getPrefix("http://www.spiritconsortium.org/XMLSchema/SPIRIT/1685-2009"), "id", x.toString, attr) }
    __obj.spiritdependency foreach { x => attr = scala.xml.Attribute(__scope.getPrefix("http://www.spiritconsortium.org/XMLSchema/SPIRIT/1685-2009"), "dependency", x.toString, attr) }
    __obj.attributes.toList map {
        case (key, x) => attr = scala.xml.Attribute((x.namespace map { __scope.getPrefix(_) }).orNull, x.key.orNull, x.value.toString, attr) }
    __obj.spiritchoiceRef foreach { x => attr = scala.xml.Attribute(__scope.getPrefix("http://www.spiritconsortium.org/XMLSchema/SPIRIT/1685-2009"), "choiceRef", x.toString, attr) }
    __obj.spiritorder foreach { x => attr = scala.xml.Attribute(__scope.getPrefix("http://www.spiritconsortium.org/XMLSchema/SPIRIT/1685-2009"), "order", x.toString, attr) }
    __obj.spiritconfigGroups foreach { x => attr = scala.xml.Attribute(__scope.getPrefix("http://www.spiritconsortium.org/XMLSchema/SPIRIT/1685-2009"), "configGroups", x.toString, attr) }
    __obj.spiritbitStringLength foreach { x => attr = scala.xml.Attribute(__scope.getPrefix("http://www.spiritconsortium.org/XMLSchema/SPIRIT/1685-2009"), "bitStringLength", x.toString, attr) }
    __obj.spiritminimum foreach { x => attr = scala.xml.Attribute(__scope.getPrefix("http://www.spiritconsortium.org/XMLSchema/SPIRIT/1685-2009"), "minimum", x.toString, attr) }
    __obj.spiritmaximum foreach { x => attr = scala.xml.Attribute(__scope.getPrefix("http://www.spiritconsortium.org/XMLSchema/SPIRIT/1685-2009"), "maximum", x.toString, attr) }
    __obj.spiritrangeType foreach { x => attr = scala.xml.Attribute(__scope.getPrefix("http://www.spiritconsortium.org/XMLSchema/SPIRIT/1685-2009"), "rangeType", x.toString, attr) }
    __obj.spiritprompt foreach { x => attr = scala.xml.Attribute(__scope.getPrefix("http://www.spiritconsortium.org/XMLSchema/SPIRIT/1685-2009"), "prompt", x.toString, attr) }
      attr
    }
  }

  trait Default_SystemGroupNamesFormat extends IPXACT2009scalaxb.ElemNameParser[SystemGroupNames] {
    val targetNamespace: Option[String] = Some("http://www.spiritconsortium.org/XMLSchema/SPIRIT/1685-2009")
    
    def parser(node: scala.xml.Node, stack: List[IPXACT2009scalaxb.ElemName]): Parser[SystemGroupNames] =
      phrase(safeRep(IPXACT2009scalaxb.ElemName(Some("http://www.spiritconsortium.org/XMLSchema/SPIRIT/1685-2009"), "systemGroupName")) ^^
      { case p1 =>
      SystemGroupNames(p1 map { IPXACT2009scalaxb.fromXML[String](_, IPXACT2009scalaxb.ElemName(node) :: stack) }) })
    
    def writesChildNodes(__obj: SystemGroupNames, __scope: scala.xml.NamespaceBinding): Seq[scala.xml.Node] =
      (__obj.systemGroupName flatMap { IPXACT2009scalaxb.toXML[String](_, Some("http://www.spiritconsortium.org/XMLSchema/SPIRIT/1685-2009"), Some("systemGroupName"), __scope, false) })
  }
  trait Default_BusDefinitionFormat extends IPXACT2009scalaxb.ElemNameParser[BusDefinition] with _VersionedIdentifierGroupFormat {
    val targetNamespace: Option[String] = Some("http://www.spiritconsortium.org/XMLSchema/SPIRIT/1685-2009")
    
    def parser(node: scala.xml.Node, stack: List[IPXACT2009scalaxb.ElemName]): Parser[BusDefinition] =
      phrase((parseVersionedIdentifierGroup(node, IPXACT2009scalaxb.ElemName(node) :: stack)) ~
      (IPXACT2009scalaxb.ElemName(Some("http://www.spiritconsortium.org/XMLSchema/SPIRIT/1685-2009"), "directConnection")) ~
      (IPXACT2009scalaxb.ElemName(Some("http://www.spiritconsortium.org/XMLSchema/SPIRIT/1685-2009"), "isAddressable")) ~
      opt(IPXACT2009scalaxb.ElemName(Some("http://www.spiritconsortium.org/XMLSchema/SPIRIT/1685-2009"), "extends")) ~
      opt(IPXACT2009scalaxb.ElemName(Some("http://www.spiritconsortium.org/XMLSchema/SPIRIT/1685-2009"), "maxMasters")) ~
      opt(IPXACT2009scalaxb.ElemName(Some("http://www.spiritconsortium.org/XMLSchema/SPIRIT/1685-2009"), "maxSlaves")) ~
      opt(IPXACT2009scalaxb.ElemName(Some("http://www.spiritconsortium.org/XMLSchema/SPIRIT/1685-2009"), "systemGroupNames")) ~
      opt(IPXACT2009scalaxb.ElemName(Some("http://www.spiritconsortium.org/XMLSchema/SPIRIT/1685-2009"), "description")) ~
      opt(IPXACT2009scalaxb.ElemName(Some("http://www.spiritconsortium.org/XMLSchema/SPIRIT/1685-2009"), "vendorExtensions")) ^^
      { case p1 ~ p2 ~ p3 ~ p4 ~ p5 ~ p6 ~ p7 ~ p8 ~ p9 =>
      BusDefinition(p1,
        IPXACT2009scalaxb.fromXML[Boolean](p2, IPXACT2009scalaxb.ElemName(node) :: stack),
        IPXACT2009scalaxb.fromXML[Boolean](p3, IPXACT2009scalaxb.ElemName(node) :: stack),
        p4.headOption map { IPXACT2009scalaxb.fromXML[LibraryRefType](_, IPXACT2009scalaxb.ElemName(node) :: stack) },
        p5.headOption map { IPXACT2009scalaxb.fromXML[BigInt](_, IPXACT2009scalaxb.ElemName(node) :: stack) },
        p6.headOption map { IPXACT2009scalaxb.fromXML[BigInt](_, IPXACT2009scalaxb.ElemName(node) :: stack) },
        p7.headOption map { IPXACT2009scalaxb.fromXML[SystemGroupNames](_, IPXACT2009scalaxb.ElemName(node) :: stack) },
        p8.headOption map { IPXACT2009scalaxb.fromXML[String](_, IPXACT2009scalaxb.ElemName(node) :: stack) },
        p9.headOption map { IPXACT2009scalaxb.fromXML[VendorExtensions](_, IPXACT2009scalaxb.ElemName(node) :: stack) }) })
    
    def writesChildNodes(__obj: BusDefinition, __scope: scala.xml.NamespaceBinding): Seq[scala.xml.Node] =
      Seq.concat(IPXACT2009scalaxb.toXML[VersionedIdentifierSequence](__obj.versionedIdentifierSequence1, None, Some("versionedIdentifierSequence1"), __scope, false),
        IPXACT2009scalaxb.toXML[Boolean](__obj.directConnection, Some("http://www.spiritconsortium.org/XMLSchema/SPIRIT/1685-2009"), Some("directConnection"), __scope, false),
        IPXACT2009scalaxb.toXML[Boolean](__obj.isAddressable, Some("http://www.spiritconsortium.org/XMLSchema/SPIRIT/1685-2009"), Some("isAddressable"), __scope, false),
        __obj.extendsValue map { IPXACT2009scalaxb.toXML[LibraryRefType](_, Some("http://www.spiritconsortium.org/XMLSchema/SPIRIT/1685-2009"), Some("extends"), __scope, false) } getOrElse {Nil},
        __obj.maxMasters map { IPXACT2009scalaxb.toXML[BigInt](_, Some("http://www.spiritconsortium.org/XMLSchema/SPIRIT/1685-2009"), Some("maxMasters"), __scope, false) } getOrElse {Nil},
        __obj.maxSlaves map { IPXACT2009scalaxb.toXML[BigInt](_, Some("http://www.spiritconsortium.org/XMLSchema/SPIRIT/1685-2009"), Some("maxSlaves"), __scope, false) } getOrElse {Nil},
        __obj.systemGroupNames map { IPXACT2009scalaxb.toXML[SystemGroupNames](_, Some("http://www.spiritconsortium.org/XMLSchema/SPIRIT/1685-2009"), Some("systemGroupNames"), __scope, false) } getOrElse {Nil},
        __obj.description map { IPXACT2009scalaxb.toXML[String](_, Some("http://www.spiritconsortium.org/XMLSchema/SPIRIT/1685-2009"), Some("description"), __scope, false) } getOrElse {Nil},
        __obj.vendorExtensions map { IPXACT2009scalaxb.toXML[VendorExtensions](_, Some("http://www.spiritconsortium.org/XMLSchema/SPIRIT/1685-2009"), Some("vendorExtensions"), __scope, false) } getOrElse {Nil})

  }


  trait _PortPropertiesGroupFormat extends IPXACT2009scalaxb.AnyElemNameParser {
    def parsePortPropertiesGroup(node: scala.xml.Node, stack: List[IPXACT2009scalaxb.ElemName]): Parser[IPXACT2009scalaxb.DataRecord[Any]] =
      (((IPXACT2009scalaxb.ElemName(Some("http://www.spiritconsortium.org/XMLSchema/SPIRIT/1685-2009"), "direction")) ^^
      (x => IPXACT2009scalaxb.DataRecord(x.namespace, Some(x.name), IPXACT2009scalaxb.fromXML[String](x, IPXACT2009scalaxb.ElemName(node) :: stack)))) |
      ((IPXACT2009scalaxb.ElemName(Some("http://www.spiritconsortium.org/XMLSchema/SPIRIT/1685-2009"), "initiative")) ^^
      (x => IPXACT2009scalaxb.DataRecord(x.namespace, Some(x.name), IPXACT2009scalaxb.fromXML[String](x, IPXACT2009scalaxb.ElemName(node) :: stack)))))
  
    def parsePortPropertiesGroup(node: scala.xml.Node, stack: List[IPXACT2009scalaxb.ElemName], wrap: Boolean): Parser[IPXACT2009scalaxb.DataRecord[Any]] =
      (((IPXACT2009scalaxb.ElemName(Some("http://www.spiritconsortium.org/XMLSchema/SPIRIT/1685-2009"), "direction")) ^^
      (x => IPXACT2009scalaxb.DataRecord(x.namespace, Some(x.name), IPXACT2009scalaxb.fromXML[String](x, IPXACT2009scalaxb.ElemName(node) :: stack)))) |
      ((IPXACT2009scalaxb.ElemName(Some("http://www.spiritconsortium.org/XMLSchema/SPIRIT/1685-2009"), "initiative")) ^^
      (x => IPXACT2009scalaxb.DataRecord(x.namespace, Some(x.name), IPXACT2009scalaxb.fromXML[String](x, IPXACT2009scalaxb.ElemName(node) :: stack)))))
    
    def parsemixedPortPropertiesGroup(node: scala.xml.Node, stack: List[IPXACT2009scalaxb.ElemName]): Parser[Seq[IPXACT2009scalaxb.DataRecord[Any]]] =
      (((((IPXACT2009scalaxb.ElemName(Some("http://www.spiritconsortium.org/XMLSchema/SPIRIT/1685-2009"), "direction")) ^^
      (x => IPXACT2009scalaxb.DataRecord(x.namespace, Some(x.name), IPXACT2009scalaxb.fromXML[String](x, IPXACT2009scalaxb.ElemName(node) :: stack)))) ~
      optTextRecord) ^^ 
        { case p1 ~ p2 => Seq.concat(Seq(p1),
        p2.toList) }) ||| 
      ((((IPXACT2009scalaxb.ElemName(Some("http://www.spiritconsortium.org/XMLSchema/SPIRIT/1685-2009"), "initiative")) ^^
      (x => IPXACT2009scalaxb.DataRecord(x.namespace, Some(x.name), IPXACT2009scalaxb.fromXML[String](x, IPXACT2009scalaxb.ElemName(node) :: stack)))) ~
      optTextRecord) ^^ 
        { case p1 ~ p2 => Seq.concat(Seq(p1),
        p2.toList) }))
  }

  def build_BitSteeringTypeFormat = new Default_BitSteeringTypeFormat {}
  trait Default_BitSteeringTypeFormat extends IPXACT2009scalaxb.XMLFormat[BitSteeringType] {
    val targetNamespace: Option[String] = Some("http://www.spiritconsortium.org/XMLSchema/SPIRIT/1685-2009")
    
    def fromString(value: String, scope: scala.xml.NamespaceBinding): BitSteeringType =
        (fromString0(value, scope)).apply(IPXACT2009scalaxb.fromXML[String](scala.xml.Text(value)))

    private def fromString0(value: String, scope: scala.xml.NamespaceBinding): PartialFunction[Any, BitSteeringType] = {
      case x: String if x == IPXACT2009scalaxb.fromXML[String](scala.xml.Text("on")) => On
      case x: String if x == IPXACT2009scalaxb.fromXML[String](scala.xml.Text("off")) => Off

    }



    def reads(seq: scala.xml.NodeSeq, stack: List[IPXACT2009scalaxb.ElemName]): Either[String, BitSteeringType] = seq match {
      case elem: scala.xml.Elem => Right(fromString(elem.text, elem.scope))
      case _ => Right(fromString(seq.text, scala.xml.TopScope))
    }
    
    def writes(__obj: BitSteeringType, __namespace: Option[String], __elementLabel: Option[String],
        __scope: scala.xml.NamespaceBinding, __typeAttribute: Boolean): scala.xml.NodeSeq =
      scala.xml.Elem(IPXACT2009scalaxb.Helper.getPrefix(__namespace, __scope).orNull,
        __elementLabel getOrElse { sys.error("missing element label.") },
        scala.xml.Null, __scope, true, scala.xml.Text(__obj.toString))
  }
  def build_EndianessTypeFormat = new Default_EndianessTypeFormat {}
  trait Default_EndianessTypeFormat extends IPXACT2009scalaxb.XMLFormat[EndianessType] {
    val targetNamespace: Option[String] = Some("http://www.spiritconsortium.org/XMLSchema/SPIRIT/1685-2009")
    
    def fromString(value: String, scope: scala.xml.NamespaceBinding): EndianessType =
        (fromString0(value, scope)).apply(IPXACT2009scalaxb.fromXML[String](scala.xml.Text(value)))

    private def fromString0(value: String, scope: scala.xml.NamespaceBinding): PartialFunction[Any, EndianessType] = {
      case x: String if x == IPXACT2009scalaxb.fromXML[String](scala.xml.Text("big")) => Big
      case x: String if x == IPXACT2009scalaxb.fromXML[String](scala.xml.Text("little")) => Little

    }



    def reads(seq: scala.xml.NodeSeq, stack: List[IPXACT2009scalaxb.ElemName]): Either[String, EndianessType] = seq match {
      case elem: scala.xml.Elem => Right(fromString(elem.text, elem.scope))
      case _ => Right(fromString(seq.text, scala.xml.TopScope))
    }
    
    def writes(__obj: EndianessType, __namespace: Option[String], __elementLabel: Option[String],
        __scope: scala.xml.NamespaceBinding, __typeAttribute: Boolean): scala.xml.NodeSeq =
      scala.xml.Elem(IPXACT2009scalaxb.Helper.getPrefix(__namespace, __scope).orNull,
        __elementLabel getOrElse { sys.error("missing element label.") },
        scala.xml.Null, __scope, true, scala.xml.Text(__obj.toString))
  }
  trait Default_BusInterfacesFormat extends IPXACT2009scalaxb.ElemNameParser[BusInterfaces] {
    val targetNamespace: Option[String] = Some("http://www.spiritconsortium.org/XMLSchema/SPIRIT/1685-2009")
    
    def parser(node: scala.xml.Node, stack: List[IPXACT2009scalaxb.ElemName]): Parser[BusInterfaces] =
      phrase(safeRep(IPXACT2009scalaxb.ElemName(Some("http://www.spiritconsortium.org/XMLSchema/SPIRIT/1685-2009"), "busInterface")) ^^
      { case p1 =>
      BusInterfaces(p1 map { IPXACT2009scalaxb.fromXML[BusInterfaceType](_, IPXACT2009scalaxb.ElemName(node) :: stack) }) })
    
    def writesChildNodes(__obj: BusInterfaces, __scope: scala.xml.NamespaceBinding): Seq[scala.xml.Node] =
      (__obj.busInterface flatMap { IPXACT2009scalaxb.toXML[BusInterfaceType](_, Some("http://www.spiritconsortium.org/XMLSchema/SPIRIT/1685-2009"), Some("busInterface"), __scope, false) })
  }
  trait Default_LeftTypeFormat extends IPXACT2009scalaxb.XMLFormat[LeftType] with IPXACT2009scalaxb.CanWriteChildNodes[LeftType] {
    val targetNamespace: Option[String] = Some("http://www.spiritconsortium.org/XMLSchema/SPIRIT/1685-2009")
    def reads(seq: scala.xml.NodeSeq, stack: List[IPXACT2009scalaxb.ElemName]): Either[String, LeftType] = seq match {
      case node: scala.xml.Node => Right(LeftType(IPXACT2009scalaxb.fromXML[BigInt](node, IPXACT2009scalaxb.ElemName(node) :: stack),
        scala.collection.immutable.ListMap(List(
        (node \ "@{http://www.spiritconsortium.org/XMLSchema/SPIRIT/1685-2009}format").headOption map { x => IPXACT2009scalaxb.DataRecord(x, node, IPXACT2009scalaxb.fromXML[FormatType](x, IPXACT2009scalaxb.ElemName(node) :: stack)) } orElse Some(IPXACT2009scalaxb.DataRecord(None, None, IPXACT2009scalaxb.fromXML[FormatType](scala.xml.Text("long"), IPXACT2009scalaxb.ElemName(node) :: stack))) map { "@{http://www.spiritconsortium.org/XMLSchema/SPIRIT/1685-2009}format" -> _ },
        (node \ "@{http://www.spiritconsortium.org/XMLSchema/SPIRIT/1685-2009}resolve").headOption map { x => IPXACT2009scalaxb.DataRecord(x, node, IPXACT2009scalaxb.fromXML[ResolveType](x, IPXACT2009scalaxb.ElemName(node) :: stack)) } map { "@{http://www.spiritconsortium.org/XMLSchema/SPIRIT/1685-2009}resolve" -> _ },
        (node \ "@{http://www.spiritconsortium.org/XMLSchema/SPIRIT/1685-2009}id").headOption map { x => IPXACT2009scalaxb.DataRecord(x, node, IPXACT2009scalaxb.fromXML[String](x, IPXACT2009scalaxb.ElemName(node) :: stack)) } map { "@{http://www.spiritconsortium.org/XMLSchema/SPIRIT/1685-2009}id" -> _ },
        (node \ "@{http://www.spiritconsortium.org/XMLSchema/SPIRIT/1685-2009}dependency").headOption map { x => IPXACT2009scalaxb.DataRecord(x, node, IPXACT2009scalaxb.fromXML[String](x, IPXACT2009scalaxb.ElemName(node) :: stack)) } map { "@{http://www.spiritconsortium.org/XMLSchema/SPIRIT/1685-2009}dependency" -> _ },
        (node \ "@{http://www.spiritconsortium.org/XMLSchema/SPIRIT/1685-2009}choiceRef").headOption map { x => IPXACT2009scalaxb.DataRecord(x, node, IPXACT2009scalaxb.fromXML[String](x, IPXACT2009scalaxb.ElemName(node) :: stack)) } map { "@{http://www.spiritconsortium.org/XMLSchema/SPIRIT/1685-2009}choiceRef" -> _ },
        (node \ "@{http://www.spiritconsortium.org/XMLSchema/SPIRIT/1685-2009}order").headOption map { x => IPXACT2009scalaxb.DataRecord(x, node, IPXACT2009scalaxb.fromXML[Float](x, IPXACT2009scalaxb.ElemName(node) :: stack)) } map { "@{http://www.spiritconsortium.org/XMLSchema/SPIRIT/1685-2009}order" -> _ },
        (node \ "@{http://www.spiritconsortium.org/XMLSchema/SPIRIT/1685-2009}configGroups").headOption map { x => IPXACT2009scalaxb.DataRecord(x, node, IPXACT2009scalaxb.fromXML[Seq[String]](x, IPXACT2009scalaxb.ElemName(node) :: stack)) } map { "@{http://www.spiritconsortium.org/XMLSchema/SPIRIT/1685-2009}configGroups" -> _ },
        (node \ "@{http://www.spiritconsortium.org/XMLSchema/SPIRIT/1685-2009}bitStringLength").headOption map { x => IPXACT2009scalaxb.DataRecord(x, node, IPXACT2009scalaxb.fromXML[BigInt](x, IPXACT2009scalaxb.ElemName(node) :: stack)) } map { "@{http://www.spiritconsortium.org/XMLSchema/SPIRIT/1685-2009}bitStringLength" -> _ },
        (node \ "@{http://www.spiritconsortium.org/XMLSchema/SPIRIT/1685-2009}minimum").headOption map { x => IPXACT2009scalaxb.DataRecord(x, node, IPXACT2009scalaxb.fromXML[String](x, IPXACT2009scalaxb.ElemName(node) :: stack)) } map { "@{http://www.spiritconsortium.org/XMLSchema/SPIRIT/1685-2009}minimum" -> _ },
        (node \ "@{http://www.spiritconsortium.org/XMLSchema/SPIRIT/1685-2009}maximum").headOption map { x => IPXACT2009scalaxb.DataRecord(x, node, IPXACT2009scalaxb.fromXML[String](x, IPXACT2009scalaxb.ElemName(node) :: stack)) } map { "@{http://www.spiritconsortium.org/XMLSchema/SPIRIT/1685-2009}maximum" -> _ },
        (node \ "@{http://www.spiritconsortium.org/XMLSchema/SPIRIT/1685-2009}rangeType").headOption map { x => IPXACT2009scalaxb.DataRecord(x, node, IPXACT2009scalaxb.fromXML[RangeTypeType](x, IPXACT2009scalaxb.ElemName(node) :: stack)) } orElse Some(IPXACT2009scalaxb.DataRecord(None, None, IPXACT2009scalaxb.fromXML[RangeTypeType](scala.xml.Text("float"), IPXACT2009scalaxb.ElemName(node) :: stack))) map { "@{http://www.spiritconsortium.org/XMLSchema/SPIRIT/1685-2009}rangeType" -> _ },
        (node \ "@{http://www.spiritconsortium.org/XMLSchema/SPIRIT/1685-2009}prompt").headOption map { x => IPXACT2009scalaxb.DataRecord(x, node, IPXACT2009scalaxb.fromXML[String](x, IPXACT2009scalaxb.ElemName(node) :: stack)) } map { "@{http://www.spiritconsortium.org/XMLSchema/SPIRIT/1685-2009}prompt" -> _ }
        ).flatten[(String, IPXACT2009scalaxb.DataRecord[Any])] ::: (node match {
          case elem: scala.xml.Elem =>
            elem.attributes.toList flatMap {
              case scala.xml.PrefixedAttribute(pre, key, value, _) if pre == elem.scope.getPrefix("http://www.spiritconsortium.org/XMLSchema/SPIRIT/1685-2009") &&
                key == "format" => Nil
              case scala.xml.PrefixedAttribute(pre, key, value, _) if pre == elem.scope.getPrefix("http://www.spiritconsortium.org/XMLSchema/SPIRIT/1685-2009") &&
                key == "resolve" => Nil
              case scala.xml.PrefixedAttribute(pre, key, value, _) if pre == elem.scope.getPrefix("http://www.spiritconsortium.org/XMLSchema/SPIRIT/1685-2009") &&
                key == "id" => Nil
              case scala.xml.PrefixedAttribute(pre, key, value, _) if pre == elem.scope.getPrefix("http://www.spiritconsortium.org/XMLSchema/SPIRIT/1685-2009") &&
                key == "dependency" => Nil
              case scala.xml.PrefixedAttribute(pre, key, value, _) if pre == elem.scope.getPrefix("http://www.spiritconsortium.org/XMLSchema/SPIRIT/1685-2009") &&
                key == "choiceRef" => Nil
              case scala.xml.PrefixedAttribute(pre, key, value, _) if pre == elem.scope.getPrefix("http://www.spiritconsortium.org/XMLSchema/SPIRIT/1685-2009") &&
                key == "order" => Nil
              case scala.xml.PrefixedAttribute(pre, key, value, _) if pre == elem.scope.getPrefix("http://www.spiritconsortium.org/XMLSchema/SPIRIT/1685-2009") &&
                key == "configGroups" => Nil
              case scala.xml.PrefixedAttribute(pre, key, value, _) if pre == elem.scope.getPrefix("http://www.spiritconsortium.org/XMLSchema/SPIRIT/1685-2009") &&
                key == "bitStringLength" => Nil
              case scala.xml.PrefixedAttribute(pre, key, value, _) if pre == elem.scope.getPrefix("http://www.spiritconsortium.org/XMLSchema/SPIRIT/1685-2009") &&
                key == "minimum" => Nil
              case scala.xml.PrefixedAttribute(pre, key, value, _) if pre == elem.scope.getPrefix("http://www.spiritconsortium.org/XMLSchema/SPIRIT/1685-2009") &&
                key == "maximum" => Nil
              case scala.xml.PrefixedAttribute(pre, key, value, _) if pre == elem.scope.getPrefix("http://www.spiritconsortium.org/XMLSchema/SPIRIT/1685-2009") &&
                key == "rangeType" => Nil
              case scala.xml.PrefixedAttribute(pre, key, value, _) if pre == elem.scope.getPrefix("http://www.spiritconsortium.org/XMLSchema/SPIRIT/1685-2009") &&
                key == "prompt" => Nil
              case scala.xml.UnprefixedAttribute(key, value, _) =>
                List(("@" + key, IPXACT2009scalaxb.DataRecord(None, Some(key), value.text)))
              case scala.xml.PrefixedAttribute(pre, key, value, _) =>
                val ns = elem.scope.getURI(pre)
                List(("@{" + ns + "}" + key, IPXACT2009scalaxb.DataRecord(Option[String](ns), Some(key), value.text)))
              case _ => Nil
            }
          case _ => Nil
        }): _*)))
      case _ => Left("reads failed: seq must be scala.xml.Node")
    }
    
    override def writesAttribute(__obj: LeftType, __scope: scala.xml.NamespaceBinding): scala.xml.MetaData = {
      var attr: scala.xml.MetaData  = scala.xml.Null
      __obj.attributes.toList map {
        case ("@{http://www.spiritconsortium.org/XMLSchema/SPIRIT/1685-2009}format", _) => if (__obj.spiritformat.toString != "long") attr = scala.xml.Attribute(__scope.getPrefix("http://www.spiritconsortium.org/XMLSchema/SPIRIT/1685-2009"), "format", __obj.spiritformat.toString, attr)
        case ("@{http://www.spiritconsortium.org/XMLSchema/SPIRIT/1685-2009}resolve", _) => __obj.spiritresolve foreach { x => attr = scala.xml.Attribute(__scope.getPrefix("http://www.spiritconsortium.org/XMLSchema/SPIRIT/1685-2009"), "resolve", x.toString, attr) }
        case ("@{http://www.spiritconsortium.org/XMLSchema/SPIRIT/1685-2009}id", _) => __obj.spiritid foreach { x => attr = scala.xml.Attribute(__scope.getPrefix("http://www.spiritconsortium.org/XMLSchema/SPIRIT/1685-2009"), "id", x.toString, attr) }
        case ("@{http://www.spiritconsortium.org/XMLSchema/SPIRIT/1685-2009}dependency", _) => __obj.spiritdependency foreach { x => attr = scala.xml.Attribute(__scope.getPrefix("http://www.spiritconsortium.org/XMLSchema/SPIRIT/1685-2009"), "dependency", x.toString, attr) }
        case ("@{http://www.spiritconsortium.org/XMLSchema/SPIRIT/1685-2009}choiceRef", _) => __obj.spiritchoiceRef foreach { x => attr = scala.xml.Attribute(__scope.getPrefix("http://www.spiritconsortium.org/XMLSchema/SPIRIT/1685-2009"), "choiceRef", x.toString, attr) }
        case ("@{http://www.spiritconsortium.org/XMLSchema/SPIRIT/1685-2009}order", _) => __obj.spiritorder foreach { x => attr = scala.xml.Attribute(__scope.getPrefix("http://www.spiritconsortium.org/XMLSchema/SPIRIT/1685-2009"), "order", x.toString, attr) }
        case ("@{http://www.spiritconsortium.org/XMLSchema/SPIRIT/1685-2009}configGroups", _) => __obj.spiritconfigGroups foreach { x => attr = scala.xml.Attribute(__scope.getPrefix("http://www.spiritconsortium.org/XMLSchema/SPIRIT/1685-2009"), "configGroups", x.toString, attr) }
        case ("@{http://www.spiritconsortium.org/XMLSchema/SPIRIT/1685-2009}bitStringLength", _) => __obj.spiritbitStringLength foreach { x => attr = scala.xml.Attribute(__scope.getPrefix("http://www.spiritconsortium.org/XMLSchema/SPIRIT/1685-2009"), "bitStringLength", x.toString, attr) }
        case ("@{http://www.spiritconsortium.org/XMLSchema/SPIRIT/1685-2009}minimum", _) => __obj.spiritminimum foreach { x => attr = scala.xml.Attribute(__scope.getPrefix("http://www.spiritconsortium.org/XMLSchema/SPIRIT/1685-2009"), "minimum", x.toString, attr) }
        case ("@{http://www.spiritconsortium.org/XMLSchema/SPIRIT/1685-2009}maximum", _) => __obj.spiritmaximum foreach { x => attr = scala.xml.Attribute(__scope.getPrefix("http://www.spiritconsortium.org/XMLSchema/SPIRIT/1685-2009"), "maximum", x.toString, attr) }
        case ("@{http://www.spiritconsortium.org/XMLSchema/SPIRIT/1685-2009}rangeType", _) => if (__obj.spiritrangeType.toString != "float") attr = scala.xml.Attribute(__scope.getPrefix("http://www.spiritconsortium.org/XMLSchema/SPIRIT/1685-2009"), "rangeType", __obj.spiritrangeType.toString, attr)
        case ("@{http://www.spiritconsortium.org/XMLSchema/SPIRIT/1685-2009}prompt", _) => __obj.spiritprompt foreach { x => attr = scala.xml.Attribute(__scope.getPrefix("http://www.spiritconsortium.org/XMLSchema/SPIRIT/1685-2009"), "prompt", x.toString, attr) }
        case (key, x) => attr = scala.xml.Attribute((x.namespace map { __scope.getPrefix(_) }).orNull, x.key.orNull, x.value.toString, attr)
      }
      attr
    }

    def writesChildNodes(__obj: LeftType, __scope: scala.xml.NamespaceBinding): Seq[scala.xml.Node] =
      Seq(scala.xml.Text(__obj.value.toString))

  }

  trait Default_RightTypeFormat extends IPXACT2009scalaxb.XMLFormat[RightType] with IPXACT2009scalaxb.CanWriteChildNodes[RightType] {
    val targetNamespace: Option[String] = Some("http://www.spiritconsortium.org/XMLSchema/SPIRIT/1685-2009")
    def reads(seq: scala.xml.NodeSeq, stack: List[IPXACT2009scalaxb.ElemName]): Either[String, RightType] = seq match {
      case node: scala.xml.Node => Right(RightType(IPXACT2009scalaxb.fromXML[BigInt](node, IPXACT2009scalaxb.ElemName(node) :: stack),
        scala.collection.immutable.ListMap(List(
        (node \ "@{http://www.spiritconsortium.org/XMLSchema/SPIRIT/1685-2009}format").headOption map { x => IPXACT2009scalaxb.DataRecord(x, node, IPXACT2009scalaxb.fromXML[FormatType](x, IPXACT2009scalaxb.ElemName(node) :: stack)) } orElse Some(IPXACT2009scalaxb.DataRecord(None, None, IPXACT2009scalaxb.fromXML[FormatType](scala.xml.Text("long"), IPXACT2009scalaxb.ElemName(node) :: stack))) map { "@{http://www.spiritconsortium.org/XMLSchema/SPIRIT/1685-2009}format" -> _ },
        (node \ "@{http://www.spiritconsortium.org/XMLSchema/SPIRIT/1685-2009}resolve").headOption map { x => IPXACT2009scalaxb.DataRecord(x, node, IPXACT2009scalaxb.fromXML[ResolveType](x, IPXACT2009scalaxb.ElemName(node) :: stack)) } map { "@{http://www.spiritconsortium.org/XMLSchema/SPIRIT/1685-2009}resolve" -> _ },
        (node \ "@{http://www.spiritconsortium.org/XMLSchema/SPIRIT/1685-2009}id").headOption map { x => IPXACT2009scalaxb.DataRecord(x, node, IPXACT2009scalaxb.fromXML[String](x, IPXACT2009scalaxb.ElemName(node) :: stack)) } map { "@{http://www.spiritconsortium.org/XMLSchema/SPIRIT/1685-2009}id" -> _ },
        (node \ "@{http://www.spiritconsortium.org/XMLSchema/SPIRIT/1685-2009}dependency").headOption map { x => IPXACT2009scalaxb.DataRecord(x, node, IPXACT2009scalaxb.fromXML[String](x, IPXACT2009scalaxb.ElemName(node) :: stack)) } map { "@{http://www.spiritconsortium.org/XMLSchema/SPIRIT/1685-2009}dependency" -> _ },
        (node \ "@{http://www.spiritconsortium.org/XMLSchema/SPIRIT/1685-2009}choiceRef").headOption map { x => IPXACT2009scalaxb.DataRecord(x, node, IPXACT2009scalaxb.fromXML[String](x, IPXACT2009scalaxb.ElemName(node) :: stack)) } map { "@{http://www.spiritconsortium.org/XMLSchema/SPIRIT/1685-2009}choiceRef" -> _ },
        (node \ "@{http://www.spiritconsortium.org/XMLSchema/SPIRIT/1685-2009}order").headOption map { x => IPXACT2009scalaxb.DataRecord(x, node, IPXACT2009scalaxb.fromXML[Float](x, IPXACT2009scalaxb.ElemName(node) :: stack)) } map { "@{http://www.spiritconsortium.org/XMLSchema/SPIRIT/1685-2009}order" -> _ },
        (node \ "@{http://www.spiritconsortium.org/XMLSchema/SPIRIT/1685-2009}configGroups").headOption map { x => IPXACT2009scalaxb.DataRecord(x, node, IPXACT2009scalaxb.fromXML[Seq[String]](x, IPXACT2009scalaxb.ElemName(node) :: stack)) } map { "@{http://www.spiritconsortium.org/XMLSchema/SPIRIT/1685-2009}configGroups" -> _ },
        (node \ "@{http://www.spiritconsortium.org/XMLSchema/SPIRIT/1685-2009}bitStringLength").headOption map { x => IPXACT2009scalaxb.DataRecord(x, node, IPXACT2009scalaxb.fromXML[BigInt](x, IPXACT2009scalaxb.ElemName(node) :: stack)) } map { "@{http://www.spiritconsortium.org/XMLSchema/SPIRIT/1685-2009}bitStringLength" -> _ },
        (node \ "@{http://www.spiritconsortium.org/XMLSchema/SPIRIT/1685-2009}minimum").headOption map { x => IPXACT2009scalaxb.DataRecord(x, node, IPXACT2009scalaxb.fromXML[String](x, IPXACT2009scalaxb.ElemName(node) :: stack)) } map { "@{http://www.spiritconsortium.org/XMLSchema/SPIRIT/1685-2009}minimum" -> _ },
        (node \ "@{http://www.spiritconsortium.org/XMLSchema/SPIRIT/1685-2009}maximum").headOption map { x => IPXACT2009scalaxb.DataRecord(x, node, IPXACT2009scalaxb.fromXML[String](x, IPXACT2009scalaxb.ElemName(node) :: stack)) } map { "@{http://www.spiritconsortium.org/XMLSchema/SPIRIT/1685-2009}maximum" -> _ },
        (node \ "@{http://www.spiritconsortium.org/XMLSchema/SPIRIT/1685-2009}rangeType").headOption map { x => IPXACT2009scalaxb.DataRecord(x, node, IPXACT2009scalaxb.fromXML[RangeTypeType](x, IPXACT2009scalaxb.ElemName(node) :: stack)) } orElse Some(IPXACT2009scalaxb.DataRecord(None, None, IPXACT2009scalaxb.fromXML[RangeTypeType](scala.xml.Text("float"), IPXACT2009scalaxb.ElemName(node) :: stack))) map { "@{http://www.spiritconsortium.org/XMLSchema/SPIRIT/1685-2009}rangeType" -> _ },
        (node \ "@{http://www.spiritconsortium.org/XMLSchema/SPIRIT/1685-2009}prompt").headOption map { x => IPXACT2009scalaxb.DataRecord(x, node, IPXACT2009scalaxb.fromXML[String](x, IPXACT2009scalaxb.ElemName(node) :: stack)) } map { "@{http://www.spiritconsortium.org/XMLSchema/SPIRIT/1685-2009}prompt" -> _ }
        ).flatten[(String, IPXACT2009scalaxb.DataRecord[Any])] ::: (node match {
          case elem: scala.xml.Elem =>
            elem.attributes.toList flatMap {
              case scala.xml.PrefixedAttribute(pre, key, value, _) if pre == elem.scope.getPrefix("http://www.spiritconsortium.org/XMLSchema/SPIRIT/1685-2009") &&
                key == "format" => Nil
              case scala.xml.PrefixedAttribute(pre, key, value, _) if pre == elem.scope.getPrefix("http://www.spiritconsortium.org/XMLSchema/SPIRIT/1685-2009") &&
                key == "resolve" => Nil
              case scala.xml.PrefixedAttribute(pre, key, value, _) if pre == elem.scope.getPrefix("http://www.spiritconsortium.org/XMLSchema/SPIRIT/1685-2009") &&
                key == "id" => Nil
              case scala.xml.PrefixedAttribute(pre, key, value, _) if pre == elem.scope.getPrefix("http://www.spiritconsortium.org/XMLSchema/SPIRIT/1685-2009") &&
                key == "dependency" => Nil
              case scala.xml.PrefixedAttribute(pre, key, value, _) if pre == elem.scope.getPrefix("http://www.spiritconsortium.org/XMLSchema/SPIRIT/1685-2009") &&
                key == "choiceRef" => Nil
              case scala.xml.PrefixedAttribute(pre, key, value, _) if pre == elem.scope.getPrefix("http://www.spiritconsortium.org/XMLSchema/SPIRIT/1685-2009") &&
                key == "order" => Nil
              case scala.xml.PrefixedAttribute(pre, key, value, _) if pre == elem.scope.getPrefix("http://www.spiritconsortium.org/XMLSchema/SPIRIT/1685-2009") &&
                key == "configGroups" => Nil
              case scala.xml.PrefixedAttribute(pre, key, value, _) if pre == elem.scope.getPrefix("http://www.spiritconsortium.org/XMLSchema/SPIRIT/1685-2009") &&
                key == "bitStringLength" => Nil
              case scala.xml.PrefixedAttribute(pre, key, value, _) if pre == elem.scope.getPrefix("http://www.spiritconsortium.org/XMLSchema/SPIRIT/1685-2009") &&
                key == "minimum" => Nil
              case scala.xml.PrefixedAttribute(pre, key, value, _) if pre == elem.scope.getPrefix("http://www.spiritconsortium.org/XMLSchema/SPIRIT/1685-2009") &&
                key == "maximum" => Nil
              case scala.xml.PrefixedAttribute(pre, key, value, _) if pre == elem.scope.getPrefix("http://www.spiritconsortium.org/XMLSchema/SPIRIT/1685-2009") &&
                key == "rangeType" => Nil
              case scala.xml.PrefixedAttribute(pre, key, value, _) if pre == elem.scope.getPrefix("http://www.spiritconsortium.org/XMLSchema/SPIRIT/1685-2009") &&
                key == "prompt" => Nil
              case scala.xml.UnprefixedAttribute(key, value, _) =>
                List(("@" + key, IPXACT2009scalaxb.DataRecord(None, Some(key), value.text)))
              case scala.xml.PrefixedAttribute(pre, key, value, _) =>
                val ns = elem.scope.getURI(pre)
                List(("@{" + ns + "}" + key, IPXACT2009scalaxb.DataRecord(Option[String](ns), Some(key), value.text)))
              case _ => Nil
            }
          case _ => Nil
        }): _*)))
      case _ => Left("reads failed: seq must be scala.xml.Node")
    }
    
    override def writesAttribute(__obj: RightType, __scope: scala.xml.NamespaceBinding): scala.xml.MetaData = {
      var attr: scala.xml.MetaData  = scala.xml.Null
      __obj.attributes.toList map {
        case ("@{http://www.spiritconsortium.org/XMLSchema/SPIRIT/1685-2009}format", _) => if (__obj.spiritformat.toString != "long") attr = scala.xml.Attribute(__scope.getPrefix("http://www.spiritconsortium.org/XMLSchema/SPIRIT/1685-2009"), "format", __obj.spiritformat.toString, attr)
        case ("@{http://www.spiritconsortium.org/XMLSchema/SPIRIT/1685-2009}resolve", _) => __obj.spiritresolve foreach { x => attr = scala.xml.Attribute(__scope.getPrefix("http://www.spiritconsortium.org/XMLSchema/SPIRIT/1685-2009"), "resolve", x.toString, attr) }
        case ("@{http://www.spiritconsortium.org/XMLSchema/SPIRIT/1685-2009}id", _) => __obj.spiritid foreach { x => attr = scala.xml.Attribute(__scope.getPrefix("http://www.spiritconsortium.org/XMLSchema/SPIRIT/1685-2009"), "id", x.toString, attr) }
        case ("@{http://www.spiritconsortium.org/XMLSchema/SPIRIT/1685-2009}dependency", _) => __obj.spiritdependency foreach { x => attr = scala.xml.Attribute(__scope.getPrefix("http://www.spiritconsortium.org/XMLSchema/SPIRIT/1685-2009"), "dependency", x.toString, attr) }
        case ("@{http://www.spiritconsortium.org/XMLSchema/SPIRIT/1685-2009}choiceRef", _) => __obj.spiritchoiceRef foreach { x => attr = scala.xml.Attribute(__scope.getPrefix("http://www.spiritconsortium.org/XMLSchema/SPIRIT/1685-2009"), "choiceRef", x.toString, attr) }
        case ("@{http://www.spiritconsortium.org/XMLSchema/SPIRIT/1685-2009}order", _) => __obj.spiritorder foreach { x => attr = scala.xml.Attribute(__scope.getPrefix("http://www.spiritconsortium.org/XMLSchema/SPIRIT/1685-2009"), "order", x.toString, attr) }
        case ("@{http://www.spiritconsortium.org/XMLSchema/SPIRIT/1685-2009}configGroups", _) => __obj.spiritconfigGroups foreach { x => attr = scala.xml.Attribute(__scope.getPrefix("http://www.spiritconsortium.org/XMLSchema/SPIRIT/1685-2009"), "configGroups", x.toString, attr) }
        case ("@{http://www.spiritconsortium.org/XMLSchema/SPIRIT/1685-2009}bitStringLength", _) => __obj.spiritbitStringLength foreach { x => attr = scala.xml.Attribute(__scope.getPrefix("http://www.spiritconsortium.org/XMLSchema/SPIRIT/1685-2009"), "bitStringLength", x.toString, attr) }
        case ("@{http://www.spiritconsortium.org/XMLSchema/SPIRIT/1685-2009}minimum", _) => __obj.spiritminimum foreach { x => attr = scala.xml.Attribute(__scope.getPrefix("http://www.spiritconsortium.org/XMLSchema/SPIRIT/1685-2009"), "minimum", x.toString, attr) }
        case ("@{http://www.spiritconsortium.org/XMLSchema/SPIRIT/1685-2009}maximum", _) => __obj.spiritmaximum foreach { x => attr = scala.xml.Attribute(__scope.getPrefix("http://www.spiritconsortium.org/XMLSchema/SPIRIT/1685-2009"), "maximum", x.toString, attr) }
        case ("@{http://www.spiritconsortium.org/XMLSchema/SPIRIT/1685-2009}rangeType", _) => if (__obj.spiritrangeType.toString != "float") attr = scala.xml.Attribute(__scope.getPrefix("http://www.spiritconsortium.org/XMLSchema/SPIRIT/1685-2009"), "rangeType", __obj.spiritrangeType.toString, attr)
        case ("@{http://www.spiritconsortium.org/XMLSchema/SPIRIT/1685-2009}prompt", _) => __obj.spiritprompt foreach { x => attr = scala.xml.Attribute(__scope.getPrefix("http://www.spiritconsortium.org/XMLSchema/SPIRIT/1685-2009"), "prompt", x.toString, attr) }
        case (key, x) => attr = scala.xml.Attribute((x.namespace map { __scope.getPrefix(_) }).orNull, x.key.orNull, x.value.toString, attr)
      }
      attr
    }

    def writesChildNodes(__obj: RightType, __scope: scala.xml.NamespaceBinding): Seq[scala.xml.Node] =
      Seq(scala.xml.Text(__obj.value.toString))

  }

  trait Default_VectorFormat extends IPXACT2009scalaxb.ElemNameParser[Vector] {
    val targetNamespace: Option[String] = Some("http://www.spiritconsortium.org/XMLSchema/SPIRIT/1685-2009")
    
    def parser(node: scala.xml.Node, stack: List[IPXACT2009scalaxb.ElemName]): Parser[Vector] =
      phrase((IPXACT2009scalaxb.ElemName(Some("http://www.spiritconsortium.org/XMLSchema/SPIRIT/1685-2009"), "left")) ~
      (IPXACT2009scalaxb.ElemName(Some("http://www.spiritconsortium.org/XMLSchema/SPIRIT/1685-2009"), "right")) ^^
      { case p1 ~ p2 =>
      Vector(IPXACT2009scalaxb.fromXML[LeftType](p1, IPXACT2009scalaxb.ElemName(node) :: stack),
        IPXACT2009scalaxb.fromXML[RightType](p2, IPXACT2009scalaxb.ElemName(node) :: stack)) })
    
    def writesChildNodes(__obj: Vector, __scope: scala.xml.NamespaceBinding): Seq[scala.xml.Node] =
      Seq.concat(IPXACT2009scalaxb.toXML[LeftType](__obj.left, Some("http://www.spiritconsortium.org/XMLSchema/SPIRIT/1685-2009"), Some("left"), __scope, false),
        IPXACT2009scalaxb.toXML[RightType](__obj.right, Some("http://www.spiritconsortium.org/XMLSchema/SPIRIT/1685-2009"), Some("right"), __scope, false))

  }

  trait Default_LogicalPortFormat extends IPXACT2009scalaxb.ElemNameParser[LogicalPort] {
    val targetNamespace: Option[String] = Some("http://www.spiritconsortium.org/XMLSchema/SPIRIT/1685-2009")
    
    def parser(node: scala.xml.Node, stack: List[IPXACT2009scalaxb.ElemName]): Parser[LogicalPort] =
      phrase((IPXACT2009scalaxb.ElemName(Some("http://www.spiritconsortium.org/XMLSchema/SPIRIT/1685-2009"), "name")) ~
      opt(IPXACT2009scalaxb.ElemName(Some("http://www.spiritconsortium.org/XMLSchema/SPIRIT/1685-2009"), "vector")) ^^
      { case p1 ~ p2 =>
      LogicalPort(IPXACT2009scalaxb.fromXML[String](p1, IPXACT2009scalaxb.ElemName(node) :: stack),
        p2.headOption map { IPXACT2009scalaxb.fromXML[Vector](_, IPXACT2009scalaxb.ElemName(node) :: stack) }) })
    
    def writesChildNodes(__obj: LogicalPort, __scope: scala.xml.NamespaceBinding): Seq[scala.xml.Node] =
      Seq.concat(IPXACT2009scalaxb.toXML[String](__obj.name, Some("http://www.spiritconsortium.org/XMLSchema/SPIRIT/1685-2009"), Some("name"), __scope, false),
        __obj.vector map { IPXACT2009scalaxb.toXML[Vector](_, Some("http://www.spiritconsortium.org/XMLSchema/SPIRIT/1685-2009"), Some("vector"), __scope, false) } getOrElse {Nil})

  }

  trait Default_PhysicalPortFormat extends IPXACT2009scalaxb.ElemNameParser[PhysicalPort] {
    val targetNamespace: Option[String] = Some("http://www.spiritconsortium.org/XMLSchema/SPIRIT/1685-2009")
    
    def parser(node: scala.xml.Node, stack: List[IPXACT2009scalaxb.ElemName]): Parser[PhysicalPort] =
      phrase((IPXACT2009scalaxb.ElemName(Some("http://www.spiritconsortium.org/XMLSchema/SPIRIT/1685-2009"), "name")) ~
      opt(IPXACT2009scalaxb.ElemName(Some("http://www.spiritconsortium.org/XMLSchema/SPIRIT/1685-2009"), "vector")) ^^
      { case p1 ~ p2 =>
      PhysicalPort(IPXACT2009scalaxb.fromXML[String](p1, IPXACT2009scalaxb.ElemName(node) :: stack),
        p2.headOption map { IPXACT2009scalaxb.fromXML[Vector4](_, IPXACT2009scalaxb.ElemName(node) :: stack) }) })
    
    def writesChildNodes(__obj: PhysicalPort, __scope: scala.xml.NamespaceBinding): Seq[scala.xml.Node] =
      Seq.concat(IPXACT2009scalaxb.toXML[String](__obj.name, Some("http://www.spiritconsortium.org/XMLSchema/SPIRIT/1685-2009"), Some("name"), __scope, false),
        __obj.vector map { IPXACT2009scalaxb.toXML[Vector4](_, Some("http://www.spiritconsortium.org/XMLSchema/SPIRIT/1685-2009"), Some("vector"), __scope, false) } getOrElse {Nil})

  }

  trait Default_PortMapFormat extends IPXACT2009scalaxb.ElemNameParser[PortMap] {
    val targetNamespace: Option[String] = Some("http://www.spiritconsortium.org/XMLSchema/SPIRIT/1685-2009")
    
    def parser(node: scala.xml.Node, stack: List[IPXACT2009scalaxb.ElemName]): Parser[PortMap] =
      phrase((IPXACT2009scalaxb.ElemName(Some("http://www.spiritconsortium.org/XMLSchema/SPIRIT/1685-2009"), "logicalPort")) ~
      (IPXACT2009scalaxb.ElemName(Some("http://www.spiritconsortium.org/XMLSchema/SPIRIT/1685-2009"), "physicalPort")) ^^
      { case p1 ~ p2 =>
      PortMap(IPXACT2009scalaxb.fromXML[LogicalPort](p1, IPXACT2009scalaxb.ElemName(node) :: stack),
        IPXACT2009scalaxb.fromXML[PhysicalPort](p2, IPXACT2009scalaxb.ElemName(node) :: stack)) })
    
    def writesChildNodes(__obj: PortMap, __scope: scala.xml.NamespaceBinding): Seq[scala.xml.Node] =
      Seq.concat(IPXACT2009scalaxb.toXML[LogicalPort](__obj.logicalPort, Some("http://www.spiritconsortium.org/XMLSchema/SPIRIT/1685-2009"), Some("logicalPort"), __scope, false),
        IPXACT2009scalaxb.toXML[PhysicalPort](__obj.physicalPort, Some("http://www.spiritconsortium.org/XMLSchema/SPIRIT/1685-2009"), Some("physicalPort"), __scope, false))

  }

  trait Default_PortMapsFormat extends IPXACT2009scalaxb.ElemNameParser[PortMaps] {
    val targetNamespace: Option[String] = Some("http://www.spiritconsortium.org/XMLSchema/SPIRIT/1685-2009")
    
    def parser(node: scala.xml.Node, stack: List[IPXACT2009scalaxb.ElemName]): Parser[PortMaps] =
      phrase(safeRep(IPXACT2009scalaxb.ElemName(Some("http://www.spiritconsortium.org/XMLSchema/SPIRIT/1685-2009"), "portMap")) ^^
      { case p1 =>
      PortMaps(p1 map { IPXACT2009scalaxb.fromXML[PortMap](_, IPXACT2009scalaxb.ElemName(node) :: stack) }) })
    
    def writesChildNodes(__obj: PortMaps, __scope: scala.xml.NamespaceBinding): Seq[scala.xml.Node] =
      (__obj.portMap flatMap { IPXACT2009scalaxb.toXML[PortMap](_, Some("http://www.spiritconsortium.org/XMLSchema/SPIRIT/1685-2009"), Some("portMap"), __scope, false) })
  }
  trait Default_BitSteeringFormat extends IPXACT2009scalaxb.XMLFormat[BitSteering] with IPXACT2009scalaxb.CanWriteChildNodes[BitSteering] {
    val targetNamespace: Option[String] = Some("http://www.spiritconsortium.org/XMLSchema/SPIRIT/1685-2009")
    def reads(seq: scala.xml.NodeSeq, stack: List[IPXACT2009scalaxb.ElemName]): Either[String, BitSteering] = seq match {
      case node: scala.xml.Node => Right(BitSteering(IPXACT2009scalaxb.fromXML[BitSteeringType](node, IPXACT2009scalaxb.ElemName(node) :: stack),
        scala.collection.immutable.ListMap(List(
        (node \ "@{http://www.spiritconsortium.org/XMLSchema/SPIRIT/1685-2009}format").headOption map { x => IPXACT2009scalaxb.DataRecord(x, node, IPXACT2009scalaxb.fromXML[FormatType](x, IPXACT2009scalaxb.ElemName(node) :: stack)) } orElse Some(IPXACT2009scalaxb.DataRecord(None, None, IPXACT2009scalaxb.fromXML[FormatType](scala.xml.Text("string"), IPXACT2009scalaxb.ElemName(node) :: stack))) map { "@{http://www.spiritconsortium.org/XMLSchema/SPIRIT/1685-2009}format" -> _ },
        (node \ "@{http://www.spiritconsortium.org/XMLSchema/SPIRIT/1685-2009}resolve").headOption map { x => IPXACT2009scalaxb.DataRecord(x, node, IPXACT2009scalaxb.fromXML[ResolveType](x, IPXACT2009scalaxb.ElemName(node) :: stack)) } map { "@{http://www.spiritconsortium.org/XMLSchema/SPIRIT/1685-2009}resolve" -> _ },
        (node \ "@{http://www.spiritconsortium.org/XMLSchema/SPIRIT/1685-2009}id").headOption map { x => IPXACT2009scalaxb.DataRecord(x, node, IPXACT2009scalaxb.fromXML[String](x, IPXACT2009scalaxb.ElemName(node) :: stack)) } map { "@{http://www.spiritconsortium.org/XMLSchema/SPIRIT/1685-2009}id" -> _ },
        (node \ "@{http://www.spiritconsortium.org/XMLSchema/SPIRIT/1685-2009}dependency").headOption map { x => IPXACT2009scalaxb.DataRecord(x, node, IPXACT2009scalaxb.fromXML[String](x, IPXACT2009scalaxb.ElemName(node) :: stack)) } map { "@{http://www.spiritconsortium.org/XMLSchema/SPIRIT/1685-2009}dependency" -> _ },
        (node \ "@{http://www.spiritconsortium.org/XMLSchema/SPIRIT/1685-2009}choiceRef").headOption map { x => IPXACT2009scalaxb.DataRecord(x, node, IPXACT2009scalaxb.fromXML[String](x, IPXACT2009scalaxb.ElemName(node) :: stack)) } map { "@{http://www.spiritconsortium.org/XMLSchema/SPIRIT/1685-2009}choiceRef" -> _ },
        (node \ "@{http://www.spiritconsortium.org/XMLSchema/SPIRIT/1685-2009}order").headOption map { x => IPXACT2009scalaxb.DataRecord(x, node, IPXACT2009scalaxb.fromXML[Float](x, IPXACT2009scalaxb.ElemName(node) :: stack)) } map { "@{http://www.spiritconsortium.org/XMLSchema/SPIRIT/1685-2009}order" -> _ },
        (node \ "@{http://www.spiritconsortium.org/XMLSchema/SPIRIT/1685-2009}configGroups").headOption map { x => IPXACT2009scalaxb.DataRecord(x, node, IPXACT2009scalaxb.fromXML[Seq[String]](x, IPXACT2009scalaxb.ElemName(node) :: stack)) } map { "@{http://www.spiritconsortium.org/XMLSchema/SPIRIT/1685-2009}configGroups" -> _ },
        (node \ "@{http://www.spiritconsortium.org/XMLSchema/SPIRIT/1685-2009}bitStringLength").headOption map { x => IPXACT2009scalaxb.DataRecord(x, node, IPXACT2009scalaxb.fromXML[BigInt](x, IPXACT2009scalaxb.ElemName(node) :: stack)) } map { "@{http://www.spiritconsortium.org/XMLSchema/SPIRIT/1685-2009}bitStringLength" -> _ },
        (node \ "@{http://www.spiritconsortium.org/XMLSchema/SPIRIT/1685-2009}minimum").headOption map { x => IPXACT2009scalaxb.DataRecord(x, node, IPXACT2009scalaxb.fromXML[String](x, IPXACT2009scalaxb.ElemName(node) :: stack)) } map { "@{http://www.spiritconsortium.org/XMLSchema/SPIRIT/1685-2009}minimum" -> _ },
        (node \ "@{http://www.spiritconsortium.org/XMLSchema/SPIRIT/1685-2009}maximum").headOption map { x => IPXACT2009scalaxb.DataRecord(x, node, IPXACT2009scalaxb.fromXML[String](x, IPXACT2009scalaxb.ElemName(node) :: stack)) } map { "@{http://www.spiritconsortium.org/XMLSchema/SPIRIT/1685-2009}maximum" -> _ },
        (node \ "@{http://www.spiritconsortium.org/XMLSchema/SPIRIT/1685-2009}rangeType").headOption map { x => IPXACT2009scalaxb.DataRecord(x, node, IPXACT2009scalaxb.fromXML[RangeTypeType](x, IPXACT2009scalaxb.ElemName(node) :: stack)) } map { "@{http://www.spiritconsortium.org/XMLSchema/SPIRIT/1685-2009}rangeType" -> _ },
        (node \ "@{http://www.spiritconsortium.org/XMLSchema/SPIRIT/1685-2009}prompt").headOption map { x => IPXACT2009scalaxb.DataRecord(x, node, IPXACT2009scalaxb.fromXML[String](x, IPXACT2009scalaxb.ElemName(node) :: stack)) } map { "@{http://www.spiritconsortium.org/XMLSchema/SPIRIT/1685-2009}prompt" -> _ }
        ).flatten[(String, IPXACT2009scalaxb.DataRecord[Any])] ::: (node match {
          case elem: scala.xml.Elem =>
            elem.attributes.toList flatMap {
              case scala.xml.PrefixedAttribute(pre, key, value, _) if pre == elem.scope.getPrefix("http://www.spiritconsortium.org/XMLSchema/SPIRIT/1685-2009") &&
                key == "format" => Nil
              case scala.xml.PrefixedAttribute(pre, key, value, _) if pre == elem.scope.getPrefix("http://www.spiritconsortium.org/XMLSchema/SPIRIT/1685-2009") &&
                key == "resolve" => Nil
              case scala.xml.PrefixedAttribute(pre, key, value, _) if pre == elem.scope.getPrefix("http://www.spiritconsortium.org/XMLSchema/SPIRIT/1685-2009") &&
                key == "id" => Nil
              case scala.xml.PrefixedAttribute(pre, key, value, _) if pre == elem.scope.getPrefix("http://www.spiritconsortium.org/XMLSchema/SPIRIT/1685-2009") &&
                key == "dependency" => Nil
              case scala.xml.PrefixedAttribute(pre, key, value, _) if pre == elem.scope.getPrefix("http://www.spiritconsortium.org/XMLSchema/SPIRIT/1685-2009") &&
                key == "choiceRef" => Nil
              case scala.xml.PrefixedAttribute(pre, key, value, _) if pre == elem.scope.getPrefix("http://www.spiritconsortium.org/XMLSchema/SPIRIT/1685-2009") &&
                key == "order" => Nil
              case scala.xml.PrefixedAttribute(pre, key, value, _) if pre == elem.scope.getPrefix("http://www.spiritconsortium.org/XMLSchema/SPIRIT/1685-2009") &&
                key == "configGroups" => Nil
              case scala.xml.PrefixedAttribute(pre, key, value, _) if pre == elem.scope.getPrefix("http://www.spiritconsortium.org/XMLSchema/SPIRIT/1685-2009") &&
                key == "bitStringLength" => Nil
              case scala.xml.PrefixedAttribute(pre, key, value, _) if pre == elem.scope.getPrefix("http://www.spiritconsortium.org/XMLSchema/SPIRIT/1685-2009") &&
                key == "minimum" => Nil
              case scala.xml.PrefixedAttribute(pre, key, value, _) if pre == elem.scope.getPrefix("http://www.spiritconsortium.org/XMLSchema/SPIRIT/1685-2009") &&
                key == "maximum" => Nil
              case scala.xml.PrefixedAttribute(pre, key, value, _) if pre == elem.scope.getPrefix("http://www.spiritconsortium.org/XMLSchema/SPIRIT/1685-2009") &&
                key == "rangeType" => Nil
              case scala.xml.PrefixedAttribute(pre, key, value, _) if pre == elem.scope.getPrefix("http://www.spiritconsortium.org/XMLSchema/SPIRIT/1685-2009") &&
                key == "prompt" => Nil
              case scala.xml.UnprefixedAttribute(key, value, _) =>
                List(("@" + key, IPXACT2009scalaxb.DataRecord(None, Some(key), value.text)))
              case scala.xml.PrefixedAttribute(pre, key, value, _) =>
                val ns = elem.scope.getURI(pre)
                List(("@{" + ns + "}" + key, IPXACT2009scalaxb.DataRecord(Option[String](ns), Some(key), value.text)))
              case _ => Nil
            }
          case _ => Nil
        }): _*)))
      case _ => Left("reads failed: seq must be scala.xml.Node")
    }
    
    override def writesAttribute(__obj: BitSteering, __scope: scala.xml.NamespaceBinding): scala.xml.MetaData = {
      var attr: scala.xml.MetaData  = scala.xml.Null
      __obj.attributes.toList map {
        case ("@{http://www.spiritconsortium.org/XMLSchema/SPIRIT/1685-2009}format", _) => if (__obj.spiritformat.toString != "string") attr = scala.xml.Attribute(__scope.getPrefix("http://www.spiritconsortium.org/XMLSchema/SPIRIT/1685-2009"), "format", __obj.spiritformat.toString, attr)
        case ("@{http://www.spiritconsortium.org/XMLSchema/SPIRIT/1685-2009}resolve", _) => __obj.spiritresolve foreach { x => attr = scala.xml.Attribute(__scope.getPrefix("http://www.spiritconsortium.org/XMLSchema/SPIRIT/1685-2009"), "resolve", x.toString, attr) }
        case ("@{http://www.spiritconsortium.org/XMLSchema/SPIRIT/1685-2009}id", _) => __obj.spiritid foreach { x => attr = scala.xml.Attribute(__scope.getPrefix("http://www.spiritconsortium.org/XMLSchema/SPIRIT/1685-2009"), "id", x.toString, attr) }
        case ("@{http://www.spiritconsortium.org/XMLSchema/SPIRIT/1685-2009}dependency", _) => __obj.spiritdependency foreach { x => attr = scala.xml.Attribute(__scope.getPrefix("http://www.spiritconsortium.org/XMLSchema/SPIRIT/1685-2009"), "dependency", x.toString, attr) }
        case ("@{http://www.spiritconsortium.org/XMLSchema/SPIRIT/1685-2009}choiceRef", _) => __obj.spiritchoiceRef foreach { x => attr = scala.xml.Attribute(__scope.getPrefix("http://www.spiritconsortium.org/XMLSchema/SPIRIT/1685-2009"), "choiceRef", x.toString, attr) }
        case ("@{http://www.spiritconsortium.org/XMLSchema/SPIRIT/1685-2009}order", _) => __obj.spiritorder foreach { x => attr = scala.xml.Attribute(__scope.getPrefix("http://www.spiritconsortium.org/XMLSchema/SPIRIT/1685-2009"), "order", x.toString, attr) }
        case ("@{http://www.spiritconsortium.org/XMLSchema/SPIRIT/1685-2009}configGroups", _) => __obj.spiritconfigGroups foreach { x => attr = scala.xml.Attribute(__scope.getPrefix("http://www.spiritconsortium.org/XMLSchema/SPIRIT/1685-2009"), "configGroups", x.toString, attr) }
        case ("@{http://www.spiritconsortium.org/XMLSchema/SPIRIT/1685-2009}bitStringLength", _) => __obj.spiritbitStringLength foreach { x => attr = scala.xml.Attribute(__scope.getPrefix("http://www.spiritconsortium.org/XMLSchema/SPIRIT/1685-2009"), "bitStringLength", x.toString, attr) }
        case ("@{http://www.spiritconsortium.org/XMLSchema/SPIRIT/1685-2009}minimum", _) => __obj.spiritminimum foreach { x => attr = scala.xml.Attribute(__scope.getPrefix("http://www.spiritconsortium.org/XMLSchema/SPIRIT/1685-2009"), "minimum", x.toString, attr) }
        case ("@{http://www.spiritconsortium.org/XMLSchema/SPIRIT/1685-2009}maximum", _) => __obj.spiritmaximum foreach { x => attr = scala.xml.Attribute(__scope.getPrefix("http://www.spiritconsortium.org/XMLSchema/SPIRIT/1685-2009"), "maximum", x.toString, attr) }
        case ("@{http://www.spiritconsortium.org/XMLSchema/SPIRIT/1685-2009}rangeType", _) => __obj.spiritrangeType foreach { x => attr = scala.xml.Attribute(__scope.getPrefix("http://www.spiritconsortium.org/XMLSchema/SPIRIT/1685-2009"), "rangeType", x.toString, attr) }
        case ("@{http://www.spiritconsortium.org/XMLSchema/SPIRIT/1685-2009}prompt", _) => __obj.spiritprompt foreach { x => attr = scala.xml.Attribute(__scope.getPrefix("http://www.spiritconsortium.org/XMLSchema/SPIRIT/1685-2009"), "prompt", x.toString, attr) }
        case (key, x) => attr = scala.xml.Attribute((x.namespace map { __scope.getPrefix(_) }).orNull, x.key.orNull, x.value.toString, attr)
      }
      attr
    }

    def writesChildNodes(__obj: BitSteering, __scope: scala.xml.NamespaceBinding): Seq[scala.xml.Node] =
      Seq(scala.xml.Text(__obj.value.toString))

  }

  trait Default_BusInterfaceTypeFormat extends IPXACT2009scalaxb.ElemNameParser[BusInterfaceType] with _NameGroupGroupFormat with _InterfaceModeGroupFormat {
    val targetNamespace: Option[String] = Some("http://www.spiritconsortium.org/XMLSchema/SPIRIT/1685-2009")
    
    override def typeName: Option[String] = Some("busInterfaceType")

    def parser(node: scala.xml.Node, stack: List[IPXACT2009scalaxb.ElemName]): Parser[BusInterfaceType] =
      phrase((parseNameGroupGroup(node, IPXACT2009scalaxb.ElemName(node) :: stack)) ~
      (IPXACT2009scalaxb.ElemName(Some("http://www.spiritconsortium.org/XMLSchema/SPIRIT/1685-2009"), "busType")) ~
      opt(IPXACT2009scalaxb.ElemName(Some("http://www.spiritconsortium.org/XMLSchema/SPIRIT/1685-2009"), "abstractionType")) ~
      (parseInterfaceModeGroup(node, IPXACT2009scalaxb.ElemName(node) :: stack)) ~
      opt(IPXACT2009scalaxb.ElemName(Some("http://www.spiritconsortium.org/XMLSchema/SPIRIT/1685-2009"), "connectionRequired")) ~
      opt(IPXACT2009scalaxb.ElemName(Some("http://www.spiritconsortium.org/XMLSchema/SPIRIT/1685-2009"), "portMaps")) ~
      opt(IPXACT2009scalaxb.ElemName(Some("http://www.spiritconsortium.org/XMLSchema/SPIRIT/1685-2009"), "bitsInLau")) ~
      opt(IPXACT2009scalaxb.ElemName(Some("http://www.spiritconsortium.org/XMLSchema/SPIRIT/1685-2009"), "bitSteering")) ~
      opt(IPXACT2009scalaxb.ElemName(Some("http://www.spiritconsortium.org/XMLSchema/SPIRIT/1685-2009"), "endianness")) ~
      opt(IPXACT2009scalaxb.ElemName(Some("http://www.spiritconsortium.org/XMLSchema/SPIRIT/1685-2009"), "parameters")) ~
      opt(IPXACT2009scalaxb.ElemName(Some("http://www.spiritconsortium.org/XMLSchema/SPIRIT/1685-2009"), "vendorExtensions")) ^^
      { case p1 ~ p2 ~ p3 ~ p4 ~ p5 ~ p6 ~ p7 ~ p8 ~ p9 ~ p10 ~ p11 =>
      BusInterfaceType(p1,
        IPXACT2009scalaxb.fromXML[LibraryRefType](p2, IPXACT2009scalaxb.ElemName(node) :: stack),
        p3.headOption map { IPXACT2009scalaxb.fromXML[LibraryRefType](_, IPXACT2009scalaxb.ElemName(node) :: stack) },
        p4,
        p5.headOption map { IPXACT2009scalaxb.fromXML[Boolean](_, IPXACT2009scalaxb.ElemName(node) :: stack) },
        p6.headOption map { IPXACT2009scalaxb.fromXML[PortMaps](_, IPXACT2009scalaxb.ElemName(node) :: stack) },
        p7.headOption map { IPXACT2009scalaxb.fromXML[BigInt](_, IPXACT2009scalaxb.ElemName(node) :: stack) },
        p8.headOption map { IPXACT2009scalaxb.fromXML[BitSteering](_, IPXACT2009scalaxb.ElemName(node) :: stack) },
        p9.headOption map { IPXACT2009scalaxb.fromXML[EndianessType](_, IPXACT2009scalaxb.ElemName(node) :: stack) },
        p10.headOption map { IPXACT2009scalaxb.fromXML[Parameters](_, IPXACT2009scalaxb.ElemName(node) :: stack) },
        p11.headOption map { IPXACT2009scalaxb.fromXML[VendorExtensions](_, IPXACT2009scalaxb.ElemName(node) :: stack) },
        scala.collection.immutable.ListMap((node match {
          case elem: scala.xml.Elem =>
            elem.attributes.toList flatMap {
              
              case scala.xml.UnprefixedAttribute(key, value, _) =>
                List(("@" + key, IPXACT2009scalaxb.DataRecord(None, Some(key), value.text)))
              case scala.xml.PrefixedAttribute(pre, key, value, _) =>
                val ns = elem.scope.getURI(pre)
                List(("@{" + ns + "}" + key, IPXACT2009scalaxb.DataRecord(Option[String](ns), Some(key), value.text)))
              case _ => Nil
            }
          case _ => Nil
        }): _*)) })
    
    override def writesAttribute(__obj: BusInterfaceType, __scope: scala.xml.NamespaceBinding): scala.xml.MetaData = {
      var attr: scala.xml.MetaData  = scala.xml.Null
      __obj.attributes.toList map {
        case (key, x) => attr = scala.xml.Attribute((x.namespace map { __scope.getPrefix(_) }).orNull, x.key.orNull, x.value.toString, attr)
      }
      attr
    }
    def writesChildNodes(__obj: BusInterfaceType, __scope: scala.xml.NamespaceBinding): Seq[scala.xml.Node] =
      Seq.concat(IPXACT2009scalaxb.toXML[NameGroupSequence](__obj.nameGroupSequence1, None, Some("nameGroupSequence1"), __scope, false),
        IPXACT2009scalaxb.toXML[LibraryRefType](__obj.busType, Some("http://www.spiritconsortium.org/XMLSchema/SPIRIT/1685-2009"), Some("busType"), __scope, false),
        __obj.abstractionType map { IPXACT2009scalaxb.toXML[LibraryRefType](_, Some("http://www.spiritconsortium.org/XMLSchema/SPIRIT/1685-2009"), Some("abstractionType"), __scope, false) } getOrElse {Nil},
        (Some(__obj.interfaceModeOption4) map {x => IPXACT2009scalaxb.toXML[IPXACT2009scalaxb.DataRecord[InterfaceModeOption]](x, x.namespace, x.key, __scope, false)}).get,
        __obj.connectionRequired map { IPXACT2009scalaxb.toXML[Boolean](_, Some("http://www.spiritconsortium.org/XMLSchema/SPIRIT/1685-2009"), Some("connectionRequired"), __scope, false) } getOrElse {Nil},
        __obj.portMaps map { IPXACT2009scalaxb.toXML[PortMaps](_, Some("http://www.spiritconsortium.org/XMLSchema/SPIRIT/1685-2009"), Some("portMaps"), __scope, false) } getOrElse {Nil},
        __obj.bitsInLau map { IPXACT2009scalaxb.toXML[BigInt](_, Some("http://www.spiritconsortium.org/XMLSchema/SPIRIT/1685-2009"), Some("bitsInLau"), __scope, false) } getOrElse {Nil},
        __obj.bitSteering map { IPXACT2009scalaxb.toXML[BitSteering](_, Some("http://www.spiritconsortium.org/XMLSchema/SPIRIT/1685-2009"), Some("bitSteering"), __scope, false) } getOrElse {Nil},
        __obj.endianness map { IPXACT2009scalaxb.toXML[EndianessType](_, Some("http://www.spiritconsortium.org/XMLSchema/SPIRIT/1685-2009"), Some("endianness"), __scope, false) } getOrElse {Nil},
        __obj.parameters map { IPXACT2009scalaxb.toXML[Parameters](_, Some("http://www.spiritconsortium.org/XMLSchema/SPIRIT/1685-2009"), Some("parameters"), __scope, false) } getOrElse {Nil},
        __obj.vendorExtensions map { IPXACT2009scalaxb.toXML[VendorExtensions](_, Some("http://www.spiritconsortium.org/XMLSchema/SPIRIT/1685-2009"), Some("vendorExtensions"), __scope, false) } getOrElse {Nil})

  }

  trait Default_ChannelFormat extends IPXACT2009scalaxb.ElemNameParser[Channel] with _NameGroupGroupFormat {
    val targetNamespace: Option[String] = Some("http://www.spiritconsortium.org/XMLSchema/SPIRIT/1685-2009")
    
    def parser(node: scala.xml.Node, stack: List[IPXACT2009scalaxb.ElemName]): Parser[Channel] =
      phrase((parseNameGroupGroup(node, IPXACT2009scalaxb.ElemName(node) :: stack)) ~
      safeRep(IPXACT2009scalaxb.ElemName(Some("http://www.spiritconsortium.org/XMLSchema/SPIRIT/1685-2009"), "busInterfaceRef")) ^^
      { case p1 ~ p2 =>
      Channel(p1,
        p2 map { IPXACT2009scalaxb.fromXML[String](_, IPXACT2009scalaxb.ElemName(node) :: stack) }) })
    
    def writesChildNodes(__obj: Channel, __scope: scala.xml.NamespaceBinding): Seq[scala.xml.Node] =
      Seq.concat(IPXACT2009scalaxb.toXML[NameGroupSequence](__obj.nameGroupSequence1, None, Some("nameGroupSequence1"), __scope, false),
        __obj.busInterfaceRef flatMap { IPXACT2009scalaxb.toXML[String](_, Some("http://www.spiritconsortium.org/XMLSchema/SPIRIT/1685-2009"), Some("busInterfaceRef"), __scope, false) })

  }

  trait Default_ChannelsFormat extends IPXACT2009scalaxb.ElemNameParser[Channels] {
    val targetNamespace: Option[String] = Some("http://www.spiritconsortium.org/XMLSchema/SPIRIT/1685-2009")
    
    def parser(node: scala.xml.Node, stack: List[IPXACT2009scalaxb.ElemName]): Parser[Channels] =
      phrase(safeRep(IPXACT2009scalaxb.ElemName(Some("http://www.spiritconsortium.org/XMLSchema/SPIRIT/1685-2009"), "channel")) ^^
      { case p1 =>
      Channels(p1 map { IPXACT2009scalaxb.fromXML[Channel](_, IPXACT2009scalaxb.ElemName(node) :: stack) }) })
    
    def writesChildNodes(__obj: Channels, __scope: scala.xml.NamespaceBinding): Seq[scala.xml.Node] =
      (__obj.channel flatMap { IPXACT2009scalaxb.toXML[Channel](_, Some("http://www.spiritconsortium.org/XMLSchema/SPIRIT/1685-2009"), Some("channel"), __scope, false) })
  }
  trait Default_RemapPortFormat extends IPXACT2009scalaxb.XMLFormat[RemapPort] with IPXACT2009scalaxb.CanWriteChildNodes[RemapPort] {
    val targetNamespace: Option[String] = Some("http://www.spiritconsortium.org/XMLSchema/SPIRIT/1685-2009")
    def reads(seq: scala.xml.NodeSeq, stack: List[IPXACT2009scalaxb.ElemName]): Either[String, RemapPort] = seq match {
      case node: scala.xml.Node => Right(RemapPort(IPXACT2009scalaxb.fromXML[String](node, IPXACT2009scalaxb.ElemName(node) :: stack),
        scala.collection.immutable.ListMap(List(
        (node \ "@{http://www.spiritconsortium.org/XMLSchema/SPIRIT/1685-2009}portNameRef").headOption map { x => IPXACT2009scalaxb.DataRecord(x, node, IPXACT2009scalaxb.fromXML[String](x, IPXACT2009scalaxb.ElemName(node) :: stack)) } map { "@portNameRef" -> _ },
        (node \ "@{http://www.spiritconsortium.org/XMLSchema/SPIRIT/1685-2009}portIndex").headOption map { x => IPXACT2009scalaxb.DataRecord(x, node, IPXACT2009scalaxb.fromXML[BigInt](x, IPXACT2009scalaxb.ElemName(node) :: stack)) } map { "@portIndex" -> _ }
        ).flatten[(String, IPXACT2009scalaxb.DataRecord[Any])]: _*)))
      case _ => Left("reads failed: seq must be scala.xml.Node")
    }
    
    override def writesAttribute(__obj: RemapPort, __scope: scala.xml.NamespaceBinding): scala.xml.MetaData = {
      var attr: scala.xml.MetaData  = scala.xml.Null
      __obj.attributes.toList map {
        case ("@portNameRef", _) => attr = scala.xml.Attribute(__scope.getPrefix("http://www.spiritconsortium.org/XMLSchema/SPIRIT/1685-2009"), "portNameRef", __obj.portNameRef.toString, attr)
        case ("@portIndex", _) => __obj.portIndex foreach { x => attr = scala.xml.Attribute(__scope.getPrefix("http://www.spiritconsortium.org/XMLSchema/SPIRIT/1685-2009"), "portIndex", x.toString, attr) }
        case (key, x) => attr = scala.xml.Attribute((x.namespace map { __scope.getPrefix(_) }).orNull, x.key.orNull, x.value.toString, attr)
      }
      attr
    }

    def writesChildNodes(__obj: RemapPort, __scope: scala.xml.NamespaceBinding): Seq[scala.xml.Node] =
      Seq(scala.xml.Text(__obj.value.toString))

  }

  trait Default_RemapPortsFormat extends IPXACT2009scalaxb.ElemNameParser[RemapPorts] {
    val targetNamespace: Option[String] = Some("http://www.spiritconsortium.org/XMLSchema/SPIRIT/1685-2009")
    
    def parser(node: scala.xml.Node, stack: List[IPXACT2009scalaxb.ElemName]): Parser[RemapPorts] =
      phrase(safeRep(IPXACT2009scalaxb.ElemName(Some("http://www.spiritconsortium.org/XMLSchema/SPIRIT/1685-2009"), "remapPort")) ^^
      { case p1 =>
      RemapPorts(p1 map { IPXACT2009scalaxb.fromXML[RemapPort](_, IPXACT2009scalaxb.ElemName(node) :: stack) }) })
    
    def writesChildNodes(__obj: RemapPorts, __scope: scala.xml.NamespaceBinding): Seq[scala.xml.Node] =
      (__obj.remapPort flatMap { IPXACT2009scalaxb.toXML[RemapPort](_, Some("http://www.spiritconsortium.org/XMLSchema/SPIRIT/1685-2009"), Some("remapPort"), __scope, false) })
  }
  trait Default_RemapStateFormat extends IPXACT2009scalaxb.ElemNameParser[RemapState] with _NameGroupGroupFormat {
    val targetNamespace: Option[String] = Some("http://www.spiritconsortium.org/XMLSchema/SPIRIT/1685-2009")
    
    def parser(node: scala.xml.Node, stack: List[IPXACT2009scalaxb.ElemName]): Parser[RemapState] =
      phrase((parseNameGroupGroup(node, IPXACT2009scalaxb.ElemName(node) :: stack)) ~
      opt(IPXACT2009scalaxb.ElemName(Some("http://www.spiritconsortium.org/XMLSchema/SPIRIT/1685-2009"), "remapPorts")) ^^
      { case p1 ~ p2 =>
      RemapState(p1,
        p2.headOption map { IPXACT2009scalaxb.fromXML[RemapPorts](_, IPXACT2009scalaxb.ElemName(node) :: stack) }) })
    
    def writesChildNodes(__obj: RemapState, __scope: scala.xml.NamespaceBinding): Seq[scala.xml.Node] =
      Seq.concat(IPXACT2009scalaxb.toXML[NameGroupSequence](__obj.nameGroupSequence1, None, Some("nameGroupSequence1"), __scope, false),
        __obj.remapPorts map { IPXACT2009scalaxb.toXML[RemapPorts](_, Some("http://www.spiritconsortium.org/XMLSchema/SPIRIT/1685-2009"), Some("remapPorts"), __scope, false) } getOrElse {Nil})

  }

  trait Default_RemapStatesFormat extends IPXACT2009scalaxb.ElemNameParser[RemapStates] {
    val targetNamespace: Option[String] = Some("http://www.spiritconsortium.org/XMLSchema/SPIRIT/1685-2009")
    
    def parser(node: scala.xml.Node, stack: List[IPXACT2009scalaxb.ElemName]): Parser[RemapStates] =
      phrase(safeRep(IPXACT2009scalaxb.ElemName(Some("http://www.spiritconsortium.org/XMLSchema/SPIRIT/1685-2009"), "remapState")) ^^
      { case p1 =>
      RemapStates(p1 map { IPXACT2009scalaxb.fromXML[RemapState](_, IPXACT2009scalaxb.ElemName(node) :: stack) }) })
    
    def writesChildNodes(__obj: RemapStates, __scope: scala.xml.NamespaceBinding): Seq[scala.xml.Node] =
      (__obj.remapState flatMap { IPXACT2009scalaxb.toXML[RemapState](_, Some("http://www.spiritconsortium.org/XMLSchema/SPIRIT/1685-2009"), Some("remapState"), __scope, false) })
  }
  trait Default_BaseAddressFormat extends IPXACT2009scalaxb.XMLFormat[BaseAddress] with IPXACT2009scalaxb.CanWriteChildNodes[BaseAddress] {
    val targetNamespace: Option[String] = Some("http://www.spiritconsortium.org/XMLSchema/SPIRIT/1685-2009")
    def reads(seq: scala.xml.NodeSeq, stack: List[IPXACT2009scalaxb.ElemName]): Either[String, BaseAddress] = seq match {
      case node: scala.xml.Node => Right(BaseAddress(IPXACT2009scalaxb.fromXML[String](node, IPXACT2009scalaxb.ElemName(node) :: stack),
        scala.collection.immutable.ListMap(List(
        (node \ "@{http://www.spiritconsortium.org/XMLSchema/SPIRIT/1685-2009}format").headOption map { x => IPXACT2009scalaxb.DataRecord(x, node, IPXACT2009scalaxb.fromXML[FormatType](x, IPXACT2009scalaxb.ElemName(node) :: stack)) } orElse Some(IPXACT2009scalaxb.DataRecord(None, None, IPXACT2009scalaxb.fromXML[FormatType](scala.xml.Text("long"), IPXACT2009scalaxb.ElemName(node) :: stack))) map { "@{http://www.spiritconsortium.org/XMLSchema/SPIRIT/1685-2009}format" -> _ },
        (node \ "@{http://www.spiritconsortium.org/XMLSchema/SPIRIT/1685-2009}resolve").headOption map { x => IPXACT2009scalaxb.DataRecord(x, node, IPXACT2009scalaxb.fromXML[ResolveType](x, IPXACT2009scalaxb.ElemName(node) :: stack)) } map { "@{http://www.spiritconsortium.org/XMLSchema/SPIRIT/1685-2009}resolve" -> _ },
        (node \ "@{http://www.spiritconsortium.org/XMLSchema/SPIRIT/1685-2009}id").headOption map { x => IPXACT2009scalaxb.DataRecord(x, node, IPXACT2009scalaxb.fromXML[String](x, IPXACT2009scalaxb.ElemName(node) :: stack)) } map { "@{http://www.spiritconsortium.org/XMLSchema/SPIRIT/1685-2009}id" -> _ },
        (node \ "@{http://www.spiritconsortium.org/XMLSchema/SPIRIT/1685-2009}dependency").headOption map { x => IPXACT2009scalaxb.DataRecord(x, node, IPXACT2009scalaxb.fromXML[String](x, IPXACT2009scalaxb.ElemName(node) :: stack)) } map { "@{http://www.spiritconsortium.org/XMLSchema/SPIRIT/1685-2009}dependency" -> _ },
        (node \ "@{http://www.spiritconsortium.org/XMLSchema/SPIRIT/1685-2009}choiceRef").headOption map { x => IPXACT2009scalaxb.DataRecord(x, node, IPXACT2009scalaxb.fromXML[String](x, IPXACT2009scalaxb.ElemName(node) :: stack)) } map { "@{http://www.spiritconsortium.org/XMLSchema/SPIRIT/1685-2009}choiceRef" -> _ },
        (node \ "@{http://www.spiritconsortium.org/XMLSchema/SPIRIT/1685-2009}order").headOption map { x => IPXACT2009scalaxb.DataRecord(x, node, IPXACT2009scalaxb.fromXML[Float](x, IPXACT2009scalaxb.ElemName(node) :: stack)) } map { "@{http://www.spiritconsortium.org/XMLSchema/SPIRIT/1685-2009}order" -> _ },
        (node \ "@{http://www.spiritconsortium.org/XMLSchema/SPIRIT/1685-2009}configGroups").headOption map { x => IPXACT2009scalaxb.DataRecord(x, node, IPXACT2009scalaxb.fromXML[Seq[String]](x, IPXACT2009scalaxb.ElemName(node) :: stack)) } map { "@{http://www.spiritconsortium.org/XMLSchema/SPIRIT/1685-2009}configGroups" -> _ },
        (node \ "@{http://www.spiritconsortium.org/XMLSchema/SPIRIT/1685-2009}bitStringLength").headOption map { x => IPXACT2009scalaxb.DataRecord(x, node, IPXACT2009scalaxb.fromXML[BigInt](x, IPXACT2009scalaxb.ElemName(node) :: stack)) } map { "@{http://www.spiritconsortium.org/XMLSchema/SPIRIT/1685-2009}bitStringLength" -> _ },
        (node \ "@{http://www.spiritconsortium.org/XMLSchema/SPIRIT/1685-2009}minimum").headOption map { x => IPXACT2009scalaxb.DataRecord(x, node, IPXACT2009scalaxb.fromXML[String](x, IPXACT2009scalaxb.ElemName(node) :: stack)) } map { "@{http://www.spiritconsortium.org/XMLSchema/SPIRIT/1685-2009}minimum" -> _ },
        (node \ "@{http://www.spiritconsortium.org/XMLSchema/SPIRIT/1685-2009}maximum").headOption map { x => IPXACT2009scalaxb.DataRecord(x, node, IPXACT2009scalaxb.fromXML[String](x, IPXACT2009scalaxb.ElemName(node) :: stack)) } map { "@{http://www.spiritconsortium.org/XMLSchema/SPIRIT/1685-2009}maximum" -> _ },
        (node \ "@{http://www.spiritconsortium.org/XMLSchema/SPIRIT/1685-2009}rangeType").headOption map { x => IPXACT2009scalaxb.DataRecord(x, node, IPXACT2009scalaxb.fromXML[RangeTypeType](x, IPXACT2009scalaxb.ElemName(node) :: stack)) } orElse Some(IPXACT2009scalaxb.DataRecord(None, None, IPXACT2009scalaxb.fromXML[RangeTypeType](scala.xml.Text("float"), IPXACT2009scalaxb.ElemName(node) :: stack))) map { "@{http://www.spiritconsortium.org/XMLSchema/SPIRIT/1685-2009}rangeType" -> _ },
        (node \ "@{http://www.spiritconsortium.org/XMLSchema/SPIRIT/1685-2009}prompt").headOption map { x => IPXACT2009scalaxb.DataRecord(x, node, IPXACT2009scalaxb.fromXML[String](x, IPXACT2009scalaxb.ElemName(node) :: stack)) } orElse Some(IPXACT2009scalaxb.DataRecord(None, None, IPXACT2009scalaxb.fromXML[String](scala.xml.Text("Base Address:"), IPXACT2009scalaxb.ElemName(node) :: stack))) map { "@{http://www.spiritconsortium.org/XMLSchema/SPIRIT/1685-2009}prompt" -> _ }
        ).flatten[(String, IPXACT2009scalaxb.DataRecord[Any])] ::: (node match {
          case elem: scala.xml.Elem =>
            elem.attributes.toList flatMap {
              case scala.xml.PrefixedAttribute(pre, key, value, _) if pre == elem.scope.getPrefix("http://www.spiritconsortium.org/XMLSchema/SPIRIT/1685-2009") &&
                key == "format" => Nil
              case scala.xml.PrefixedAttribute(pre, key, value, _) if pre == elem.scope.getPrefix("http://www.spiritconsortium.org/XMLSchema/SPIRIT/1685-2009") &&
                key == "resolve" => Nil
              case scala.xml.PrefixedAttribute(pre, key, value, _) if pre == elem.scope.getPrefix("http://www.spiritconsortium.org/XMLSchema/SPIRIT/1685-2009") &&
                key == "id" => Nil
              case scala.xml.PrefixedAttribute(pre, key, value, _) if pre == elem.scope.getPrefix("http://www.spiritconsortium.org/XMLSchema/SPIRIT/1685-2009") &&
                key == "dependency" => Nil
              case scala.xml.PrefixedAttribute(pre, key, value, _) if pre == elem.scope.getPrefix("http://www.spiritconsortium.org/XMLSchema/SPIRIT/1685-2009") &&
                key == "choiceRef" => Nil
              case scala.xml.PrefixedAttribute(pre, key, value, _) if pre == elem.scope.getPrefix("http://www.spiritconsortium.org/XMLSchema/SPIRIT/1685-2009") &&
                key == "order" => Nil
              case scala.xml.PrefixedAttribute(pre, key, value, _) if pre == elem.scope.getPrefix("http://www.spiritconsortium.org/XMLSchema/SPIRIT/1685-2009") &&
                key == "configGroups" => Nil
              case scala.xml.PrefixedAttribute(pre, key, value, _) if pre == elem.scope.getPrefix("http://www.spiritconsortium.org/XMLSchema/SPIRIT/1685-2009") &&
                key == "bitStringLength" => Nil
              case scala.xml.PrefixedAttribute(pre, key, value, _) if pre == elem.scope.getPrefix("http://www.spiritconsortium.org/XMLSchema/SPIRIT/1685-2009") &&
                key == "minimum" => Nil
              case scala.xml.PrefixedAttribute(pre, key, value, _) if pre == elem.scope.getPrefix("http://www.spiritconsortium.org/XMLSchema/SPIRIT/1685-2009") &&
                key == "maximum" => Nil
              case scala.xml.PrefixedAttribute(pre, key, value, _) if pre == elem.scope.getPrefix("http://www.spiritconsortium.org/XMLSchema/SPIRIT/1685-2009") &&
                key == "rangeType" => Nil
              case scala.xml.PrefixedAttribute(pre, key, value, _) if pre == elem.scope.getPrefix("http://www.spiritconsortium.org/XMLSchema/SPIRIT/1685-2009") &&
                key == "prompt" => Nil
              case scala.xml.UnprefixedAttribute(key, value, _) =>
                List(("@" + key, IPXACT2009scalaxb.DataRecord(None, Some(key), value.text)))
              case scala.xml.PrefixedAttribute(pre, key, value, _) =>
                val ns = elem.scope.getURI(pre)
                List(("@{" + ns + "}" + key, IPXACT2009scalaxb.DataRecord(Option[String](ns), Some(key), value.text)))
              case _ => Nil
            }
          case _ => Nil
        }): _*)))
      case _ => Left("reads failed: seq must be scala.xml.Node")
    }
    
    override def writesAttribute(__obj: BaseAddress, __scope: scala.xml.NamespaceBinding): scala.xml.MetaData = {
      var attr: scala.xml.MetaData  = scala.xml.Null
      __obj.attributes.toList map {
        case ("@{http://www.spiritconsortium.org/XMLSchema/SPIRIT/1685-2009}format", _) => if (__obj.spiritformat.toString != "long") attr = scala.xml.Attribute(__scope.getPrefix("http://www.spiritconsortium.org/XMLSchema/SPIRIT/1685-2009"), "format", __obj.spiritformat.toString, attr)
        case ("@{http://www.spiritconsortium.org/XMLSchema/SPIRIT/1685-2009}resolve", _) => __obj.spiritresolve foreach { x => attr = scala.xml.Attribute(__scope.getPrefix("http://www.spiritconsortium.org/XMLSchema/SPIRIT/1685-2009"), "resolve", x.toString, attr) }
        case ("@{http://www.spiritconsortium.org/XMLSchema/SPIRIT/1685-2009}id", _) => __obj.spiritid foreach { x => attr = scala.xml.Attribute(__scope.getPrefix("http://www.spiritconsortium.org/XMLSchema/SPIRIT/1685-2009"), "id", x.toString, attr) }
        case ("@{http://www.spiritconsortium.org/XMLSchema/SPIRIT/1685-2009}dependency", _) => __obj.spiritdependency foreach { x => attr = scala.xml.Attribute(__scope.getPrefix("http://www.spiritconsortium.org/XMLSchema/SPIRIT/1685-2009"), "dependency", x.toString, attr) }
        case ("@{http://www.spiritconsortium.org/XMLSchema/SPIRIT/1685-2009}choiceRef", _) => __obj.spiritchoiceRef foreach { x => attr = scala.xml.Attribute(__scope.getPrefix("http://www.spiritconsortium.org/XMLSchema/SPIRIT/1685-2009"), "choiceRef", x.toString, attr) }
        case ("@{http://www.spiritconsortium.org/XMLSchema/SPIRIT/1685-2009}order", _) => __obj.spiritorder foreach { x => attr = scala.xml.Attribute(__scope.getPrefix("http://www.spiritconsortium.org/XMLSchema/SPIRIT/1685-2009"), "order", x.toString, attr) }
        case ("@{http://www.spiritconsortium.org/XMLSchema/SPIRIT/1685-2009}configGroups", _) => __obj.spiritconfigGroups foreach { x => attr = scala.xml.Attribute(__scope.getPrefix("http://www.spiritconsortium.org/XMLSchema/SPIRIT/1685-2009"), "configGroups", x.toString, attr) }
        case ("@{http://www.spiritconsortium.org/XMLSchema/SPIRIT/1685-2009}bitStringLength", _) => __obj.spiritbitStringLength foreach { x => attr = scala.xml.Attribute(__scope.getPrefix("http://www.spiritconsortium.org/XMLSchema/SPIRIT/1685-2009"), "bitStringLength", x.toString, attr) }
        case ("@{http://www.spiritconsortium.org/XMLSchema/SPIRIT/1685-2009}minimum", _) => __obj.spiritminimum foreach { x => attr = scala.xml.Attribute(__scope.getPrefix("http://www.spiritconsortium.org/XMLSchema/SPIRIT/1685-2009"), "minimum", x.toString, attr) }
        case ("@{http://www.spiritconsortium.org/XMLSchema/SPIRIT/1685-2009}maximum", _) => __obj.spiritmaximum foreach { x => attr = scala.xml.Attribute(__scope.getPrefix("http://www.spiritconsortium.org/XMLSchema/SPIRIT/1685-2009"), "maximum", x.toString, attr) }
        case ("@{http://www.spiritconsortium.org/XMLSchema/SPIRIT/1685-2009}rangeType", _) => if (__obj.spiritrangeType.toString != "float") attr = scala.xml.Attribute(__scope.getPrefix("http://www.spiritconsortium.org/XMLSchema/SPIRIT/1685-2009"), "rangeType", __obj.spiritrangeType.toString, attr)
        case ("@{http://www.spiritconsortium.org/XMLSchema/SPIRIT/1685-2009}prompt", _) => if (__obj.spiritprompt.toString != "Base Address:") attr = scala.xml.Attribute(__scope.getPrefix("http://www.spiritconsortium.org/XMLSchema/SPIRIT/1685-2009"), "prompt", __obj.spiritprompt.toString, attr)
        case (key, x) => attr = scala.xml.Attribute((x.namespace map { __scope.getPrefix(_) }).orNull, x.key.orNull, x.value.toString, attr)
      }
      attr
    }

    def writesChildNodes(__obj: BaseAddress, __scope: scala.xml.NamespaceBinding): Seq[scala.xml.Node] =
      Seq(scala.xml.Text(__obj.value.toString))

  }

  trait Default_AddressSpaceRefFormat extends IPXACT2009scalaxb.ElemNameParser[AddressSpaceRef] {
    val targetNamespace: Option[String] = Some("http://www.spiritconsortium.org/XMLSchema/SPIRIT/1685-2009")
    
    def parser(node: scala.xml.Node, stack: List[IPXACT2009scalaxb.ElemName]): Parser[AddressSpaceRef] =
      phrase(opt(IPXACT2009scalaxb.ElemName(Some("http://www.spiritconsortium.org/XMLSchema/SPIRIT/1685-2009"), "baseAddress")) ^^
      { case p1 =>
      AddressSpaceRef(p1.headOption map { IPXACT2009scalaxb.fromXML[BaseAddress](_, IPXACT2009scalaxb.ElemName(node) :: stack) },
        scala.collection.immutable.ListMap(List(
        (node \ "@{http://www.spiritconsortium.org/XMLSchema/SPIRIT/1685-2009}addressSpaceRef").headOption map { x => IPXACT2009scalaxb.DataRecord(x, node, IPXACT2009scalaxb.fromXML[String](x, IPXACT2009scalaxb.ElemName(node) :: stack)) } map { "@{http://www.spiritconsortium.org/XMLSchema/SPIRIT/1685-2009}addressSpaceRef" -> _ }
        ).flatten[(String, IPXACT2009scalaxb.DataRecord[Any])]: _*)) })
    
    override def writesAttribute(__obj: AddressSpaceRef, __scope: scala.xml.NamespaceBinding): scala.xml.MetaData = {
      var attr: scala.xml.MetaData  = scala.xml.Null
      __obj.attributes.toList map {
        case ("@{http://www.spiritconsortium.org/XMLSchema/SPIRIT/1685-2009}addressSpaceRef", _) => attr = scala.xml.Attribute(__scope.getPrefix("http://www.spiritconsortium.org/XMLSchema/SPIRIT/1685-2009"), "addressSpaceRef", __obj.spiritaddressSpaceRef.toString, attr)
        case (key, x) => attr = scala.xml.Attribute((x.namespace map { __scope.getPrefix(_) }).orNull, x.key.orNull, x.value.toString, attr)
      }
      attr
    }

    def writesChildNodes(__obj: AddressSpaceRef, __scope: scala.xml.NamespaceBinding): Seq[scala.xml.Node] =
      (__obj.baseAddress map { IPXACT2009scalaxb.toXML[BaseAddress](_, Some("http://www.spiritconsortium.org/XMLSchema/SPIRIT/1685-2009"), Some("baseAddress"), __scope, false) } getOrElse {Nil})
  }

  trait Default_MasterFormat extends IPXACT2009scalaxb.ElemNameParser[Master] {
    val targetNamespace: Option[String] = Some("http://www.spiritconsortium.org/XMLSchema/SPIRIT/1685-2009")
    
    def parser(node: scala.xml.Node, stack: List[IPXACT2009scalaxb.ElemName]): Parser[Master] =
      phrase(opt(IPXACT2009scalaxb.ElemName(Some("http://www.spiritconsortium.org/XMLSchema/SPIRIT/1685-2009"), "addressSpaceRef")) ^^
      { case p1 =>
      Master(p1.headOption map { IPXACT2009scalaxb.fromXML[AddressSpaceRef](_, IPXACT2009scalaxb.ElemName(node) :: stack) }) })
    
    def writesChildNodes(__obj: Master, __scope: scala.xml.NamespaceBinding): Seq[scala.xml.Node] =
      (__obj.addressSpaceRef map { IPXACT2009scalaxb.toXML[AddressSpaceRef](_, Some("http://www.spiritconsortium.org/XMLSchema/SPIRIT/1685-2009"), Some("addressSpaceRef"), __scope, false) } getOrElse {Nil})
  }
  trait Default_BridgeFormat extends IPXACT2009scalaxb.XMLFormat[Bridge] with IPXACT2009scalaxb.CanWriteChildNodes[Bridge] {
    val targetNamespace: Option[String] = Some("http://www.spiritconsortium.org/XMLSchema/SPIRIT/1685-2009")
    def reads(seq: scala.xml.NodeSeq, stack: List[IPXACT2009scalaxb.ElemName]): Either[String, Bridge] = seq match {
      case node: scala.xml.Node => Right(Bridge(scala.collection.immutable.ListMap(List(
        (node \ "@{http://www.spiritconsortium.org/XMLSchema/SPIRIT/1685-2009}masterRef").headOption map { x => IPXACT2009scalaxb.DataRecord(x, node, IPXACT2009scalaxb.fromXML[String](x, IPXACT2009scalaxb.ElemName(node) :: stack)) } map { "@masterRef" -> _ },
        (node \ "@{http://www.spiritconsortium.org/XMLSchema/SPIRIT/1685-2009}opaque").headOption map { x => IPXACT2009scalaxb.DataRecord(x, node, IPXACT2009scalaxb.fromXML[Boolean](x, IPXACT2009scalaxb.ElemName(node) :: stack)) } map { "@opaque" -> _ }
        ).flatten[(String, IPXACT2009scalaxb.DataRecord[Any])]: _*)))
      case _ => Left("reads failed: seq must be scala.xml.Node")
    }
    
    override def writesAttribute(__obj: Bridge, __scope: scala.xml.NamespaceBinding): scala.xml.MetaData = {
      var attr: scala.xml.MetaData  = scala.xml.Null
      __obj.attributes.toList map {
        case ("@masterRef", _) => attr = scala.xml.Attribute(__scope.getPrefix("http://www.spiritconsortium.org/XMLSchema/SPIRIT/1685-2009"), "masterRef", __obj.masterRef.toString, attr)
        case ("@opaque", _) => attr = scala.xml.Attribute(__scope.getPrefix("http://www.spiritconsortium.org/XMLSchema/SPIRIT/1685-2009"), "opaque", __obj.opaque.toString, attr)
        case (key, x) => attr = scala.xml.Attribute((x.namespace map { __scope.getPrefix(_) }).orNull, x.key.orNull, x.value.toString, attr)
      }
      attr
    }

    def writesChildNodes(__obj: Bridge, __scope: scala.xml.NamespaceBinding): Seq[scala.xml.Node] =
      Nil

  }

  trait Default_FileSetRefGroup2Format extends IPXACT2009scalaxb.ElemNameParser[FileSetRefGroup2] {
    val targetNamespace: Option[String] = Some("http://www.spiritconsortium.org/XMLSchema/SPIRIT/1685-2009")
    
    def parser(node: scala.xml.Node, stack: List[IPXACT2009scalaxb.ElemName]): Parser[FileSetRefGroup2] =
      phrase(opt(IPXACT2009scalaxb.ElemName(Some("http://www.spiritconsortium.org/XMLSchema/SPIRIT/1685-2009"), "group")) ~
      safeRep(IPXACT2009scalaxb.ElemName(Some("http://www.spiritconsortium.org/XMLSchema/SPIRIT/1685-2009"), "fileSetRef")) ^^
      { case p1 ~ p2 =>
      FileSetRefGroup2(p1.headOption map { IPXACT2009scalaxb.fromXML[String](_, IPXACT2009scalaxb.ElemName(node) :: stack) },
        p2 map { IPXACT2009scalaxb.fromXML[FileSetRef](_, IPXACT2009scalaxb.ElemName(node) :: stack) }) })
    
    def writesChildNodes(__obj: FileSetRefGroup2, __scope: scala.xml.NamespaceBinding): Seq[scala.xml.Node] =
      Seq.concat(__obj.group map { IPXACT2009scalaxb.toXML[String](_, Some("http://www.spiritconsortium.org/XMLSchema/SPIRIT/1685-2009"), Some("group"), __scope, false) } getOrElse {Nil},
        __obj.fileSetRef flatMap { IPXACT2009scalaxb.toXML[FileSetRef](_, Some("http://www.spiritconsortium.org/XMLSchema/SPIRIT/1685-2009"), Some("fileSetRef"), __scope, false) })

  }

  trait Default_SlaveFormat extends IPXACT2009scalaxb.ElemNameParser[Slave] {
    val targetNamespace: Option[String] = Some("http://www.spiritconsortium.org/XMLSchema/SPIRIT/1685-2009")
    
    def parser(node: scala.xml.Node, stack: List[IPXACT2009scalaxb.ElemName]): Parser[Slave] =
      phrase(opt(IPXACT2009scalaxb.ElemName(Some("http://www.spiritconsortium.org/XMLSchema/SPIRIT/1685-2009"), "memoryMapRef")) ~
      safeRep(IPXACT2009scalaxb.ElemName(Some("http://www.spiritconsortium.org/XMLSchema/SPIRIT/1685-2009"), "bridge")) ~
      safeRep(IPXACT2009scalaxb.ElemName(Some("http://www.spiritconsortium.org/XMLSchema/SPIRIT/1685-2009"), "fileSetRefGroup")) ^^
      { case p1 ~ p2 ~ p3 =>
      Slave(p1.headOption map { IPXACT2009scalaxb.fromXML[MemoryMapRefType](_, IPXACT2009scalaxb.ElemName(node) :: stack) },
        p2 map { IPXACT2009scalaxb.fromXML[Bridge](_, IPXACT2009scalaxb.ElemName(node) :: stack) },
        p3 map { IPXACT2009scalaxb.fromXML[FileSetRefGroup2](_, IPXACT2009scalaxb.ElemName(node) :: stack) }) })
    
    def writesChildNodes(__obj: Slave, __scope: scala.xml.NamespaceBinding): Seq[scala.xml.Node] =
      Seq.concat(__obj.memoryMapRef map { IPXACT2009scalaxb.toXML[MemoryMapRefType](_, Some("http://www.spiritconsortium.org/XMLSchema/SPIRIT/1685-2009"), Some("memoryMapRef"), __scope, false) } getOrElse {Nil},
        __obj.bridge flatMap { IPXACT2009scalaxb.toXML[Bridge](_, Some("http://www.spiritconsortium.org/XMLSchema/SPIRIT/1685-2009"), Some("bridge"), __scope, false) },
        __obj.fileSetRefGroup flatMap { IPXACT2009scalaxb.toXML[FileSetRefGroup2](_, Some("http://www.spiritconsortium.org/XMLSchema/SPIRIT/1685-2009"), Some("fileSetRefGroup"), __scope, false) })

  }

  trait Default_SystemFormat extends IPXACT2009scalaxb.ElemNameParser[System] {
    val targetNamespace: Option[String] = Some("http://www.spiritconsortium.org/XMLSchema/SPIRIT/1685-2009")
    
    def parser(node: scala.xml.Node, stack: List[IPXACT2009scalaxb.ElemName]): Parser[System] =
      phrase((IPXACT2009scalaxb.ElemName(Some("http://www.spiritconsortium.org/XMLSchema/SPIRIT/1685-2009"), "group")) ^^
      { case p1 =>
      System(IPXACT2009scalaxb.fromXML[String](p1, IPXACT2009scalaxb.ElemName(node) :: stack)) })
    
    def writesChildNodes(__obj: System, __scope: scala.xml.NamespaceBinding): Seq[scala.xml.Node] =
      (IPXACT2009scalaxb.toXML[String](__obj.group, Some("http://www.spiritconsortium.org/XMLSchema/SPIRIT/1685-2009"), Some("group"), __scope, false))
  }
  trait Default_RemapAddressFormat extends IPXACT2009scalaxb.XMLFormat[RemapAddress] with IPXACT2009scalaxb.CanWriteChildNodes[RemapAddress] {
    val targetNamespace: Option[String] = Some("http://www.spiritconsortium.org/XMLSchema/SPIRIT/1685-2009")
    def reads(seq: scala.xml.NodeSeq, stack: List[IPXACT2009scalaxb.ElemName]): Either[String, RemapAddress] = seq match {
      case node: scala.xml.Node => Right(RemapAddress(IPXACT2009scalaxb.fromXML[String](node, IPXACT2009scalaxb.ElemName(node) :: stack),
        scala.collection.immutable.ListMap(List(
        (node \ "@{http://www.spiritconsortium.org/XMLSchema/SPIRIT/1685-2009}format").headOption map { x => IPXACT2009scalaxb.DataRecord(x, node, IPXACT2009scalaxb.fromXML[FormatType](x, IPXACT2009scalaxb.ElemName(node) :: stack)) } orElse Some(IPXACT2009scalaxb.DataRecord(None, None, IPXACT2009scalaxb.fromXML[FormatType](scala.xml.Text("long"), IPXACT2009scalaxb.ElemName(node) :: stack))) map { "@{http://www.spiritconsortium.org/XMLSchema/SPIRIT/1685-2009}format" -> _ },
        (node \ "@{http://www.spiritconsortium.org/XMLSchema/SPIRIT/1685-2009}resolve").headOption map { x => IPXACT2009scalaxb.DataRecord(x, node, IPXACT2009scalaxb.fromXML[ResolveType](x, IPXACT2009scalaxb.ElemName(node) :: stack)) } map { "@{http://www.spiritconsortium.org/XMLSchema/SPIRIT/1685-2009}resolve" -> _ },
        (node \ "@{http://www.spiritconsortium.org/XMLSchema/SPIRIT/1685-2009}id").headOption map { x => IPXACT2009scalaxb.DataRecord(x, node, IPXACT2009scalaxb.fromXML[String](x, IPXACT2009scalaxb.ElemName(node) :: stack)) } map { "@{http://www.spiritconsortium.org/XMLSchema/SPIRIT/1685-2009}id" -> _ },
        (node \ "@{http://www.spiritconsortium.org/XMLSchema/SPIRIT/1685-2009}dependency").headOption map { x => IPXACT2009scalaxb.DataRecord(x, node, IPXACT2009scalaxb.fromXML[String](x, IPXACT2009scalaxb.ElemName(node) :: stack)) } map { "@{http://www.spiritconsortium.org/XMLSchema/SPIRIT/1685-2009}dependency" -> _ },
        (node \ "@{http://www.spiritconsortium.org/XMLSchema/SPIRIT/1685-2009}choiceRef").headOption map { x => IPXACT2009scalaxb.DataRecord(x, node, IPXACT2009scalaxb.fromXML[String](x, IPXACT2009scalaxb.ElemName(node) :: stack)) } map { "@{http://www.spiritconsortium.org/XMLSchema/SPIRIT/1685-2009}choiceRef" -> _ },
        (node \ "@{http://www.spiritconsortium.org/XMLSchema/SPIRIT/1685-2009}order").headOption map { x => IPXACT2009scalaxb.DataRecord(x, node, IPXACT2009scalaxb.fromXML[Float](x, IPXACT2009scalaxb.ElemName(node) :: stack)) } map { "@{http://www.spiritconsortium.org/XMLSchema/SPIRIT/1685-2009}order" -> _ },
        (node \ "@{http://www.spiritconsortium.org/XMLSchema/SPIRIT/1685-2009}configGroups").headOption map { x => IPXACT2009scalaxb.DataRecord(x, node, IPXACT2009scalaxb.fromXML[Seq[String]](x, IPXACT2009scalaxb.ElemName(node) :: stack)) } map { "@{http://www.spiritconsortium.org/XMLSchema/SPIRIT/1685-2009}configGroups" -> _ },
        (node \ "@{http://www.spiritconsortium.org/XMLSchema/SPIRIT/1685-2009}bitStringLength").headOption map { x => IPXACT2009scalaxb.DataRecord(x, node, IPXACT2009scalaxb.fromXML[BigInt](x, IPXACT2009scalaxb.ElemName(node) :: stack)) } map { "@{http://www.spiritconsortium.org/XMLSchema/SPIRIT/1685-2009}bitStringLength" -> _ },
        (node \ "@{http://www.spiritconsortium.org/XMLSchema/SPIRIT/1685-2009}minimum").headOption map { x => IPXACT2009scalaxb.DataRecord(x, node, IPXACT2009scalaxb.fromXML[String](x, IPXACT2009scalaxb.ElemName(node) :: stack)) } map { "@{http://www.spiritconsortium.org/XMLSchema/SPIRIT/1685-2009}minimum" -> _ },
        (node \ "@{http://www.spiritconsortium.org/XMLSchema/SPIRIT/1685-2009}maximum").headOption map { x => IPXACT2009scalaxb.DataRecord(x, node, IPXACT2009scalaxb.fromXML[String](x, IPXACT2009scalaxb.ElemName(node) :: stack)) } map { "@{http://www.spiritconsortium.org/XMLSchema/SPIRIT/1685-2009}maximum" -> _ },
        (node \ "@{http://www.spiritconsortium.org/XMLSchema/SPIRIT/1685-2009}rangeType").headOption map { x => IPXACT2009scalaxb.DataRecord(x, node, IPXACT2009scalaxb.fromXML[RangeTypeType](x, IPXACT2009scalaxb.ElemName(node) :: stack)) } orElse Some(IPXACT2009scalaxb.DataRecord(None, None, IPXACT2009scalaxb.fromXML[RangeTypeType](scala.xml.Text("float"), IPXACT2009scalaxb.ElemName(node) :: stack))) map { "@{http://www.spiritconsortium.org/XMLSchema/SPIRIT/1685-2009}rangeType" -> _ },
        (node \ "@{http://www.spiritconsortium.org/XMLSchema/SPIRIT/1685-2009}prompt").headOption map { x => IPXACT2009scalaxb.DataRecord(x, node, IPXACT2009scalaxb.fromXML[String](x, IPXACT2009scalaxb.ElemName(node) :: stack)) } orElse Some(IPXACT2009scalaxb.DataRecord(None, None, IPXACT2009scalaxb.fromXML[String](scala.xml.Text("Base Address:"), IPXACT2009scalaxb.ElemName(node) :: stack))) map { "@{http://www.spiritconsortium.org/XMLSchema/SPIRIT/1685-2009}prompt" -> _ },
        (node \ "@{http://www.spiritconsortium.org/XMLSchema/SPIRIT/1685-2009}state").headOption map { x => IPXACT2009scalaxb.DataRecord(x, node, IPXACT2009scalaxb.fromXML[String](x, IPXACT2009scalaxb.ElemName(node) :: stack)) } map { "@state" -> _ }
        ).flatten[(String, IPXACT2009scalaxb.DataRecord[Any])] ::: (node match {
          case elem: scala.xml.Elem =>
            elem.attributes.toList flatMap {
              case scala.xml.PrefixedAttribute(pre, key, value, _) if pre == elem.scope.getPrefix("http://www.spiritconsortium.org/XMLSchema/SPIRIT/1685-2009") &&
                key == "format" => Nil
              case scala.xml.PrefixedAttribute(pre, key, value, _) if pre == elem.scope.getPrefix("http://www.spiritconsortium.org/XMLSchema/SPIRIT/1685-2009") &&
                key == "resolve" => Nil
              case scala.xml.PrefixedAttribute(pre, key, value, _) if pre == elem.scope.getPrefix("http://www.spiritconsortium.org/XMLSchema/SPIRIT/1685-2009") &&
                key == "id" => Nil
              case scala.xml.PrefixedAttribute(pre, key, value, _) if pre == elem.scope.getPrefix("http://www.spiritconsortium.org/XMLSchema/SPIRIT/1685-2009") &&
                key == "dependency" => Nil
              case scala.xml.PrefixedAttribute(pre, key, value, _) if pre == elem.scope.getPrefix("http://www.spiritconsortium.org/XMLSchema/SPIRIT/1685-2009") &&
                key == "choiceRef" => Nil
              case scala.xml.PrefixedAttribute(pre, key, value, _) if pre == elem.scope.getPrefix("http://www.spiritconsortium.org/XMLSchema/SPIRIT/1685-2009") &&
                key == "order" => Nil
              case scala.xml.PrefixedAttribute(pre, key, value, _) if pre == elem.scope.getPrefix("http://www.spiritconsortium.org/XMLSchema/SPIRIT/1685-2009") &&
                key == "configGroups" => Nil
              case scala.xml.PrefixedAttribute(pre, key, value, _) if pre == elem.scope.getPrefix("http://www.spiritconsortium.org/XMLSchema/SPIRIT/1685-2009") &&
                key == "bitStringLength" => Nil
              case scala.xml.PrefixedAttribute(pre, key, value, _) if pre == elem.scope.getPrefix("http://www.spiritconsortium.org/XMLSchema/SPIRIT/1685-2009") &&
                key == "minimum" => Nil
              case scala.xml.PrefixedAttribute(pre, key, value, _) if pre == elem.scope.getPrefix("http://www.spiritconsortium.org/XMLSchema/SPIRIT/1685-2009") &&
                key == "maximum" => Nil
              case scala.xml.PrefixedAttribute(pre, key, value, _) if pre == elem.scope.getPrefix("http://www.spiritconsortium.org/XMLSchema/SPIRIT/1685-2009") &&
                key == "rangeType" => Nil
              case scala.xml.PrefixedAttribute(pre, key, value, _) if pre == elem.scope.getPrefix("http://www.spiritconsortium.org/XMLSchema/SPIRIT/1685-2009") &&
                key == "prompt" => Nil
              case scala.xml.PrefixedAttribute(pre, key, value, _) if pre == elem.scope.getPrefix("http://www.spiritconsortium.org/XMLSchema/SPIRIT/1685-2009") &&
                key == "state" => Nil
              case scala.xml.UnprefixedAttribute(key, value, _) =>
                List(("@" + key, IPXACT2009scalaxb.DataRecord(None, Some(key), value.text)))
              case scala.xml.PrefixedAttribute(pre, key, value, _) =>
                val ns = elem.scope.getURI(pre)
                List(("@{" + ns + "}" + key, IPXACT2009scalaxb.DataRecord(Option[String](ns), Some(key), value.text)))
              case _ => Nil
            }
          case _ => Nil
        }): _*)))
      case _ => Left("reads failed: seq must be scala.xml.Node")
    }
    
    override def writesAttribute(__obj: RemapAddress, __scope: scala.xml.NamespaceBinding): scala.xml.MetaData = {
      var attr: scala.xml.MetaData  = scala.xml.Null
      __obj.attributes.toList map {
        case ("@{http://www.spiritconsortium.org/XMLSchema/SPIRIT/1685-2009}format", _) => if (__obj.spiritformat.toString != "long") attr = scala.xml.Attribute(__scope.getPrefix("http://www.spiritconsortium.org/XMLSchema/SPIRIT/1685-2009"), "format", __obj.spiritformat.toString, attr)
        case ("@{http://www.spiritconsortium.org/XMLSchema/SPIRIT/1685-2009}resolve", _) => __obj.spiritresolve foreach { x => attr = scala.xml.Attribute(__scope.getPrefix("http://www.spiritconsortium.org/XMLSchema/SPIRIT/1685-2009"), "resolve", x.toString, attr) }
        case ("@{http://www.spiritconsortium.org/XMLSchema/SPIRIT/1685-2009}id", _) => __obj.spiritid foreach { x => attr = scala.xml.Attribute(__scope.getPrefix("http://www.spiritconsortium.org/XMLSchema/SPIRIT/1685-2009"), "id", x.toString, attr) }
        case ("@{http://www.spiritconsortium.org/XMLSchema/SPIRIT/1685-2009}dependency", _) => __obj.spiritdependency foreach { x => attr = scala.xml.Attribute(__scope.getPrefix("http://www.spiritconsortium.org/XMLSchema/SPIRIT/1685-2009"), "dependency", x.toString, attr) }
        case ("@{http://www.spiritconsortium.org/XMLSchema/SPIRIT/1685-2009}choiceRef", _) => __obj.spiritchoiceRef foreach { x => attr = scala.xml.Attribute(__scope.getPrefix("http://www.spiritconsortium.org/XMLSchema/SPIRIT/1685-2009"), "choiceRef", x.toString, attr) }
        case ("@{http://www.spiritconsortium.org/XMLSchema/SPIRIT/1685-2009}order", _) => __obj.spiritorder foreach { x => attr = scala.xml.Attribute(__scope.getPrefix("http://www.spiritconsortium.org/XMLSchema/SPIRIT/1685-2009"), "order", x.toString, attr) }
        case ("@{http://www.spiritconsortium.org/XMLSchema/SPIRIT/1685-2009}configGroups", _) => __obj.spiritconfigGroups foreach { x => attr = scala.xml.Attribute(__scope.getPrefix("http://www.spiritconsortium.org/XMLSchema/SPIRIT/1685-2009"), "configGroups", x.toString, attr) }
        case ("@{http://www.spiritconsortium.org/XMLSchema/SPIRIT/1685-2009}bitStringLength", _) => __obj.spiritbitStringLength foreach { x => attr = scala.xml.Attribute(__scope.getPrefix("http://www.spiritconsortium.org/XMLSchema/SPIRIT/1685-2009"), "bitStringLength", x.toString, attr) }
        case ("@{http://www.spiritconsortium.org/XMLSchema/SPIRIT/1685-2009}minimum", _) => __obj.spiritminimum foreach { x => attr = scala.xml.Attribute(__scope.getPrefix("http://www.spiritconsortium.org/XMLSchema/SPIRIT/1685-2009"), "minimum", x.toString, attr) }
        case ("@{http://www.spiritconsortium.org/XMLSchema/SPIRIT/1685-2009}maximum", _) => __obj.spiritmaximum foreach { x => attr = scala.xml.Attribute(__scope.getPrefix("http://www.spiritconsortium.org/XMLSchema/SPIRIT/1685-2009"), "maximum", x.toString, attr) }
        case ("@{http://www.spiritconsortium.org/XMLSchema/SPIRIT/1685-2009}rangeType", _) => if (__obj.spiritrangeType.toString != "float") attr = scala.xml.Attribute(__scope.getPrefix("http://www.spiritconsortium.org/XMLSchema/SPIRIT/1685-2009"), "rangeType", __obj.spiritrangeType.toString, attr)
        case ("@{http://www.spiritconsortium.org/XMLSchema/SPIRIT/1685-2009}prompt", _) => if (__obj.spiritprompt.toString != "Base Address:") attr = scala.xml.Attribute(__scope.getPrefix("http://www.spiritconsortium.org/XMLSchema/SPIRIT/1685-2009"), "prompt", __obj.spiritprompt.toString, attr)
        case ("@state", _) => __obj.state foreach { x => attr = scala.xml.Attribute(__scope.getPrefix("http://www.spiritconsortium.org/XMLSchema/SPIRIT/1685-2009"), "state", x.toString, attr) }
        case (key, x) => attr = scala.xml.Attribute((x.namespace map { __scope.getPrefix(_) }).orNull, x.key.orNull, x.value.toString, attr)
      }
      attr
    }

    def writesChildNodes(__obj: RemapAddress, __scope: scala.xml.NamespaceBinding): Seq[scala.xml.Node] =
      Seq(scala.xml.Text(__obj.value.toString))

  }

  trait Default_RangeTypeFormat extends IPXACT2009scalaxb.XMLFormat[RangeType] with IPXACT2009scalaxb.CanWriteChildNodes[RangeType] {
    val targetNamespace: Option[String] = Some("http://www.spiritconsortium.org/XMLSchema/SPIRIT/1685-2009")
    def reads(seq: scala.xml.NodeSeq, stack: List[IPXACT2009scalaxb.ElemName]): Either[String, RangeType] = seq match {
      case node: scala.xml.Node => Right(RangeType(IPXACT2009scalaxb.fromXML[String](node, IPXACT2009scalaxb.ElemName(node) :: stack),
        scala.collection.immutable.ListMap(List(
        (node \ "@{http://www.spiritconsortium.org/XMLSchema/SPIRIT/1685-2009}format").headOption map { x => IPXACT2009scalaxb.DataRecord(x, node, IPXACT2009scalaxb.fromXML[FormatType](x, IPXACT2009scalaxb.ElemName(node) :: stack)) } orElse Some(IPXACT2009scalaxb.DataRecord(None, None, IPXACT2009scalaxb.fromXML[FormatType](scala.xml.Text("long"), IPXACT2009scalaxb.ElemName(node) :: stack))) map { "@{http://www.spiritconsortium.org/XMLSchema/SPIRIT/1685-2009}format" -> _ },
        (node \ "@{http://www.spiritconsortium.org/XMLSchema/SPIRIT/1685-2009}resolve").headOption map { x => IPXACT2009scalaxb.DataRecord(x, node, IPXACT2009scalaxb.fromXML[ResolveType](x, IPXACT2009scalaxb.ElemName(node) :: stack)) } map { "@{http://www.spiritconsortium.org/XMLSchema/SPIRIT/1685-2009}resolve" -> _ },
        (node \ "@{http://www.spiritconsortium.org/XMLSchema/SPIRIT/1685-2009}id").headOption map { x => IPXACT2009scalaxb.DataRecord(x, node, IPXACT2009scalaxb.fromXML[String](x, IPXACT2009scalaxb.ElemName(node) :: stack)) } map { "@{http://www.spiritconsortium.org/XMLSchema/SPIRIT/1685-2009}id" -> _ },
        (node \ "@{http://www.spiritconsortium.org/XMLSchema/SPIRIT/1685-2009}dependency").headOption map { x => IPXACT2009scalaxb.DataRecord(x, node, IPXACT2009scalaxb.fromXML[String](x, IPXACT2009scalaxb.ElemName(node) :: stack)) } map { "@{http://www.spiritconsortium.org/XMLSchema/SPIRIT/1685-2009}dependency" -> _ },
        (node \ "@{http://www.spiritconsortium.org/XMLSchema/SPIRIT/1685-2009}choiceRef").headOption map { x => IPXACT2009scalaxb.DataRecord(x, node, IPXACT2009scalaxb.fromXML[String](x, IPXACT2009scalaxb.ElemName(node) :: stack)) } map { "@{http://www.spiritconsortium.org/XMLSchema/SPIRIT/1685-2009}choiceRef" -> _ },
        (node \ "@{http://www.spiritconsortium.org/XMLSchema/SPIRIT/1685-2009}order").headOption map { x => IPXACT2009scalaxb.DataRecord(x, node, IPXACT2009scalaxb.fromXML[Float](x, IPXACT2009scalaxb.ElemName(node) :: stack)) } map { "@{http://www.spiritconsortium.org/XMLSchema/SPIRIT/1685-2009}order" -> _ },
        (node \ "@{http://www.spiritconsortium.org/XMLSchema/SPIRIT/1685-2009}configGroups").headOption map { x => IPXACT2009scalaxb.DataRecord(x, node, IPXACT2009scalaxb.fromXML[Seq[String]](x, IPXACT2009scalaxb.ElemName(node) :: stack)) } map { "@{http://www.spiritconsortium.org/XMLSchema/SPIRIT/1685-2009}configGroups" -> _ },
        (node \ "@{http://www.spiritconsortium.org/XMLSchema/SPIRIT/1685-2009}bitStringLength").headOption map { x => IPXACT2009scalaxb.DataRecord(x, node, IPXACT2009scalaxb.fromXML[BigInt](x, IPXACT2009scalaxb.ElemName(node) :: stack)) } map { "@{http://www.spiritconsortium.org/XMLSchema/SPIRIT/1685-2009}bitStringLength" -> _ },
        (node \ "@{http://www.spiritconsortium.org/XMLSchema/SPIRIT/1685-2009}minimum").headOption map { x => IPXACT2009scalaxb.DataRecord(x, node, IPXACT2009scalaxb.fromXML[String](x, IPXACT2009scalaxb.ElemName(node) :: stack)) } map { "@{http://www.spiritconsortium.org/XMLSchema/SPIRIT/1685-2009}minimum" -> _ },
        (node \ "@{http://www.spiritconsortium.org/XMLSchema/SPIRIT/1685-2009}maximum").headOption map { x => IPXACT2009scalaxb.DataRecord(x, node, IPXACT2009scalaxb.fromXML[String](x, IPXACT2009scalaxb.ElemName(node) :: stack)) } map { "@{http://www.spiritconsortium.org/XMLSchema/SPIRIT/1685-2009}maximum" -> _ },
        (node \ "@{http://www.spiritconsortium.org/XMLSchema/SPIRIT/1685-2009}rangeType").headOption map { x => IPXACT2009scalaxb.DataRecord(x, node, IPXACT2009scalaxb.fromXML[RangeTypeType](x, IPXACT2009scalaxb.ElemName(node) :: stack)) } orElse Some(IPXACT2009scalaxb.DataRecord(None, None, IPXACT2009scalaxb.fromXML[RangeTypeType](scala.xml.Text("float"), IPXACT2009scalaxb.ElemName(node) :: stack))) map { "@{http://www.spiritconsortium.org/XMLSchema/SPIRIT/1685-2009}rangeType" -> _ },
        (node \ "@{http://www.spiritconsortium.org/XMLSchema/SPIRIT/1685-2009}prompt").headOption map { x => IPXACT2009scalaxb.DataRecord(x, node, IPXACT2009scalaxb.fromXML[String](x, IPXACT2009scalaxb.ElemName(node) :: stack)) } map { "@{http://www.spiritconsortium.org/XMLSchema/SPIRIT/1685-2009}prompt" -> _ }
        ).flatten[(String, IPXACT2009scalaxb.DataRecord[Any])] ::: (node match {
          case elem: scala.xml.Elem =>
            elem.attributes.toList flatMap {
              case scala.xml.PrefixedAttribute(pre, key, value, _) if pre == elem.scope.getPrefix("http://www.spiritconsortium.org/XMLSchema/SPIRIT/1685-2009") &&
                key == "format" => Nil
              case scala.xml.PrefixedAttribute(pre, key, value, _) if pre == elem.scope.getPrefix("http://www.spiritconsortium.org/XMLSchema/SPIRIT/1685-2009") &&
                key == "resolve" => Nil
              case scala.xml.PrefixedAttribute(pre, key, value, _) if pre == elem.scope.getPrefix("http://www.spiritconsortium.org/XMLSchema/SPIRIT/1685-2009") &&
                key == "id" => Nil
              case scala.xml.PrefixedAttribute(pre, key, value, _) if pre == elem.scope.getPrefix("http://www.spiritconsortium.org/XMLSchema/SPIRIT/1685-2009") &&
                key == "dependency" => Nil
              case scala.xml.PrefixedAttribute(pre, key, value, _) if pre == elem.scope.getPrefix("http://www.spiritconsortium.org/XMLSchema/SPIRIT/1685-2009") &&
                key == "choiceRef" => Nil
              case scala.xml.PrefixedAttribute(pre, key, value, _) if pre == elem.scope.getPrefix("http://www.spiritconsortium.org/XMLSchema/SPIRIT/1685-2009") &&
                key == "order" => Nil
              case scala.xml.PrefixedAttribute(pre, key, value, _) if pre == elem.scope.getPrefix("http://www.spiritconsortium.org/XMLSchema/SPIRIT/1685-2009") &&
                key == "configGroups" => Nil
              case scala.xml.PrefixedAttribute(pre, key, value, _) if pre == elem.scope.getPrefix("http://www.spiritconsortium.org/XMLSchema/SPIRIT/1685-2009") &&
                key == "bitStringLength" => Nil
              case scala.xml.PrefixedAttribute(pre, key, value, _) if pre == elem.scope.getPrefix("http://www.spiritconsortium.org/XMLSchema/SPIRIT/1685-2009") &&
                key == "minimum" => Nil
              case scala.xml.PrefixedAttribute(pre, key, value, _) if pre == elem.scope.getPrefix("http://www.spiritconsortium.org/XMLSchema/SPIRIT/1685-2009") &&
                key == "maximum" => Nil
              case scala.xml.PrefixedAttribute(pre, key, value, _) if pre == elem.scope.getPrefix("http://www.spiritconsortium.org/XMLSchema/SPIRIT/1685-2009") &&
                key == "rangeType" => Nil
              case scala.xml.PrefixedAttribute(pre, key, value, _) if pre == elem.scope.getPrefix("http://www.spiritconsortium.org/XMLSchema/SPIRIT/1685-2009") &&
                key == "prompt" => Nil
              case scala.xml.UnprefixedAttribute(key, value, _) =>
                List(("@" + key, IPXACT2009scalaxb.DataRecord(None, Some(key), value.text)))
              case scala.xml.PrefixedAttribute(pre, key, value, _) =>
                val ns = elem.scope.getURI(pre)
                List(("@{" + ns + "}" + key, IPXACT2009scalaxb.DataRecord(Option[String](ns), Some(key), value.text)))
              case _ => Nil
            }
          case _ => Nil
        }): _*)))
      case _ => Left("reads failed: seq must be scala.xml.Node")
    }
    
    override def writesAttribute(__obj: RangeType, __scope: scala.xml.NamespaceBinding): scala.xml.MetaData = {
      var attr: scala.xml.MetaData  = scala.xml.Null
      __obj.attributes.toList map {
        case ("@{http://www.spiritconsortium.org/XMLSchema/SPIRIT/1685-2009}format", _) => if (__obj.spiritformat.toString != "long") attr = scala.xml.Attribute(__scope.getPrefix("http://www.spiritconsortium.org/XMLSchema/SPIRIT/1685-2009"), "format", __obj.spiritformat.toString, attr)
        case ("@{http://www.spiritconsortium.org/XMLSchema/SPIRIT/1685-2009}resolve", _) => __obj.spiritresolve foreach { x => attr = scala.xml.Attribute(__scope.getPrefix("http://www.spiritconsortium.org/XMLSchema/SPIRIT/1685-2009"), "resolve", x.toString, attr) }
        case ("@{http://www.spiritconsortium.org/XMLSchema/SPIRIT/1685-2009}id", _) => __obj.spiritid foreach { x => attr = scala.xml.Attribute(__scope.getPrefix("http://www.spiritconsortium.org/XMLSchema/SPIRIT/1685-2009"), "id", x.toString, attr) }
        case ("@{http://www.spiritconsortium.org/XMLSchema/SPIRIT/1685-2009}dependency", _) => __obj.spiritdependency foreach { x => attr = scala.xml.Attribute(__scope.getPrefix("http://www.spiritconsortium.org/XMLSchema/SPIRIT/1685-2009"), "dependency", x.toString, attr) }
        case ("@{http://www.spiritconsortium.org/XMLSchema/SPIRIT/1685-2009}choiceRef", _) => __obj.spiritchoiceRef foreach { x => attr = scala.xml.Attribute(__scope.getPrefix("http://www.spiritconsortium.org/XMLSchema/SPIRIT/1685-2009"), "choiceRef", x.toString, attr) }
        case ("@{http://www.spiritconsortium.org/XMLSchema/SPIRIT/1685-2009}order", _) => __obj.spiritorder foreach { x => attr = scala.xml.Attribute(__scope.getPrefix("http://www.spiritconsortium.org/XMLSchema/SPIRIT/1685-2009"), "order", x.toString, attr) }
        case ("@{http://www.spiritconsortium.org/XMLSchema/SPIRIT/1685-2009}configGroups", _) => __obj.spiritconfigGroups foreach { x => attr = scala.xml.Attribute(__scope.getPrefix("http://www.spiritconsortium.org/XMLSchema/SPIRIT/1685-2009"), "configGroups", x.toString, attr) }
        case ("@{http://www.spiritconsortium.org/XMLSchema/SPIRIT/1685-2009}bitStringLength", _) => __obj.spiritbitStringLength foreach { x => attr = scala.xml.Attribute(__scope.getPrefix("http://www.spiritconsortium.org/XMLSchema/SPIRIT/1685-2009"), "bitStringLength", x.toString, attr) }
        case ("@{http://www.spiritconsortium.org/XMLSchema/SPIRIT/1685-2009}minimum", _) => __obj.spiritminimum foreach { x => attr = scala.xml.Attribute(__scope.getPrefix("http://www.spiritconsortium.org/XMLSchema/SPIRIT/1685-2009"), "minimum", x.toString, attr) }
        case ("@{http://www.spiritconsortium.org/XMLSchema/SPIRIT/1685-2009}maximum", _) => __obj.spiritmaximum foreach { x => attr = scala.xml.Attribute(__scope.getPrefix("http://www.spiritconsortium.org/XMLSchema/SPIRIT/1685-2009"), "maximum", x.toString, attr) }
        case ("@{http://www.spiritconsortium.org/XMLSchema/SPIRIT/1685-2009}rangeType", _) => if (__obj.spiritrangeType.toString != "float") attr = scala.xml.Attribute(__scope.getPrefix("http://www.spiritconsortium.org/XMLSchema/SPIRIT/1685-2009"), "rangeType", __obj.spiritrangeType.toString, attr)
        case ("@{http://www.spiritconsortium.org/XMLSchema/SPIRIT/1685-2009}prompt", _) => __obj.spiritprompt foreach { x => attr = scala.xml.Attribute(__scope.getPrefix("http://www.spiritconsortium.org/XMLSchema/SPIRIT/1685-2009"), "prompt", x.toString, attr) }
        case (key, x) => attr = scala.xml.Attribute((x.namespace map { __scope.getPrefix(_) }).orNull, x.key.orNull, x.value.toString, attr)
      }
      attr
    }

    def writesChildNodes(__obj: RangeType, __scope: scala.xml.NamespaceBinding): Seq[scala.xml.Node] =
      Seq(scala.xml.Text(__obj.value.toString))

  }

  trait Default_BaseAddressesFormat extends IPXACT2009scalaxb.ElemNameParser[BaseAddresses] {
    val targetNamespace: Option[String] = Some("http://www.spiritconsortium.org/XMLSchema/SPIRIT/1685-2009")
    
    def parser(node: scala.xml.Node, stack: List[IPXACT2009scalaxb.ElemName]): Parser[BaseAddresses] =
      phrase(safeRep(IPXACT2009scalaxb.ElemName(Some("http://www.spiritconsortium.org/XMLSchema/SPIRIT/1685-2009"), "remapAddress")) ~
      (IPXACT2009scalaxb.ElemName(Some("http://www.spiritconsortium.org/XMLSchema/SPIRIT/1685-2009"), "range")) ^^
      { case p1 ~ p2 =>
      BaseAddresses(p1 map { IPXACT2009scalaxb.fromXML[RemapAddress](_, IPXACT2009scalaxb.ElemName(node) :: stack) },
        IPXACT2009scalaxb.fromXML[RangeType](p2, IPXACT2009scalaxb.ElemName(node) :: stack)) })
    
    def writesChildNodes(__obj: BaseAddresses, __scope: scala.xml.NamespaceBinding): Seq[scala.xml.Node] =
      Seq.concat(__obj.remapAddress flatMap { IPXACT2009scalaxb.toXML[RemapAddress](_, Some("http://www.spiritconsortium.org/XMLSchema/SPIRIT/1685-2009"), Some("remapAddress"), __scope, false) },
        IPXACT2009scalaxb.toXML[RangeType](__obj.range, Some("http://www.spiritconsortium.org/XMLSchema/SPIRIT/1685-2009"), Some("range"), __scope, false))

  }

  trait Default_MirroredSlaveFormat extends IPXACT2009scalaxb.ElemNameParser[MirroredSlave] {
    val targetNamespace: Option[String] = Some("http://www.spiritconsortium.org/XMLSchema/SPIRIT/1685-2009")
    
    def parser(node: scala.xml.Node, stack: List[IPXACT2009scalaxb.ElemName]): Parser[MirroredSlave] =
      phrase(opt((opt(IPXACT2009scalaxb.ElemName(Some("http://www.spiritconsortium.org/XMLSchema/SPIRIT/1685-2009"), "baseAddresses"))) ^^
        { case p1 => MirroredSlaveSequence1(p1.headOption map { IPXACT2009scalaxb.fromXML[BaseAddresses](_, IPXACT2009scalaxb.ElemName(node) :: stack) }) }) ^^
      { case p1 =>
      MirroredSlave(p1) })
    
    def writesChildNodes(__obj: MirroredSlave, __scope: scala.xml.NamespaceBinding): Seq[scala.xml.Node] =
      (__obj.mirroredslavesequence1 map { IPXACT2009scalaxb.toXML[MirroredSlaveSequence1](_, None, Some("mirroredslavesequence1"), __scope, false) } getOrElse {Nil})
  }

  trait Default_MirroredSlaveSequence1Format extends IPXACT2009scalaxb.XMLFormat[MirroredSlaveSequence1] {
    def reads(seq: scala.xml.NodeSeq, stack: List[IPXACT2009scalaxb.ElemName]): Either[String, MirroredSlaveSequence1] = Left("don't call me.")
    
    def writes(__obj: MirroredSlaveSequence1, __namespace: Option[String], __elementLabel: Option[String], 
        __scope: scala.xml.NamespaceBinding, __typeAttribute: Boolean): scala.xml.NodeSeq =
      __obj.baseAddresses map { IPXACT2009scalaxb.toXML[BaseAddresses](_, Some("http://www.spiritconsortium.org/XMLSchema/SPIRIT/1685-2009"), Some("baseAddresses"), __scope, false) } getOrElse {Nil}

  }
  trait Default_MirroredMasterFormat extends IPXACT2009scalaxb.XMLFormat[MirroredMaster] with IPXACT2009scalaxb.CanWriteChildNodes[MirroredMaster] {
    val targetNamespace: Option[String] = Some("http://www.spiritconsortium.org/XMLSchema/SPIRIT/1685-2009")
    def reads(seq: scala.xml.NodeSeq, stack: List[IPXACT2009scalaxb.ElemName]): Either[String, MirroredMaster] = seq match {
      case node: scala.xml.Node => Right(MirroredMaster())
      case _ => Left("reads failed: seq must be scala.xml.Node")
    }
    
    def writesChildNodes(__obj: MirroredMaster, __scope: scala.xml.NamespaceBinding): Seq[scala.xml.Node] =
      Nil

  }
  trait Default_MirroredSystemFormat extends IPXACT2009scalaxb.ElemNameParser[MirroredSystem] {
    val targetNamespace: Option[String] = Some("http://www.spiritconsortium.org/XMLSchema/SPIRIT/1685-2009")
    
    def parser(node: scala.xml.Node, stack: List[IPXACT2009scalaxb.ElemName]): Parser[MirroredSystem] =
      phrase((IPXACT2009scalaxb.ElemName(Some("http://www.spiritconsortium.org/XMLSchema/SPIRIT/1685-2009"), "group")) ^^
      { case p1 =>
      MirroredSystem(IPXACT2009scalaxb.fromXML[String](p1, IPXACT2009scalaxb.ElemName(node) :: stack)) })
    
    def writesChildNodes(__obj: MirroredSystem, __scope: scala.xml.NamespaceBinding): Seq[scala.xml.Node] =
      (IPXACT2009scalaxb.toXML[String](__obj.group, Some("http://www.spiritconsortium.org/XMLSchema/SPIRIT/1685-2009"), Some("group"), __scope, false))
  }
  def build_InterfaceModeFormat = new Default_InterfaceModeFormat {}
  trait Default_InterfaceModeFormat extends IPXACT2009scalaxb.XMLFormat[InterfaceMode] {
    val targetNamespace: Option[String] = Some("http://www.spiritconsortium.org/XMLSchema/SPIRIT/1685-2009")
    
    def fromString(value: String, scope: scala.xml.NamespaceBinding): InterfaceMode =
        (fromString0(value, scope)).apply(IPXACT2009scalaxb.fromXML[String](scala.xml.Text(value)))

    private def fromString0(value: String, scope: scala.xml.NamespaceBinding): PartialFunction[Any, InterfaceMode] = {
      case x: String if x == IPXACT2009scalaxb.fromXML[String](scala.xml.Text("master")) => MasterValue2
      case x: String if x == IPXACT2009scalaxb.fromXML[String](scala.xml.Text("slave")) => SlaveValue2
      case x: String if x == IPXACT2009scalaxb.fromXML[String](scala.xml.Text("system")) => SystemValue2
      case x: String if x == IPXACT2009scalaxb.fromXML[String](scala.xml.Text("mirroredMaster")) => MirroredMasterValue
      case x: String if x == IPXACT2009scalaxb.fromXML[String](scala.xml.Text("mirroredSlave")) => MirroredSlaveValue
      case x: String if x == IPXACT2009scalaxb.fromXML[String](scala.xml.Text("mirroredSystem")) => MirroredSystemValue

    }



    def reads(seq: scala.xml.NodeSeq, stack: List[IPXACT2009scalaxb.ElemName]): Either[String, InterfaceMode] = seq match {
      case elem: scala.xml.Elem => Right(fromString(elem.text, elem.scope))
      case _ => Right(fromString(seq.text, scala.xml.TopScope))
    }
    
    def writes(__obj: InterfaceMode, __namespace: Option[String], __elementLabel: Option[String],
        __scope: scala.xml.NamespaceBinding, __typeAttribute: Boolean): scala.xml.NodeSeq =
      scala.xml.Elem(IPXACT2009scalaxb.Helper.getPrefix(__namespace, __scope).orNull,
        __elementLabel getOrElse { sys.error("missing element label.") },
        scala.xml.Null, __scope, true, scala.xml.Text(__obj.toString))
  }
  trait Default_MonitorFormat extends IPXACT2009scalaxb.ElemNameParser[Monitor] {
    val targetNamespace: Option[String] = Some("http://www.spiritconsortium.org/XMLSchema/SPIRIT/1685-2009")
    
    def parser(node: scala.xml.Node, stack: List[IPXACT2009scalaxb.ElemName]): Parser[Monitor] =
      phrase(opt(IPXACT2009scalaxb.ElemName(Some("http://www.spiritconsortium.org/XMLSchema/SPIRIT/1685-2009"), "group")) ^^
      { case p1 =>
      Monitor(p1.headOption map { IPXACT2009scalaxb.fromXML[String](_, IPXACT2009scalaxb.ElemName(node) :: stack) },
        scala.collection.immutable.ListMap(List(
        (node \ "@{http://www.spiritconsortium.org/XMLSchema/SPIRIT/1685-2009}interfaceMode").headOption map { x => IPXACT2009scalaxb.DataRecord(x, node, IPXACT2009scalaxb.fromXML[InterfaceMode](x, IPXACT2009scalaxb.ElemName(node) :: stack)) } map { "@interfaceMode" -> _ }
        ).flatten[(String, IPXACT2009scalaxb.DataRecord[Any])]: _*)) })
    
    override def writesAttribute(__obj: Monitor, __scope: scala.xml.NamespaceBinding): scala.xml.MetaData = {
      var attr: scala.xml.MetaData  = scala.xml.Null
      __obj.attributes.toList map {
        case ("@interfaceMode", _) => attr = scala.xml.Attribute(__scope.getPrefix("http://www.spiritconsortium.org/XMLSchema/SPIRIT/1685-2009"), "interfaceMode", __obj.interfaceMode.toString, attr)
        case (key, x) => attr = scala.xml.Attribute((x.namespace map { __scope.getPrefix(_) }).orNull, x.key.orNull, x.value.toString, attr)
      }
      attr
    }

    def writesChildNodes(__obj: Monitor, __scope: scala.xml.NamespaceBinding): Seq[scala.xml.Node] =
      (__obj.group map { IPXACT2009scalaxb.toXML[String](_, Some("http://www.spiritconsortium.org/XMLSchema/SPIRIT/1685-2009"), Some("group"), __scope, false) } getOrElse {Nil})
  }

  trait Default_Master2Format extends IPXACT2009scalaxb.XMLFormat[Master2] with IPXACT2009scalaxb.CanWriteChildNodes[Master2] {
    val targetNamespace: Option[String] = Some("http://www.spiritconsortium.org/XMLSchema/SPIRIT/1685-2009")
    def reads(seq: scala.xml.NodeSeq, stack: List[IPXACT2009scalaxb.ElemName]): Either[String, Master2] = seq match {
      case node: scala.xml.Node => Right(Master2())
      case _ => Left("reads failed: seq must be scala.xml.Node")
    }
    
    def writesChildNodes(__obj: Master2, __scope: scala.xml.NamespaceBinding): Seq[scala.xml.Node] =
      Nil

  }
  trait Default_Slave2Format extends IPXACT2009scalaxb.XMLFormat[Slave2] with IPXACT2009scalaxb.CanWriteChildNodes[Slave2] {
    val targetNamespace: Option[String] = Some("http://www.spiritconsortium.org/XMLSchema/SPIRIT/1685-2009")
    def reads(seq: scala.xml.NodeSeq, stack: List[IPXACT2009scalaxb.ElemName]): Either[String, Slave2] = seq match {
      case node: scala.xml.Node => Right(Slave2())
      case _ => Left("reads failed: seq must be scala.xml.Node")
    }
    
    def writesChildNodes(__obj: Slave2, __scope: scala.xml.NamespaceBinding): Seq[scala.xml.Node] =
      Nil

  }
  trait Default_System2Format extends IPXACT2009scalaxb.ElemNameParser[System2] {
    val targetNamespace: Option[String] = Some("http://www.spiritconsortium.org/XMLSchema/SPIRIT/1685-2009")
    
    def parser(node: scala.xml.Node, stack: List[IPXACT2009scalaxb.ElemName]): Parser[System2] =
      phrase((IPXACT2009scalaxb.ElemName(Some("http://www.spiritconsortium.org/XMLSchema/SPIRIT/1685-2009"), "group")) ^^
      { case p1 =>
      System2(IPXACT2009scalaxb.fromXML[String](p1, IPXACT2009scalaxb.ElemName(node) :: stack)) })
    
    def writesChildNodes(__obj: System2, __scope: scala.xml.NamespaceBinding): Seq[scala.xml.Node] =
      (IPXACT2009scalaxb.toXML[String](__obj.group, Some("http://www.spiritconsortium.org/XMLSchema/SPIRIT/1685-2009"), Some("group"), __scope, false))
  }
  trait Default_MirroredSlave2Format extends IPXACT2009scalaxb.XMLFormat[MirroredSlave2] with IPXACT2009scalaxb.CanWriteChildNodes[MirroredSlave2] {
    val targetNamespace: Option[String] = Some("http://www.spiritconsortium.org/XMLSchema/SPIRIT/1685-2009")
    def reads(seq: scala.xml.NodeSeq, stack: List[IPXACT2009scalaxb.ElemName]): Either[String, MirroredSlave2] = seq match {
      case node: scala.xml.Node => Right(MirroredSlave2())
      case _ => Left("reads failed: seq must be scala.xml.Node")
    }
    
    def writesChildNodes(__obj: MirroredSlave2, __scope: scala.xml.NamespaceBinding): Seq[scala.xml.Node] =
      Nil

  }
  trait Default_MirroredMaster2Format extends IPXACT2009scalaxb.XMLFormat[MirroredMaster2] with IPXACT2009scalaxb.CanWriteChildNodes[MirroredMaster2] {
    val targetNamespace: Option[String] = Some("http://www.spiritconsortium.org/XMLSchema/SPIRIT/1685-2009")
    def reads(seq: scala.xml.NodeSeq, stack: List[IPXACT2009scalaxb.ElemName]): Either[String, MirroredMaster2] = seq match {
      case node: scala.xml.Node => Right(MirroredMaster2())
      case _ => Left("reads failed: seq must be scala.xml.Node")
    }
    
    def writesChildNodes(__obj: MirroredMaster2, __scope: scala.xml.NamespaceBinding): Seq[scala.xml.Node] =
      Nil

  }
  trait Default_MirroredSystem2Format extends IPXACT2009scalaxb.ElemNameParser[MirroredSystem2] {
    val targetNamespace: Option[String] = Some("http://www.spiritconsortium.org/XMLSchema/SPIRIT/1685-2009")
    
    def parser(node: scala.xml.Node, stack: List[IPXACT2009scalaxb.ElemName]): Parser[MirroredSystem2] =
      phrase((IPXACT2009scalaxb.ElemName(Some("http://www.spiritconsortium.org/XMLSchema/SPIRIT/1685-2009"), "group")) ^^
      { case p1 =>
      MirroredSystem2(IPXACT2009scalaxb.fromXML[String](p1, IPXACT2009scalaxb.ElemName(node) :: stack)) })
    
    def writesChildNodes(__obj: MirroredSystem2, __scope: scala.xml.NamespaceBinding): Seq[scala.xml.Node] =
      (IPXACT2009scalaxb.toXML[String](__obj.group, Some("http://www.spiritconsortium.org/XMLSchema/SPIRIT/1685-2009"), Some("group"), __scope, false))
  }
  trait Default_LeftType2Format extends IPXACT2009scalaxb.XMLFormat[LeftType2] with IPXACT2009scalaxb.CanWriteChildNodes[LeftType2] {
    val targetNamespace: Option[String] = Some("http://www.spiritconsortium.org/XMLSchema/SPIRIT/1685-2009")
    def reads(seq: scala.xml.NodeSeq, stack: List[IPXACT2009scalaxb.ElemName]): Either[String, LeftType2] = seq match {
      case node: scala.xml.Node => Right(LeftType2(IPXACT2009scalaxb.fromXML[BigInt](node, IPXACT2009scalaxb.ElemName(node) :: stack),
        scala.collection.immutable.ListMap(List(
        (node \ "@{http://www.spiritconsortium.org/XMLSchema/SPIRIT/1685-2009}format").headOption map { x => IPXACT2009scalaxb.DataRecord(x, node, IPXACT2009scalaxb.fromXML[FormatType](x, IPXACT2009scalaxb.ElemName(node) :: stack)) } orElse Some(IPXACT2009scalaxb.DataRecord(None, None, IPXACT2009scalaxb.fromXML[FormatType](scala.xml.Text("long"), IPXACT2009scalaxb.ElemName(node) :: stack))) map { "@{http://www.spiritconsortium.org/XMLSchema/SPIRIT/1685-2009}format" -> _ },
        (node \ "@{http://www.spiritconsortium.org/XMLSchema/SPIRIT/1685-2009}resolve").headOption map { x => IPXACT2009scalaxb.DataRecord(x, node, IPXACT2009scalaxb.fromXML[ResolveType](x, IPXACT2009scalaxb.ElemName(node) :: stack)) } map { "@{http://www.spiritconsortium.org/XMLSchema/SPIRIT/1685-2009}resolve" -> _ },
        (node \ "@{http://www.spiritconsortium.org/XMLSchema/SPIRIT/1685-2009}id").headOption map { x => IPXACT2009scalaxb.DataRecord(x, node, IPXACT2009scalaxb.fromXML[String](x, IPXACT2009scalaxb.ElemName(node) :: stack)) } map { "@{http://www.spiritconsortium.org/XMLSchema/SPIRIT/1685-2009}id" -> _ },
        (node \ "@{http://www.spiritconsortium.org/XMLSchema/SPIRIT/1685-2009}dependency").headOption map { x => IPXACT2009scalaxb.DataRecord(x, node, IPXACT2009scalaxb.fromXML[String](x, IPXACT2009scalaxb.ElemName(node) :: stack)) } map { "@{http://www.spiritconsortium.org/XMLSchema/SPIRIT/1685-2009}dependency" -> _ },
        (node \ "@{http://www.spiritconsortium.org/XMLSchema/SPIRIT/1685-2009}choiceRef").headOption map { x => IPXACT2009scalaxb.DataRecord(x, node, IPXACT2009scalaxb.fromXML[String](x, IPXACT2009scalaxb.ElemName(node) :: stack)) } map { "@{http://www.spiritconsortium.org/XMLSchema/SPIRIT/1685-2009}choiceRef" -> _ },
        (node \ "@{http://www.spiritconsortium.org/XMLSchema/SPIRIT/1685-2009}order").headOption map { x => IPXACT2009scalaxb.DataRecord(x, node, IPXACT2009scalaxb.fromXML[Float](x, IPXACT2009scalaxb.ElemName(node) :: stack)) } map { "@{http://www.spiritconsortium.org/XMLSchema/SPIRIT/1685-2009}order" -> _ },
        (node \ "@{http://www.spiritconsortium.org/XMLSchema/SPIRIT/1685-2009}configGroups").headOption map { x => IPXACT2009scalaxb.DataRecord(x, node, IPXACT2009scalaxb.fromXML[Seq[String]](x, IPXACT2009scalaxb.ElemName(node) :: stack)) } map { "@{http://www.spiritconsortium.org/XMLSchema/SPIRIT/1685-2009}configGroups" -> _ },
        (node \ "@{http://www.spiritconsortium.org/XMLSchema/SPIRIT/1685-2009}bitStringLength").headOption map { x => IPXACT2009scalaxb.DataRecord(x, node, IPXACT2009scalaxb.fromXML[BigInt](x, IPXACT2009scalaxb.ElemName(node) :: stack)) } map { "@{http://www.spiritconsortium.org/XMLSchema/SPIRIT/1685-2009}bitStringLength" -> _ },
        (node \ "@{http://www.spiritconsortium.org/XMLSchema/SPIRIT/1685-2009}minimum").headOption map { x => IPXACT2009scalaxb.DataRecord(x, node, IPXACT2009scalaxb.fromXML[String](x, IPXACT2009scalaxb.ElemName(node) :: stack)) } map { "@{http://www.spiritconsortium.org/XMLSchema/SPIRIT/1685-2009}minimum" -> _ },
        (node \ "@{http://www.spiritconsortium.org/XMLSchema/SPIRIT/1685-2009}maximum").headOption map { x => IPXACT2009scalaxb.DataRecord(x, node, IPXACT2009scalaxb.fromXML[String](x, IPXACT2009scalaxb.ElemName(node) :: stack)) } map { "@{http://www.spiritconsortium.org/XMLSchema/SPIRIT/1685-2009}maximum" -> _ },
        (node \ "@{http://www.spiritconsortium.org/XMLSchema/SPIRIT/1685-2009}rangeType").headOption map { x => IPXACT2009scalaxb.DataRecord(x, node, IPXACT2009scalaxb.fromXML[RangeTypeType](x, IPXACT2009scalaxb.ElemName(node) :: stack)) } orElse Some(IPXACT2009scalaxb.DataRecord(None, None, IPXACT2009scalaxb.fromXML[RangeTypeType](scala.xml.Text("float"), IPXACT2009scalaxb.ElemName(node) :: stack))) map { "@{http://www.spiritconsortium.org/XMLSchema/SPIRIT/1685-2009}rangeType" -> _ },
        (node \ "@{http://www.spiritconsortium.org/XMLSchema/SPIRIT/1685-2009}prompt").headOption map { x => IPXACT2009scalaxb.DataRecord(x, node, IPXACT2009scalaxb.fromXML[String](x, IPXACT2009scalaxb.ElemName(node) :: stack)) } map { "@{http://www.spiritconsortium.org/XMLSchema/SPIRIT/1685-2009}prompt" -> _ }
        ).flatten[(String, IPXACT2009scalaxb.DataRecord[Any])] ::: (node match {
          case elem: scala.xml.Elem =>
            elem.attributes.toList flatMap {
              case scala.xml.PrefixedAttribute(pre, key, value, _) if pre == elem.scope.getPrefix("http://www.spiritconsortium.org/XMLSchema/SPIRIT/1685-2009") &&
                key == "format" => Nil
              case scala.xml.PrefixedAttribute(pre, key, value, _) if pre == elem.scope.getPrefix("http://www.spiritconsortium.org/XMLSchema/SPIRIT/1685-2009") &&
                key == "resolve" => Nil
              case scala.xml.PrefixedAttribute(pre, key, value, _) if pre == elem.scope.getPrefix("http://www.spiritconsortium.org/XMLSchema/SPIRIT/1685-2009") &&
                key == "id" => Nil
              case scala.xml.PrefixedAttribute(pre, key, value, _) if pre == elem.scope.getPrefix("http://www.spiritconsortium.org/XMLSchema/SPIRIT/1685-2009") &&
                key == "dependency" => Nil
              case scala.xml.PrefixedAttribute(pre, key, value, _) if pre == elem.scope.getPrefix("http://www.spiritconsortium.org/XMLSchema/SPIRIT/1685-2009") &&
                key == "choiceRef" => Nil
              case scala.xml.PrefixedAttribute(pre, key, value, _) if pre == elem.scope.getPrefix("http://www.spiritconsortium.org/XMLSchema/SPIRIT/1685-2009") &&
                key == "order" => Nil
              case scala.xml.PrefixedAttribute(pre, key, value, _) if pre == elem.scope.getPrefix("http://www.spiritconsortium.org/XMLSchema/SPIRIT/1685-2009") &&
                key == "configGroups" => Nil
              case scala.xml.PrefixedAttribute(pre, key, value, _) if pre == elem.scope.getPrefix("http://www.spiritconsortium.org/XMLSchema/SPIRIT/1685-2009") &&
                key == "bitStringLength" => Nil
              case scala.xml.PrefixedAttribute(pre, key, value, _) if pre == elem.scope.getPrefix("http://www.spiritconsortium.org/XMLSchema/SPIRIT/1685-2009") &&
                key == "minimum" => Nil
              case scala.xml.PrefixedAttribute(pre, key, value, _) if pre == elem.scope.getPrefix("http://www.spiritconsortium.org/XMLSchema/SPIRIT/1685-2009") &&
                key == "maximum" => Nil
              case scala.xml.PrefixedAttribute(pre, key, value, _) if pre == elem.scope.getPrefix("http://www.spiritconsortium.org/XMLSchema/SPIRIT/1685-2009") &&
                key == "rangeType" => Nil
              case scala.xml.PrefixedAttribute(pre, key, value, _) if pre == elem.scope.getPrefix("http://www.spiritconsortium.org/XMLSchema/SPIRIT/1685-2009") &&
                key == "prompt" => Nil
              case scala.xml.UnprefixedAttribute(key, value, _) =>
                List(("@" + key, IPXACT2009scalaxb.DataRecord(None, Some(key), value.text)))
              case scala.xml.PrefixedAttribute(pre, key, value, _) =>
                val ns = elem.scope.getURI(pre)
                List(("@{" + ns + "}" + key, IPXACT2009scalaxb.DataRecord(Option[String](ns), Some(key), value.text)))
              case _ => Nil
            }
          case _ => Nil
        }): _*)))
      case _ => Left("reads failed: seq must be scala.xml.Node")
    }
    
    override def writesAttribute(__obj: LeftType2, __scope: scala.xml.NamespaceBinding): scala.xml.MetaData = {
      var attr: scala.xml.MetaData  = scala.xml.Null
      __obj.attributes.toList map {
        case ("@{http://www.spiritconsortium.org/XMLSchema/SPIRIT/1685-2009}format", _) => if (__obj.spiritformat.toString != "long") attr = scala.xml.Attribute(__scope.getPrefix("http://www.spiritconsortium.org/XMLSchema/SPIRIT/1685-2009"), "format", __obj.spiritformat.toString, attr)
        case ("@{http://www.spiritconsortium.org/XMLSchema/SPIRIT/1685-2009}resolve", _) => __obj.spiritresolve foreach { x => attr = scala.xml.Attribute(__scope.getPrefix("http://www.spiritconsortium.org/XMLSchema/SPIRIT/1685-2009"), "resolve", x.toString, attr) }
        case ("@{http://www.spiritconsortium.org/XMLSchema/SPIRIT/1685-2009}id", _) => __obj.spiritid foreach { x => attr = scala.xml.Attribute(__scope.getPrefix("http://www.spiritconsortium.org/XMLSchema/SPIRIT/1685-2009"), "id", x.toString, attr) }
        case ("@{http://www.spiritconsortium.org/XMLSchema/SPIRIT/1685-2009}dependency", _) => __obj.spiritdependency foreach { x => attr = scala.xml.Attribute(__scope.getPrefix("http://www.spiritconsortium.org/XMLSchema/SPIRIT/1685-2009"), "dependency", x.toString, attr) }
        case ("@{http://www.spiritconsortium.org/XMLSchema/SPIRIT/1685-2009}choiceRef", _) => __obj.spiritchoiceRef foreach { x => attr = scala.xml.Attribute(__scope.getPrefix("http://www.spiritconsortium.org/XMLSchema/SPIRIT/1685-2009"), "choiceRef", x.toString, attr) }
        case ("@{http://www.spiritconsortium.org/XMLSchema/SPIRIT/1685-2009}order", _) => __obj.spiritorder foreach { x => attr = scala.xml.Attribute(__scope.getPrefix("http://www.spiritconsortium.org/XMLSchema/SPIRIT/1685-2009"), "order", x.toString, attr) }
        case ("@{http://www.spiritconsortium.org/XMLSchema/SPIRIT/1685-2009}configGroups", _) => __obj.spiritconfigGroups foreach { x => attr = scala.xml.Attribute(__scope.getPrefix("http://www.spiritconsortium.org/XMLSchema/SPIRIT/1685-2009"), "configGroups", x.toString, attr) }
        case ("@{http://www.spiritconsortium.org/XMLSchema/SPIRIT/1685-2009}bitStringLength", _) => __obj.spiritbitStringLength foreach { x => attr = scala.xml.Attribute(__scope.getPrefix("http://www.spiritconsortium.org/XMLSchema/SPIRIT/1685-2009"), "bitStringLength", x.toString, attr) }
        case ("@{http://www.spiritconsortium.org/XMLSchema/SPIRIT/1685-2009}minimum", _) => __obj.spiritminimum foreach { x => attr = scala.xml.Attribute(__scope.getPrefix("http://www.spiritconsortium.org/XMLSchema/SPIRIT/1685-2009"), "minimum", x.toString, attr) }
        case ("@{http://www.spiritconsortium.org/XMLSchema/SPIRIT/1685-2009}maximum", _) => __obj.spiritmaximum foreach { x => attr = scala.xml.Attribute(__scope.getPrefix("http://www.spiritconsortium.org/XMLSchema/SPIRIT/1685-2009"), "maximum", x.toString, attr) }
        case ("@{http://www.spiritconsortium.org/XMLSchema/SPIRIT/1685-2009}rangeType", _) => if (__obj.spiritrangeType.toString != "float") attr = scala.xml.Attribute(__scope.getPrefix("http://www.spiritconsortium.org/XMLSchema/SPIRIT/1685-2009"), "rangeType", __obj.spiritrangeType.toString, attr)
        case ("@{http://www.spiritconsortium.org/XMLSchema/SPIRIT/1685-2009}prompt", _) => __obj.spiritprompt foreach { x => attr = scala.xml.Attribute(__scope.getPrefix("http://www.spiritconsortium.org/XMLSchema/SPIRIT/1685-2009"), "prompt", x.toString, attr) }
        case (key, x) => attr = scala.xml.Attribute((x.namespace map { __scope.getPrefix(_) }).orNull, x.key.orNull, x.value.toString, attr)
      }
      attr
    }

    def writesChildNodes(__obj: LeftType2, __scope: scala.xml.NamespaceBinding): Seq[scala.xml.Node] =
      Seq(scala.xml.Text(__obj.value.toString))

  }

  trait Default_RightType2Format extends IPXACT2009scalaxb.XMLFormat[RightType2] with IPXACT2009scalaxb.CanWriteChildNodes[RightType2] {
    val targetNamespace: Option[String] = Some("http://www.spiritconsortium.org/XMLSchema/SPIRIT/1685-2009")
    def reads(seq: scala.xml.NodeSeq, stack: List[IPXACT2009scalaxb.ElemName]): Either[String, RightType2] = seq match {
      case node: scala.xml.Node => Right(RightType2(IPXACT2009scalaxb.fromXML[BigInt](node, IPXACT2009scalaxb.ElemName(node) :: stack),
        scala.collection.immutable.ListMap(List(
        (node \ "@{http://www.spiritconsortium.org/XMLSchema/SPIRIT/1685-2009}format").headOption map { x => IPXACT2009scalaxb.DataRecord(x, node, IPXACT2009scalaxb.fromXML[FormatType](x, IPXACT2009scalaxb.ElemName(node) :: stack)) } orElse Some(IPXACT2009scalaxb.DataRecord(None, None, IPXACT2009scalaxb.fromXML[FormatType](scala.xml.Text("long"), IPXACT2009scalaxb.ElemName(node) :: stack))) map { "@{http://www.spiritconsortium.org/XMLSchema/SPIRIT/1685-2009}format" -> _ },
        (node \ "@{http://www.spiritconsortium.org/XMLSchema/SPIRIT/1685-2009}resolve").headOption map { x => IPXACT2009scalaxb.DataRecord(x, node, IPXACT2009scalaxb.fromXML[ResolveType](x, IPXACT2009scalaxb.ElemName(node) :: stack)) } map { "@{http://www.spiritconsortium.org/XMLSchema/SPIRIT/1685-2009}resolve" -> _ },
        (node \ "@{http://www.spiritconsortium.org/XMLSchema/SPIRIT/1685-2009}id").headOption map { x => IPXACT2009scalaxb.DataRecord(x, node, IPXACT2009scalaxb.fromXML[String](x, IPXACT2009scalaxb.ElemName(node) :: stack)) } map { "@{http://www.spiritconsortium.org/XMLSchema/SPIRIT/1685-2009}id" -> _ },
        (node \ "@{http://www.spiritconsortium.org/XMLSchema/SPIRIT/1685-2009}dependency").headOption map { x => IPXACT2009scalaxb.DataRecord(x, node, IPXACT2009scalaxb.fromXML[String](x, IPXACT2009scalaxb.ElemName(node) :: stack)) } map { "@{http://www.spiritconsortium.org/XMLSchema/SPIRIT/1685-2009}dependency" -> _ },
        (node \ "@{http://www.spiritconsortium.org/XMLSchema/SPIRIT/1685-2009}choiceRef").headOption map { x => IPXACT2009scalaxb.DataRecord(x, node, IPXACT2009scalaxb.fromXML[String](x, IPXACT2009scalaxb.ElemName(node) :: stack)) } map { "@{http://www.spiritconsortium.org/XMLSchema/SPIRIT/1685-2009}choiceRef" -> _ },
        (node \ "@{http://www.spiritconsortium.org/XMLSchema/SPIRIT/1685-2009}order").headOption map { x => IPXACT2009scalaxb.DataRecord(x, node, IPXACT2009scalaxb.fromXML[Float](x, IPXACT2009scalaxb.ElemName(node) :: stack)) } map { "@{http://www.spiritconsortium.org/XMLSchema/SPIRIT/1685-2009}order" -> _ },
        (node \ "@{http://www.spiritconsortium.org/XMLSchema/SPIRIT/1685-2009}configGroups").headOption map { x => IPXACT2009scalaxb.DataRecord(x, node, IPXACT2009scalaxb.fromXML[Seq[String]](x, IPXACT2009scalaxb.ElemName(node) :: stack)) } map { "@{http://www.spiritconsortium.org/XMLSchema/SPIRIT/1685-2009}configGroups" -> _ },
        (node \ "@{http://www.spiritconsortium.org/XMLSchema/SPIRIT/1685-2009}bitStringLength").headOption map { x => IPXACT2009scalaxb.DataRecord(x, node, IPXACT2009scalaxb.fromXML[BigInt](x, IPXACT2009scalaxb.ElemName(node) :: stack)) } map { "@{http://www.spiritconsortium.org/XMLSchema/SPIRIT/1685-2009}bitStringLength" -> _ },
        (node \ "@{http://www.spiritconsortium.org/XMLSchema/SPIRIT/1685-2009}minimum").headOption map { x => IPXACT2009scalaxb.DataRecord(x, node, IPXACT2009scalaxb.fromXML[String](x, IPXACT2009scalaxb.ElemName(node) :: stack)) } map { "@{http://www.spiritconsortium.org/XMLSchema/SPIRIT/1685-2009}minimum" -> _ },
        (node \ "@{http://www.spiritconsortium.org/XMLSchema/SPIRIT/1685-2009}maximum").headOption map { x => IPXACT2009scalaxb.DataRecord(x, node, IPXACT2009scalaxb.fromXML[String](x, IPXACT2009scalaxb.ElemName(node) :: stack)) } map { "@{http://www.spiritconsortium.org/XMLSchema/SPIRIT/1685-2009}maximum" -> _ },
        (node \ "@{http://www.spiritconsortium.org/XMLSchema/SPIRIT/1685-2009}rangeType").headOption map { x => IPXACT2009scalaxb.DataRecord(x, node, IPXACT2009scalaxb.fromXML[RangeTypeType](x, IPXACT2009scalaxb.ElemName(node) :: stack)) } orElse Some(IPXACT2009scalaxb.DataRecord(None, None, IPXACT2009scalaxb.fromXML[RangeTypeType](scala.xml.Text("float"), IPXACT2009scalaxb.ElemName(node) :: stack))) map { "@{http://www.spiritconsortium.org/XMLSchema/SPIRIT/1685-2009}rangeType" -> _ },
        (node \ "@{http://www.spiritconsortium.org/XMLSchema/SPIRIT/1685-2009}prompt").headOption map { x => IPXACT2009scalaxb.DataRecord(x, node, IPXACT2009scalaxb.fromXML[String](x, IPXACT2009scalaxb.ElemName(node) :: stack)) } map { "@{http://www.spiritconsortium.org/XMLSchema/SPIRIT/1685-2009}prompt" -> _ }
        ).flatten[(String, IPXACT2009scalaxb.DataRecord[Any])] ::: (node match {
          case elem: scala.xml.Elem =>
            elem.attributes.toList flatMap {
              case scala.xml.PrefixedAttribute(pre, key, value, _) if pre == elem.scope.getPrefix("http://www.spiritconsortium.org/XMLSchema/SPIRIT/1685-2009") &&
                key == "format" => Nil
              case scala.xml.PrefixedAttribute(pre, key, value, _) if pre == elem.scope.getPrefix("http://www.spiritconsortium.org/XMLSchema/SPIRIT/1685-2009") &&
                key == "resolve" => Nil
              case scala.xml.PrefixedAttribute(pre, key, value, _) if pre == elem.scope.getPrefix("http://www.spiritconsortium.org/XMLSchema/SPIRIT/1685-2009") &&
                key == "id" => Nil
              case scala.xml.PrefixedAttribute(pre, key, value, _) if pre == elem.scope.getPrefix("http://www.spiritconsortium.org/XMLSchema/SPIRIT/1685-2009") &&
                key == "dependency" => Nil
              case scala.xml.PrefixedAttribute(pre, key, value, _) if pre == elem.scope.getPrefix("http://www.spiritconsortium.org/XMLSchema/SPIRIT/1685-2009") &&
                key == "choiceRef" => Nil
              case scala.xml.PrefixedAttribute(pre, key, value, _) if pre == elem.scope.getPrefix("http://www.spiritconsortium.org/XMLSchema/SPIRIT/1685-2009") &&
                key == "order" => Nil
              case scala.xml.PrefixedAttribute(pre, key, value, _) if pre == elem.scope.getPrefix("http://www.spiritconsortium.org/XMLSchema/SPIRIT/1685-2009") &&
                key == "configGroups" => Nil
              case scala.xml.PrefixedAttribute(pre, key, value, _) if pre == elem.scope.getPrefix("http://www.spiritconsortium.org/XMLSchema/SPIRIT/1685-2009") &&
                key == "bitStringLength" => Nil
              case scala.xml.PrefixedAttribute(pre, key, value, _) if pre == elem.scope.getPrefix("http://www.spiritconsortium.org/XMLSchema/SPIRIT/1685-2009") &&
                key == "minimum" => Nil
              case scala.xml.PrefixedAttribute(pre, key, value, _) if pre == elem.scope.getPrefix("http://www.spiritconsortium.org/XMLSchema/SPIRIT/1685-2009") &&
                key == "maximum" => Nil
              case scala.xml.PrefixedAttribute(pre, key, value, _) if pre == elem.scope.getPrefix("http://www.spiritconsortium.org/XMLSchema/SPIRIT/1685-2009") &&
                key == "rangeType" => Nil
              case scala.xml.PrefixedAttribute(pre, key, value, _) if pre == elem.scope.getPrefix("http://www.spiritconsortium.org/XMLSchema/SPIRIT/1685-2009") &&
                key == "prompt" => Nil
              case scala.xml.UnprefixedAttribute(key, value, _) =>
                List(("@" + key, IPXACT2009scalaxb.DataRecord(None, Some(key), value.text)))
              case scala.xml.PrefixedAttribute(pre, key, value, _) =>
                val ns = elem.scope.getURI(pre)
                List(("@{" + ns + "}" + key, IPXACT2009scalaxb.DataRecord(Option[String](ns), Some(key), value.text)))
              case _ => Nil
            }
          case _ => Nil
        }): _*)))
      case _ => Left("reads failed: seq must be scala.xml.Node")
    }
    
    override def writesAttribute(__obj: RightType2, __scope: scala.xml.NamespaceBinding): scala.xml.MetaData = {
      var attr: scala.xml.MetaData  = scala.xml.Null
      __obj.attributes.toList map {
        case ("@{http://www.spiritconsortium.org/XMLSchema/SPIRIT/1685-2009}format", _) => if (__obj.spiritformat.toString != "long") attr = scala.xml.Attribute(__scope.getPrefix("http://www.spiritconsortium.org/XMLSchema/SPIRIT/1685-2009"), "format", __obj.spiritformat.toString, attr)
        case ("@{http://www.spiritconsortium.org/XMLSchema/SPIRIT/1685-2009}resolve", _) => __obj.spiritresolve foreach { x => attr = scala.xml.Attribute(__scope.getPrefix("http://www.spiritconsortium.org/XMLSchema/SPIRIT/1685-2009"), "resolve", x.toString, attr) }
        case ("@{http://www.spiritconsortium.org/XMLSchema/SPIRIT/1685-2009}id", _) => __obj.spiritid foreach { x => attr = scala.xml.Attribute(__scope.getPrefix("http://www.spiritconsortium.org/XMLSchema/SPIRIT/1685-2009"), "id", x.toString, attr) }
        case ("@{http://www.spiritconsortium.org/XMLSchema/SPIRIT/1685-2009}dependency", _) => __obj.spiritdependency foreach { x => attr = scala.xml.Attribute(__scope.getPrefix("http://www.spiritconsortium.org/XMLSchema/SPIRIT/1685-2009"), "dependency", x.toString, attr) }
        case ("@{http://www.spiritconsortium.org/XMLSchema/SPIRIT/1685-2009}choiceRef", _) => __obj.spiritchoiceRef foreach { x => attr = scala.xml.Attribute(__scope.getPrefix("http://www.spiritconsortium.org/XMLSchema/SPIRIT/1685-2009"), "choiceRef", x.toString, attr) }
        case ("@{http://www.spiritconsortium.org/XMLSchema/SPIRIT/1685-2009}order", _) => __obj.spiritorder foreach { x => attr = scala.xml.Attribute(__scope.getPrefix("http://www.spiritconsortium.org/XMLSchema/SPIRIT/1685-2009"), "order", x.toString, attr) }
        case ("@{http://www.spiritconsortium.org/XMLSchema/SPIRIT/1685-2009}configGroups", _) => __obj.spiritconfigGroups foreach { x => attr = scala.xml.Attribute(__scope.getPrefix("http://www.spiritconsortium.org/XMLSchema/SPIRIT/1685-2009"), "configGroups", x.toString, attr) }
        case ("@{http://www.spiritconsortium.org/XMLSchema/SPIRIT/1685-2009}bitStringLength", _) => __obj.spiritbitStringLength foreach { x => attr = scala.xml.Attribute(__scope.getPrefix("http://www.spiritconsortium.org/XMLSchema/SPIRIT/1685-2009"), "bitStringLength", x.toString, attr) }
        case ("@{http://www.spiritconsortium.org/XMLSchema/SPIRIT/1685-2009}minimum", _) => __obj.spiritminimum foreach { x => attr = scala.xml.Attribute(__scope.getPrefix("http://www.spiritconsortium.org/XMLSchema/SPIRIT/1685-2009"), "minimum", x.toString, attr) }
        case ("@{http://www.spiritconsortium.org/XMLSchema/SPIRIT/1685-2009}maximum", _) => __obj.spiritmaximum foreach { x => attr = scala.xml.Attribute(__scope.getPrefix("http://www.spiritconsortium.org/XMLSchema/SPIRIT/1685-2009"), "maximum", x.toString, attr) }
        case ("@{http://www.spiritconsortium.org/XMLSchema/SPIRIT/1685-2009}rangeType", _) => if (__obj.spiritrangeType.toString != "float") attr = scala.xml.Attribute(__scope.getPrefix("http://www.spiritconsortium.org/XMLSchema/SPIRIT/1685-2009"), "rangeType", __obj.spiritrangeType.toString, attr)
        case ("@{http://www.spiritconsortium.org/XMLSchema/SPIRIT/1685-2009}prompt", _) => __obj.spiritprompt foreach { x => attr = scala.xml.Attribute(__scope.getPrefix("http://www.spiritconsortium.org/XMLSchema/SPIRIT/1685-2009"), "prompt", x.toString, attr) }
        case (key, x) => attr = scala.xml.Attribute((x.namespace map { __scope.getPrefix(_) }).orNull, x.key.orNull, x.value.toString, attr)
      }
      attr
    }

    def writesChildNodes(__obj: RightType2, __scope: scala.xml.NamespaceBinding): Seq[scala.xml.Node] =
      Seq(scala.xml.Text(__obj.value.toString))

  }

  trait Default_Vector2Format extends IPXACT2009scalaxb.ElemNameParser[Vector2] {
    val targetNamespace: Option[String] = Some("http://www.spiritconsortium.org/XMLSchema/SPIRIT/1685-2009")
    
    def parser(node: scala.xml.Node, stack: List[IPXACT2009scalaxb.ElemName]): Parser[Vector2] =
      phrase((IPXACT2009scalaxb.ElemName(Some("http://www.spiritconsortium.org/XMLSchema/SPIRIT/1685-2009"), "left")) ~
      (IPXACT2009scalaxb.ElemName(Some("http://www.spiritconsortium.org/XMLSchema/SPIRIT/1685-2009"), "right")) ^^
      { case p1 ~ p2 =>
      Vector2(IPXACT2009scalaxb.fromXML[LeftType2](p1, IPXACT2009scalaxb.ElemName(node) :: stack),
        IPXACT2009scalaxb.fromXML[RightType2](p2, IPXACT2009scalaxb.ElemName(node) :: stack)) })
    
    def writesChildNodes(__obj: Vector2, __scope: scala.xml.NamespaceBinding): Seq[scala.xml.Node] =
      Seq.concat(IPXACT2009scalaxb.toXML[LeftType2](__obj.left, Some("http://www.spiritconsortium.org/XMLSchema/SPIRIT/1685-2009"), Some("left"), __scope, false),
        IPXACT2009scalaxb.toXML[RightType2](__obj.right, Some("http://www.spiritconsortium.org/XMLSchema/SPIRIT/1685-2009"), Some("right"), __scope, false))

  }

  trait Default_LogicalPort2Format extends IPXACT2009scalaxb.ElemNameParser[LogicalPort2] {
    val targetNamespace: Option[String] = Some("http://www.spiritconsortium.org/XMLSchema/SPIRIT/1685-2009")
    
    def parser(node: scala.xml.Node, stack: List[IPXACT2009scalaxb.ElemName]): Parser[LogicalPort2] =
      phrase((IPXACT2009scalaxb.ElemName(Some("http://www.spiritconsortium.org/XMLSchema/SPIRIT/1685-2009"), "name")) ~
      opt(IPXACT2009scalaxb.ElemName(Some("http://www.spiritconsortium.org/XMLSchema/SPIRIT/1685-2009"), "vector")) ^^
      { case p1 ~ p2 =>
      LogicalPort2(IPXACT2009scalaxb.fromXML[String](p1, IPXACT2009scalaxb.ElemName(node) :: stack),
        p2.headOption map { IPXACT2009scalaxb.fromXML[Vector2](_, IPXACT2009scalaxb.ElemName(node) :: stack) }) })
    
    def writesChildNodes(__obj: LogicalPort2, __scope: scala.xml.NamespaceBinding): Seq[scala.xml.Node] =
      Seq.concat(IPXACT2009scalaxb.toXML[String](__obj.name, Some("http://www.spiritconsortium.org/XMLSchema/SPIRIT/1685-2009"), Some("name"), __scope, false),
        __obj.vector map { IPXACT2009scalaxb.toXML[Vector2](_, Some("http://www.spiritconsortium.org/XMLSchema/SPIRIT/1685-2009"), Some("vector"), __scope, false) } getOrElse {Nil})

  }

  trait Default_PhysicalPort2Format extends IPXACT2009scalaxb.ElemNameParser[PhysicalPort2] {
    val targetNamespace: Option[String] = Some("http://www.spiritconsortium.org/XMLSchema/SPIRIT/1685-2009")
    
    def parser(node: scala.xml.Node, stack: List[IPXACT2009scalaxb.ElemName]): Parser[PhysicalPort2] =
      phrase((IPXACT2009scalaxb.ElemName(Some("http://www.spiritconsortium.org/XMLSchema/SPIRIT/1685-2009"), "name")) ~
      opt(IPXACT2009scalaxb.ElemName(Some("http://www.spiritconsortium.org/XMLSchema/SPIRIT/1685-2009"), "vector")) ^^
      { case p1 ~ p2 =>
      PhysicalPort2(IPXACT2009scalaxb.fromXML[String](p1, IPXACT2009scalaxb.ElemName(node) :: stack),
        p2.headOption map { IPXACT2009scalaxb.fromXML[Vector4](_, IPXACT2009scalaxb.ElemName(node) :: stack) }) })
    
    def writesChildNodes(__obj: PhysicalPort2, __scope: scala.xml.NamespaceBinding): Seq[scala.xml.Node] =
      Seq.concat(IPXACT2009scalaxb.toXML[String](__obj.name, Some("http://www.spiritconsortium.org/XMLSchema/SPIRIT/1685-2009"), Some("name"), __scope, false),
        __obj.vector map { IPXACT2009scalaxb.toXML[Vector4](_, Some("http://www.spiritconsortium.org/XMLSchema/SPIRIT/1685-2009"), Some("vector"), __scope, false) } getOrElse {Nil})

  }

  trait Default_PortMap2Format extends IPXACT2009scalaxb.ElemNameParser[PortMap2] {
    val targetNamespace: Option[String] = Some("http://www.spiritconsortium.org/XMLSchema/SPIRIT/1685-2009")
    
    def parser(node: scala.xml.Node, stack: List[IPXACT2009scalaxb.ElemName]): Parser[PortMap2] =
      phrase((IPXACT2009scalaxb.ElemName(Some("http://www.spiritconsortium.org/XMLSchema/SPIRIT/1685-2009"), "logicalPort")) ~
      (IPXACT2009scalaxb.ElemName(Some("http://www.spiritconsortium.org/XMLSchema/SPIRIT/1685-2009"), "physicalPort")) ^^
      { case p1 ~ p2 =>
      PortMap2(IPXACT2009scalaxb.fromXML[LogicalPort2](p1, IPXACT2009scalaxb.ElemName(node) :: stack),
        IPXACT2009scalaxb.fromXML[PhysicalPort2](p2, IPXACT2009scalaxb.ElemName(node) :: stack)) })
    
    def writesChildNodes(__obj: PortMap2, __scope: scala.xml.NamespaceBinding): Seq[scala.xml.Node] =
      Seq.concat(IPXACT2009scalaxb.toXML[LogicalPort2](__obj.logicalPort, Some("http://www.spiritconsortium.org/XMLSchema/SPIRIT/1685-2009"), Some("logicalPort"), __scope, false),
        IPXACT2009scalaxb.toXML[PhysicalPort2](__obj.physicalPort, Some("http://www.spiritconsortium.org/XMLSchema/SPIRIT/1685-2009"), Some("physicalPort"), __scope, false))

  }

  trait Default_PortMaps2Format extends IPXACT2009scalaxb.ElemNameParser[PortMaps2] {
    val targetNamespace: Option[String] = Some("http://www.spiritconsortium.org/XMLSchema/SPIRIT/1685-2009")
    
    def parser(node: scala.xml.Node, stack: List[IPXACT2009scalaxb.ElemName]): Parser[PortMaps2] =
      phrase(safeRep(IPXACT2009scalaxb.ElemName(Some("http://www.spiritconsortium.org/XMLSchema/SPIRIT/1685-2009"), "portMap")) ^^
      { case p1 =>
      PortMaps2(p1 map { IPXACT2009scalaxb.fromXML[PortMap2](_, IPXACT2009scalaxb.ElemName(node) :: stack) }) })
    
    def writesChildNodes(__obj: PortMaps2, __scope: scala.xml.NamespaceBinding): Seq[scala.xml.Node] =
      (__obj.portMap flatMap { IPXACT2009scalaxb.toXML[PortMap2](_, Some("http://www.spiritconsortium.org/XMLSchema/SPIRIT/1685-2009"), Some("portMap"), __scope, false) })
  }
  trait Default_AbstractorBusInterfaceTypeFormat extends IPXACT2009scalaxb.ElemNameParser[AbstractorBusInterfaceType] with _NameGroupGroupFormat {
    val targetNamespace: Option[String] = Some("http://www.spiritconsortium.org/XMLSchema/SPIRIT/1685-2009")
    
    override def typeName: Option[String] = Some("abstractorBusInterfaceType")

    def parser(node: scala.xml.Node, stack: List[IPXACT2009scalaxb.ElemName]): Parser[AbstractorBusInterfaceType] =
      phrase((parseNameGroupGroup(node, IPXACT2009scalaxb.ElemName(node) :: stack)) ~
      (IPXACT2009scalaxb.ElemName(Some("http://www.spiritconsortium.org/XMLSchema/SPIRIT/1685-2009"), "abstractionType")) ~
      opt(IPXACT2009scalaxb.ElemName(Some("http://www.spiritconsortium.org/XMLSchema/SPIRIT/1685-2009"), "portMaps")) ~
      opt(IPXACT2009scalaxb.ElemName(Some("http://www.spiritconsortium.org/XMLSchema/SPIRIT/1685-2009"), "parameters")) ~
      opt(IPXACT2009scalaxb.ElemName(Some("http://www.spiritconsortium.org/XMLSchema/SPIRIT/1685-2009"), "vendorExtensions")) ^^
      { case p1 ~ p2 ~ p3 ~ p4 ~ p5 =>
      AbstractorBusInterfaceType(p1,
        IPXACT2009scalaxb.fromXML[LibraryRefType](p2, IPXACT2009scalaxb.ElemName(node) :: stack),
        p3.headOption map { IPXACT2009scalaxb.fromXML[PortMaps2](_, IPXACT2009scalaxb.ElemName(node) :: stack) },
        p4.headOption map { IPXACT2009scalaxb.fromXML[Parameters](_, IPXACT2009scalaxb.ElemName(node) :: stack) },
        p5.headOption map { IPXACT2009scalaxb.fromXML[VendorExtensions](_, IPXACT2009scalaxb.ElemName(node) :: stack) },
        scala.collection.immutable.ListMap((node match {
          case elem: scala.xml.Elem =>
            elem.attributes.toList flatMap {
              
              case scala.xml.UnprefixedAttribute(key, value, _) =>
                List(("@" + key, IPXACT2009scalaxb.DataRecord(None, Some(key), value.text)))
              case scala.xml.PrefixedAttribute(pre, key, value, _) =>
                val ns = elem.scope.getURI(pre)
                List(("@{" + ns + "}" + key, IPXACT2009scalaxb.DataRecord(Option[String](ns), Some(key), value.text)))
              case _ => Nil
            }
          case _ => Nil
        }): _*)) })
    
    override def writesAttribute(__obj: AbstractorBusInterfaceType, __scope: scala.xml.NamespaceBinding): scala.xml.MetaData = {
      var attr: scala.xml.MetaData  = scala.xml.Null
      __obj.attributes.toList map {
        case (key, x) => attr = scala.xml.Attribute((x.namespace map { __scope.getPrefix(_) }).orNull, x.key.orNull, x.value.toString, attr)
      }
      attr
    }
    def writesChildNodes(__obj: AbstractorBusInterfaceType, __scope: scala.xml.NamespaceBinding): Seq[scala.xml.Node] =
      Seq.concat(IPXACT2009scalaxb.toXML[NameGroupSequence](__obj.nameGroupSequence1, None, Some("nameGroupSequence1"), __scope, false),
        IPXACT2009scalaxb.toXML[LibraryRefType](__obj.abstractionType, Some("http://www.spiritconsortium.org/XMLSchema/SPIRIT/1685-2009"), Some("abstractionType"), __scope, false),
        __obj.portMaps map { IPXACT2009scalaxb.toXML[PortMaps2](_, Some("http://www.spiritconsortium.org/XMLSchema/SPIRIT/1685-2009"), Some("portMaps"), __scope, false) } getOrElse {Nil},
        __obj.parameters map { IPXACT2009scalaxb.toXML[Parameters](_, Some("http://www.spiritconsortium.org/XMLSchema/SPIRIT/1685-2009"), Some("parameters"), __scope, false) } getOrElse {Nil},
        __obj.vendorExtensions map { IPXACT2009scalaxb.toXML[VendorExtensions](_, Some("http://www.spiritconsortium.org/XMLSchema/SPIRIT/1685-2009"), Some("vendorExtensions"), __scope, false) } getOrElse {Nil})

  }


/** Group of the different modes a busInterface can take on in an abstractor
*/
  trait _AbstractorInterfaceModeGroupFormat extends IPXACT2009scalaxb.AnyElemNameParser {
    def parseAbstractorInterfaceModeGroup(node: scala.xml.Node, stack: List[IPXACT2009scalaxb.ElemName]): Parser[IPXACT2009scalaxb.DataRecord[AbstractorInterfaceModeOption]] =
      (((IPXACT2009scalaxb.ElemName(Some("http://www.spiritconsortium.org/XMLSchema/SPIRIT/1685-2009"), "master")) ^^
      (x => IPXACT2009scalaxb.DataRecord(x.namespace, Some(x.name), IPXACT2009scalaxb.fromXML[Master2](x, IPXACT2009scalaxb.ElemName(node) :: stack)))) |
      ((IPXACT2009scalaxb.ElemName(Some("http://www.spiritconsortium.org/XMLSchema/SPIRIT/1685-2009"), "slave")) ^^
      (x => IPXACT2009scalaxb.DataRecord(x.namespace, Some(x.name), IPXACT2009scalaxb.fromXML[Slave2](x, IPXACT2009scalaxb.ElemName(node) :: stack)))) |
      ((IPXACT2009scalaxb.ElemName(Some("http://www.spiritconsortium.org/XMLSchema/SPIRIT/1685-2009"), "system")) ^^
      (x => IPXACT2009scalaxb.DataRecord(x.namespace, Some(x.name), IPXACT2009scalaxb.fromXML[System2](x, IPXACT2009scalaxb.ElemName(node) :: stack)))) |
      ((IPXACT2009scalaxb.ElemName(Some("http://www.spiritconsortium.org/XMLSchema/SPIRIT/1685-2009"), "mirroredSlave")) ^^
      (x => IPXACT2009scalaxb.DataRecord(x.namespace, Some(x.name), IPXACT2009scalaxb.fromXML[MirroredSlave2](x, IPXACT2009scalaxb.ElemName(node) :: stack)))) |
      ((IPXACT2009scalaxb.ElemName(Some("http://www.spiritconsortium.org/XMLSchema/SPIRIT/1685-2009"), "mirroredMaster")) ^^
      (x => IPXACT2009scalaxb.DataRecord(x.namespace, Some(x.name), IPXACT2009scalaxb.fromXML[MirroredMaster2](x, IPXACT2009scalaxb.ElemName(node) :: stack)))) |
      ((IPXACT2009scalaxb.ElemName(Some("http://www.spiritconsortium.org/XMLSchema/SPIRIT/1685-2009"), "mirroredSystem")) ^^
      (x => IPXACT2009scalaxb.DataRecord(x.namespace, Some(x.name), IPXACT2009scalaxb.fromXML[MirroredSystem2](x, IPXACT2009scalaxb.ElemName(node) :: stack)))))
  
    def parseAbstractorInterfaceModeGroup(node: scala.xml.Node, stack: List[IPXACT2009scalaxb.ElemName], wrap: Boolean): Parser[IPXACT2009scalaxb.DataRecord[AbstractorInterfaceModeOption]] =
      (((IPXACT2009scalaxb.ElemName(Some("http://www.spiritconsortium.org/XMLSchema/SPIRIT/1685-2009"), "master")) ^^
      (x => IPXACT2009scalaxb.DataRecord(x.namespace, Some(x.name), IPXACT2009scalaxb.fromXML[Master2](x, IPXACT2009scalaxb.ElemName(node) :: stack)))) |
      ((IPXACT2009scalaxb.ElemName(Some("http://www.spiritconsortium.org/XMLSchema/SPIRIT/1685-2009"), "slave")) ^^
      (x => IPXACT2009scalaxb.DataRecord(x.namespace, Some(x.name), IPXACT2009scalaxb.fromXML[Slave2](x, IPXACT2009scalaxb.ElemName(node) :: stack)))) |
      ((IPXACT2009scalaxb.ElemName(Some("http://www.spiritconsortium.org/XMLSchema/SPIRIT/1685-2009"), "system")) ^^
      (x => IPXACT2009scalaxb.DataRecord(x.namespace, Some(x.name), IPXACT2009scalaxb.fromXML[System2](x, IPXACT2009scalaxb.ElemName(node) :: stack)))) |
      ((IPXACT2009scalaxb.ElemName(Some("http://www.spiritconsortium.org/XMLSchema/SPIRIT/1685-2009"), "mirroredSlave")) ^^
      (x => IPXACT2009scalaxb.DataRecord(x.namespace, Some(x.name), IPXACT2009scalaxb.fromXML[MirroredSlave2](x, IPXACT2009scalaxb.ElemName(node) :: stack)))) |
      ((IPXACT2009scalaxb.ElemName(Some("http://www.spiritconsortium.org/XMLSchema/SPIRIT/1685-2009"), "mirroredMaster")) ^^
      (x => IPXACT2009scalaxb.DataRecord(x.namespace, Some(x.name), IPXACT2009scalaxb.fromXML[MirroredMaster2](x, IPXACT2009scalaxb.ElemName(node) :: stack)))) |
      ((IPXACT2009scalaxb.ElemName(Some("http://www.spiritconsortium.org/XMLSchema/SPIRIT/1685-2009"), "mirroredSystem")) ^^
      (x => IPXACT2009scalaxb.DataRecord(x.namespace, Some(x.name), IPXACT2009scalaxb.fromXML[MirroredSystem2](x, IPXACT2009scalaxb.ElemName(node) :: stack)))))
    
    def parsemixedAbstractorInterfaceModeGroup(node: scala.xml.Node, stack: List[IPXACT2009scalaxb.ElemName]): Parser[Seq[IPXACT2009scalaxb.DataRecord[Any]]] =
      (((((IPXACT2009scalaxb.ElemName(Some("http://www.spiritconsortium.org/XMLSchema/SPIRIT/1685-2009"), "master")) ^^
      (x => IPXACT2009scalaxb.DataRecord(x.namespace, Some(x.name), IPXACT2009scalaxb.fromXML[Master2](x, IPXACT2009scalaxb.ElemName(node) :: stack)))) ~
      optTextRecord) ^^ 
        { case p1 ~ p2 => Seq.concat(Seq(p1),
        p2.toList) }) ||| 
      ((((IPXACT2009scalaxb.ElemName(Some("http://www.spiritconsortium.org/XMLSchema/SPIRIT/1685-2009"), "slave")) ^^
      (x => IPXACT2009scalaxb.DataRecord(x.namespace, Some(x.name), IPXACT2009scalaxb.fromXML[Slave2](x, IPXACT2009scalaxb.ElemName(node) :: stack)))) ~
      optTextRecord) ^^ 
        { case p1 ~ p2 => Seq.concat(Seq(p1),
        p2.toList) }) ||| 
      ((((IPXACT2009scalaxb.ElemName(Some("http://www.spiritconsortium.org/XMLSchema/SPIRIT/1685-2009"), "system")) ^^
      (x => IPXACT2009scalaxb.DataRecord(x.namespace, Some(x.name), IPXACT2009scalaxb.fromXML[System2](x, IPXACT2009scalaxb.ElemName(node) :: stack)))) ~
      optTextRecord) ^^ 
        { case p1 ~ p2 => Seq.concat(Seq(p1),
        p2.toList) }) ||| 
      ((((IPXACT2009scalaxb.ElemName(Some("http://www.spiritconsortium.org/XMLSchema/SPIRIT/1685-2009"), "mirroredSlave")) ^^
      (x => IPXACT2009scalaxb.DataRecord(x.namespace, Some(x.name), IPXACT2009scalaxb.fromXML[MirroredSlave2](x, IPXACT2009scalaxb.ElemName(node) :: stack)))) ~
      optTextRecord) ^^ 
        { case p1 ~ p2 => Seq.concat(Seq(p1),
        p2.toList) }) ||| 
      ((((IPXACT2009scalaxb.ElemName(Some("http://www.spiritconsortium.org/XMLSchema/SPIRIT/1685-2009"), "mirroredMaster")) ^^
      (x => IPXACT2009scalaxb.DataRecord(x.namespace, Some(x.name), IPXACT2009scalaxb.fromXML[MirroredMaster2](x, IPXACT2009scalaxb.ElemName(node) :: stack)))) ~
      optTextRecord) ^^ 
        { case p1 ~ p2 => Seq.concat(Seq(p1),
        p2.toList) }) ||| 
      ((((IPXACT2009scalaxb.ElemName(Some("http://www.spiritconsortium.org/XMLSchema/SPIRIT/1685-2009"), "mirroredSystem")) ^^
      (x => IPXACT2009scalaxb.DataRecord(x.namespace, Some(x.name), IPXACT2009scalaxb.fromXML[MirroredSystem2](x, IPXACT2009scalaxb.ElemName(node) :: stack)))) ~
      optTextRecord) ^^ 
        { case p1 ~ p2 => Seq.concat(Seq(p1),
        p2.toList) }))
  }


/** Group of the different modes a busInterface can take on in a component
*/
  trait _InterfaceModeGroupFormat extends IPXACT2009scalaxb.AnyElemNameParser {
    def parseInterfaceModeGroup(node: scala.xml.Node, stack: List[IPXACT2009scalaxb.ElemName]): Parser[IPXACT2009scalaxb.DataRecord[InterfaceModeOption]] =
      (((IPXACT2009scalaxb.ElemName(Some("http://www.spiritconsortium.org/XMLSchema/SPIRIT/1685-2009"), "master")) ^^
      (x => IPXACT2009scalaxb.DataRecord(x.namespace, Some(x.name), IPXACT2009scalaxb.fromXML[Master](x, IPXACT2009scalaxb.ElemName(node) :: stack)))) |
      ((IPXACT2009scalaxb.ElemName(Some("http://www.spiritconsortium.org/XMLSchema/SPIRIT/1685-2009"), "slave")) ^^
      (x => IPXACT2009scalaxb.DataRecord(x.namespace, Some(x.name), IPXACT2009scalaxb.fromXML[Slave](x, IPXACT2009scalaxb.ElemName(node) :: stack)))) |
      ((IPXACT2009scalaxb.ElemName(Some("http://www.spiritconsortium.org/XMLSchema/SPIRIT/1685-2009"), "system")) ^^
      (x => IPXACT2009scalaxb.DataRecord(x.namespace, Some(x.name), IPXACT2009scalaxb.fromXML[System](x, IPXACT2009scalaxb.ElemName(node) :: stack)))) |
      ((IPXACT2009scalaxb.ElemName(Some("http://www.spiritconsortium.org/XMLSchema/SPIRIT/1685-2009"), "mirroredSlave")) ^^
      (x => IPXACT2009scalaxb.DataRecord(x.namespace, Some(x.name), IPXACT2009scalaxb.fromXML[MirroredSlave](x, IPXACT2009scalaxb.ElemName(node) :: stack)))) |
      ((IPXACT2009scalaxb.ElemName(Some("http://www.spiritconsortium.org/XMLSchema/SPIRIT/1685-2009"), "mirroredMaster")) ^^
      (x => IPXACT2009scalaxb.DataRecord(x.namespace, Some(x.name), IPXACT2009scalaxb.fromXML[MirroredMaster](x, IPXACT2009scalaxb.ElemName(node) :: stack)))) |
      ((IPXACT2009scalaxb.ElemName(Some("http://www.spiritconsortium.org/XMLSchema/SPIRIT/1685-2009"), "mirroredSystem")) ^^
      (x => IPXACT2009scalaxb.DataRecord(x.namespace, Some(x.name), IPXACT2009scalaxb.fromXML[MirroredSystem](x, IPXACT2009scalaxb.ElemName(node) :: stack)))) |
      ((IPXACT2009scalaxb.ElemName(Some("http://www.spiritconsortium.org/XMLSchema/SPIRIT/1685-2009"), "monitor")) ^^
      (x => IPXACT2009scalaxb.DataRecord(x.namespace, Some(x.name), IPXACT2009scalaxb.fromXML[Monitor](x, IPXACT2009scalaxb.ElemName(node) :: stack)))))
  
    def parseInterfaceModeGroup(node: scala.xml.Node, stack: List[IPXACT2009scalaxb.ElemName], wrap: Boolean): Parser[IPXACT2009scalaxb.DataRecord[InterfaceModeOption]] =
      (((IPXACT2009scalaxb.ElemName(Some("http://www.spiritconsortium.org/XMLSchema/SPIRIT/1685-2009"), "master")) ^^
      (x => IPXACT2009scalaxb.DataRecord(x.namespace, Some(x.name), IPXACT2009scalaxb.fromXML[Master](x, IPXACT2009scalaxb.ElemName(node) :: stack)))) |
      ((IPXACT2009scalaxb.ElemName(Some("http://www.spiritconsortium.org/XMLSchema/SPIRIT/1685-2009"), "slave")) ^^
      (x => IPXACT2009scalaxb.DataRecord(x.namespace, Some(x.name), IPXACT2009scalaxb.fromXML[Slave](x, IPXACT2009scalaxb.ElemName(node) :: stack)))) |
      ((IPXACT2009scalaxb.ElemName(Some("http://www.spiritconsortium.org/XMLSchema/SPIRIT/1685-2009"), "system")) ^^
      (x => IPXACT2009scalaxb.DataRecord(x.namespace, Some(x.name), IPXACT2009scalaxb.fromXML[System](x, IPXACT2009scalaxb.ElemName(node) :: stack)))) |
      ((IPXACT2009scalaxb.ElemName(Some("http://www.spiritconsortium.org/XMLSchema/SPIRIT/1685-2009"), "mirroredSlave")) ^^
      (x => IPXACT2009scalaxb.DataRecord(x.namespace, Some(x.name), IPXACT2009scalaxb.fromXML[MirroredSlave](x, IPXACT2009scalaxb.ElemName(node) :: stack)))) |
      ((IPXACT2009scalaxb.ElemName(Some("http://www.spiritconsortium.org/XMLSchema/SPIRIT/1685-2009"), "mirroredMaster")) ^^
      (x => IPXACT2009scalaxb.DataRecord(x.namespace, Some(x.name), IPXACT2009scalaxb.fromXML[MirroredMaster](x, IPXACT2009scalaxb.ElemName(node) :: stack)))) |
      ((IPXACT2009scalaxb.ElemName(Some("http://www.spiritconsortium.org/XMLSchema/SPIRIT/1685-2009"), "mirroredSystem")) ^^
      (x => IPXACT2009scalaxb.DataRecord(x.namespace, Some(x.name), IPXACT2009scalaxb.fromXML[MirroredSystem](x, IPXACT2009scalaxb.ElemName(node) :: stack)))) |
      ((IPXACT2009scalaxb.ElemName(Some("http://www.spiritconsortium.org/XMLSchema/SPIRIT/1685-2009"), "monitor")) ^^
      (x => IPXACT2009scalaxb.DataRecord(x.namespace, Some(x.name), IPXACT2009scalaxb.fromXML[Monitor](x, IPXACT2009scalaxb.ElemName(node) :: stack)))))
    
    def parsemixedInterfaceModeGroup(node: scala.xml.Node, stack: List[IPXACT2009scalaxb.ElemName]): Parser[Seq[IPXACT2009scalaxb.DataRecord[Any]]] =
      (((((IPXACT2009scalaxb.ElemName(Some("http://www.spiritconsortium.org/XMLSchema/SPIRIT/1685-2009"), "master")) ^^
      (x => IPXACT2009scalaxb.DataRecord(x.namespace, Some(x.name), IPXACT2009scalaxb.fromXML[Master](x, IPXACT2009scalaxb.ElemName(node) :: stack)))) ~
      optTextRecord) ^^ 
        { case p1 ~ p2 => Seq.concat(Seq(p1),
        p2.toList) }) ||| 
      ((((IPXACT2009scalaxb.ElemName(Some("http://www.spiritconsortium.org/XMLSchema/SPIRIT/1685-2009"), "slave")) ^^
      (x => IPXACT2009scalaxb.DataRecord(x.namespace, Some(x.name), IPXACT2009scalaxb.fromXML[Slave](x, IPXACT2009scalaxb.ElemName(node) :: stack)))) ~
      optTextRecord) ^^ 
        { case p1 ~ p2 => Seq.concat(Seq(p1),
        p2.toList) }) ||| 
      ((((IPXACT2009scalaxb.ElemName(Some("http://www.spiritconsortium.org/XMLSchema/SPIRIT/1685-2009"), "system")) ^^
      (x => IPXACT2009scalaxb.DataRecord(x.namespace, Some(x.name), IPXACT2009scalaxb.fromXML[System](x, IPXACT2009scalaxb.ElemName(node) :: stack)))) ~
      optTextRecord) ^^ 
        { case p1 ~ p2 => Seq.concat(Seq(p1),
        p2.toList) }) ||| 
      ((((IPXACT2009scalaxb.ElemName(Some("http://www.spiritconsortium.org/XMLSchema/SPIRIT/1685-2009"), "mirroredSlave")) ^^
      (x => IPXACT2009scalaxb.DataRecord(x.namespace, Some(x.name), IPXACT2009scalaxb.fromXML[MirroredSlave](x, IPXACT2009scalaxb.ElemName(node) :: stack)))) ~
      optTextRecord) ^^ 
        { case p1 ~ p2 => Seq.concat(Seq(p1),
        p2.toList) }) ||| 
      ((((IPXACT2009scalaxb.ElemName(Some("http://www.spiritconsortium.org/XMLSchema/SPIRIT/1685-2009"), "mirroredMaster")) ^^
      (x => IPXACT2009scalaxb.DataRecord(x.namespace, Some(x.name), IPXACT2009scalaxb.fromXML[MirroredMaster](x, IPXACT2009scalaxb.ElemName(node) :: stack)))) ~
      optTextRecord) ^^ 
        { case p1 ~ p2 => Seq.concat(Seq(p1),
        p2.toList) }) ||| 
      ((((IPXACT2009scalaxb.ElemName(Some("http://www.spiritconsortium.org/XMLSchema/SPIRIT/1685-2009"), "mirroredSystem")) ^^
      (x => IPXACT2009scalaxb.DataRecord(x.namespace, Some(x.name), IPXACT2009scalaxb.fromXML[MirroredSystem](x, IPXACT2009scalaxb.ElemName(node) :: stack)))) ~
      optTextRecord) ^^ 
        { case p1 ~ p2 => Seq.concat(Seq(p1),
        p2.toList) }) ||| 
      ((((IPXACT2009scalaxb.ElemName(Some("http://www.spiritconsortium.org/XMLSchema/SPIRIT/1685-2009"), "monitor")) ^^
      (x => IPXACT2009scalaxb.DataRecord(x.namespace, Some(x.name), IPXACT2009scalaxb.fromXML[Monitor](x, IPXACT2009scalaxb.ElemName(node) :: stack)))) ~
      optTextRecord) ^^ 
        { case p1 ~ p2 => Seq.concat(Seq(p1),
        p2.toList) }))
  }

  def build_UsageTypeTypeFormat = new Default_UsageTypeTypeFormat {}
  trait Default_UsageTypeTypeFormat extends IPXACT2009scalaxb.XMLFormat[UsageTypeType] {
    val targetNamespace: Option[String] = Some("http://www.spiritconsortium.org/XMLSchema/SPIRIT/1685-2009")
    
    def fromString(value: String, scope: scala.xml.NamespaceBinding): UsageTypeType =
        (fromString0(value, scope)).apply(IPXACT2009scalaxb.fromXML[String](scala.xml.Text(value)))

    private def fromString0(value: String, scope: scala.xml.NamespaceBinding): PartialFunction[Any, UsageTypeType] = {
      case x: String if x == IPXACT2009scalaxb.fromXML[String](scala.xml.Text("nontyped")) => Nontyped
      case x: String if x == IPXACT2009scalaxb.fromXML[String](scala.xml.Text("typed")) => Typed

    }



    def reads(seq: scala.xml.NodeSeq, stack: List[IPXACT2009scalaxb.ElemName]): Either[String, UsageTypeType] = seq match {
      case elem: scala.xml.Elem => Right(fromString(elem.text, elem.scope))
      case _ => Right(fromString(seq.text, scala.xml.TopScope))
    }
    
    def writes(__obj: UsageTypeType, __namespace: Option[String], __elementLabel: Option[String],
        __scope: scala.xml.NamespaceBinding, __typeAttribute: Boolean): scala.xml.NodeSeq =
      scala.xml.Elem(IPXACT2009scalaxb.Helper.getPrefix(__namespace, __scope).orNull,
        __elementLabel getOrElse { sys.error("missing element label.") },
        scala.xml.Null, __scope, true, scala.xml.Text(__obj.toString))
  }
  trait Default_NameValueTypeTypeFormat extends IPXACT2009scalaxb.ElemNameParser[NameValueTypeType] with _NameGroupStringGroupFormat {
    val targetNamespace: Option[String] = Some("http://www.spiritconsortium.org/XMLSchema/SPIRIT/1685-2009")
    
    override def typeName: Option[String] = Some("nameValueTypeType")

    def parser(node: scala.xml.Node, stack: List[IPXACT2009scalaxb.ElemName]): Parser[NameValueTypeType] =
      phrase((parseNameGroupStringGroup(node, IPXACT2009scalaxb.ElemName(node) :: stack)) ~
      (IPXACT2009scalaxb.ElemName(Some("http://www.spiritconsortium.org/XMLSchema/SPIRIT/1685-2009"), "value")) ~
      opt(IPXACT2009scalaxb.ElemName(Some("http://www.spiritconsortium.org/XMLSchema/SPIRIT/1685-2009"), "vendorExtensions")) ^^
      { case p1 ~ p2 ~ p3 =>
      NameValueTypeType(p1,
        IPXACT2009scalaxb.fromXML[Value](p2, IPXACT2009scalaxb.ElemName(node) :: stack),
        p3.headOption map { IPXACT2009scalaxb.fromXML[VendorExtensions](_, IPXACT2009scalaxb.ElemName(node) :: stack) },
        scala.collection.immutable.ListMap(List(
        (node \ "@{http://www.spiritconsortium.org/XMLSchema/SPIRIT/1685-2009}dataType").headOption map { x => IPXACT2009scalaxb.DataRecord(x, node, IPXACT2009scalaxb.fromXML[String](x, IPXACT2009scalaxb.ElemName(node) :: stack)) } map { "@dataType" -> _ },
        (node \ "@{http://www.spiritconsortium.org/XMLSchema/SPIRIT/1685-2009}usageType").headOption map { x => IPXACT2009scalaxb.DataRecord(x, node, IPXACT2009scalaxb.fromXML[UsageTypeType](x, IPXACT2009scalaxb.ElemName(node) :: stack)) } orElse Some(IPXACT2009scalaxb.DataRecord(None, None, IPXACT2009scalaxb.fromXML[UsageTypeType](scala.xml.Text("nontyped"), IPXACT2009scalaxb.ElemName(node) :: stack))) map { "@usageType" -> _ }
        ).flatten[(String, IPXACT2009scalaxb.DataRecord[Any])] ::: (node match {
          case elem: scala.xml.Elem =>
            elem.attributes.toList flatMap {
              case scala.xml.PrefixedAttribute(pre, key, value, _) if pre == elem.scope.getPrefix("http://www.spiritconsortium.org/XMLSchema/SPIRIT/1685-2009") &&
                key == "dataType" => Nil
              case scala.xml.PrefixedAttribute(pre, key, value, _) if pre == elem.scope.getPrefix("http://www.spiritconsortium.org/XMLSchema/SPIRIT/1685-2009") &&
                key == "usageType" => Nil
              case scala.xml.UnprefixedAttribute(key, value, _) =>
                List(("@" + key, IPXACT2009scalaxb.DataRecord(None, Some(key), value.text)))
              case scala.xml.PrefixedAttribute(pre, key, value, _) =>
                val ns = elem.scope.getURI(pre)
                List(("@{" + ns + "}" + key, IPXACT2009scalaxb.DataRecord(Option[String](ns), Some(key), value.text)))
              case _ => Nil
            }
          case _ => Nil
        }): _*)) })
    
    override def writesAttribute(__obj: NameValueTypeType, __scope: scala.xml.NamespaceBinding): scala.xml.MetaData = {
      var attr: scala.xml.MetaData  = scala.xml.Null
      __obj.attributes.toList map {
        case ("@dataType", _) => __obj.dataType foreach { x => attr = scala.xml.Attribute(__scope.getPrefix("http://www.spiritconsortium.org/XMLSchema/SPIRIT/1685-2009"), "dataType", x.toString, attr) }
        case ("@usageType", _) => if (__obj.usageType.toString != "nontyped") attr = scala.xml.Attribute(__scope.getPrefix("http://www.spiritconsortium.org/XMLSchema/SPIRIT/1685-2009"), "usageType", __obj.usageType.toString, attr)
        case (key, x) => attr = scala.xml.Attribute((x.namespace map { __scope.getPrefix(_) }).orNull, x.key.orNull, x.value.toString, attr)
      }
      attr
    }

    def writesChildNodes(__obj: NameValueTypeType, __scope: scala.xml.NamespaceBinding): Seq[scala.xml.Node] =
      Seq.concat(IPXACT2009scalaxb.toXML[NameGroupStringSequence](__obj.nameGroupStringSequence1, None, Some("nameGroupStringSequence1"), __scope, false),
        IPXACT2009scalaxb.toXML[Value](__obj.value, Some("http://www.spiritconsortium.org/XMLSchema/SPIRIT/1685-2009"), Some("value"), __scope, false),
        __obj.vendorExtensions map { IPXACT2009scalaxb.toXML[VendorExtensions](_, Some("http://www.spiritconsortium.org/XMLSchema/SPIRIT/1685-2009"), Some("vendorExtensions"), __scope, false) } getOrElse {Nil})

  }

  trait Default_ParametersFormat extends IPXACT2009scalaxb.ElemNameParser[Parameters] {
    val targetNamespace: Option[String] = Some("http://www.spiritconsortium.org/XMLSchema/SPIRIT/1685-2009")
    
    def parser(node: scala.xml.Node, stack: List[IPXACT2009scalaxb.ElemName]): Parser[Parameters] =
      phrase(safeRep(IPXACT2009scalaxb.ElemName(Some("http://www.spiritconsortium.org/XMLSchema/SPIRIT/1685-2009"), "parameter")) ^^
      { case p1 =>
      Parameters(p1 map { IPXACT2009scalaxb.fromXML[NameValuePairTypable](_, IPXACT2009scalaxb.ElemName(node) :: stack) }) })
    
    def writesChildNodes(__obj: Parameters, __scope: scala.xml.NamespaceBinding): Seq[scala.xml.Node] =
      (__obj.parameter flatMap { IPXACT2009scalaxb.toXML[NameValuePairTypable](_, Some("http://www.spiritconsortium.org/XMLSchema/SPIRIT/1685-2009"), Some("parameter"), __scope, false) })
  }
  trait Default_VendorExtensionsFormat extends IPXACT2009scalaxb.ElemNameParser[VendorExtensions] {
    val targetNamespace: Option[String] = Some("http://www.spiritconsortium.org/XMLSchema/SPIRIT/1685-2009")
    
    def parser(node: scala.xml.Node, stack: List[IPXACT2009scalaxb.ElemName]): Parser[VendorExtensions] =
      phrase(safeRep(any(_ => true)) ^^
      { case p1 =>
      VendorExtensions(p1 map { IPXACT2009scalaxb.fromXML[IPXACT2009scalaxb.DataRecord[Any]](_, IPXACT2009scalaxb.ElemName(node) :: stack) }) })
    
    def writesChildNodes(__obj: VendorExtensions, __scope: scala.xml.NamespaceBinding): Seq[scala.xml.Node] =
      (__obj.any flatMap { x => IPXACT2009scalaxb.toXML[IPXACT2009scalaxb.DataRecord[Any]](x, x.namespace, x.key, __scope, true) })
  }
  trait Default_ValueFormat extends IPXACT2009scalaxb.XMLFormat[Value] with IPXACT2009scalaxb.CanWriteChildNodes[Value] {
    val targetNamespace: Option[String] = Some("http://www.spiritconsortium.org/XMLSchema/SPIRIT/1685-2009")
    def reads(seq: scala.xml.NodeSeq, stack: List[IPXACT2009scalaxb.ElemName]): Either[String, Value] = seq match {
      case node: scala.xml.Node => Right(Value(IPXACT2009scalaxb.fromXML[String](node, IPXACT2009scalaxb.ElemName(node) :: stack),
        scala.collection.immutable.ListMap(List(
        (node \ "@{http://www.spiritconsortium.org/XMLSchema/SPIRIT/1685-2009}format").headOption map { x => IPXACT2009scalaxb.DataRecord(x, node, IPXACT2009scalaxb.fromXML[FormatType](x, IPXACT2009scalaxb.ElemName(node) :: stack)) } orElse Some(IPXACT2009scalaxb.DataRecord(None, None, IPXACT2009scalaxb.fromXML[FormatType](scala.xml.Text("string"), IPXACT2009scalaxb.ElemName(node) :: stack))) map { "@{http://www.spiritconsortium.org/XMLSchema/SPIRIT/1685-2009}format" -> _ },
        (node \ "@{http://www.spiritconsortium.org/XMLSchema/SPIRIT/1685-2009}resolve").headOption map { x => IPXACT2009scalaxb.DataRecord(x, node, IPXACT2009scalaxb.fromXML[ResolveType](x, IPXACT2009scalaxb.ElemName(node) :: stack)) } map { "@{http://www.spiritconsortium.org/XMLSchema/SPIRIT/1685-2009}resolve" -> _ },
        (node \ "@{http://www.spiritconsortium.org/XMLSchema/SPIRIT/1685-2009}id").headOption map { x => IPXACT2009scalaxb.DataRecord(x, node, IPXACT2009scalaxb.fromXML[String](x, IPXACT2009scalaxb.ElemName(node) :: stack)) } map { "@{http://www.spiritconsortium.org/XMLSchema/SPIRIT/1685-2009}id" -> _ },
        (node \ "@{http://www.spiritconsortium.org/XMLSchema/SPIRIT/1685-2009}dependency").headOption map { x => IPXACT2009scalaxb.DataRecord(x, node, IPXACT2009scalaxb.fromXML[String](x, IPXACT2009scalaxb.ElemName(node) :: stack)) } map { "@{http://www.spiritconsortium.org/XMLSchema/SPIRIT/1685-2009}dependency" -> _ },
        (node \ "@{http://www.spiritconsortium.org/XMLSchema/SPIRIT/1685-2009}choiceRef").headOption map { x => IPXACT2009scalaxb.DataRecord(x, node, IPXACT2009scalaxb.fromXML[String](x, IPXACT2009scalaxb.ElemName(node) :: stack)) } map { "@{http://www.spiritconsortium.org/XMLSchema/SPIRIT/1685-2009}choiceRef" -> _ },
        (node \ "@{http://www.spiritconsortium.org/XMLSchema/SPIRIT/1685-2009}order").headOption map { x => IPXACT2009scalaxb.DataRecord(x, node, IPXACT2009scalaxb.fromXML[Float](x, IPXACT2009scalaxb.ElemName(node) :: stack)) } map { "@{http://www.spiritconsortium.org/XMLSchema/SPIRIT/1685-2009}order" -> _ },
        (node \ "@{http://www.spiritconsortium.org/XMLSchema/SPIRIT/1685-2009}configGroups").headOption map { x => IPXACT2009scalaxb.DataRecord(x, node, IPXACT2009scalaxb.fromXML[Seq[String]](x, IPXACT2009scalaxb.ElemName(node) :: stack)) } map { "@{http://www.spiritconsortium.org/XMLSchema/SPIRIT/1685-2009}configGroups" -> _ },
        (node \ "@{http://www.spiritconsortium.org/XMLSchema/SPIRIT/1685-2009}bitStringLength").headOption map { x => IPXACT2009scalaxb.DataRecord(x, node, IPXACT2009scalaxb.fromXML[BigInt](x, IPXACT2009scalaxb.ElemName(node) :: stack)) } map { "@{http://www.spiritconsortium.org/XMLSchema/SPIRIT/1685-2009}bitStringLength" -> _ },
        (node \ "@{http://www.spiritconsortium.org/XMLSchema/SPIRIT/1685-2009}minimum").headOption map { x => IPXACT2009scalaxb.DataRecord(x, node, IPXACT2009scalaxb.fromXML[String](x, IPXACT2009scalaxb.ElemName(node) :: stack)) } map { "@{http://www.spiritconsortium.org/XMLSchema/SPIRIT/1685-2009}minimum" -> _ },
        (node \ "@{http://www.spiritconsortium.org/XMLSchema/SPIRIT/1685-2009}maximum").headOption map { x => IPXACT2009scalaxb.DataRecord(x, node, IPXACT2009scalaxb.fromXML[String](x, IPXACT2009scalaxb.ElemName(node) :: stack)) } map { "@{http://www.spiritconsortium.org/XMLSchema/SPIRIT/1685-2009}maximum" -> _ },
        (node \ "@{http://www.spiritconsortium.org/XMLSchema/SPIRIT/1685-2009}rangeType").headOption map { x => IPXACT2009scalaxb.DataRecord(x, node, IPXACT2009scalaxb.fromXML[RangeTypeType](x, IPXACT2009scalaxb.ElemName(node) :: stack)) } map { "@{http://www.spiritconsortium.org/XMLSchema/SPIRIT/1685-2009}rangeType" -> _ },
        (node \ "@{http://www.spiritconsortium.org/XMLSchema/SPIRIT/1685-2009}prompt").headOption map { x => IPXACT2009scalaxb.DataRecord(x, node, IPXACT2009scalaxb.fromXML[String](x, IPXACT2009scalaxb.ElemName(node) :: stack)) } map { "@{http://www.spiritconsortium.org/XMLSchema/SPIRIT/1685-2009}prompt" -> _ }
        ).flatten[(String, IPXACT2009scalaxb.DataRecord[Any])] ::: (node match {
          case elem: scala.xml.Elem =>
            elem.attributes.toList flatMap {
              case scala.xml.PrefixedAttribute(pre, key, value, _) if pre == elem.scope.getPrefix("http://www.spiritconsortium.org/XMLSchema/SPIRIT/1685-2009") &&
                key == "format" => Nil
              case scala.xml.PrefixedAttribute(pre, key, value, _) if pre == elem.scope.getPrefix("http://www.spiritconsortium.org/XMLSchema/SPIRIT/1685-2009") &&
                key == "resolve" => Nil
              case scala.xml.PrefixedAttribute(pre, key, value, _) if pre == elem.scope.getPrefix("http://www.spiritconsortium.org/XMLSchema/SPIRIT/1685-2009") &&
                key == "id" => Nil
              case scala.xml.PrefixedAttribute(pre, key, value, _) if pre == elem.scope.getPrefix("http://www.spiritconsortium.org/XMLSchema/SPIRIT/1685-2009") &&
                key == "dependency" => Nil
              case scala.xml.PrefixedAttribute(pre, key, value, _) if pre == elem.scope.getPrefix("http://www.spiritconsortium.org/XMLSchema/SPIRIT/1685-2009") &&
                key == "choiceRef" => Nil
              case scala.xml.PrefixedAttribute(pre, key, value, _) if pre == elem.scope.getPrefix("http://www.spiritconsortium.org/XMLSchema/SPIRIT/1685-2009") &&
                key == "order" => Nil
              case scala.xml.PrefixedAttribute(pre, key, value, _) if pre == elem.scope.getPrefix("http://www.spiritconsortium.org/XMLSchema/SPIRIT/1685-2009") &&
                key == "configGroups" => Nil
              case scala.xml.PrefixedAttribute(pre, key, value, _) if pre == elem.scope.getPrefix("http://www.spiritconsortium.org/XMLSchema/SPIRIT/1685-2009") &&
                key == "bitStringLength" => Nil
              case scala.xml.PrefixedAttribute(pre, key, value, _) if pre == elem.scope.getPrefix("http://www.spiritconsortium.org/XMLSchema/SPIRIT/1685-2009") &&
                key == "minimum" => Nil
              case scala.xml.PrefixedAttribute(pre, key, value, _) if pre == elem.scope.getPrefix("http://www.spiritconsortium.org/XMLSchema/SPIRIT/1685-2009") &&
                key == "maximum" => Nil
              case scala.xml.PrefixedAttribute(pre, key, value, _) if pre == elem.scope.getPrefix("http://www.spiritconsortium.org/XMLSchema/SPIRIT/1685-2009") &&
                key == "rangeType" => Nil
              case scala.xml.PrefixedAttribute(pre, key, value, _) if pre == elem.scope.getPrefix("http://www.spiritconsortium.org/XMLSchema/SPIRIT/1685-2009") &&
                key == "prompt" => Nil
              case scala.xml.UnprefixedAttribute(key, value, _) =>
                List(("@" + key, IPXACT2009scalaxb.DataRecord(None, Some(key), value.text)))
              case scala.xml.PrefixedAttribute(pre, key, value, _) =>
                val ns = elem.scope.getURI(pre)
                List(("@{" + ns + "}" + key, IPXACT2009scalaxb.DataRecord(Option[String](ns), Some(key), value.text)))
              case _ => Nil
            }
          case _ => Nil
        }): _*)))
      case _ => Left("reads failed: seq must be scala.xml.Node")
    }
    
    override def writesAttribute(__obj: Value, __scope: scala.xml.NamespaceBinding): scala.xml.MetaData = {
      var attr: scala.xml.MetaData  = scala.xml.Null
      __obj.attributes.toList map {
        case ("@{http://www.spiritconsortium.org/XMLSchema/SPIRIT/1685-2009}format", _) => if (__obj.spiritformat.toString != "string") attr = scala.xml.Attribute(__scope.getPrefix("http://www.spiritconsortium.org/XMLSchema/SPIRIT/1685-2009"), "format", __obj.spiritformat.toString, attr)
        case ("@{http://www.spiritconsortium.org/XMLSchema/SPIRIT/1685-2009}resolve", _) => __obj.spiritresolve foreach { x => attr = scala.xml.Attribute(__scope.getPrefix("http://www.spiritconsortium.org/XMLSchema/SPIRIT/1685-2009"), "resolve", x.toString, attr) }
        case ("@{http://www.spiritconsortium.org/XMLSchema/SPIRIT/1685-2009}id", _) => __obj.spiritid foreach { x => attr = scala.xml.Attribute(__scope.getPrefix("http://www.spiritconsortium.org/XMLSchema/SPIRIT/1685-2009"), "id", x.toString, attr) }
        case ("@{http://www.spiritconsortium.org/XMLSchema/SPIRIT/1685-2009}dependency", _) => __obj.spiritdependency foreach { x => attr = scala.xml.Attribute(__scope.getPrefix("http://www.spiritconsortium.org/XMLSchema/SPIRIT/1685-2009"), "dependency", x.toString, attr) }
        case ("@{http://www.spiritconsortium.org/XMLSchema/SPIRIT/1685-2009}choiceRef", _) => __obj.spiritchoiceRef foreach { x => attr = scala.xml.Attribute(__scope.getPrefix("http://www.spiritconsortium.org/XMLSchema/SPIRIT/1685-2009"), "choiceRef", x.toString, attr) }
        case ("@{http://www.spiritconsortium.org/XMLSchema/SPIRIT/1685-2009}order", _) => __obj.spiritorder foreach { x => attr = scala.xml.Attribute(__scope.getPrefix("http://www.spiritconsortium.org/XMLSchema/SPIRIT/1685-2009"), "order", x.toString, attr) }
        case ("@{http://www.spiritconsortium.org/XMLSchema/SPIRIT/1685-2009}configGroups", _) => __obj.spiritconfigGroups foreach { x => attr = scala.xml.Attribute(__scope.getPrefix("http://www.spiritconsortium.org/XMLSchema/SPIRIT/1685-2009"), "configGroups", x.toString, attr) }
        case ("@{http://www.spiritconsortium.org/XMLSchema/SPIRIT/1685-2009}bitStringLength", _) => __obj.spiritbitStringLength foreach { x => attr = scala.xml.Attribute(__scope.getPrefix("http://www.spiritconsortium.org/XMLSchema/SPIRIT/1685-2009"), "bitStringLength", x.toString, attr) }
        case ("@{http://www.spiritconsortium.org/XMLSchema/SPIRIT/1685-2009}minimum", _) => __obj.spiritminimum foreach { x => attr = scala.xml.Attribute(__scope.getPrefix("http://www.spiritconsortium.org/XMLSchema/SPIRIT/1685-2009"), "minimum", x.toString, attr) }
        case ("@{http://www.spiritconsortium.org/XMLSchema/SPIRIT/1685-2009}maximum", _) => __obj.spiritmaximum foreach { x => attr = scala.xml.Attribute(__scope.getPrefix("http://www.spiritconsortium.org/XMLSchema/SPIRIT/1685-2009"), "maximum", x.toString, attr) }
        case ("@{http://www.spiritconsortium.org/XMLSchema/SPIRIT/1685-2009}rangeType", _) => __obj.spiritrangeType foreach { x => attr = scala.xml.Attribute(__scope.getPrefix("http://www.spiritconsortium.org/XMLSchema/SPIRIT/1685-2009"), "rangeType", x.toString, attr) }
        case ("@{http://www.spiritconsortium.org/XMLSchema/SPIRIT/1685-2009}prompt", _) => __obj.spiritprompt foreach { x => attr = scala.xml.Attribute(__scope.getPrefix("http://www.spiritconsortium.org/XMLSchema/SPIRIT/1685-2009"), "prompt", x.toString, attr) }
        case (key, x) => attr = scala.xml.Attribute((x.namespace map { __scope.getPrefix(_) }).orNull, x.key.orNull, x.value.toString, attr)
      }
      attr
    }

    def writesChildNodes(__obj: Value, __scope: scala.xml.NamespaceBinding): Seq[scala.xml.Node] =
      Seq(scala.xml.Text(__obj.value.toString))

  }

  trait Default_NameValuePairTypableFormat extends IPXACT2009scalaxb.XMLFormat[NameValuePairTypable] {
    def reads(seq: scala.xml.NodeSeq, stack: List[IPXACT2009scalaxb.ElemName]): Either[String, NameValuePairTypable] = seq match {
      case node: scala.xml.Node =>     
        IPXACT2009scalaxb.Helper.instanceType(node) match {
          case (Some("http://www.spiritconsortium.org/XMLSchema/SPIRIT/1685-2009"), Some("nameValueTypeType")) => Right(IPXACT2009scalaxb.fromXML[NameValueTypeType](node, stack))
          case _ => Right(IPXACT2009scalaxb.fromXML[NameValuePairType](node, stack))
        }
      case _ => Left("reads failed: seq must be scala.xml.Node")  
    }
    
    def writes(__obj: NameValuePairTypable, __namespace: Option[String], __elementLabel: Option[String],
        __scope: scala.xml.NamespaceBinding, __typeAttribute: Boolean): scala.xml.NodeSeq = __obj match {
      case x: NameValueTypeType => IPXACT2009scalaxb.toXML[NameValueTypeType](x, __namespace, __elementLabel, __scope, true)
      case x: Argument => IPXACT2009scalaxb.toXML[Argument](x, __namespace, __elementLabel, __scope, true)
      case x: NameValuePairType => IPXACT2009scalaxb.toXML[NameValuePairType](x, __namespace, __elementLabel, __scope, __typeAttribute)
    }
  }

  trait Default_NameValuePairTypeFormat extends IPXACT2009scalaxb.ElemNameParser[NameValuePairType] with _NameGroupStringGroupFormat {
    val targetNamespace: Option[String] = Some("http://www.spiritconsortium.org/XMLSchema/SPIRIT/1685-2009")
    
    override def typeName: Option[String] = Some("nameValuePairType")

    def parser(node: scala.xml.Node, stack: List[IPXACT2009scalaxb.ElemName]): Parser[NameValuePairType] =
      phrase((parseNameGroupStringGroup(node, IPXACT2009scalaxb.ElemName(node) :: stack)) ~
      (IPXACT2009scalaxb.ElemName(Some("http://www.spiritconsortium.org/XMLSchema/SPIRIT/1685-2009"), "value")) ~
      opt(IPXACT2009scalaxb.ElemName(Some("http://www.spiritconsortium.org/XMLSchema/SPIRIT/1685-2009"), "vendorExtensions")) ^^
      { case p1 ~ p2 ~ p3 =>
      NameValuePairType(p1,
        IPXACT2009scalaxb.fromXML[Value](p2, IPXACT2009scalaxb.ElemName(node) :: stack),
        p3.headOption map { IPXACT2009scalaxb.fromXML[VendorExtensions](_, IPXACT2009scalaxb.ElemName(node) :: stack) },
        scala.collection.immutable.ListMap((node match {
          case elem: scala.xml.Elem =>
            elem.attributes.toList flatMap {
              
              case scala.xml.UnprefixedAttribute(key, value, _) =>
                List(("@" + key, IPXACT2009scalaxb.DataRecord(None, Some(key), value.text)))
              case scala.xml.PrefixedAttribute(pre, key, value, _) =>
                val ns = elem.scope.getURI(pre)
                List(("@{" + ns + "}" + key, IPXACT2009scalaxb.DataRecord(Option[String](ns), Some(key), value.text)))
              case _ => Nil
            }
          case _ => Nil
        }): _*)) })
    
    override def writesAttribute(__obj: NameValuePairType, __scope: scala.xml.NamespaceBinding): scala.xml.MetaData = {
      var attr: scala.xml.MetaData  = scala.xml.Null
      __obj.attributes.toList map {
        case (key, x) => attr = scala.xml.Attribute((x.namespace map { __scope.getPrefix(_) }).orNull, x.key.orNull, x.value.toString, attr)
      }
      attr
    }
    def writesChildNodes(__obj: NameValuePairType, __scope: scala.xml.NamespaceBinding): Seq[scala.xml.Node] =
      Seq.concat(IPXACT2009scalaxb.toXML[NameGroupStringSequence](__obj.nameGroupStringSequence1, None, Some("nameGroupStringSequence1"), __scope, false),
        IPXACT2009scalaxb.toXML[Value](__obj.value, Some("http://www.spiritconsortium.org/XMLSchema/SPIRIT/1685-2009"), Some("value"), __scope, false),
        __obj.vendorExtensions map { IPXACT2009scalaxb.toXML[VendorExtensions](_, Some("http://www.spiritconsortium.org/XMLSchema/SPIRIT/1685-2009"), Some("vendorExtensions"), __scope, false) } getOrElse {Nil})

  }


/** A group of elements for name(xs:string), displayName and description
*/
  trait _NameGroupStringGroupFormat extends IPXACT2009scalaxb.AnyElemNameParser {
    def parseNameGroupStringGroup(node: scala.xml.Node, stack: List[IPXACT2009scalaxb.ElemName]): Parser[NameGroupStringSequence] =
      (((IPXACT2009scalaxb.ElemName(Some("http://www.spiritconsortium.org/XMLSchema/SPIRIT/1685-2009"), "name")) ~
      opt(IPXACT2009scalaxb.ElemName(Some("http://www.spiritconsortium.org/XMLSchema/SPIRIT/1685-2009"), "displayName")) ~
      opt(IPXACT2009scalaxb.ElemName(Some("http://www.spiritconsortium.org/XMLSchema/SPIRIT/1685-2009"), "description"))) ^^
        { case p1 ~ p2 ~ p3 => NameGroupStringSequence(IPXACT2009scalaxb.fromXML[String](p1, IPXACT2009scalaxb.ElemName(node) :: stack),
        p2.headOption map { IPXACT2009scalaxb.fromXML[String](_, IPXACT2009scalaxb.ElemName(node) :: stack) },
        p3.headOption map { IPXACT2009scalaxb.fromXML[String](_, IPXACT2009scalaxb.ElemName(node) :: stack) }) })
  
    def parseNameGroupStringGroup(node: scala.xml.Node, stack: List[IPXACT2009scalaxb.ElemName], wrap: Boolean): Parser[IPXACT2009scalaxb.DataRecord[Any]] =
      (((IPXACT2009scalaxb.ElemName(Some("http://www.spiritconsortium.org/XMLSchema/SPIRIT/1685-2009"), "name")) ~
      opt(IPXACT2009scalaxb.ElemName(Some("http://www.spiritconsortium.org/XMLSchema/SPIRIT/1685-2009"), "displayName")) ~
      opt(IPXACT2009scalaxb.ElemName(Some("http://www.spiritconsortium.org/XMLSchema/SPIRIT/1685-2009"), "description"))) ^^
        { case p1 ~ p2 ~ p3 => IPXACT2009scalaxb.DataRecord(NameGroupStringSequence(IPXACT2009scalaxb.fromXML[String](p1, IPXACT2009scalaxb.ElemName(node) :: stack),
        p2.headOption map { IPXACT2009scalaxb.fromXML[String](_, IPXACT2009scalaxb.ElemName(node) :: stack) },
        p3.headOption map { IPXACT2009scalaxb.fromXML[String](_, IPXACT2009scalaxb.ElemName(node) :: stack) })) })
    
    def parsemixedNameGroupStringGroup(node: scala.xml.Node, stack: List[IPXACT2009scalaxb.ElemName]): Parser[Seq[IPXACT2009scalaxb.DataRecord[Any]]] =
      ((((IPXACT2009scalaxb.ElemName(Some("http://www.spiritconsortium.org/XMLSchema/SPIRIT/1685-2009"), "name")) ^^
      (x => IPXACT2009scalaxb.DataRecord(x.namespace, Some(x.name), IPXACT2009scalaxb.fromXML[String](x, IPXACT2009scalaxb.ElemName(node) :: stack)))) ~
      optTextRecord ~ 
      (opt(IPXACT2009scalaxb.ElemName(Some("http://www.spiritconsortium.org/XMLSchema/SPIRIT/1685-2009"), "displayName")) ^^
      (_ map { x => IPXACT2009scalaxb.DataRecord(x.namespace, Some(x.name), IPXACT2009scalaxb.fromXML[String](x, IPXACT2009scalaxb.ElemName(node) :: stack)) })) ~
      optTextRecord ~ 
      (opt(IPXACT2009scalaxb.ElemName(Some("http://www.spiritconsortium.org/XMLSchema/SPIRIT/1685-2009"), "description")) ^^
      (_ map { x => IPXACT2009scalaxb.DataRecord(x.namespace, Some(x.name), IPXACT2009scalaxb.fromXML[String](x, IPXACT2009scalaxb.ElemName(node) :: stack)) })) ~
      optTextRecord) ^^ 
        { case p1 ~ p2 ~ p3 ~ p4 ~ p5 ~ p6 => Seq.concat(Seq(p1),
        p2.toList,
        p3.toList,
        p4.toList,
        p5.toList,
        p6.toList) })
  }

  trait Default_NameGroupStringSequenceFormat extends IPXACT2009scalaxb.XMLFormat[NameGroupStringSequence] {
    def reads(seq: scala.xml.NodeSeq, stack: List[IPXACT2009scalaxb.ElemName]): Either[String, NameGroupStringSequence] = Left("don't call me.")
    
    def writes(__obj: NameGroupStringSequence, __namespace: Option[String], __elementLabel: Option[String], 
        __scope: scala.xml.NamespaceBinding, __typeAttribute: Boolean): scala.xml.NodeSeq =
      Seq.concat(IPXACT2009scalaxb.toXML[String](__obj.name, Some("http://www.spiritconsortium.org/XMLSchema/SPIRIT/1685-2009"), Some("name"), __scope, false),
        __obj.displayName map { IPXACT2009scalaxb.toXML[String](_, Some("http://www.spiritconsortium.org/XMLSchema/SPIRIT/1685-2009"), Some("displayName"), __scope, false) } getOrElse {Nil},
        __obj.description map { IPXACT2009scalaxb.toXML[String](_, Some("http://www.spiritconsortium.org/XMLSchema/SPIRIT/1685-2009"), Some("description"), __scope, false) } getOrElse {Nil})


  }


/** A group of elements for name(xs:NMTOKEN), displayName and description
*/
  trait _NameGroupNMTOKENGroupFormat extends IPXACT2009scalaxb.AnyElemNameParser {
    def parseNameGroupNMTOKENGroup(node: scala.xml.Node, stack: List[IPXACT2009scalaxb.ElemName]): Parser[NameGroupNMTOKENSequence] =
      (((IPXACT2009scalaxb.ElemName(Some("http://www.spiritconsortium.org/XMLSchema/SPIRIT/1685-2009"), "name")) ~
      opt(IPXACT2009scalaxb.ElemName(Some("http://www.spiritconsortium.org/XMLSchema/SPIRIT/1685-2009"), "displayName")) ~
      opt(IPXACT2009scalaxb.ElemName(Some("http://www.spiritconsortium.org/XMLSchema/SPIRIT/1685-2009"), "description"))) ^^
        { case p1 ~ p2 ~ p3 => NameGroupNMTOKENSequence(IPXACT2009scalaxb.fromXML[String](p1, IPXACT2009scalaxb.ElemName(node) :: stack),
        p2.headOption map { IPXACT2009scalaxb.fromXML[String](_, IPXACT2009scalaxb.ElemName(node) :: stack) },
        p3.headOption map { IPXACT2009scalaxb.fromXML[String](_, IPXACT2009scalaxb.ElemName(node) :: stack) }) })
  
    def parseNameGroupNMTOKENGroup(node: scala.xml.Node, stack: List[IPXACT2009scalaxb.ElemName], wrap: Boolean): Parser[IPXACT2009scalaxb.DataRecord[Any]] =
      (((IPXACT2009scalaxb.ElemName(Some("http://www.spiritconsortium.org/XMLSchema/SPIRIT/1685-2009"), "name")) ~
      opt(IPXACT2009scalaxb.ElemName(Some("http://www.spiritconsortium.org/XMLSchema/SPIRIT/1685-2009"), "displayName")) ~
      opt(IPXACT2009scalaxb.ElemName(Some("http://www.spiritconsortium.org/XMLSchema/SPIRIT/1685-2009"), "description"))) ^^
        { case p1 ~ p2 ~ p3 => IPXACT2009scalaxb.DataRecord(NameGroupNMTOKENSequence(IPXACT2009scalaxb.fromXML[String](p1, IPXACT2009scalaxb.ElemName(node) :: stack),
        p2.headOption map { IPXACT2009scalaxb.fromXML[String](_, IPXACT2009scalaxb.ElemName(node) :: stack) },
        p3.headOption map { IPXACT2009scalaxb.fromXML[String](_, IPXACT2009scalaxb.ElemName(node) :: stack) })) })
    
    def parsemixedNameGroupNMTOKENGroup(node: scala.xml.Node, stack: List[IPXACT2009scalaxb.ElemName]): Parser[Seq[IPXACT2009scalaxb.DataRecord[Any]]] =
      ((((IPXACT2009scalaxb.ElemName(Some("http://www.spiritconsortium.org/XMLSchema/SPIRIT/1685-2009"), "name")) ^^
      (x => IPXACT2009scalaxb.DataRecord(x.namespace, Some(x.name), IPXACT2009scalaxb.fromXML[String](x, IPXACT2009scalaxb.ElemName(node) :: stack)))) ~
      optTextRecord ~ 
      (opt(IPXACT2009scalaxb.ElemName(Some("http://www.spiritconsortium.org/XMLSchema/SPIRIT/1685-2009"), "displayName")) ^^
      (_ map { x => IPXACT2009scalaxb.DataRecord(x.namespace, Some(x.name), IPXACT2009scalaxb.fromXML[String](x, IPXACT2009scalaxb.ElemName(node) :: stack)) })) ~
      optTextRecord ~ 
      (opt(IPXACT2009scalaxb.ElemName(Some("http://www.spiritconsortium.org/XMLSchema/SPIRIT/1685-2009"), "description")) ^^
      (_ map { x => IPXACT2009scalaxb.DataRecord(x.namespace, Some(x.name), IPXACT2009scalaxb.fromXML[String](x, IPXACT2009scalaxb.ElemName(node) :: stack)) })) ~
      optTextRecord) ^^ 
        { case p1 ~ p2 ~ p3 ~ p4 ~ p5 ~ p6 => Seq.concat(Seq(p1),
        p2.toList,
        p3.toList,
        p4.toList,
        p5.toList,
        p6.toList) })
  }

  trait Default_NameGroupNMTOKENSequenceFormat extends IPXACT2009scalaxb.XMLFormat[NameGroupNMTOKENSequence] {
    def reads(seq: scala.xml.NodeSeq, stack: List[IPXACT2009scalaxb.ElemName]): Either[String, NameGroupNMTOKENSequence] = Left("don't call me.")
    
    def writes(__obj: NameGroupNMTOKENSequence, __namespace: Option[String], __elementLabel: Option[String], 
        __scope: scala.xml.NamespaceBinding, __typeAttribute: Boolean): scala.xml.NodeSeq =
      Seq.concat(IPXACT2009scalaxb.toXML[String](__obj.name, Some("http://www.spiritconsortium.org/XMLSchema/SPIRIT/1685-2009"), Some("name"), __scope, false),
        __obj.displayName map { IPXACT2009scalaxb.toXML[String](_, Some("http://www.spiritconsortium.org/XMLSchema/SPIRIT/1685-2009"), Some("displayName"), __scope, false) } getOrElse {Nil},
        __obj.description map { IPXACT2009scalaxb.toXML[String](_, Some("http://www.spiritconsortium.org/XMLSchema/SPIRIT/1685-2009"), Some("description"), __scope, false) } getOrElse {Nil})


  }


/** A group of elements for name (xs:name), displayName and description
*/
  trait _NameGroupGroupFormat extends IPXACT2009scalaxb.AnyElemNameParser {
    def parseNameGroupGroup(node: scala.xml.Node, stack: List[IPXACT2009scalaxb.ElemName]): Parser[NameGroupSequence] =
      (((IPXACT2009scalaxb.ElemName(Some("http://www.spiritconsortium.org/XMLSchema/SPIRIT/1685-2009"), "name")) ~
      opt(IPXACT2009scalaxb.ElemName(Some("http://www.spiritconsortium.org/XMLSchema/SPIRIT/1685-2009"), "displayName")) ~
      opt(IPXACT2009scalaxb.ElemName(Some("http://www.spiritconsortium.org/XMLSchema/SPIRIT/1685-2009"), "description"))) ^^
        { case p1 ~ p2 ~ p3 => NameGroupSequence(IPXACT2009scalaxb.fromXML[String](p1, IPXACT2009scalaxb.ElemName(node) :: stack),
        p2.headOption map { IPXACT2009scalaxb.fromXML[String](_, IPXACT2009scalaxb.ElemName(node) :: stack) },
        p3.headOption map { IPXACT2009scalaxb.fromXML[String](_, IPXACT2009scalaxb.ElemName(node) :: stack) }) })
  
    def parseNameGroupGroup(node: scala.xml.Node, stack: List[IPXACT2009scalaxb.ElemName], wrap: Boolean): Parser[IPXACT2009scalaxb.DataRecord[Any]] =
      (((IPXACT2009scalaxb.ElemName(Some("http://www.spiritconsortium.org/XMLSchema/SPIRIT/1685-2009"), "name")) ~
      opt(IPXACT2009scalaxb.ElemName(Some("http://www.spiritconsortium.org/XMLSchema/SPIRIT/1685-2009"), "displayName")) ~
      opt(IPXACT2009scalaxb.ElemName(Some("http://www.spiritconsortium.org/XMLSchema/SPIRIT/1685-2009"), "description"))) ^^
        { case p1 ~ p2 ~ p3 => IPXACT2009scalaxb.DataRecord(NameGroupSequence(IPXACT2009scalaxb.fromXML[String](p1, IPXACT2009scalaxb.ElemName(node) :: stack),
        p2.headOption map { IPXACT2009scalaxb.fromXML[String](_, IPXACT2009scalaxb.ElemName(node) :: stack) },
        p3.headOption map { IPXACT2009scalaxb.fromXML[String](_, IPXACT2009scalaxb.ElemName(node) :: stack) })) })
    
    def parsemixedNameGroupGroup(node: scala.xml.Node, stack: List[IPXACT2009scalaxb.ElemName]): Parser[Seq[IPXACT2009scalaxb.DataRecord[Any]]] =
      ((((IPXACT2009scalaxb.ElemName(Some("http://www.spiritconsortium.org/XMLSchema/SPIRIT/1685-2009"), "name")) ^^
      (x => IPXACT2009scalaxb.DataRecord(x.namespace, Some(x.name), IPXACT2009scalaxb.fromXML[String](x, IPXACT2009scalaxb.ElemName(node) :: stack)))) ~
      optTextRecord ~ 
      (opt(IPXACT2009scalaxb.ElemName(Some("http://www.spiritconsortium.org/XMLSchema/SPIRIT/1685-2009"), "displayName")) ^^
      (_ map { x => IPXACT2009scalaxb.DataRecord(x.namespace, Some(x.name), IPXACT2009scalaxb.fromXML[String](x, IPXACT2009scalaxb.ElemName(node) :: stack)) })) ~
      optTextRecord ~ 
      (opt(IPXACT2009scalaxb.ElemName(Some("http://www.spiritconsortium.org/XMLSchema/SPIRIT/1685-2009"), "description")) ^^
      (_ map { x => IPXACT2009scalaxb.DataRecord(x.namespace, Some(x.name), IPXACT2009scalaxb.fromXML[String](x, IPXACT2009scalaxb.ElemName(node) :: stack)) })) ~
      optTextRecord) ^^ 
        { case p1 ~ p2 ~ p3 ~ p4 ~ p5 ~ p6 => Seq.concat(Seq(p1),
        p2.toList,
        p3.toList,
        p4.toList,
        p5.toList,
        p6.toList) })
  }

  trait Default_NameGroupSequenceFormat extends IPXACT2009scalaxb.XMLFormat[NameGroupSequence] {
    def reads(seq: scala.xml.NodeSeq, stack: List[IPXACT2009scalaxb.ElemName]): Either[String, NameGroupSequence] = Left("don't call me.")
    
    def writes(__obj: NameGroupSequence, __namespace: Option[String], __elementLabel: Option[String], 
        __scope: scala.xml.NamespaceBinding, __typeAttribute: Boolean): scala.xml.NodeSeq =
      Seq.concat(IPXACT2009scalaxb.toXML[String](__obj.name, Some("http://www.spiritconsortium.org/XMLSchema/SPIRIT/1685-2009"), Some("name"), __scope, false),
        __obj.displayName map { IPXACT2009scalaxb.toXML[String](_, Some("http://www.spiritconsortium.org/XMLSchema/SPIRIT/1685-2009"), Some("displayName"), __scope, false) } getOrElse {Nil},
        __obj.description map { IPXACT2009scalaxb.toXML[String](_, Some("http://www.spiritconsortium.org/XMLSchema/SPIRIT/1685-2009"), Some("description"), __scope, false) } getOrElse {Nil})


  }


/** A group of elements for name (xs:name), displayName and description where the name is optional
*/
  trait _NameGroupOptionalGroupFormat extends IPXACT2009scalaxb.AnyElemNameParser {
    def parseNameGroupOptionalGroup(node: scala.xml.Node, stack: List[IPXACT2009scalaxb.ElemName]): Parser[NameGroupOptionalSequence] =
      ((opt(IPXACT2009scalaxb.ElemName(Some("http://www.spiritconsortium.org/XMLSchema/SPIRIT/1685-2009"), "name")) ~
      opt(IPXACT2009scalaxb.ElemName(Some("http://www.spiritconsortium.org/XMLSchema/SPIRIT/1685-2009"), "displayName")) ~
      opt(IPXACT2009scalaxb.ElemName(Some("http://www.spiritconsortium.org/XMLSchema/SPIRIT/1685-2009"), "description"))) ^^
        { case p1 ~ p2 ~ p3 => NameGroupOptionalSequence(p1.headOption map { IPXACT2009scalaxb.fromXML[String](_, IPXACT2009scalaxb.ElemName(node) :: stack) },
        p2.headOption map { IPXACT2009scalaxb.fromXML[String](_, IPXACT2009scalaxb.ElemName(node) :: stack) },
        p3.headOption map { IPXACT2009scalaxb.fromXML[String](_, IPXACT2009scalaxb.ElemName(node) :: stack) }) })
  
    def parseNameGroupOptionalGroup(node: scala.xml.Node, stack: List[IPXACT2009scalaxb.ElemName], wrap: Boolean): Parser[IPXACT2009scalaxb.DataRecord[Any]] =
      ((opt(IPXACT2009scalaxb.ElemName(Some("http://www.spiritconsortium.org/XMLSchema/SPIRIT/1685-2009"), "name")) ~
      opt(IPXACT2009scalaxb.ElemName(Some("http://www.spiritconsortium.org/XMLSchema/SPIRIT/1685-2009"), "displayName")) ~
      opt(IPXACT2009scalaxb.ElemName(Some("http://www.spiritconsortium.org/XMLSchema/SPIRIT/1685-2009"), "description"))) ^^
        { case p1 ~ p2 ~ p3 => IPXACT2009scalaxb.DataRecord(NameGroupOptionalSequence(p1.headOption map { IPXACT2009scalaxb.fromXML[String](_, IPXACT2009scalaxb.ElemName(node) :: stack) },
        p2.headOption map { IPXACT2009scalaxb.fromXML[String](_, IPXACT2009scalaxb.ElemName(node) :: stack) },
        p3.headOption map { IPXACT2009scalaxb.fromXML[String](_, IPXACT2009scalaxb.ElemName(node) :: stack) })) })
    
    def parsemixedNameGroupOptionalGroup(node: scala.xml.Node, stack: List[IPXACT2009scalaxb.ElemName]): Parser[Seq[IPXACT2009scalaxb.DataRecord[Any]]] =
      (((opt(IPXACT2009scalaxb.ElemName(Some("http://www.spiritconsortium.org/XMLSchema/SPIRIT/1685-2009"), "name")) ^^
      (_ map { x => IPXACT2009scalaxb.DataRecord(x.namespace, Some(x.name), IPXACT2009scalaxb.fromXML[String](x, IPXACT2009scalaxb.ElemName(node) :: stack)) })) ~
      optTextRecord ~ 
      (opt(IPXACT2009scalaxb.ElemName(Some("http://www.spiritconsortium.org/XMLSchema/SPIRIT/1685-2009"), "displayName")) ^^
      (_ map { x => IPXACT2009scalaxb.DataRecord(x.namespace, Some(x.name), IPXACT2009scalaxb.fromXML[String](x, IPXACT2009scalaxb.ElemName(node) :: stack)) })) ~
      optTextRecord ~ 
      (opt(IPXACT2009scalaxb.ElemName(Some("http://www.spiritconsortium.org/XMLSchema/SPIRIT/1685-2009"), "description")) ^^
      (_ map { x => IPXACT2009scalaxb.DataRecord(x.namespace, Some(x.name), IPXACT2009scalaxb.fromXML[String](x, IPXACT2009scalaxb.ElemName(node) :: stack)) })) ~
      optTextRecord) ^^ 
        { case p1 ~ p2 ~ p3 ~ p4 ~ p5 ~ p6 => Seq.concat(p1.toList,
        p2.toList,
        p3.toList,
        p4.toList,
        p5.toList,
        p6.toList) })
  }

  trait Default_NameGroupOptionalSequenceFormat extends IPXACT2009scalaxb.XMLFormat[NameGroupOptionalSequence] {
    def reads(seq: scala.xml.NodeSeq, stack: List[IPXACT2009scalaxb.ElemName]): Either[String, NameGroupOptionalSequence] = Left("don't call me.")
    
    def writes(__obj: NameGroupOptionalSequence, __namespace: Option[String], __elementLabel: Option[String], 
        __scope: scala.xml.NamespaceBinding, __typeAttribute: Boolean): scala.xml.NodeSeq =
      Seq.concat(__obj.name map { IPXACT2009scalaxb.toXML[String](_, Some("http://www.spiritconsortium.org/XMLSchema/SPIRIT/1685-2009"), Some("name"), __scope, false) } getOrElse {Nil},
        __obj.displayName map { IPXACT2009scalaxb.toXML[String](_, Some("http://www.spiritconsortium.org/XMLSchema/SPIRIT/1685-2009"), Some("displayName"), __scope, false) } getOrElse {Nil},
        __obj.description map { IPXACT2009scalaxb.toXML[String](_, Some("http://www.spiritconsortium.org/XMLSchema/SPIRIT/1685-2009"), Some("description"), __scope, false) } getOrElse {Nil})


  }


/** A group of elements for name(portName), displayName and description
*/
  trait _NameGroupPortGroupFormat extends IPXACT2009scalaxb.AnyElemNameParser {
    def parseNameGroupPortGroup(node: scala.xml.Node, stack: List[IPXACT2009scalaxb.ElemName]): Parser[NameGroupPortSequence] =
      (((IPXACT2009scalaxb.ElemName(Some("http://www.spiritconsortium.org/XMLSchema/SPIRIT/1685-2009"), "name")) ~
      opt(IPXACT2009scalaxb.ElemName(Some("http://www.spiritconsortium.org/XMLSchema/SPIRIT/1685-2009"), "displayName")) ~
      opt(IPXACT2009scalaxb.ElemName(Some("http://www.spiritconsortium.org/XMLSchema/SPIRIT/1685-2009"), "description"))) ^^
        { case p1 ~ p2 ~ p3 => NameGroupPortSequence(IPXACT2009scalaxb.fromXML[String](p1, IPXACT2009scalaxb.ElemName(node) :: stack),
        p2.headOption map { IPXACT2009scalaxb.fromXML[String](_, IPXACT2009scalaxb.ElemName(node) :: stack) },
        p3.headOption map { IPXACT2009scalaxb.fromXML[String](_, IPXACT2009scalaxb.ElemName(node) :: stack) }) })
  
    def parseNameGroupPortGroup(node: scala.xml.Node, stack: List[IPXACT2009scalaxb.ElemName], wrap: Boolean): Parser[IPXACT2009scalaxb.DataRecord[Any]] =
      (((IPXACT2009scalaxb.ElemName(Some("http://www.spiritconsortium.org/XMLSchema/SPIRIT/1685-2009"), "name")) ~
      opt(IPXACT2009scalaxb.ElemName(Some("http://www.spiritconsortium.org/XMLSchema/SPIRIT/1685-2009"), "displayName")) ~
      opt(IPXACT2009scalaxb.ElemName(Some("http://www.spiritconsortium.org/XMLSchema/SPIRIT/1685-2009"), "description"))) ^^
        { case p1 ~ p2 ~ p3 => IPXACT2009scalaxb.DataRecord(NameGroupPortSequence(IPXACT2009scalaxb.fromXML[String](p1, IPXACT2009scalaxb.ElemName(node) :: stack),
        p2.headOption map { IPXACT2009scalaxb.fromXML[String](_, IPXACT2009scalaxb.ElemName(node) :: stack) },
        p3.headOption map { IPXACT2009scalaxb.fromXML[String](_, IPXACT2009scalaxb.ElemName(node) :: stack) })) })
    
    def parsemixedNameGroupPortGroup(node: scala.xml.Node, stack: List[IPXACT2009scalaxb.ElemName]): Parser[Seq[IPXACT2009scalaxb.DataRecord[Any]]] =
      ((((IPXACT2009scalaxb.ElemName(Some("http://www.spiritconsortium.org/XMLSchema/SPIRIT/1685-2009"), "name")) ^^
      (x => IPXACT2009scalaxb.DataRecord(x.namespace, Some(x.name), IPXACT2009scalaxb.fromXML[String](x, IPXACT2009scalaxb.ElemName(node) :: stack)))) ~
      optTextRecord ~ 
      (opt(IPXACT2009scalaxb.ElemName(Some("http://www.spiritconsortium.org/XMLSchema/SPIRIT/1685-2009"), "displayName")) ^^
      (_ map { x => IPXACT2009scalaxb.DataRecord(x.namespace, Some(x.name), IPXACT2009scalaxb.fromXML[String](x, IPXACT2009scalaxb.ElemName(node) :: stack)) })) ~
      optTextRecord ~ 
      (opt(IPXACT2009scalaxb.ElemName(Some("http://www.spiritconsortium.org/XMLSchema/SPIRIT/1685-2009"), "description")) ^^
      (_ map { x => IPXACT2009scalaxb.DataRecord(x.namespace, Some(x.name), IPXACT2009scalaxb.fromXML[String](x, IPXACT2009scalaxb.ElemName(node) :: stack)) })) ~
      optTextRecord) ^^ 
        { case p1 ~ p2 ~ p3 ~ p4 ~ p5 ~ p6 => Seq.concat(Seq(p1),
        p2.toList,
        p3.toList,
        p4.toList,
        p5.toList,
        p6.toList) })
  }

  trait Default_NameGroupPortSequenceFormat extends IPXACT2009scalaxb.XMLFormat[NameGroupPortSequence] {
    def reads(seq: scala.xml.NodeSeq, stack: List[IPXACT2009scalaxb.ElemName]): Either[String, NameGroupPortSequence] = Left("don't call me.")
    
    def writes(__obj: NameGroupPortSequence, __namespace: Option[String], __elementLabel: Option[String], 
        __scope: scala.xml.NamespaceBinding, __typeAttribute: Boolean): scala.xml.NodeSeq =
      Seq.concat(IPXACT2009scalaxb.toXML[String](__obj.name, Some("http://www.spiritconsortium.org/XMLSchema/SPIRIT/1685-2009"), Some("name"), __scope, false),
        __obj.displayName map { IPXACT2009scalaxb.toXML[String](_, Some("http://www.spiritconsortium.org/XMLSchema/SPIRIT/1685-2009"), Some("displayName"), __scope, false) } getOrElse {Nil},
        __obj.description map { IPXACT2009scalaxb.toXML[String](_, Some("http://www.spiritconsortium.org/XMLSchema/SPIRIT/1685-2009"), Some("description"), __scope, false) } getOrElse {Nil})


  }

  trait Default_WhiteboxElementsFormat extends IPXACT2009scalaxb.ElemNameParser[WhiteboxElements] {
    val targetNamespace: Option[String] = Some("http://www.spiritconsortium.org/XMLSchema/SPIRIT/1685-2009")
    
    def parser(node: scala.xml.Node, stack: List[IPXACT2009scalaxb.ElemName]): Parser[WhiteboxElements] =
      phrase(safeRep(IPXACT2009scalaxb.ElemName(Some("http://www.spiritconsortium.org/XMLSchema/SPIRIT/1685-2009"), "whiteboxElement")) ^^
      { case p1 =>
      WhiteboxElements(p1 map { IPXACT2009scalaxb.fromXML[WhiteboxElementType](_, IPXACT2009scalaxb.ElemName(node) :: stack) }) })
    
    def writesChildNodes(__obj: WhiteboxElements, __scope: scala.xml.NamespaceBinding): Seq[scala.xml.Node] =
      (__obj.whiteboxElement flatMap { IPXACT2009scalaxb.toXML[WhiteboxElementType](_, Some("http://www.spiritconsortium.org/XMLSchema/SPIRIT/1685-2009"), Some("whiteboxElement"), __scope, false) })
  }
  trait Default_CpuFormat extends IPXACT2009scalaxb.ElemNameParser[Cpu] with _NameGroupGroupFormat {
    val targetNamespace: Option[String] = Some("http://www.spiritconsortium.org/XMLSchema/SPIRIT/1685-2009")
    
    def parser(node: scala.xml.Node, stack: List[IPXACT2009scalaxb.ElemName]): Parser[Cpu] =
      phrase((parseNameGroupGroup(node, IPXACT2009scalaxb.ElemName(node) :: stack)) ~
      safeRep(IPXACT2009scalaxb.ElemName(Some("http://www.spiritconsortium.org/XMLSchema/SPIRIT/1685-2009"), "addressSpaceRef")) ~
      opt(IPXACT2009scalaxb.ElemName(Some("http://www.spiritconsortium.org/XMLSchema/SPIRIT/1685-2009"), "parameters")) ~
      opt(IPXACT2009scalaxb.ElemName(Some("http://www.spiritconsortium.org/XMLSchema/SPIRIT/1685-2009"), "vendorExtensions")) ^^
      { case p1 ~ p2 ~ p3 ~ p4 =>
      Cpu(p1,
        p2 map { IPXACT2009scalaxb.fromXML[AddrSpaceRefTypable](_, IPXACT2009scalaxb.ElemName(node) :: stack) },
        p3.headOption map { IPXACT2009scalaxb.fromXML[Parameters](_, IPXACT2009scalaxb.ElemName(node) :: stack) },
        p4.headOption map { IPXACT2009scalaxb.fromXML[VendorExtensions](_, IPXACT2009scalaxb.ElemName(node) :: stack) }) })
    
    def writesChildNodes(__obj: Cpu, __scope: scala.xml.NamespaceBinding): Seq[scala.xml.Node] =
      Seq.concat(IPXACT2009scalaxb.toXML[NameGroupSequence](__obj.nameGroupSequence1, None, Some("nameGroupSequence1"), __scope, false),
        __obj.addressSpaceRef flatMap { IPXACT2009scalaxb.toXML[AddrSpaceRefTypable](_, Some("http://www.spiritconsortium.org/XMLSchema/SPIRIT/1685-2009"), Some("addressSpaceRef"), __scope, false) },
        __obj.parameters map { IPXACT2009scalaxb.toXML[Parameters](_, Some("http://www.spiritconsortium.org/XMLSchema/SPIRIT/1685-2009"), Some("parameters"), __scope, false) } getOrElse {Nil},
        __obj.vendorExtensions map { IPXACT2009scalaxb.toXML[VendorExtensions](_, Some("http://www.spiritconsortium.org/XMLSchema/SPIRIT/1685-2009"), Some("vendorExtensions"), __scope, false) } getOrElse {Nil})

  }

  trait Default_CpusFormat extends IPXACT2009scalaxb.ElemNameParser[Cpus] {
    val targetNamespace: Option[String] = Some("http://www.spiritconsortium.org/XMLSchema/SPIRIT/1685-2009")
    
    def parser(node: scala.xml.Node, stack: List[IPXACT2009scalaxb.ElemName]): Parser[Cpus] =
      phrase(safeRep(IPXACT2009scalaxb.ElemName(Some("http://www.spiritconsortium.org/XMLSchema/SPIRIT/1685-2009"), "cpu")) ^^
      { case p1 =>
      Cpus(p1 map { IPXACT2009scalaxb.fromXML[Cpu](_, IPXACT2009scalaxb.ElemName(node) :: stack) }) })
    
    def writesChildNodes(__obj: Cpus, __scope: scala.xml.NamespaceBinding): Seq[scala.xml.Node] =
      (__obj.cpu flatMap { IPXACT2009scalaxb.toXML[Cpu](_, Some("http://www.spiritconsortium.org/XMLSchema/SPIRIT/1685-2009"), Some("cpu"), __scope, false) })
  }
  trait Default_ComponentTypeFormat extends IPXACT2009scalaxb.ElemNameParser[ComponentType] with _VersionedIdentifierGroupFormat {
    val targetNamespace: Option[String] = Some("http://www.spiritconsortium.org/XMLSchema/SPIRIT/1685-2009")
    
    override def typeName: Option[String] = Some("componentType")

    def parser(node: scala.xml.Node, stack: List[IPXACT2009scalaxb.ElemName]): Parser[ComponentType] =
      phrase((parseVersionedIdentifierGroup(node, IPXACT2009scalaxb.ElemName(node) :: stack)) ~
      opt(IPXACT2009scalaxb.ElemName(Some("http://www.spiritconsortium.org/XMLSchema/SPIRIT/1685-2009"), "busInterfaces")) ~
      opt(IPXACT2009scalaxb.ElemName(Some("http://www.spiritconsortium.org/XMLSchema/SPIRIT/1685-2009"), "channels")) ~
      opt(IPXACT2009scalaxb.ElemName(Some("http://www.spiritconsortium.org/XMLSchema/SPIRIT/1685-2009"), "remapStates")) ~
      opt(IPXACT2009scalaxb.ElemName(Some("http://www.spiritconsortium.org/XMLSchema/SPIRIT/1685-2009"), "addressSpaces")) ~
      opt(IPXACT2009scalaxb.ElemName(Some("http://www.spiritconsortium.org/XMLSchema/SPIRIT/1685-2009"), "memoryMaps")) ~
      opt(IPXACT2009scalaxb.ElemName(Some("http://www.spiritconsortium.org/XMLSchema/SPIRIT/1685-2009"), "model")) ~
      opt(IPXACT2009scalaxb.ElemName(Some("http://www.spiritconsortium.org/XMLSchema/SPIRIT/1685-2009"), "componentGenerators")) ~
      opt(IPXACT2009scalaxb.ElemName(Some("http://www.spiritconsortium.org/XMLSchema/SPIRIT/1685-2009"), "choices")) ~
      opt(IPXACT2009scalaxb.ElemName(Some("http://www.spiritconsortium.org/XMLSchema/SPIRIT/1685-2009"), "fileSets")) ~
      opt(IPXACT2009scalaxb.ElemName(Some("http://www.spiritconsortium.org/XMLSchema/SPIRIT/1685-2009"), "whiteboxElements")) ~
      opt(IPXACT2009scalaxb.ElemName(Some("http://www.spiritconsortium.org/XMLSchema/SPIRIT/1685-2009"), "cpus")) ~
      opt(IPXACT2009scalaxb.ElemName(Some("http://www.spiritconsortium.org/XMLSchema/SPIRIT/1685-2009"), "otherClockDrivers")) ~
      opt(IPXACT2009scalaxb.ElemName(Some("http://www.spiritconsortium.org/XMLSchema/SPIRIT/1685-2009"), "description")) ~
      opt(IPXACT2009scalaxb.ElemName(Some("http://www.spiritconsortium.org/XMLSchema/SPIRIT/1685-2009"), "parameters")) ~
      opt(IPXACT2009scalaxb.ElemName(Some("http://www.spiritconsortium.org/XMLSchema/SPIRIT/1685-2009"), "vendorExtensions")) ^^
      { case p1 ~ p2 ~ p3 ~ p4 ~ p5 ~ p6 ~ p7 ~ p8 ~ p9 ~ p10 ~ p11 ~ p12 ~ p13 ~ p14 ~ p15 ~ p16 =>
      ComponentType(p1,
        p2.headOption map { IPXACT2009scalaxb.fromXML[BusInterfaces](_, IPXACT2009scalaxb.ElemName(node) :: stack) },
        p3.headOption map { IPXACT2009scalaxb.fromXML[Channels](_, IPXACT2009scalaxb.ElemName(node) :: stack) },
        p4.headOption map { IPXACT2009scalaxb.fromXML[RemapStates](_, IPXACT2009scalaxb.ElemName(node) :: stack) },
        p5.headOption map { IPXACT2009scalaxb.fromXML[AddressSpaces](_, IPXACT2009scalaxb.ElemName(node) :: stack) },
        p6.headOption map { IPXACT2009scalaxb.fromXML[MemoryMaps](_, IPXACT2009scalaxb.ElemName(node) :: stack) },
        p7.headOption map { IPXACT2009scalaxb.fromXML[ModelType](_, IPXACT2009scalaxb.ElemName(node) :: stack) },
        p8.headOption map { IPXACT2009scalaxb.fromXML[ComponentGenerators](_, IPXACT2009scalaxb.ElemName(node) :: stack) },
        p9.headOption map { IPXACT2009scalaxb.fromXML[Choices](_, IPXACT2009scalaxb.ElemName(node) :: stack) },
        p10.headOption map { IPXACT2009scalaxb.fromXML[FileSets](_, IPXACT2009scalaxb.ElemName(node) :: stack) },
        p11.headOption map { IPXACT2009scalaxb.fromXML[WhiteboxElements](_, IPXACT2009scalaxb.ElemName(node) :: stack) },
        p12.headOption map { IPXACT2009scalaxb.fromXML[Cpus](_, IPXACT2009scalaxb.ElemName(node) :: stack) },
        p13.headOption map { IPXACT2009scalaxb.fromXML[OtherClocks](_, IPXACT2009scalaxb.ElemName(node) :: stack) },
        p14.headOption map { IPXACT2009scalaxb.fromXML[String](_, IPXACT2009scalaxb.ElemName(node) :: stack) },
        p15.headOption map { IPXACT2009scalaxb.fromXML[Parameters](_, IPXACT2009scalaxb.ElemName(node) :: stack) },
        p16.headOption map { IPXACT2009scalaxb.fromXML[VendorExtensions](_, IPXACT2009scalaxb.ElemName(node) :: stack) }) })
    
    def writesChildNodes(__obj: ComponentType, __scope: scala.xml.NamespaceBinding): Seq[scala.xml.Node] =
      Seq.concat(IPXACT2009scalaxb.toXML[VersionedIdentifierSequence](__obj.versionedIdentifierSequence1, None, Some("versionedIdentifierSequence1"), __scope, false),
        __obj.busInterfaces map { IPXACT2009scalaxb.toXML[BusInterfaces](_, Some("http://www.spiritconsortium.org/XMLSchema/SPIRIT/1685-2009"), Some("busInterfaces"), __scope, false) } getOrElse {Nil},
        __obj.channels map { IPXACT2009scalaxb.toXML[Channels](_, Some("http://www.spiritconsortium.org/XMLSchema/SPIRIT/1685-2009"), Some("channels"), __scope, false) } getOrElse {Nil},
        __obj.remapStates map { IPXACT2009scalaxb.toXML[RemapStates](_, Some("http://www.spiritconsortium.org/XMLSchema/SPIRIT/1685-2009"), Some("remapStates"), __scope, false) } getOrElse {Nil},
        __obj.addressSpaces map { IPXACT2009scalaxb.toXML[AddressSpaces](_, Some("http://www.spiritconsortium.org/XMLSchema/SPIRIT/1685-2009"), Some("addressSpaces"), __scope, false) } getOrElse {Nil},
        __obj.memoryMaps map { IPXACT2009scalaxb.toXML[MemoryMaps](_, Some("http://www.spiritconsortium.org/XMLSchema/SPIRIT/1685-2009"), Some("memoryMaps"), __scope, false) } getOrElse {Nil},
        __obj.model map { IPXACT2009scalaxb.toXML[ModelType](_, Some("http://www.spiritconsortium.org/XMLSchema/SPIRIT/1685-2009"), Some("model"), __scope, false) } getOrElse {Nil},
        __obj.componentGenerators map { IPXACT2009scalaxb.toXML[ComponentGenerators](_, Some("http://www.spiritconsortium.org/XMLSchema/SPIRIT/1685-2009"), Some("componentGenerators"), __scope, false) } getOrElse {Nil},
        __obj.choices map { IPXACT2009scalaxb.toXML[Choices](_, Some("http://www.spiritconsortium.org/XMLSchema/SPIRIT/1685-2009"), Some("choices"), __scope, false) } getOrElse {Nil},
        __obj.fileSets map { IPXACT2009scalaxb.toXML[FileSets](_, Some("http://www.spiritconsortium.org/XMLSchema/SPIRIT/1685-2009"), Some("fileSets"), __scope, false) } getOrElse {Nil},
        __obj.whiteboxElements map { IPXACT2009scalaxb.toXML[WhiteboxElements](_, Some("http://www.spiritconsortium.org/XMLSchema/SPIRIT/1685-2009"), Some("whiteboxElements"), __scope, false) } getOrElse {Nil},
        __obj.cpus map { IPXACT2009scalaxb.toXML[Cpus](_, Some("http://www.spiritconsortium.org/XMLSchema/SPIRIT/1685-2009"), Some("cpus"), __scope, false) } getOrElse {Nil},
        __obj.otherClockDrivers map { IPXACT2009scalaxb.toXML[OtherClocks](_, Some("http://www.spiritconsortium.org/XMLSchema/SPIRIT/1685-2009"), Some("otherClockDrivers"), __scope, false) } getOrElse {Nil},
        __obj.description map { IPXACT2009scalaxb.toXML[String](_, Some("http://www.spiritconsortium.org/XMLSchema/SPIRIT/1685-2009"), Some("description"), __scope, false) } getOrElse {Nil},
        __obj.parameters map { IPXACT2009scalaxb.toXML[Parameters](_, Some("http://www.spiritconsortium.org/XMLSchema/SPIRIT/1685-2009"), Some("parameters"), __scope, false) } getOrElse {Nil},
        __obj.vendorExtensions map { IPXACT2009scalaxb.toXML[VendorExtensions](_, Some("http://www.spiritconsortium.org/XMLSchema/SPIRIT/1685-2009"), Some("vendorExtensions"), __scope, false) } getOrElse {Nil})

  }

  def build_WhiteboxTypeFormat = new Default_WhiteboxTypeFormat {}
  trait Default_WhiteboxTypeFormat extends IPXACT2009scalaxb.XMLFormat[WhiteboxType] {
    val targetNamespace: Option[String] = Some("http://www.spiritconsortium.org/XMLSchema/SPIRIT/1685-2009")
    
    def fromString(value: String, scope: scala.xml.NamespaceBinding): WhiteboxType =
        (fromString0(value, scope)).apply(IPXACT2009scalaxb.fromXML[String](scala.xml.Text(value)))

    private def fromString0(value: String, scope: scala.xml.NamespaceBinding): PartialFunction[Any, WhiteboxType] = {
      case x: String if x == IPXACT2009scalaxb.fromXML[String](scala.xml.Text("register")) => RegisterValue2
      case x: String if x == IPXACT2009scalaxb.fromXML[String](scala.xml.Text("signal")) => Signal
      case x: String if x == IPXACT2009scalaxb.fromXML[String](scala.xml.Text("pin")) => Pin
      case x: String if x == IPXACT2009scalaxb.fromXML[String](scala.xml.Text("interface")) => Interface

    }



    def reads(seq: scala.xml.NodeSeq, stack: List[IPXACT2009scalaxb.ElemName]): Either[String, WhiteboxType] = seq match {
      case elem: scala.xml.Elem => Right(fromString(elem.text, elem.scope))
      case _ => Right(fromString(seq.text, scala.xml.TopScope))
    }
    
    def writes(__obj: WhiteboxType, __namespace: Option[String], __elementLabel: Option[String],
        __scope: scala.xml.NamespaceBinding, __typeAttribute: Boolean): scala.xml.NodeSeq =
      scala.xml.Elem(IPXACT2009scalaxb.Helper.getPrefix(__namespace, __scope).orNull,
        __elementLabel getOrElse { sys.error("missing element label.") },
        scala.xml.Null, __scope, true, scala.xml.Text(__obj.toString))
  }
  trait Default_WhiteboxElementTypeFormat extends IPXACT2009scalaxb.ElemNameParser[WhiteboxElementType] with _NameGroupGroupFormat {
    val targetNamespace: Option[String] = Some("http://www.spiritconsortium.org/XMLSchema/SPIRIT/1685-2009")
    
    override def typeName: Option[String] = Some("whiteboxElementType")

    def parser(node: scala.xml.Node, stack: List[IPXACT2009scalaxb.ElemName]): Parser[WhiteboxElementType] =
      phrase((parseNameGroupGroup(node, IPXACT2009scalaxb.ElemName(node) :: stack)) ~
      (IPXACT2009scalaxb.ElemName(Some("http://www.spiritconsortium.org/XMLSchema/SPIRIT/1685-2009"), "whiteboxType")) ~
      opt(IPXACT2009scalaxb.ElemName(Some("http://www.spiritconsortium.org/XMLSchema/SPIRIT/1685-2009"), "driveable")) ~
      opt(IPXACT2009scalaxb.ElemName(Some("http://www.spiritconsortium.org/XMLSchema/SPIRIT/1685-2009"), "registerRef")) ~
      opt(IPXACT2009scalaxb.ElemName(Some("http://www.spiritconsortium.org/XMLSchema/SPIRIT/1685-2009"), "parameters")) ~
      opt(IPXACT2009scalaxb.ElemName(Some("http://www.spiritconsortium.org/XMLSchema/SPIRIT/1685-2009"), "vendorExtensions")) ^^
      { case p1 ~ p2 ~ p3 ~ p4 ~ p5 ~ p6 =>
      WhiteboxElementType(p1,
        IPXACT2009scalaxb.fromXML[WhiteboxType](p2, IPXACT2009scalaxb.ElemName(node) :: stack),
        p3.headOption map { IPXACT2009scalaxb.fromXML[Boolean](_, IPXACT2009scalaxb.ElemName(node) :: stack) },
        p4.headOption map { IPXACT2009scalaxb.fromXML[String](_, IPXACT2009scalaxb.ElemName(node) :: stack) },
        p5.headOption map { IPXACT2009scalaxb.fromXML[Parameters](_, IPXACT2009scalaxb.ElemName(node) :: stack) },
        p6.headOption map { IPXACT2009scalaxb.fromXML[VendorExtensions](_, IPXACT2009scalaxb.ElemName(node) :: stack) }) })
    
    def writesChildNodes(__obj: WhiteboxElementType, __scope: scala.xml.NamespaceBinding): Seq[scala.xml.Node] =
      Seq.concat(IPXACT2009scalaxb.toXML[NameGroupSequence](__obj.nameGroupSequence1, None, Some("nameGroupSequence1"), __scope, false),
        IPXACT2009scalaxb.toXML[WhiteboxType](__obj.whiteboxType, Some("http://www.spiritconsortium.org/XMLSchema/SPIRIT/1685-2009"), Some("whiteboxType"), __scope, false),
        __obj.driveable map { IPXACT2009scalaxb.toXML[Boolean](_, Some("http://www.spiritconsortium.org/XMLSchema/SPIRIT/1685-2009"), Some("driveable"), __scope, false) } getOrElse {Nil},
        __obj.registerRef map { IPXACT2009scalaxb.toXML[String](_, Some("http://www.spiritconsortium.org/XMLSchema/SPIRIT/1685-2009"), Some("registerRef"), __scope, false) } getOrElse {Nil},
        __obj.parameters map { IPXACT2009scalaxb.toXML[Parameters](_, Some("http://www.spiritconsortium.org/XMLSchema/SPIRIT/1685-2009"), Some("parameters"), __scope, false) } getOrElse {Nil},
        __obj.vendorExtensions map { IPXACT2009scalaxb.toXML[VendorExtensions](_, Some("http://www.spiritconsortium.org/XMLSchema/SPIRIT/1685-2009"), Some("vendorExtensions"), __scope, false) } getOrElse {Nil})

  }

  def build_ResolveTypeFormat = new Default_ResolveTypeFormat {}
  trait Default_ResolveTypeFormat extends IPXACT2009scalaxb.XMLFormat[ResolveType] {
    val targetNamespace: Option[String] = Some("http://www.spiritconsortium.org/XMLSchema/SPIRIT/1685-2009")
    
    def fromString(value: String, scope: scala.xml.NamespaceBinding): ResolveType =
        (fromString0(value, scope)).apply(IPXACT2009scalaxb.fromXML[String](scala.xml.Text(value)))

    private def fromString0(value: String, scope: scala.xml.NamespaceBinding): PartialFunction[Any, ResolveType] = {
      case x: String if x == IPXACT2009scalaxb.fromXML[String](scala.xml.Text("immediate")) => Immediate
      case x: String if x == IPXACT2009scalaxb.fromXML[String](scala.xml.Text("user")) => User
      case x: String if x == IPXACT2009scalaxb.fromXML[String](scala.xml.Text("dependent")) => Dependent
      case x: String if x == IPXACT2009scalaxb.fromXML[String](scala.xml.Text("generated")) => Generated

    }



    def reads(seq: scala.xml.NodeSeq, stack: List[IPXACT2009scalaxb.ElemName]): Either[String, ResolveType] = seq match {
      case elem: scala.xml.Elem => Right(fromString(elem.text, elem.scope))
      case _ => Right(fromString(seq.text, scala.xml.TopScope))
    }
    
    def writes(__obj: ResolveType, __namespace: Option[String], __elementLabel: Option[String],
        __scope: scala.xml.NamespaceBinding, __typeAttribute: Boolean): scala.xml.NodeSeq =
      scala.xml.Elem(IPXACT2009scalaxb.Helper.getPrefix(__namespace, __scope).orNull,
        __elementLabel getOrElse { sys.error("missing element label.") },
        scala.xml.Null, __scope, true, scala.xml.Text(__obj.toString))
  }
  trait Default_ConfigurableFormat extends IPXACT2009scalaxb.AttributeGroupFormat[Configurable] {
    val targetNamespace: Option[String] = Some("http://www.spiritconsortium.org/XMLSchema/SPIRIT/1685-2009")
    
    def reads(seq: scala.xml.NodeSeq, stack: List[IPXACT2009scalaxb.ElemName]): Either[String, Configurable] = seq match {
      case node: scala.xml.Node => Right(Configurable((node \ "@{http://www.spiritconsortium.org/XMLSchema/SPIRIT/1685-2009}resolve").headOption map { IPXACT2009scalaxb.fromXML[ResolveType](_, IPXACT2009scalaxb.ElemName(node) :: stack) },
      (node \ "@{http://www.spiritconsortium.org/XMLSchema/SPIRIT/1685-2009}id").headOption map { IPXACT2009scalaxb.fromXML[String](_, IPXACT2009scalaxb.ElemName(node) :: stack) },
      (node \ "@{http://www.spiritconsortium.org/XMLSchema/SPIRIT/1685-2009}dependency").headOption map { IPXACT2009scalaxb.fromXML[String](_, IPXACT2009scalaxb.ElemName(node) :: stack) },
      scala.collection.immutable.ListMap((node match {
          case elem: scala.xml.Elem =>
            elem.attributes.toList flatMap {
              case scala.xml.PrefixedAttribute(pre, key, value, _) if pre == elem.scope.getPrefix("http://www.spiritconsortium.org/XMLSchema/SPIRIT/1685-2009") &&
                key == "resolve" => Nil
              case scala.xml.PrefixedAttribute(pre, key, value, _) if pre == elem.scope.getPrefix("http://www.spiritconsortium.org/XMLSchema/SPIRIT/1685-2009") &&
                key == "id" => Nil
              case scala.xml.PrefixedAttribute(pre, key, value, _) if pre == elem.scope.getPrefix("http://www.spiritconsortium.org/XMLSchema/SPIRIT/1685-2009") &&
                key == "dependency" => Nil
              case scala.xml.UnprefixedAttribute(key, value, _) =>
                List(("@" + key, IPXACT2009scalaxb.DataRecord(None, Some(key), value.text)))
              case scala.xml.PrefixedAttribute(pre, key, value, _) =>
                val ns = elem.scope.getURI(pre)
                List(("@{" + ns + "}" + key, IPXACT2009scalaxb.DataRecord(Option[String](ns), Some(key), value.text)))
              case _ => Nil
            }
          case _ => Nil
        }): _*)))
      case _ => Left("reads failed: seq must be scala.xml.Node")
    }
    
    def toAttribute(__obj: Configurable, __attr: scala.xml.MetaData, __scope: scala.xml.NamespaceBinding): scala.xml.MetaData = {
      var attr: scala.xml.MetaData  = __attr
      __obj.spiritresolve foreach { x => attr = scala.xml.Attribute(__scope.getPrefix("http://www.spiritconsortium.org/XMLSchema/SPIRIT/1685-2009"), "resolve", x.toString, attr) }
    __obj.spiritid foreach { x => attr = scala.xml.Attribute(__scope.getPrefix("http://www.spiritconsortium.org/XMLSchema/SPIRIT/1685-2009"), "id", x.toString, attr) }
    __obj.spiritdependency foreach { x => attr = scala.xml.Attribute(__scope.getPrefix("http://www.spiritconsortium.org/XMLSchema/SPIRIT/1685-2009"), "dependency", x.toString, attr) }
    __obj.attributes.toList map {
        case (key, x) => attr = scala.xml.Attribute((x.namespace map { __scope.getPrefix(_) }).orNull, x.key.orNull, x.value.toString, attr) }
      attr
    }
  }

  def build_CellFunctionValueTypeFormat = new Default_CellFunctionValueTypeFormat {}
  trait Default_CellFunctionValueTypeFormat extends IPXACT2009scalaxb.XMLFormat[CellFunctionValueType] {
    val targetNamespace: Option[String] = Some("http://www.spiritconsortium.org/XMLSchema/SPIRIT/1685-2009")
    
    def fromString(value: String, scope: scala.xml.NamespaceBinding): CellFunctionValueType =
        (fromString0(value, scope)).apply(IPXACT2009scalaxb.fromXML[String](scala.xml.Text(value)))

    private def fromString0(value: String, scope: scala.xml.NamespaceBinding): PartialFunction[Any, CellFunctionValueType] = {
      case x: String if x == IPXACT2009scalaxb.fromXML[String](scala.xml.Text("nand2")) => Nand2
      case x: String if x == IPXACT2009scalaxb.fromXML[String](scala.xml.Text("buf")) => Buf
      case x: String if x == IPXACT2009scalaxb.fromXML[String](scala.xml.Text("inv")) => Inv
      case x: String if x == IPXACT2009scalaxb.fromXML[String](scala.xml.Text("mux21")) => Mux21
      case x: String if x == IPXACT2009scalaxb.fromXML[String](scala.xml.Text("dff")) => Dff
      case x: String if x == IPXACT2009scalaxb.fromXML[String](scala.xml.Text("latch")) => Latch
      case x: String if x == IPXACT2009scalaxb.fromXML[String](scala.xml.Text("xor2")) => Xor2

    }



    def reads(seq: scala.xml.NodeSeq, stack: List[IPXACT2009scalaxb.ElemName]): Either[String, CellFunctionValueType] = seq match {
      case elem: scala.xml.Elem => Right(fromString(elem.text, elem.scope))
      case _ => Right(fromString(seq.text, scala.xml.TopScope))
    }
    
    def writes(__obj: CellFunctionValueType, __namespace: Option[String], __elementLabel: Option[String],
        __scope: scala.xml.NamespaceBinding, __typeAttribute: Boolean): scala.xml.NodeSeq =
      scala.xml.Elem(IPXACT2009scalaxb.Helper.getPrefix(__namespace, __scope).orNull,
        __elementLabel getOrElse { sys.error("missing element label.") },
        scala.xml.Null, __scope, true, scala.xml.Text(__obj.toString))
  }
  def build_CellClassValueTypeFormat = new Default_CellClassValueTypeFormat {}
  trait Default_CellClassValueTypeFormat extends IPXACT2009scalaxb.XMLFormat[CellClassValueType] {
    val targetNamespace: Option[String] = Some("http://www.spiritconsortium.org/XMLSchema/SPIRIT/1685-2009")
    
    def fromString(value: String, scope: scala.xml.NamespaceBinding): CellClassValueType =
        (fromString0(value, scope)).apply(IPXACT2009scalaxb.fromXML[String](scala.xml.Text(value)))

    private def fromString0(value: String, scope: scala.xml.NamespaceBinding): PartialFunction[Any, CellClassValueType] = {
      case x: String if x == IPXACT2009scalaxb.fromXML[String](scala.xml.Text("combinational")) => Combinational
      case x: String if x == IPXACT2009scalaxb.fromXML[String](scala.xml.Text("sequential")) => Sequential

    }



    def reads(seq: scala.xml.NodeSeq, stack: List[IPXACT2009scalaxb.ElemName]): Either[String, CellClassValueType] = seq match {
      case elem: scala.xml.Elem => Right(fromString(elem.text, elem.scope))
      case _ => Right(fromString(seq.text, scala.xml.TopScope))
    }
    
    def writes(__obj: CellClassValueType, __namespace: Option[String], __elementLabel: Option[String],
        __scope: scala.xml.NamespaceBinding, __typeAttribute: Boolean): scala.xml.NodeSeq =
      scala.xml.Elem(IPXACT2009scalaxb.Helper.getPrefix(__namespace, __scope).orNull,
        __elementLabel getOrElse { sys.error("missing element label.") },
        scala.xml.Null, __scope, true, scala.xml.Text(__obj.toString))
  }
  def build_CellStrengthValueTypeFormat = new Default_CellStrengthValueTypeFormat {}
  trait Default_CellStrengthValueTypeFormat extends IPXACT2009scalaxb.XMLFormat[CellStrengthValueType] {
    val targetNamespace: Option[String] = Some("http://www.spiritconsortium.org/XMLSchema/SPIRIT/1685-2009")
    
    def fromString(value: String, scope: scala.xml.NamespaceBinding): CellStrengthValueType =
        (fromString0(value, scope)).apply(IPXACT2009scalaxb.fromXML[String](scala.xml.Text(value)))

    private def fromString0(value: String, scope: scala.xml.NamespaceBinding): PartialFunction[Any, CellStrengthValueType] = {
      case x: String if x == IPXACT2009scalaxb.fromXML[String](scala.xml.Text("low")) => Low
      case x: String if x == IPXACT2009scalaxb.fromXML[String](scala.xml.Text("median")) => Median
      case x: String if x == IPXACT2009scalaxb.fromXML[String](scala.xml.Text("high")) => High

    }



    def reads(seq: scala.xml.NodeSeq, stack: List[IPXACT2009scalaxb.ElemName]): Either[String, CellStrengthValueType] = seq match {
      case elem: scala.xml.Elem => Right(fromString(elem.text, elem.scope))
      case _ => Right(fromString(seq.text, scala.xml.TopScope))
    }
    
    def writes(__obj: CellStrengthValueType, __namespace: Option[String], __elementLabel: Option[String],
        __scope: scala.xml.NamespaceBinding, __typeAttribute: Boolean): scala.xml.NodeSeq =
      scala.xml.Elem(IPXACT2009scalaxb.Helper.getPrefix(__namespace, __scope).orNull,
        __elementLabel getOrElse { sys.error("missing element label.") },
        scala.xml.Null, __scope, true, scala.xml.Text(__obj.toString))
  }
  def build_EdgeValueTypeFormat = new Default_EdgeValueTypeFormat {}
  trait Default_EdgeValueTypeFormat extends IPXACT2009scalaxb.XMLFormat[EdgeValueType] {
    val targetNamespace: Option[String] = Some("http://www.spiritconsortium.org/XMLSchema/SPIRIT/1685-2009")
    
    def fromString(value: String, scope: scala.xml.NamespaceBinding): EdgeValueType =
        (fromString0(value, scope)).apply(IPXACT2009scalaxb.fromXML[String](scala.xml.Text(value)))

    private def fromString0(value: String, scope: scala.xml.NamespaceBinding): PartialFunction[Any, EdgeValueType] = {
      case x: String if x == IPXACT2009scalaxb.fromXML[String](scala.xml.Text("rise")) => Rise
      case x: String if x == IPXACT2009scalaxb.fromXML[String](scala.xml.Text("fall")) => Fall

    }



    def reads(seq: scala.xml.NodeSeq, stack: List[IPXACT2009scalaxb.ElemName]): Either[String, EdgeValueType] = seq match {
      case elem: scala.xml.Elem => Right(fromString(elem.text, elem.scope))
      case _ => Right(fromString(seq.text, scala.xml.TopScope))
    }
    
    def writes(__obj: EdgeValueType, __namespace: Option[String], __elementLabel: Option[String],
        __scope: scala.xml.NamespaceBinding, __typeAttribute: Boolean): scala.xml.NodeSeq =
      scala.xml.Elem(IPXACT2009scalaxb.Helper.getPrefix(__namespace, __scope).orNull,
        __elementLabel getOrElse { sys.error("missing element label.") },
        scala.xml.Null, __scope, true, scala.xml.Text(__obj.toString))
  }
  def build_DelayValueTypeFormat = new Default_DelayValueTypeFormat {}
  trait Default_DelayValueTypeFormat extends IPXACT2009scalaxb.XMLFormat[DelayValueType] {
    val targetNamespace: Option[String] = Some("http://www.spiritconsortium.org/XMLSchema/SPIRIT/1685-2009")
    
    def fromString(value: String, scope: scala.xml.NamespaceBinding): DelayValueType =
        (fromString0(value, scope)).apply(IPXACT2009scalaxb.fromXML[String](scala.xml.Text(value)))

    private def fromString0(value: String, scope: scala.xml.NamespaceBinding): PartialFunction[Any, DelayValueType] = {
      case x: String if x == IPXACT2009scalaxb.fromXML[String](scala.xml.Text("min")) => Min
      case x: String if x == IPXACT2009scalaxb.fromXML[String](scala.xml.Text("max")) => Max

    }



    def reads(seq: scala.xml.NodeSeq, stack: List[IPXACT2009scalaxb.ElemName]): Either[String, DelayValueType] = seq match {
      case elem: scala.xml.Elem => Right(fromString(elem.text, elem.scope))
      case _ => Right(fromString(seq.text, scala.xml.TopScope))
    }
    
    def writes(__obj: DelayValueType, __namespace: Option[String], __elementLabel: Option[String],
        __scope: scala.xml.NamespaceBinding, __typeAttribute: Boolean): scala.xml.NodeSeq =
      scala.xml.Elem(IPXACT2009scalaxb.Helper.getPrefix(__namespace, __scope).orNull,
        __elementLabel getOrElse { sys.error("missing element label.") },
        scala.xml.Null, __scope, true, scala.xml.Text(__obj.toString))
  }
  trait Default_OtherClocksFormat extends IPXACT2009scalaxb.ElemNameParser[OtherClocks] {
    val targetNamespace: Option[String] = Some("http://www.spiritconsortium.org/XMLSchema/SPIRIT/1685-2009")
    
    override def typeName: Option[String] = Some("otherClocks")

    def parser(node: scala.xml.Node, stack: List[IPXACT2009scalaxb.ElemName]): Parser[OtherClocks] =
      phrase(safeRep(IPXACT2009scalaxb.ElemName(Some("http://www.spiritconsortium.org/XMLSchema/SPIRIT/1685-2009"), "otherClockDriver")) ^^
      { case p1 =>
      OtherClocks(p1 map { IPXACT2009scalaxb.fromXML[OtherClockDriver](_, IPXACT2009scalaxb.ElemName(node) :: stack) }) })
    
    def writesChildNodes(__obj: OtherClocks, __scope: scala.xml.NamespaceBinding): Seq[scala.xml.Node] =
      (__obj.otherClockDriver flatMap { IPXACT2009scalaxb.toXML[OtherClockDriver](_, Some("http://www.spiritconsortium.org/XMLSchema/SPIRIT/1685-2009"), Some("otherClockDriver"), __scope, false) })
  }

  trait Default_CellFunctionFormat extends IPXACT2009scalaxb.XMLFormat[CellFunction] with IPXACT2009scalaxb.CanWriteChildNodes[CellFunction] {
    val targetNamespace: Option[String] = Some("http://www.spiritconsortium.org/XMLSchema/SPIRIT/1685-2009")
    def reads(seq: scala.xml.NodeSeq, stack: List[IPXACT2009scalaxb.ElemName]): Either[String, CellFunction] = seq match {
      case node: scala.xml.Node => Right(CellFunction(IPXACT2009scalaxb.fromXML[CellFunctionValueType](node, IPXACT2009scalaxb.ElemName(node) :: stack),
        scala.collection.immutable.ListMap(List(
        (node \ "@{http://www.spiritconsortium.org/XMLSchema/SPIRIT/1685-2009}cellStrength").headOption map { x => IPXACT2009scalaxb.DataRecord(x, node, IPXACT2009scalaxb.fromXML[CellStrengthValueType](x, IPXACT2009scalaxb.ElemName(node) :: stack)) } map { "@{http://www.spiritconsortium.org/XMLSchema/SPIRIT/1685-2009}cellStrength" -> _ }
        ).flatten[(String, IPXACT2009scalaxb.DataRecord[Any])]: _*)))
      case _ => Left("reads failed: seq must be scala.xml.Node")
    }
    
    override def writesAttribute(__obj: CellFunction, __scope: scala.xml.NamespaceBinding): scala.xml.MetaData = {
      var attr: scala.xml.MetaData  = scala.xml.Null
      __obj.attributes.toList map {
        case ("@{http://www.spiritconsortium.org/XMLSchema/SPIRIT/1685-2009}cellStrength", _) => __obj.spiritcellStrength foreach { x => attr = scala.xml.Attribute(__scope.getPrefix("http://www.spiritconsortium.org/XMLSchema/SPIRIT/1685-2009"), "cellStrength", x.toString, attr) }
        case (key, x) => attr = scala.xml.Attribute((x.namespace map { __scope.getPrefix(_) }).orNull, x.key.orNull, x.value.toString, attr)
      }
      attr
    }

    def writesChildNodes(__obj: CellFunction, __scope: scala.xml.NamespaceBinding): Seq[scala.xml.Node] =
      Seq(scala.xml.Text(__obj.value.toString))

  }

  trait Default_CellClassFormat extends IPXACT2009scalaxb.XMLFormat[CellClass] with IPXACT2009scalaxb.CanWriteChildNodes[CellClass] {
    val targetNamespace: Option[String] = Some("http://www.spiritconsortium.org/XMLSchema/SPIRIT/1685-2009")
    def reads(seq: scala.xml.NodeSeq, stack: List[IPXACT2009scalaxb.ElemName]): Either[String, CellClass] = seq match {
      case node: scala.xml.Node => Right(CellClass(IPXACT2009scalaxb.fromXML[CellClassValueType](node, IPXACT2009scalaxb.ElemName(node) :: stack),
        scala.collection.immutable.ListMap(List(
        (node \ "@{http://www.spiritconsortium.org/XMLSchema/SPIRIT/1685-2009}cellStrength").headOption map { x => IPXACT2009scalaxb.DataRecord(x, node, IPXACT2009scalaxb.fromXML[CellStrengthValueType](x, IPXACT2009scalaxb.ElemName(node) :: stack)) } map { "@{http://www.spiritconsortium.org/XMLSchema/SPIRIT/1685-2009}cellStrength" -> _ }
        ).flatten[(String, IPXACT2009scalaxb.DataRecord[Any])]: _*)))
      case _ => Left("reads failed: seq must be scala.xml.Node")
    }
    
    override def writesAttribute(__obj: CellClass, __scope: scala.xml.NamespaceBinding): scala.xml.MetaData = {
      var attr: scala.xml.MetaData  = scala.xml.Null
      __obj.attributes.toList map {
        case ("@{http://www.spiritconsortium.org/XMLSchema/SPIRIT/1685-2009}cellStrength", _) => __obj.spiritcellStrength foreach { x => attr = scala.xml.Attribute(__scope.getPrefix("http://www.spiritconsortium.org/XMLSchema/SPIRIT/1685-2009"), "cellStrength", x.toString, attr) }
        case (key, x) => attr = scala.xml.Attribute((x.namespace map { __scope.getPrefix(_) }).orNull, x.key.orNull, x.value.toString, attr)
      }
      attr
    }

    def writesChildNodes(__obj: CellClass, __scope: scala.xml.NamespaceBinding): Seq[scala.xml.Node] =
      Seq(scala.xml.Text(__obj.value.toString))

  }

  trait Default_CellSpecificationFormat extends IPXACT2009scalaxb.ElemNameParser[CellSpecification] {
    val targetNamespace: Option[String] = Some("http://www.spiritconsortium.org/XMLSchema/SPIRIT/1685-2009")
    
    def parser(node: scala.xml.Node, stack: List[IPXACT2009scalaxb.ElemName]): Parser[CellSpecification] =
      phrase((((IPXACT2009scalaxb.ElemName(Some("http://www.spiritconsortium.org/XMLSchema/SPIRIT/1685-2009"), "cellFunction")) ^^
      (x => IPXACT2009scalaxb.DataRecord(x.namespace, Some(x.name), IPXACT2009scalaxb.fromXML[CellFunction](x, IPXACT2009scalaxb.ElemName(node) :: stack)))) |
      ((IPXACT2009scalaxb.ElemName(Some("http://www.spiritconsortium.org/XMLSchema/SPIRIT/1685-2009"), "cellClass")) ^^
      (x => IPXACT2009scalaxb.DataRecord(x.namespace, Some(x.name), IPXACT2009scalaxb.fromXML[CellClass](x, IPXACT2009scalaxb.ElemName(node) :: stack))))) ^^
      { case p1 =>
      CellSpecification(p1) })
    
    def writesChildNodes(__obj: CellSpecification, __scope: scala.xml.NamespaceBinding): Seq[scala.xml.Node] =
      ((Some(__obj.cellspecificationoption) map {x => IPXACT2009scalaxb.toXML[IPXACT2009scalaxb.DataRecord[CellSpecificationOption]](x, x.namespace, x.key, __scope, false)}).get)
  }

  trait Default_TimingConstraintFormat extends IPXACT2009scalaxb.XMLFormat[TimingConstraint] with IPXACT2009scalaxb.CanWriteChildNodes[TimingConstraint] {
    val targetNamespace: Option[String] = Some("http://www.spiritconsortium.org/XMLSchema/SPIRIT/1685-2009")
    def reads(seq: scala.xml.NodeSeq, stack: List[IPXACT2009scalaxb.ElemName]): Either[String, TimingConstraint] = seq match {
      case node: scala.xml.Node => Right(TimingConstraint(IPXACT2009scalaxb.fromXML[Float](node, IPXACT2009scalaxb.ElemName(node) :: stack),
        scala.collection.immutable.ListMap(List(
        (node \ "@{http://www.spiritconsortium.org/XMLSchema/SPIRIT/1685-2009}clockEdge").headOption map { x => IPXACT2009scalaxb.DataRecord(x, node, IPXACT2009scalaxb.fromXML[EdgeValueType](x, IPXACT2009scalaxb.ElemName(node) :: stack)) } orElse Some(IPXACT2009scalaxb.DataRecord(None, None, IPXACT2009scalaxb.fromXML[EdgeValueType](scala.xml.Text("rise"), IPXACT2009scalaxb.ElemName(node) :: stack))) map { "@{http://www.spiritconsortium.org/XMLSchema/SPIRIT/1685-2009}clockEdge" -> _ },
        (node \ "@{http://www.spiritconsortium.org/XMLSchema/SPIRIT/1685-2009}delayType").headOption map { x => IPXACT2009scalaxb.DataRecord(x, node, IPXACT2009scalaxb.fromXML[DelayValueType](x, IPXACT2009scalaxb.ElemName(node) :: stack)) } map { "@{http://www.spiritconsortium.org/XMLSchema/SPIRIT/1685-2009}delayType" -> _ },
        (node \ "@{http://www.spiritconsortium.org/XMLSchema/SPIRIT/1685-2009}clockName").headOption map { x => IPXACT2009scalaxb.DataRecord(x, node, IPXACT2009scalaxb.fromXML[String](x, IPXACT2009scalaxb.ElemName(node) :: stack)) } map { "@clockName" -> _ }
        ).flatten[(String, IPXACT2009scalaxb.DataRecord[Any])]: _*)))
      case _ => Left("reads failed: seq must be scala.xml.Node")
    }
    
    override def writesAttribute(__obj: TimingConstraint, __scope: scala.xml.NamespaceBinding): scala.xml.MetaData = {
      var attr: scala.xml.MetaData  = scala.xml.Null
      __obj.attributes.toList map {
        case ("@{http://www.spiritconsortium.org/XMLSchema/SPIRIT/1685-2009}clockEdge", _) => if (__obj.spiritclockEdge.toString != "rise") attr = scala.xml.Attribute(__scope.getPrefix("http://www.spiritconsortium.org/XMLSchema/SPIRIT/1685-2009"), "clockEdge", __obj.spiritclockEdge.toString, attr)
        case ("@{http://www.spiritconsortium.org/XMLSchema/SPIRIT/1685-2009}delayType", _) => __obj.spiritdelayType foreach { x => attr = scala.xml.Attribute(__scope.getPrefix("http://www.spiritconsortium.org/XMLSchema/SPIRIT/1685-2009"), "delayType", x.toString, attr) }
        case ("@clockName", _) => attr = scala.xml.Attribute(__scope.getPrefix("http://www.spiritconsortium.org/XMLSchema/SPIRIT/1685-2009"), "clockName", __obj.clockName.toString, attr)
        case (key, x) => attr = scala.xml.Attribute((x.namespace map { __scope.getPrefix(_) }).orNull, x.key.orNull, x.value.toString, attr)
      }
      attr
    }

    def writesChildNodes(__obj: TimingConstraint, __scope: scala.xml.NamespaceBinding): Seq[scala.xml.Node] =
      Seq(scala.xml.Text(__obj.value.toString))

  }

  trait Default_DriveConstraintFormat extends IPXACT2009scalaxb.ElemNameParser[DriveConstraint] {
    val targetNamespace: Option[String] = Some("http://www.spiritconsortium.org/XMLSchema/SPIRIT/1685-2009")
    
    def parser(node: scala.xml.Node, stack: List[IPXACT2009scalaxb.ElemName]): Parser[DriveConstraint] =
      phrase((IPXACT2009scalaxb.ElemName(Some("http://www.spiritconsortium.org/XMLSchema/SPIRIT/1685-2009"), "cellSpecification")) ^^
      { case p1 =>
      DriveConstraint(IPXACT2009scalaxb.fromXML[CellSpecification](p1, IPXACT2009scalaxb.ElemName(node) :: stack)) })
    
    def writesChildNodes(__obj: DriveConstraint, __scope: scala.xml.NamespaceBinding): Seq[scala.xml.Node] =
      (IPXACT2009scalaxb.toXML[CellSpecification](__obj.cellSpecification, Some("http://www.spiritconsortium.org/XMLSchema/SPIRIT/1685-2009"), Some("cellSpecification"), __scope, false))
  }
  trait Default_LoadConstraintFormat extends IPXACT2009scalaxb.ElemNameParser[LoadConstraint] {
    val targetNamespace: Option[String] = Some("http://www.spiritconsortium.org/XMLSchema/SPIRIT/1685-2009")
    
    def parser(node: scala.xml.Node, stack: List[IPXACT2009scalaxb.ElemName]): Parser[LoadConstraint] =
      phrase((IPXACT2009scalaxb.ElemName(Some("http://www.spiritconsortium.org/XMLSchema/SPIRIT/1685-2009"), "cellSpecification")) ~
      opt(IPXACT2009scalaxb.ElemName(Some("http://www.spiritconsortium.org/XMLSchema/SPIRIT/1685-2009"), "count")) ^^
      { case p1 ~ p2 =>
      LoadConstraint(IPXACT2009scalaxb.fromXML[CellSpecification](p1, IPXACT2009scalaxb.ElemName(node) :: stack),
        p2.headOption map { IPXACT2009scalaxb.fromXML[BigInt](_, IPXACT2009scalaxb.ElemName(node) :: stack) }) })
    
    def writesChildNodes(__obj: LoadConstraint, __scope: scala.xml.NamespaceBinding): Seq[scala.xml.Node] =
      Seq.concat(IPXACT2009scalaxb.toXML[CellSpecification](__obj.cellSpecification, Some("http://www.spiritconsortium.org/XMLSchema/SPIRIT/1685-2009"), Some("cellSpecification"), __scope, false),
        __obj.count map { IPXACT2009scalaxb.toXML[BigInt](_, Some("http://www.spiritconsortium.org/XMLSchema/SPIRIT/1685-2009"), Some("count"), __scope, false) } getOrElse {Nil})

  }

  trait Default_LeftType3Format extends IPXACT2009scalaxb.XMLFormat[LeftType3] with IPXACT2009scalaxb.CanWriteChildNodes[LeftType3] {
    val targetNamespace: Option[String] = Some("http://www.spiritconsortium.org/XMLSchema/SPIRIT/1685-2009")
    def reads(seq: scala.xml.NodeSeq, stack: List[IPXACT2009scalaxb.ElemName]): Either[String, LeftType3] = seq match {
      case node: scala.xml.Node => Right(LeftType3(IPXACT2009scalaxb.fromXML[BigInt](node, IPXACT2009scalaxb.ElemName(node) :: stack)))
      case _ => Left("reads failed: seq must be scala.xml.Node")
    }
    
    def writesChildNodes(__obj: LeftType3, __scope: scala.xml.NamespaceBinding): Seq[scala.xml.Node] =
      Seq(scala.xml.Text(__obj.value.toString))

  }
  trait Default_RightType3Format extends IPXACT2009scalaxb.XMLFormat[RightType3] with IPXACT2009scalaxb.CanWriteChildNodes[RightType3] {
    val targetNamespace: Option[String] = Some("http://www.spiritconsortium.org/XMLSchema/SPIRIT/1685-2009")
    def reads(seq: scala.xml.NodeSeq, stack: List[IPXACT2009scalaxb.ElemName]): Either[String, RightType3] = seq match {
      case node: scala.xml.Node => Right(RightType3(IPXACT2009scalaxb.fromXML[BigInt](node, IPXACT2009scalaxb.ElemName(node) :: stack)))
      case _ => Left("reads failed: seq must be scala.xml.Node")
    }
    
    def writesChildNodes(__obj: RightType3, __scope: scala.xml.NamespaceBinding): Seq[scala.xml.Node] =
      Seq(scala.xml.Text(__obj.value.toString))

  }
  trait Default_Vector3Format extends IPXACT2009scalaxb.ElemNameParser[Vector3] {
    val targetNamespace: Option[String] = Some("http://www.spiritconsortium.org/XMLSchema/SPIRIT/1685-2009")
    
    def parser(node: scala.xml.Node, stack: List[IPXACT2009scalaxb.ElemName]): Parser[Vector3] =
      phrase((IPXACT2009scalaxb.ElemName(Some("http://www.spiritconsortium.org/XMLSchema/SPIRIT/1685-2009"), "left")) ~
      (IPXACT2009scalaxb.ElemName(Some("http://www.spiritconsortium.org/XMLSchema/SPIRIT/1685-2009"), "right")) ^^
      { case p1 ~ p2 =>
      Vector3(IPXACT2009scalaxb.fromXML[LeftType3](p1, IPXACT2009scalaxb.ElemName(node) :: stack),
        IPXACT2009scalaxb.fromXML[RightType3](p2, IPXACT2009scalaxb.ElemName(node) :: stack)) })
    
    def writesChildNodes(__obj: Vector3, __scope: scala.xml.NamespaceBinding): Seq[scala.xml.Node] =
      Seq.concat(IPXACT2009scalaxb.toXML[LeftType3](__obj.left, Some("http://www.spiritconsortium.org/XMLSchema/SPIRIT/1685-2009"), Some("left"), __scope, false),
        IPXACT2009scalaxb.toXML[RightType3](__obj.right, Some("http://www.spiritconsortium.org/XMLSchema/SPIRIT/1685-2009"), Some("right"), __scope, false))

  }

  trait Default_ConstraintSetFormat extends IPXACT2009scalaxb.ElemNameParser[ConstraintSet] with _NameGroupOptionalGroupFormat {
    val targetNamespace: Option[String] = Some("http://www.spiritconsortium.org/XMLSchema/SPIRIT/1685-2009")
    
    def parser(node: scala.xml.Node, stack: List[IPXACT2009scalaxb.ElemName]): Parser[ConstraintSet] =
      phrase((parseNameGroupOptionalGroup(node, IPXACT2009scalaxb.ElemName(node) :: stack)) ~
      opt(IPXACT2009scalaxb.ElemName(Some("http://www.spiritconsortium.org/XMLSchema/SPIRIT/1685-2009"), "vector")) ~
      opt(IPXACT2009scalaxb.ElemName(Some("http://www.spiritconsortium.org/XMLSchema/SPIRIT/1685-2009"), "driveConstraint")) ~
      opt(IPXACT2009scalaxb.ElemName(Some("http://www.spiritconsortium.org/XMLSchema/SPIRIT/1685-2009"), "loadConstraint")) ~
      safeRep(IPXACT2009scalaxb.ElemName(Some("http://www.spiritconsortium.org/XMLSchema/SPIRIT/1685-2009"), "timingConstraint")) ^^
      { case p1 ~ p2 ~ p3 ~ p4 ~ p5 =>
      ConstraintSet(p1,
        p2.headOption map { IPXACT2009scalaxb.fromXML[Vector3](_, IPXACT2009scalaxb.ElemName(node) :: stack) },
        p3.headOption map { IPXACT2009scalaxb.fromXML[DriveConstraint](_, IPXACT2009scalaxb.ElemName(node) :: stack) },
        p4.headOption map { IPXACT2009scalaxb.fromXML[LoadConstraint](_, IPXACT2009scalaxb.ElemName(node) :: stack) },
        p5 map { IPXACT2009scalaxb.fromXML[TimingConstraint](_, IPXACT2009scalaxb.ElemName(node) :: stack) },
        scala.collection.immutable.ListMap(List(
        (node \ "@{http://www.spiritconsortium.org/XMLSchema/SPIRIT/1685-2009}constraintSetId").headOption map { x => IPXACT2009scalaxb.DataRecord(x, node, IPXACT2009scalaxb.fromXML[String](x, IPXACT2009scalaxb.ElemName(node) :: stack)) } map { "@{http://www.spiritconsortium.org/XMLSchema/SPIRIT/1685-2009}constraintSetId" -> _ }
        ).flatten[(String, IPXACT2009scalaxb.DataRecord[Any])]: _*)) })
    
    override def writesAttribute(__obj: ConstraintSet, __scope: scala.xml.NamespaceBinding): scala.xml.MetaData = {
      var attr: scala.xml.MetaData  = scala.xml.Null
      __obj.attributes.toList map {
        case ("@{http://www.spiritconsortium.org/XMLSchema/SPIRIT/1685-2009}constraintSetId", _) => __obj.spiritconstraintSetId foreach { x => attr = scala.xml.Attribute(__scope.getPrefix("http://www.spiritconsortium.org/XMLSchema/SPIRIT/1685-2009"), "constraintSetId", x.toString, attr) }
        case (key, x) => attr = scala.xml.Attribute((x.namespace map { __scope.getPrefix(_) }).orNull, x.key.orNull, x.value.toString, attr)
      }
      attr
    }

    def writesChildNodes(__obj: ConstraintSet, __scope: scala.xml.NamespaceBinding): Seq[scala.xml.Node] =
      Seq.concat(IPXACT2009scalaxb.toXML[NameGroupOptionalSequence](__obj.nameGroupOptionalSequence1, None, Some("nameGroupOptionalSequence1"), __scope, false),
        __obj.vector map { IPXACT2009scalaxb.toXML[Vector3](_, Some("http://www.spiritconsortium.org/XMLSchema/SPIRIT/1685-2009"), Some("vector"), __scope, false) } getOrElse {Nil},
        __obj.driveConstraint map { IPXACT2009scalaxb.toXML[DriveConstraint](_, Some("http://www.spiritconsortium.org/XMLSchema/SPIRIT/1685-2009"), Some("driveConstraint"), __scope, false) } getOrElse {Nil},
        __obj.loadConstraint map { IPXACT2009scalaxb.toXML[LoadConstraint](_, Some("http://www.spiritconsortium.org/XMLSchema/SPIRIT/1685-2009"), Some("loadConstraint"), __scope, false) } getOrElse {Nil},
        __obj.timingConstraint flatMap { IPXACT2009scalaxb.toXML[TimingConstraint](_, Some("http://www.spiritconsortium.org/XMLSchema/SPIRIT/1685-2009"), Some("timingConstraint"), __scope, false) })

  }

  trait Default_ConstraintSetsFormat extends IPXACT2009scalaxb.ElemNameParser[ConstraintSets] {
    val targetNamespace: Option[String] = Some("http://www.spiritconsortium.org/XMLSchema/SPIRIT/1685-2009")
    
    def parser(node: scala.xml.Node, stack: List[IPXACT2009scalaxb.ElemName]): Parser[ConstraintSets] =
      phrase(safeRep(IPXACT2009scalaxb.ElemName(Some("http://www.spiritconsortium.org/XMLSchema/SPIRIT/1685-2009"), "constraintSet")) ^^
      { case p1 =>
      ConstraintSets(p1 map { IPXACT2009scalaxb.fromXML[ConstraintSet](_, IPXACT2009scalaxb.ElemName(node) :: stack) }) })
    
    def writesChildNodes(__obj: ConstraintSets, __scope: scala.xml.NamespaceBinding): Seq[scala.xml.Node] =
      (__obj.constraintSet flatMap { IPXACT2009scalaxb.toXML[ConstraintSet](_, Some("http://www.spiritconsortium.org/XMLSchema/SPIRIT/1685-2009"), Some("constraintSet"), __scope, false) })
  }
  trait Default_AbstractionDefPortConstraintsTypeFormat extends IPXACT2009scalaxb.ElemNameParser[AbstractionDefPortConstraintsType] {
    val targetNamespace: Option[String] = Some("http://www.spiritconsortium.org/XMLSchema/SPIRIT/1685-2009")
    
    override def typeName: Option[String] = Some("abstractionDefPortConstraintsType")

    def parser(node: scala.xml.Node, stack: List[IPXACT2009scalaxb.ElemName]): Parser[AbstractionDefPortConstraintsType] =
      phrase((((safeRep(IPXACT2009scalaxb.ElemName(Some("http://www.spiritconsortium.org/XMLSchema/SPIRIT/1685-2009"), "timingConstraint")) ~
      opt(IPXACT2009scalaxb.ElemName(Some("http://www.spiritconsortium.org/XMLSchema/SPIRIT/1685-2009"), "driveConstraint")) ~
      opt(IPXACT2009scalaxb.ElemName(Some("http://www.spiritconsortium.org/XMLSchema/SPIRIT/1685-2009"), "loadConstraint"))) ^^
        { case p1 ~ p2 ~ p3 => IPXACT2009scalaxb.DataRecord(AbstractionDefPortConstraintsTypeSequence1(p1 map { IPXACT2009scalaxb.fromXML[TimingConstraint](_, IPXACT2009scalaxb.ElemName(node) :: stack) },
        p2.headOption map { IPXACT2009scalaxb.fromXML[DriveConstraint](_, IPXACT2009scalaxb.ElemName(node) :: stack) },
        p3.headOption map { IPXACT2009scalaxb.fromXML[LoadConstraint](_, IPXACT2009scalaxb.ElemName(node) :: stack) })) }) |||
      (((IPXACT2009scalaxb.ElemName(Some("http://www.spiritconsortium.org/XMLSchema/SPIRIT/1685-2009"), "driveConstraint")) ~
      opt(IPXACT2009scalaxb.ElemName(Some("http://www.spiritconsortium.org/XMLSchema/SPIRIT/1685-2009"), "loadConstraint"))) ^^
        { case p1 ~ p2 => IPXACT2009scalaxb.DataRecord(AbstractionDefPortConstraintsTypeSequence2(IPXACT2009scalaxb.fromXML[DriveConstraint](p1, IPXACT2009scalaxb.ElemName(node) :: stack),
        p2.headOption map { IPXACT2009scalaxb.fromXML[LoadConstraint](_, IPXACT2009scalaxb.ElemName(node) :: stack) })) }) |||
      (((IPXACT2009scalaxb.ElemName(Some("http://www.spiritconsortium.org/XMLSchema/SPIRIT/1685-2009"), "loadConstraint"))) ^^
        { case p1 => IPXACT2009scalaxb.DataRecord(AbstractionDefPortConstraintsTypeSequence3(IPXACT2009scalaxb.fromXML[LoadConstraint](p1, IPXACT2009scalaxb.ElemName(node) :: stack))) })) ^^
      { case p1 =>
      AbstractionDefPortConstraintsType(p1) })
    
    def writesChildNodes(__obj: AbstractionDefPortConstraintsType, __scope: scala.xml.NamespaceBinding): Seq[scala.xml.Node] =
      ((Some(__obj.abstractiondefportconstraintstypeoption) map {x => IPXACT2009scalaxb.toXML[IPXACT2009scalaxb.DataRecord[AbstractionDefPortConstraintsTypeOption]](x, x.namespace, x.key, __scope, false)}).get)
  }

  trait Default_AbstractionDefPortConstraintsTypeSequence3Format extends IPXACT2009scalaxb.XMLFormat[AbstractionDefPortConstraintsTypeSequence3] {
    def reads(seq: scala.xml.NodeSeq, stack: List[IPXACT2009scalaxb.ElemName]): Either[String, AbstractionDefPortConstraintsTypeSequence3] = Left("don't call me.")
    
    def writes(__obj: AbstractionDefPortConstraintsTypeSequence3, __namespace: Option[String], __elementLabel: Option[String], 
        __scope: scala.xml.NamespaceBinding, __typeAttribute: Boolean): scala.xml.NodeSeq =
      IPXACT2009scalaxb.toXML[LoadConstraint](__obj.loadConstraint, Some("http://www.spiritconsortium.org/XMLSchema/SPIRIT/1685-2009"), Some("loadConstraint"), __scope, false)

  }
  trait Default_AbstractionDefPortConstraintsTypeSequence2Format extends IPXACT2009scalaxb.XMLFormat[AbstractionDefPortConstraintsTypeSequence2] {
    def reads(seq: scala.xml.NodeSeq, stack: List[IPXACT2009scalaxb.ElemName]): Either[String, AbstractionDefPortConstraintsTypeSequence2] = Left("don't call me.")
    
    def writes(__obj: AbstractionDefPortConstraintsTypeSequence2, __namespace: Option[String], __elementLabel: Option[String], 
        __scope: scala.xml.NamespaceBinding, __typeAttribute: Boolean): scala.xml.NodeSeq =
      Seq.concat(IPXACT2009scalaxb.toXML[DriveConstraint](__obj.driveConstraint, Some("http://www.spiritconsortium.org/XMLSchema/SPIRIT/1685-2009"), Some("driveConstraint"), __scope, false),
        __obj.loadConstraint map { IPXACT2009scalaxb.toXML[LoadConstraint](_, Some("http://www.spiritconsortium.org/XMLSchema/SPIRIT/1685-2009"), Some("loadConstraint"), __scope, false) } getOrElse {Nil})


  }

  trait Default_AbstractionDefPortConstraintsTypeSequence1Format extends IPXACT2009scalaxb.XMLFormat[AbstractionDefPortConstraintsTypeSequence1] {
    def reads(seq: scala.xml.NodeSeq, stack: List[IPXACT2009scalaxb.ElemName]): Either[String, AbstractionDefPortConstraintsTypeSequence1] = Left("don't call me.")
    
    def writes(__obj: AbstractionDefPortConstraintsTypeSequence1, __namespace: Option[String], __elementLabel: Option[String], 
        __scope: scala.xml.NamespaceBinding, __typeAttribute: Boolean): scala.xml.NodeSeq =
      Seq.concat(__obj.timingConstraint flatMap { IPXACT2009scalaxb.toXML[TimingConstraint](_, Some("http://www.spiritconsortium.org/XMLSchema/SPIRIT/1685-2009"), Some("timingConstraint"), __scope, false) },
        __obj.driveConstraint map { IPXACT2009scalaxb.toXML[DriveConstraint](_, Some("http://www.spiritconsortium.org/XMLSchema/SPIRIT/1685-2009"), Some("driveConstraint"), __scope, false) } getOrElse {Nil},
        __obj.loadConstraint map { IPXACT2009scalaxb.toXML[LoadConstraint](_, Some("http://www.spiritconsortium.org/XMLSchema/SPIRIT/1685-2009"), Some("loadConstraint"), __scope, false) } getOrElse {Nil})


  }

  trait Default_HierConnectionFormat extends IPXACT2009scalaxb.ElemNameParser[HierConnection] {
    val targetNamespace: Option[String] = Some("http://www.spiritconsortium.org/XMLSchema/SPIRIT/1685-2009")
    
    def parser(node: scala.xml.Node, stack: List[IPXACT2009scalaxb.ElemName]): Parser[HierConnection] =
      phrase((IPXACT2009scalaxb.ElemName(Some("http://www.spiritconsortium.org/XMLSchema/SPIRIT/1685-2009"), "interface")) ~
      opt(IPXACT2009scalaxb.ElemName(Some("http://www.spiritconsortium.org/XMLSchema/SPIRIT/1685-2009"), "vendorExtensions")) ^^
      { case p1 ~ p2 =>
      HierConnection(IPXACT2009scalaxb.fromXML[Interfacable](p1, IPXACT2009scalaxb.ElemName(node) :: stack),
        p2.headOption map { IPXACT2009scalaxb.fromXML[VendorExtensions](_, IPXACT2009scalaxb.ElemName(node) :: stack) },
        scala.collection.immutable.ListMap(List(
        (node \ "@{http://www.spiritconsortium.org/XMLSchema/SPIRIT/1685-2009}interfaceRef").headOption map { x => IPXACT2009scalaxb.DataRecord(x, node, IPXACT2009scalaxb.fromXML[String](x, IPXACT2009scalaxb.ElemName(node) :: stack)) } map { "@interfaceRef" -> _ }
        ).flatten[(String, IPXACT2009scalaxb.DataRecord[Any])]: _*)) })
    
    override def writesAttribute(__obj: HierConnection, __scope: scala.xml.NamespaceBinding): scala.xml.MetaData = {
      var attr: scala.xml.MetaData  = scala.xml.Null
      __obj.attributes.toList map {
        case ("@interfaceRef", _) => attr = scala.xml.Attribute(__scope.getPrefix("http://www.spiritconsortium.org/XMLSchema/SPIRIT/1685-2009"), "interfaceRef", __obj.interfaceRef.toString, attr)
        case (key, x) => attr = scala.xml.Attribute((x.namespace map { __scope.getPrefix(_) }).orNull, x.key.orNull, x.value.toString, attr)
      }
      attr
    }

    def writesChildNodes(__obj: HierConnection, __scope: scala.xml.NamespaceBinding): Seq[scala.xml.Node] =
      Seq.concat(IPXACT2009scalaxb.toXML[Interfacable](__obj.interface, Some("http://www.spiritconsortium.org/XMLSchema/SPIRIT/1685-2009"), Some("interface"), __scope, false),
        __obj.vendorExtensions map { IPXACT2009scalaxb.toXML[VendorExtensions](_, Some("http://www.spiritconsortium.org/XMLSchema/SPIRIT/1685-2009"), Some("vendorExtensions"), __scope, false) } getOrElse {Nil})

  }

  trait Default_HierConnectionsFormat extends IPXACT2009scalaxb.ElemNameParser[HierConnections] {
    val targetNamespace: Option[String] = Some("http://www.spiritconsortium.org/XMLSchema/SPIRIT/1685-2009")
    
    def parser(node: scala.xml.Node, stack: List[IPXACT2009scalaxb.ElemName]): Parser[HierConnections] =
      phrase(safeRep(IPXACT2009scalaxb.ElemName(Some("http://www.spiritconsortium.org/XMLSchema/SPIRIT/1685-2009"), "hierConnection")) ^^
      { case p1 =>
      HierConnections(p1 map { IPXACT2009scalaxb.fromXML[HierConnection](_, IPXACT2009scalaxb.ElemName(node) :: stack) }) })
    
    def writesChildNodes(__obj: HierConnections, __scope: scala.xml.NamespaceBinding): Seq[scala.xml.Node] =
      (__obj.hierConnection flatMap { IPXACT2009scalaxb.toXML[HierConnection](_, Some("http://www.spiritconsortium.org/XMLSchema/SPIRIT/1685-2009"), Some("hierConnection"), __scope, false) })
  }
  trait Default_DesignFormat extends IPXACT2009scalaxb.ElemNameParser[Design] with _VersionedIdentifierGroupFormat {
    val targetNamespace: Option[String] = Some("http://www.spiritconsortium.org/XMLSchema/SPIRIT/1685-2009")
    
    def parser(node: scala.xml.Node, stack: List[IPXACT2009scalaxb.ElemName]): Parser[Design] =
      phrase((parseVersionedIdentifierGroup(node, IPXACT2009scalaxb.ElemName(node) :: stack)) ~
      opt(IPXACT2009scalaxb.ElemName(Some("http://www.spiritconsortium.org/XMLSchema/SPIRIT/1685-2009"), "componentInstances")) ~
      opt(IPXACT2009scalaxb.ElemName(Some("http://www.spiritconsortium.org/XMLSchema/SPIRIT/1685-2009"), "interconnections")) ~
      opt(IPXACT2009scalaxb.ElemName(Some("http://www.spiritconsortium.org/XMLSchema/SPIRIT/1685-2009"), "adHocConnections")) ~
      opt(IPXACT2009scalaxb.ElemName(Some("http://www.spiritconsortium.org/XMLSchema/SPIRIT/1685-2009"), "hierConnections")) ~
      opt(IPXACT2009scalaxb.ElemName(Some("http://www.spiritconsortium.org/XMLSchema/SPIRIT/1685-2009"), "description")) ~
      opt(IPXACT2009scalaxb.ElemName(Some("http://www.spiritconsortium.org/XMLSchema/SPIRIT/1685-2009"), "vendorExtensions")) ^^
      { case p1 ~ p2 ~ p3 ~ p4 ~ p5 ~ p6 ~ p7 =>
      Design(p1,
        p2.headOption map { IPXACT2009scalaxb.fromXML[ComponentInstances](_, IPXACT2009scalaxb.ElemName(node) :: stack) },
        p3.headOption map { IPXACT2009scalaxb.fromXML[Interconnections](_, IPXACT2009scalaxb.ElemName(node) :: stack) },
        p4.headOption map { IPXACT2009scalaxb.fromXML[AdHocConnections](_, IPXACT2009scalaxb.ElemName(node) :: stack) },
        p5.headOption map { IPXACT2009scalaxb.fromXML[HierConnections](_, IPXACT2009scalaxb.ElemName(node) :: stack) },
        p6.headOption map { IPXACT2009scalaxb.fromXML[String](_, IPXACT2009scalaxb.ElemName(node) :: stack) },
        p7.headOption map { IPXACT2009scalaxb.fromXML[VendorExtensions](_, IPXACT2009scalaxb.ElemName(node) :: stack) }) })
    
    def writesChildNodes(__obj: Design, __scope: scala.xml.NamespaceBinding): Seq[scala.xml.Node] =
      Seq.concat(IPXACT2009scalaxb.toXML[VersionedIdentifierSequence](__obj.versionedIdentifierSequence1, None, Some("versionedIdentifierSequence1"), __scope, false),
        __obj.componentInstances map { IPXACT2009scalaxb.toXML[ComponentInstances](_, Some("http://www.spiritconsortium.org/XMLSchema/SPIRIT/1685-2009"), Some("componentInstances"), __scope, false) } getOrElse {Nil},
        __obj.interconnections map { IPXACT2009scalaxb.toXML[Interconnections](_, Some("http://www.spiritconsortium.org/XMLSchema/SPIRIT/1685-2009"), Some("interconnections"), __scope, false) } getOrElse {Nil},
        __obj.adHocConnections map { IPXACT2009scalaxb.toXML[AdHocConnections](_, Some("http://www.spiritconsortium.org/XMLSchema/SPIRIT/1685-2009"), Some("adHocConnections"), __scope, false) } getOrElse {Nil},
        __obj.hierConnections map { IPXACT2009scalaxb.toXML[HierConnections](_, Some("http://www.spiritconsortium.org/XMLSchema/SPIRIT/1685-2009"), Some("hierConnections"), __scope, false) } getOrElse {Nil},
        __obj.description map { IPXACT2009scalaxb.toXML[String](_, Some("http://www.spiritconsortium.org/XMLSchema/SPIRIT/1685-2009"), Some("description"), __scope, false) } getOrElse {Nil},
        __obj.vendorExtensions map { IPXACT2009scalaxb.toXML[VendorExtensions](_, Some("http://www.spiritconsortium.org/XMLSchema/SPIRIT/1685-2009"), Some("vendorExtensions"), __scope, false) } getOrElse {Nil})

  }

  trait Default_GeneratorChainConfigurationFormat extends IPXACT2009scalaxb.ElemNameParser[GeneratorChainConfiguration] {
    val targetNamespace: Option[String] = Some("http://www.spiritconsortium.org/XMLSchema/SPIRIT/1685-2009")
    
    def parser(node: scala.xml.Node, stack: List[IPXACT2009scalaxb.ElemName]): Parser[GeneratorChainConfiguration] =
      phrase((IPXACT2009scalaxb.ElemName(Some("http://www.spiritconsortium.org/XMLSchema/SPIRIT/1685-2009"), "generatorChainRef")) ~
      opt(IPXACT2009scalaxb.ElemName(Some("http://www.spiritconsortium.org/XMLSchema/SPIRIT/1685-2009"), "configurableElementValues")) ^^
      { case p1 ~ p2 =>
      GeneratorChainConfiguration(IPXACT2009scalaxb.fromXML[LibraryRefType](p1, IPXACT2009scalaxb.ElemName(node) :: stack),
        p2.headOption map { IPXACT2009scalaxb.fromXML[ConfigurableElementValues](_, IPXACT2009scalaxb.ElemName(node) :: stack) }) })
    
    def writesChildNodes(__obj: GeneratorChainConfiguration, __scope: scala.xml.NamespaceBinding): Seq[scala.xml.Node] =
      Seq.concat(IPXACT2009scalaxb.toXML[LibraryRefType](__obj.generatorChainRef, Some("http://www.spiritconsortium.org/XMLSchema/SPIRIT/1685-2009"), Some("generatorChainRef"), __scope, false),
        __obj.configurableElementValues map { IPXACT2009scalaxb.toXML[ConfigurableElementValues](_, Some("http://www.spiritconsortium.org/XMLSchema/SPIRIT/1685-2009"), Some("configurableElementValues"), __scope, false) } getOrElse {Nil})

  }

  trait Default_AbstractorFormat extends IPXACT2009scalaxb.ElemNameParser[Abstractor] {
    val targetNamespace: Option[String] = Some("http://www.spiritconsortium.org/XMLSchema/SPIRIT/1685-2009")
    
    def parser(node: scala.xml.Node, stack: List[IPXACT2009scalaxb.ElemName]): Parser[Abstractor] =
      phrase((IPXACT2009scalaxb.ElemName(Some("http://www.spiritconsortium.org/XMLSchema/SPIRIT/1685-2009"), "instanceName")) ~
      opt(IPXACT2009scalaxb.ElemName(Some("http://www.spiritconsortium.org/XMLSchema/SPIRIT/1685-2009"), "displayName")) ~
      opt(IPXACT2009scalaxb.ElemName(Some("http://www.spiritconsortium.org/XMLSchema/SPIRIT/1685-2009"), "description")) ~
      (IPXACT2009scalaxb.ElemName(Some("http://www.spiritconsortium.org/XMLSchema/SPIRIT/1685-2009"), "abstractorRef")) ~
      opt(IPXACT2009scalaxb.ElemName(Some("http://www.spiritconsortium.org/XMLSchema/SPIRIT/1685-2009"), "configurableElementValues")) ~
      (IPXACT2009scalaxb.ElemName(Some("http://www.spiritconsortium.org/XMLSchema/SPIRIT/1685-2009"), "viewName")) ^^
      { case p1 ~ p2 ~ p3 ~ p4 ~ p5 ~ p6 =>
      Abstractor(IPXACT2009scalaxb.fromXML[String](p1, IPXACT2009scalaxb.ElemName(node) :: stack),
        p2.headOption map { IPXACT2009scalaxb.fromXML[String](_, IPXACT2009scalaxb.ElemName(node) :: stack) },
        p3.headOption map { IPXACT2009scalaxb.fromXML[String](_, IPXACT2009scalaxb.ElemName(node) :: stack) },
        IPXACT2009scalaxb.fromXML[LibraryRefType](p4, IPXACT2009scalaxb.ElemName(node) :: stack),
        p5.headOption map { IPXACT2009scalaxb.fromXML[ConfigurableElementValues](_, IPXACT2009scalaxb.ElemName(node) :: stack) },
        IPXACT2009scalaxb.fromXML[String](p6, IPXACT2009scalaxb.ElemName(node) :: stack)) })
    
    def writesChildNodes(__obj: Abstractor, __scope: scala.xml.NamespaceBinding): Seq[scala.xml.Node] =
      Seq.concat(IPXACT2009scalaxb.toXML[String](__obj.instanceName, Some("http://www.spiritconsortium.org/XMLSchema/SPIRIT/1685-2009"), Some("instanceName"), __scope, false),
        __obj.displayName map { IPXACT2009scalaxb.toXML[String](_, Some("http://www.spiritconsortium.org/XMLSchema/SPIRIT/1685-2009"), Some("displayName"), __scope, false) } getOrElse {Nil},
        __obj.description map { IPXACT2009scalaxb.toXML[String](_, Some("http://www.spiritconsortium.org/XMLSchema/SPIRIT/1685-2009"), Some("description"), __scope, false) } getOrElse {Nil},
        IPXACT2009scalaxb.toXML[LibraryRefType](__obj.abstractorRef, Some("http://www.spiritconsortium.org/XMLSchema/SPIRIT/1685-2009"), Some("abstractorRef"), __scope, false),
        __obj.configurableElementValues map { IPXACT2009scalaxb.toXML[ConfigurableElementValues](_, Some("http://www.spiritconsortium.org/XMLSchema/SPIRIT/1685-2009"), Some("configurableElementValues"), __scope, false) } getOrElse {Nil},
        IPXACT2009scalaxb.toXML[String](__obj.viewName, Some("http://www.spiritconsortium.org/XMLSchema/SPIRIT/1685-2009"), Some("viewName"), __scope, false))

  }

  trait Default_AbstractorsFormat extends IPXACT2009scalaxb.ElemNameParser[Abstractors] {
    val targetNamespace: Option[String] = Some("http://www.spiritconsortium.org/XMLSchema/SPIRIT/1685-2009")
    
    def parser(node: scala.xml.Node, stack: List[IPXACT2009scalaxb.ElemName]): Parser[Abstractors] =
      phrase(safeRep(IPXACT2009scalaxb.ElemName(Some("http://www.spiritconsortium.org/XMLSchema/SPIRIT/1685-2009"), "abstractor")) ^^
      { case p1 =>
      Abstractors(p1 map { IPXACT2009scalaxb.fromXML[Abstractor](_, IPXACT2009scalaxb.ElemName(node) :: stack) }) })
    
    def writesChildNodes(__obj: Abstractors, __scope: scala.xml.NamespaceBinding): Seq[scala.xml.Node] =
      (__obj.abstractor flatMap { IPXACT2009scalaxb.toXML[Abstractor](_, Some("http://www.spiritconsortium.org/XMLSchema/SPIRIT/1685-2009"), Some("abstractor"), __scope, false) })
  }
  trait Default_InterconnectionConfigurationFormat extends IPXACT2009scalaxb.ElemNameParser[InterconnectionConfiguration] {
    val targetNamespace: Option[String] = Some("http://www.spiritconsortium.org/XMLSchema/SPIRIT/1685-2009")
    
    def parser(node: scala.xml.Node, stack: List[IPXACT2009scalaxb.ElemName]): Parser[InterconnectionConfiguration] =
      phrase((IPXACT2009scalaxb.ElemName(Some("http://www.spiritconsortium.org/XMLSchema/SPIRIT/1685-2009"), "interconnectionRef")) ~
      (IPXACT2009scalaxb.ElemName(Some("http://www.spiritconsortium.org/XMLSchema/SPIRIT/1685-2009"), "abstractors")) ^^
      { case p1 ~ p2 =>
      InterconnectionConfiguration(IPXACT2009scalaxb.fromXML[String](p1, IPXACT2009scalaxb.ElemName(node) :: stack),
        IPXACT2009scalaxb.fromXML[Abstractors](p2, IPXACT2009scalaxb.ElemName(node) :: stack)) })
    
    def writesChildNodes(__obj: InterconnectionConfiguration, __scope: scala.xml.NamespaceBinding): Seq[scala.xml.Node] =
      Seq.concat(IPXACT2009scalaxb.toXML[String](__obj.interconnectionRef, Some("http://www.spiritconsortium.org/XMLSchema/SPIRIT/1685-2009"), Some("interconnectionRef"), __scope, false),
        IPXACT2009scalaxb.toXML[Abstractors](__obj.abstractors, Some("http://www.spiritconsortium.org/XMLSchema/SPIRIT/1685-2009"), Some("abstractors"), __scope, false))

  }

  trait Default_ViewConfigurationFormat extends IPXACT2009scalaxb.ElemNameParser[ViewConfiguration] {
    val targetNamespace: Option[String] = Some("http://www.spiritconsortium.org/XMLSchema/SPIRIT/1685-2009")
    
    def parser(node: scala.xml.Node, stack: List[IPXACT2009scalaxb.ElemName]): Parser[ViewConfiguration] =
      phrase((IPXACT2009scalaxb.ElemName(Some("http://www.spiritconsortium.org/XMLSchema/SPIRIT/1685-2009"), "instanceName")) ~
      (IPXACT2009scalaxb.ElemName(Some("http://www.spiritconsortium.org/XMLSchema/SPIRIT/1685-2009"), "viewName")) ^^
      { case p1 ~ p2 =>
      ViewConfiguration(IPXACT2009scalaxb.fromXML[String](p1, IPXACT2009scalaxb.ElemName(node) :: stack),
        IPXACT2009scalaxb.fromXML[String](p2, IPXACT2009scalaxb.ElemName(node) :: stack)) })
    
    def writesChildNodes(__obj: ViewConfiguration, __scope: scala.xml.NamespaceBinding): Seq[scala.xml.Node] =
      Seq.concat(IPXACT2009scalaxb.toXML[String](__obj.instanceName, Some("http://www.spiritconsortium.org/XMLSchema/SPIRIT/1685-2009"), Some("instanceName"), __scope, false),
        IPXACT2009scalaxb.toXML[String](__obj.viewName, Some("http://www.spiritconsortium.org/XMLSchema/SPIRIT/1685-2009"), Some("viewName"), __scope, false))

  }

  trait Default_DesignConfigurationFormat extends IPXACT2009scalaxb.ElemNameParser[DesignConfiguration] with _VersionedIdentifierGroupFormat {
    val targetNamespace: Option[String] = Some("http://www.spiritconsortium.org/XMLSchema/SPIRIT/1685-2009")
    
    def parser(node: scala.xml.Node, stack: List[IPXACT2009scalaxb.ElemName]): Parser[DesignConfiguration] =
      phrase((parseVersionedIdentifierGroup(node, IPXACT2009scalaxb.ElemName(node) :: stack)) ~
      (IPXACT2009scalaxb.ElemName(Some("http://www.spiritconsortium.org/XMLSchema/SPIRIT/1685-2009"), "designRef")) ~
      safeRep(IPXACT2009scalaxb.ElemName(Some("http://www.spiritconsortium.org/XMLSchema/SPIRIT/1685-2009"), "generatorChainConfiguration")) ~
      safeRep(IPXACT2009scalaxb.ElemName(Some("http://www.spiritconsortium.org/XMLSchema/SPIRIT/1685-2009"), "interconnectionConfiguration")) ~
      safeRep(IPXACT2009scalaxb.ElemName(Some("http://www.spiritconsortium.org/XMLSchema/SPIRIT/1685-2009"), "viewConfiguration")) ~
      opt(IPXACT2009scalaxb.ElemName(Some("http://www.spiritconsortium.org/XMLSchema/SPIRIT/1685-2009"), "description")) ~
      opt(IPXACT2009scalaxb.ElemName(Some("http://www.spiritconsortium.org/XMLSchema/SPIRIT/1685-2009"), "vendorExtensions")) ^^
      { case p1 ~ p2 ~ p3 ~ p4 ~ p5 ~ p6 ~ p7 =>
      DesignConfiguration(p1,
        IPXACT2009scalaxb.fromXML[LibraryRefType](p2, IPXACT2009scalaxb.ElemName(node) :: stack),
        p3 map { IPXACT2009scalaxb.fromXML[GeneratorChainConfiguration](_, IPXACT2009scalaxb.ElemName(node) :: stack) },
        p4 map { IPXACT2009scalaxb.fromXML[InterconnectionConfiguration](_, IPXACT2009scalaxb.ElemName(node) :: stack) },
        p5 map { IPXACT2009scalaxb.fromXML[ViewConfiguration](_, IPXACT2009scalaxb.ElemName(node) :: stack) },
        p6.headOption map { IPXACT2009scalaxb.fromXML[String](_, IPXACT2009scalaxb.ElemName(node) :: stack) },
        p7.headOption map { IPXACT2009scalaxb.fromXML[VendorExtensions](_, IPXACT2009scalaxb.ElemName(node) :: stack) }) })
    
    def writesChildNodes(__obj: DesignConfiguration, __scope: scala.xml.NamespaceBinding): Seq[scala.xml.Node] =
      Seq.concat(IPXACT2009scalaxb.toXML[VersionedIdentifierSequence](__obj.versionedIdentifierSequence1, None, Some("versionedIdentifierSequence1"), __scope, false),
        IPXACT2009scalaxb.toXML[LibraryRefType](__obj.designRef, Some("http://www.spiritconsortium.org/XMLSchema/SPIRIT/1685-2009"), Some("designRef"), __scope, false),
        __obj.generatorChainConfiguration flatMap { IPXACT2009scalaxb.toXML[GeneratorChainConfiguration](_, Some("http://www.spiritconsortium.org/XMLSchema/SPIRIT/1685-2009"), Some("generatorChainConfiguration"), __scope, false) },
        __obj.interconnectionConfiguration flatMap { IPXACT2009scalaxb.toXML[InterconnectionConfiguration](_, Some("http://www.spiritconsortium.org/XMLSchema/SPIRIT/1685-2009"), Some("interconnectionConfiguration"), __scope, false) },
        __obj.viewConfiguration flatMap { IPXACT2009scalaxb.toXML[ViewConfiguration](_, Some("http://www.spiritconsortium.org/XMLSchema/SPIRIT/1685-2009"), Some("viewConfiguration"), __scope, false) },
        __obj.description map { IPXACT2009scalaxb.toXML[String](_, Some("http://www.spiritconsortium.org/XMLSchema/SPIRIT/1685-2009"), Some("description"), __scope, false) } getOrElse {Nil},
        __obj.vendorExtensions map { IPXACT2009scalaxb.toXML[VendorExtensions](_, Some("http://www.spiritconsortium.org/XMLSchema/SPIRIT/1685-2009"), Some("vendorExtensions"), __scope, false) } getOrElse {Nil})

  }

  trait Default_NameFormat extends IPXACT2009scalaxb.XMLFormat[Name] with IPXACT2009scalaxb.CanWriteChildNodes[Name] {
    val targetNamespace: Option[String] = Some("http://www.spiritconsortium.org/XMLSchema/SPIRIT/1685-2009")
    def reads(seq: scala.xml.NodeSeq, stack: List[IPXACT2009scalaxb.ElemName]): Either[String, Name] = seq match {
      case node: scala.xml.Node => Right(Name(IPXACT2009scalaxb.fromXML[String](node, IPXACT2009scalaxb.ElemName(node) :: stack),
        scala.collection.immutable.ListMap(List(
        (node \ "@{http://www.spiritconsortium.org/XMLSchema/SPIRIT/1685-2009}format").headOption map { x => IPXACT2009scalaxb.DataRecord(x, node, IPXACT2009scalaxb.fromXML[FormatType](x, IPXACT2009scalaxb.ElemName(node) :: stack)) } orElse Some(IPXACT2009scalaxb.DataRecord(None, None, IPXACT2009scalaxb.fromXML[FormatType](scala.xml.Text("string"), IPXACT2009scalaxb.ElemName(node) :: stack))) map { "@{http://www.spiritconsortium.org/XMLSchema/SPIRIT/1685-2009}format" -> _ },
        (node \ "@{http://www.spiritconsortium.org/XMLSchema/SPIRIT/1685-2009}resolve").headOption map { x => IPXACT2009scalaxb.DataRecord(x, node, IPXACT2009scalaxb.fromXML[ResolveType](x, IPXACT2009scalaxb.ElemName(node) :: stack)) } map { "@{http://www.spiritconsortium.org/XMLSchema/SPIRIT/1685-2009}resolve" -> _ },
        (node \ "@{http://www.spiritconsortium.org/XMLSchema/SPIRIT/1685-2009}id").headOption map { x => IPXACT2009scalaxb.DataRecord(x, node, IPXACT2009scalaxb.fromXML[String](x, IPXACT2009scalaxb.ElemName(node) :: stack)) } map { "@{http://www.spiritconsortium.org/XMLSchema/SPIRIT/1685-2009}id" -> _ },
        (node \ "@{http://www.spiritconsortium.org/XMLSchema/SPIRIT/1685-2009}dependency").headOption map { x => IPXACT2009scalaxb.DataRecord(x, node, IPXACT2009scalaxb.fromXML[String](x, IPXACT2009scalaxb.ElemName(node) :: stack)) } map { "@{http://www.spiritconsortium.org/XMLSchema/SPIRIT/1685-2009}dependency" -> _ },
        (node \ "@{http://www.spiritconsortium.org/XMLSchema/SPIRIT/1685-2009}choiceRef").headOption map { x => IPXACT2009scalaxb.DataRecord(x, node, IPXACT2009scalaxb.fromXML[String](x, IPXACT2009scalaxb.ElemName(node) :: stack)) } map { "@{http://www.spiritconsortium.org/XMLSchema/SPIRIT/1685-2009}choiceRef" -> _ },
        (node \ "@{http://www.spiritconsortium.org/XMLSchema/SPIRIT/1685-2009}order").headOption map { x => IPXACT2009scalaxb.DataRecord(x, node, IPXACT2009scalaxb.fromXML[Float](x, IPXACT2009scalaxb.ElemName(node) :: stack)) } map { "@{http://www.spiritconsortium.org/XMLSchema/SPIRIT/1685-2009}order" -> _ },
        (node \ "@{http://www.spiritconsortium.org/XMLSchema/SPIRIT/1685-2009}configGroups").headOption map { x => IPXACT2009scalaxb.DataRecord(x, node, IPXACT2009scalaxb.fromXML[Seq[String]](x, IPXACT2009scalaxb.ElemName(node) :: stack)) } map { "@{http://www.spiritconsortium.org/XMLSchema/SPIRIT/1685-2009}configGroups" -> _ },
        (node \ "@{http://www.spiritconsortium.org/XMLSchema/SPIRIT/1685-2009}bitStringLength").headOption map { x => IPXACT2009scalaxb.DataRecord(x, node, IPXACT2009scalaxb.fromXML[BigInt](x, IPXACT2009scalaxb.ElemName(node) :: stack)) } map { "@{http://www.spiritconsortium.org/XMLSchema/SPIRIT/1685-2009}bitStringLength" -> _ },
        (node \ "@{http://www.spiritconsortium.org/XMLSchema/SPIRIT/1685-2009}minimum").headOption map { x => IPXACT2009scalaxb.DataRecord(x, node, IPXACT2009scalaxb.fromXML[String](x, IPXACT2009scalaxb.ElemName(node) :: stack)) } map { "@{http://www.spiritconsortium.org/XMLSchema/SPIRIT/1685-2009}minimum" -> _ },
        (node \ "@{http://www.spiritconsortium.org/XMLSchema/SPIRIT/1685-2009}maximum").headOption map { x => IPXACT2009scalaxb.DataRecord(x, node, IPXACT2009scalaxb.fromXML[String](x, IPXACT2009scalaxb.ElemName(node) :: stack)) } map { "@{http://www.spiritconsortium.org/XMLSchema/SPIRIT/1685-2009}maximum" -> _ },
        (node \ "@{http://www.spiritconsortium.org/XMLSchema/SPIRIT/1685-2009}rangeType").headOption map { x => IPXACT2009scalaxb.DataRecord(x, node, IPXACT2009scalaxb.fromXML[RangeTypeType](x, IPXACT2009scalaxb.ElemName(node) :: stack)) } map { "@{http://www.spiritconsortium.org/XMLSchema/SPIRIT/1685-2009}rangeType" -> _ },
        (node \ "@{http://www.spiritconsortium.org/XMLSchema/SPIRIT/1685-2009}prompt").headOption map { x => IPXACT2009scalaxb.DataRecord(x, node, IPXACT2009scalaxb.fromXML[String](x, IPXACT2009scalaxb.ElemName(node) :: stack)) } map { "@{http://www.spiritconsortium.org/XMLSchema/SPIRIT/1685-2009}prompt" -> _ }
        ).flatten[(String, IPXACT2009scalaxb.DataRecord[Any])] ::: (node match {
          case elem: scala.xml.Elem =>
            elem.attributes.toList flatMap {
              case scala.xml.PrefixedAttribute(pre, key, value, _) if pre == elem.scope.getPrefix("http://www.spiritconsortium.org/XMLSchema/SPIRIT/1685-2009") &&
                key == "format" => Nil
              case scala.xml.PrefixedAttribute(pre, key, value, _) if pre == elem.scope.getPrefix("http://www.spiritconsortium.org/XMLSchema/SPIRIT/1685-2009") &&
                key == "resolve" => Nil
              case scala.xml.PrefixedAttribute(pre, key, value, _) if pre == elem.scope.getPrefix("http://www.spiritconsortium.org/XMLSchema/SPIRIT/1685-2009") &&
                key == "id" => Nil
              case scala.xml.PrefixedAttribute(pre, key, value, _) if pre == elem.scope.getPrefix("http://www.spiritconsortium.org/XMLSchema/SPIRIT/1685-2009") &&
                key == "dependency" => Nil
              case scala.xml.PrefixedAttribute(pre, key, value, _) if pre == elem.scope.getPrefix("http://www.spiritconsortium.org/XMLSchema/SPIRIT/1685-2009") &&
                key == "choiceRef" => Nil
              case scala.xml.PrefixedAttribute(pre, key, value, _) if pre == elem.scope.getPrefix("http://www.spiritconsortium.org/XMLSchema/SPIRIT/1685-2009") &&
                key == "order" => Nil
              case scala.xml.PrefixedAttribute(pre, key, value, _) if pre == elem.scope.getPrefix("http://www.spiritconsortium.org/XMLSchema/SPIRIT/1685-2009") &&
                key == "configGroups" => Nil
              case scala.xml.PrefixedAttribute(pre, key, value, _) if pre == elem.scope.getPrefix("http://www.spiritconsortium.org/XMLSchema/SPIRIT/1685-2009") &&
                key == "bitStringLength" => Nil
              case scala.xml.PrefixedAttribute(pre, key, value, _) if pre == elem.scope.getPrefix("http://www.spiritconsortium.org/XMLSchema/SPIRIT/1685-2009") &&
                key == "minimum" => Nil
              case scala.xml.PrefixedAttribute(pre, key, value, _) if pre == elem.scope.getPrefix("http://www.spiritconsortium.org/XMLSchema/SPIRIT/1685-2009") &&
                key == "maximum" => Nil
              case scala.xml.PrefixedAttribute(pre, key, value, _) if pre == elem.scope.getPrefix("http://www.spiritconsortium.org/XMLSchema/SPIRIT/1685-2009") &&
                key == "rangeType" => Nil
              case scala.xml.PrefixedAttribute(pre, key, value, _) if pre == elem.scope.getPrefix("http://www.spiritconsortium.org/XMLSchema/SPIRIT/1685-2009") &&
                key == "prompt" => Nil
              case scala.xml.UnprefixedAttribute(key, value, _) =>
                List(("@" + key, IPXACT2009scalaxb.DataRecord(None, Some(key), value.text)))
              case scala.xml.PrefixedAttribute(pre, key, value, _) =>
                val ns = elem.scope.getURI(pre)
                List(("@{" + ns + "}" + key, IPXACT2009scalaxb.DataRecord(Option[String](ns), Some(key), value.text)))
              case _ => Nil
            }
          case _ => Nil
        }): _*)))
      case _ => Left("reads failed: seq must be scala.xml.Node")
    }
    
    override def writesAttribute(__obj: Name, __scope: scala.xml.NamespaceBinding): scala.xml.MetaData = {
      var attr: scala.xml.MetaData  = scala.xml.Null
      __obj.attributes.toList map {
        case ("@{http://www.spiritconsortium.org/XMLSchema/SPIRIT/1685-2009}format", _) => if (__obj.spiritformat.toString != "string") attr = scala.xml.Attribute(__scope.getPrefix("http://www.spiritconsortium.org/XMLSchema/SPIRIT/1685-2009"), "format", __obj.spiritformat.toString, attr)
        case ("@{http://www.spiritconsortium.org/XMLSchema/SPIRIT/1685-2009}resolve", _) => __obj.spiritresolve foreach { x => attr = scala.xml.Attribute(__scope.getPrefix("http://www.spiritconsortium.org/XMLSchema/SPIRIT/1685-2009"), "resolve", x.toString, attr) }
        case ("@{http://www.spiritconsortium.org/XMLSchema/SPIRIT/1685-2009}id", _) => __obj.spiritid foreach { x => attr = scala.xml.Attribute(__scope.getPrefix("http://www.spiritconsortium.org/XMLSchema/SPIRIT/1685-2009"), "id", x.toString, attr) }
        case ("@{http://www.spiritconsortium.org/XMLSchema/SPIRIT/1685-2009}dependency", _) => __obj.spiritdependency foreach { x => attr = scala.xml.Attribute(__scope.getPrefix("http://www.spiritconsortium.org/XMLSchema/SPIRIT/1685-2009"), "dependency", x.toString, attr) }
        case ("@{http://www.spiritconsortium.org/XMLSchema/SPIRIT/1685-2009}choiceRef", _) => __obj.spiritchoiceRef foreach { x => attr = scala.xml.Attribute(__scope.getPrefix("http://www.spiritconsortium.org/XMLSchema/SPIRIT/1685-2009"), "choiceRef", x.toString, attr) }
        case ("@{http://www.spiritconsortium.org/XMLSchema/SPIRIT/1685-2009}order", _) => __obj.spiritorder foreach { x => attr = scala.xml.Attribute(__scope.getPrefix("http://www.spiritconsortium.org/XMLSchema/SPIRIT/1685-2009"), "order", x.toString, attr) }
        case ("@{http://www.spiritconsortium.org/XMLSchema/SPIRIT/1685-2009}configGroups", _) => __obj.spiritconfigGroups foreach { x => attr = scala.xml.Attribute(__scope.getPrefix("http://www.spiritconsortium.org/XMLSchema/SPIRIT/1685-2009"), "configGroups", x.toString, attr) }
        case ("@{http://www.spiritconsortium.org/XMLSchema/SPIRIT/1685-2009}bitStringLength", _) => __obj.spiritbitStringLength foreach { x => attr = scala.xml.Attribute(__scope.getPrefix("http://www.spiritconsortium.org/XMLSchema/SPIRIT/1685-2009"), "bitStringLength", x.toString, attr) }
        case ("@{http://www.spiritconsortium.org/XMLSchema/SPIRIT/1685-2009}minimum", _) => __obj.spiritminimum foreach { x => attr = scala.xml.Attribute(__scope.getPrefix("http://www.spiritconsortium.org/XMLSchema/SPIRIT/1685-2009"), "minimum", x.toString, attr) }
        case ("@{http://www.spiritconsortium.org/XMLSchema/SPIRIT/1685-2009}maximum", _) => __obj.spiritmaximum foreach { x => attr = scala.xml.Attribute(__scope.getPrefix("http://www.spiritconsortium.org/XMLSchema/SPIRIT/1685-2009"), "maximum", x.toString, attr) }
        case ("@{http://www.spiritconsortium.org/XMLSchema/SPIRIT/1685-2009}rangeType", _) => __obj.spiritrangeType foreach { x => attr = scala.xml.Attribute(__scope.getPrefix("http://www.spiritconsortium.org/XMLSchema/SPIRIT/1685-2009"), "rangeType", x.toString, attr) }
        case ("@{http://www.spiritconsortium.org/XMLSchema/SPIRIT/1685-2009}prompt", _) => __obj.spiritprompt foreach { x => attr = scala.xml.Attribute(__scope.getPrefix("http://www.spiritconsortium.org/XMLSchema/SPIRIT/1685-2009"), "prompt", x.toString, attr) }
        case (key, x) => attr = scala.xml.Attribute((x.namespace map { __scope.getPrefix(_) }).orNull, x.key.orNull, x.value.toString, attr)
      }
      attr
    }

    def writesChildNodes(__obj: Name, __scope: scala.xml.NamespaceBinding): Seq[scala.xml.Node] =
      Seq(scala.xml.Text(__obj.value.toString))

  }

  trait Default_IsIncludeFileFormat extends IPXACT2009scalaxb.XMLFormat[IsIncludeFile] with IPXACT2009scalaxb.CanWriteChildNodes[IsIncludeFile] {
    val targetNamespace: Option[String] = Some("http://www.spiritconsortium.org/XMLSchema/SPIRIT/1685-2009")
    def reads(seq: scala.xml.NodeSeq, stack: List[IPXACT2009scalaxb.ElemName]): Either[String, IsIncludeFile] = seq match {
      case node: scala.xml.Node => Right(IsIncludeFile(IPXACT2009scalaxb.fromXML[Boolean](node, IPXACT2009scalaxb.ElemName(node) :: stack),
        scala.collection.immutable.ListMap(List(
        (node \ "@{http://www.spiritconsortium.org/XMLSchema/SPIRIT/1685-2009}externalDeclarations").headOption map { x => IPXACT2009scalaxb.DataRecord(x, node, IPXACT2009scalaxb.fromXML[Boolean](x, IPXACT2009scalaxb.ElemName(node) :: stack)) } orElse Some(IPXACT2009scalaxb.DataRecord(None, None, IPXACT2009scalaxb.fromXML[Boolean](scala.xml.Text("false"), IPXACT2009scalaxb.ElemName(node) :: stack))) map { "@externalDeclarations" -> _ }
        ).flatten[(String, IPXACT2009scalaxb.DataRecord[Any])]: _*)))
      case _ => Left("reads failed: seq must be scala.xml.Node")
    }
    
    override def writesAttribute(__obj: IsIncludeFile, __scope: scala.xml.NamespaceBinding): scala.xml.MetaData = {
      var attr: scala.xml.MetaData  = scala.xml.Null
      __obj.attributes.toList map {
        case ("@externalDeclarations", _) => if (__obj.externalDeclarations.toString != "false") attr = scala.xml.Attribute(__scope.getPrefix("http://www.spiritconsortium.org/XMLSchema/SPIRIT/1685-2009"), "externalDeclarations", __obj.externalDeclarations.toString, attr)
        case (key, x) => attr = scala.xml.Attribute((x.namespace map { __scope.getPrefix(_) }).orNull, x.key.orNull, x.value.toString, attr)
      }
      attr
    }

    def writesChildNodes(__obj: IsIncludeFile, __scope: scala.xml.NamespaceBinding): Seq[scala.xml.Node] =
      Seq(scala.xml.Text(__obj.value.toString))

  }

  trait Default_LogicalNameFormat extends IPXACT2009scalaxb.XMLFormat[LogicalName] with IPXACT2009scalaxb.CanWriteChildNodes[LogicalName] {
    val targetNamespace: Option[String] = Some("http://www.spiritconsortium.org/XMLSchema/SPIRIT/1685-2009")
    def reads(seq: scala.xml.NodeSeq, stack: List[IPXACT2009scalaxb.ElemName]): Either[String, LogicalName] = seq match {
      case node: scala.xml.Node => Right(LogicalName(IPXACT2009scalaxb.fromXML[String](node, IPXACT2009scalaxb.ElemName(node) :: stack),
        scala.collection.immutable.ListMap(List(
        (node \ "@{http://www.spiritconsortium.org/XMLSchema/SPIRIT/1685-2009}default").headOption map { x => IPXACT2009scalaxb.DataRecord(x, node, IPXACT2009scalaxb.fromXML[Boolean](x, IPXACT2009scalaxb.ElemName(node) :: stack)) } orElse Some(IPXACT2009scalaxb.DataRecord(None, None, IPXACT2009scalaxb.fromXML[Boolean](scala.xml.Text("false"), IPXACT2009scalaxb.ElemName(node) :: stack))) map { "@default" -> _ }
        ).flatten[(String, IPXACT2009scalaxb.DataRecord[Any])]: _*)))
      case _ => Left("reads failed: seq must be scala.xml.Node")
    }
    
    override def writesAttribute(__obj: LogicalName, __scope: scala.xml.NamespaceBinding): scala.xml.MetaData = {
      var attr: scala.xml.MetaData  = scala.xml.Null
      __obj.attributes.toList map {
        case ("@default", _) => if (__obj.default.toString != "false") attr = scala.xml.Attribute(__scope.getPrefix("http://www.spiritconsortium.org/XMLSchema/SPIRIT/1685-2009"), "default", __obj.default.toString, attr)
        case (key, x) => attr = scala.xml.Attribute((x.namespace map { __scope.getPrefix(_) }).orNull, x.key.orNull, x.value.toString, attr)
      }
      attr
    }

    def writesChildNodes(__obj: LogicalName, __scope: scala.xml.NamespaceBinding): Seq[scala.xml.Node] =
      Seq(scala.xml.Text(__obj.value.toString))

  }

  trait Default_CommandFormat extends IPXACT2009scalaxb.XMLFormat[Command] with IPXACT2009scalaxb.CanWriteChildNodes[Command] {
    val targetNamespace: Option[String] = Some("http://www.spiritconsortium.org/XMLSchema/SPIRIT/1685-2009")
    def reads(seq: scala.xml.NodeSeq, stack: List[IPXACT2009scalaxb.ElemName]): Either[String, Command] = seq match {
      case node: scala.xml.Node => Right(Command(IPXACT2009scalaxb.fromXML[String](node, IPXACT2009scalaxb.ElemName(node) :: stack),
        scala.collection.immutable.ListMap(List(
        (node \ "@{http://www.spiritconsortium.org/XMLSchema/SPIRIT/1685-2009}format").headOption map { x => IPXACT2009scalaxb.DataRecord(x, node, IPXACT2009scalaxb.fromXML[FormatType](x, IPXACT2009scalaxb.ElemName(node) :: stack)) } orElse Some(IPXACT2009scalaxb.DataRecord(None, None, IPXACT2009scalaxb.fromXML[FormatType](scala.xml.Text("string"), IPXACT2009scalaxb.ElemName(node) :: stack))) map { "@{http://www.spiritconsortium.org/XMLSchema/SPIRIT/1685-2009}format" -> _ },
        (node \ "@{http://www.spiritconsortium.org/XMLSchema/SPIRIT/1685-2009}resolve").headOption map { x => IPXACT2009scalaxb.DataRecord(x, node, IPXACT2009scalaxb.fromXML[ResolveType](x, IPXACT2009scalaxb.ElemName(node) :: stack)) } map { "@{http://www.spiritconsortium.org/XMLSchema/SPIRIT/1685-2009}resolve" -> _ },
        (node \ "@{http://www.spiritconsortium.org/XMLSchema/SPIRIT/1685-2009}id").headOption map { x => IPXACT2009scalaxb.DataRecord(x, node, IPXACT2009scalaxb.fromXML[String](x, IPXACT2009scalaxb.ElemName(node) :: stack)) } map { "@{http://www.spiritconsortium.org/XMLSchema/SPIRIT/1685-2009}id" -> _ },
        (node \ "@{http://www.spiritconsortium.org/XMLSchema/SPIRIT/1685-2009}dependency").headOption map { x => IPXACT2009scalaxb.DataRecord(x, node, IPXACT2009scalaxb.fromXML[String](x, IPXACT2009scalaxb.ElemName(node) :: stack)) } map { "@{http://www.spiritconsortium.org/XMLSchema/SPIRIT/1685-2009}dependency" -> _ },
        (node \ "@{http://www.spiritconsortium.org/XMLSchema/SPIRIT/1685-2009}choiceRef").headOption map { x => IPXACT2009scalaxb.DataRecord(x, node, IPXACT2009scalaxb.fromXML[String](x, IPXACT2009scalaxb.ElemName(node) :: stack)) } map { "@{http://www.spiritconsortium.org/XMLSchema/SPIRIT/1685-2009}choiceRef" -> _ },
        (node \ "@{http://www.spiritconsortium.org/XMLSchema/SPIRIT/1685-2009}order").headOption map { x => IPXACT2009scalaxb.DataRecord(x, node, IPXACT2009scalaxb.fromXML[Float](x, IPXACT2009scalaxb.ElemName(node) :: stack)) } map { "@{http://www.spiritconsortium.org/XMLSchema/SPIRIT/1685-2009}order" -> _ },
        (node \ "@{http://www.spiritconsortium.org/XMLSchema/SPIRIT/1685-2009}configGroups").headOption map { x => IPXACT2009scalaxb.DataRecord(x, node, IPXACT2009scalaxb.fromXML[Seq[String]](x, IPXACT2009scalaxb.ElemName(node) :: stack)) } map { "@{http://www.spiritconsortium.org/XMLSchema/SPIRIT/1685-2009}configGroups" -> _ },
        (node \ "@{http://www.spiritconsortium.org/XMLSchema/SPIRIT/1685-2009}bitStringLength").headOption map { x => IPXACT2009scalaxb.DataRecord(x, node, IPXACT2009scalaxb.fromXML[BigInt](x, IPXACT2009scalaxb.ElemName(node) :: stack)) } map { "@{http://www.spiritconsortium.org/XMLSchema/SPIRIT/1685-2009}bitStringLength" -> _ },
        (node \ "@{http://www.spiritconsortium.org/XMLSchema/SPIRIT/1685-2009}minimum").headOption map { x => IPXACT2009scalaxb.DataRecord(x, node, IPXACT2009scalaxb.fromXML[String](x, IPXACT2009scalaxb.ElemName(node) :: stack)) } map { "@{http://www.spiritconsortium.org/XMLSchema/SPIRIT/1685-2009}minimum" -> _ },
        (node \ "@{http://www.spiritconsortium.org/XMLSchema/SPIRIT/1685-2009}maximum").headOption map { x => IPXACT2009scalaxb.DataRecord(x, node, IPXACT2009scalaxb.fromXML[String](x, IPXACT2009scalaxb.ElemName(node) :: stack)) } map { "@{http://www.spiritconsortium.org/XMLSchema/SPIRIT/1685-2009}maximum" -> _ },
        (node \ "@{http://www.spiritconsortium.org/XMLSchema/SPIRIT/1685-2009}rangeType").headOption map { x => IPXACT2009scalaxb.DataRecord(x, node, IPXACT2009scalaxb.fromXML[RangeTypeType](x, IPXACT2009scalaxb.ElemName(node) :: stack)) } map { "@{http://www.spiritconsortium.org/XMLSchema/SPIRIT/1685-2009}rangeType" -> _ },
        (node \ "@{http://www.spiritconsortium.org/XMLSchema/SPIRIT/1685-2009}prompt").headOption map { x => IPXACT2009scalaxb.DataRecord(x, node, IPXACT2009scalaxb.fromXML[String](x, IPXACT2009scalaxb.ElemName(node) :: stack)) } map { "@{http://www.spiritconsortium.org/XMLSchema/SPIRIT/1685-2009}prompt" -> _ }
        ).flatten[(String, IPXACT2009scalaxb.DataRecord[Any])] ::: (node match {
          case elem: scala.xml.Elem =>
            elem.attributes.toList flatMap {
              case scala.xml.PrefixedAttribute(pre, key, value, _) if pre == elem.scope.getPrefix("http://www.spiritconsortium.org/XMLSchema/SPIRIT/1685-2009") &&
                key == "format" => Nil
              case scala.xml.PrefixedAttribute(pre, key, value, _) if pre == elem.scope.getPrefix("http://www.spiritconsortium.org/XMLSchema/SPIRIT/1685-2009") &&
                key == "resolve" => Nil
              case scala.xml.PrefixedAttribute(pre, key, value, _) if pre == elem.scope.getPrefix("http://www.spiritconsortium.org/XMLSchema/SPIRIT/1685-2009") &&
                key == "id" => Nil
              case scala.xml.PrefixedAttribute(pre, key, value, _) if pre == elem.scope.getPrefix("http://www.spiritconsortium.org/XMLSchema/SPIRIT/1685-2009") &&
                key == "dependency" => Nil
              case scala.xml.PrefixedAttribute(pre, key, value, _) if pre == elem.scope.getPrefix("http://www.spiritconsortium.org/XMLSchema/SPIRIT/1685-2009") &&
                key == "choiceRef" => Nil
              case scala.xml.PrefixedAttribute(pre, key, value, _) if pre == elem.scope.getPrefix("http://www.spiritconsortium.org/XMLSchema/SPIRIT/1685-2009") &&
                key == "order" => Nil
              case scala.xml.PrefixedAttribute(pre, key, value, _) if pre == elem.scope.getPrefix("http://www.spiritconsortium.org/XMLSchema/SPIRIT/1685-2009") &&
                key == "configGroups" => Nil
              case scala.xml.PrefixedAttribute(pre, key, value, _) if pre == elem.scope.getPrefix("http://www.spiritconsortium.org/XMLSchema/SPIRIT/1685-2009") &&
                key == "bitStringLength" => Nil
              case scala.xml.PrefixedAttribute(pre, key, value, _) if pre == elem.scope.getPrefix("http://www.spiritconsortium.org/XMLSchema/SPIRIT/1685-2009") &&
                key == "minimum" => Nil
              case scala.xml.PrefixedAttribute(pre, key, value, _) if pre == elem.scope.getPrefix("http://www.spiritconsortium.org/XMLSchema/SPIRIT/1685-2009") &&
                key == "maximum" => Nil
              case scala.xml.PrefixedAttribute(pre, key, value, _) if pre == elem.scope.getPrefix("http://www.spiritconsortium.org/XMLSchema/SPIRIT/1685-2009") &&
                key == "rangeType" => Nil
              case scala.xml.PrefixedAttribute(pre, key, value, _) if pre == elem.scope.getPrefix("http://www.spiritconsortium.org/XMLSchema/SPIRIT/1685-2009") &&
                key == "prompt" => Nil
              case scala.xml.UnprefixedAttribute(key, value, _) =>
                List(("@" + key, IPXACT2009scalaxb.DataRecord(None, Some(key), value.text)))
              case scala.xml.PrefixedAttribute(pre, key, value, _) =>
                val ns = elem.scope.getURI(pre)
                List(("@{" + ns + "}" + key, IPXACT2009scalaxb.DataRecord(Option[String](ns), Some(key), value.text)))
              case _ => Nil
            }
          case _ => Nil
        }): _*)))
      case _ => Left("reads failed: seq must be scala.xml.Node")
    }
    
    override def writesAttribute(__obj: Command, __scope: scala.xml.NamespaceBinding): scala.xml.MetaData = {
      var attr: scala.xml.MetaData  = scala.xml.Null
      __obj.attributes.toList map {
        case ("@{http://www.spiritconsortium.org/XMLSchema/SPIRIT/1685-2009}format", _) => if (__obj.spiritformat.toString != "string") attr = scala.xml.Attribute(__scope.getPrefix("http://www.spiritconsortium.org/XMLSchema/SPIRIT/1685-2009"), "format", __obj.spiritformat.toString, attr)
        case ("@{http://www.spiritconsortium.org/XMLSchema/SPIRIT/1685-2009}resolve", _) => __obj.spiritresolve foreach { x => attr = scala.xml.Attribute(__scope.getPrefix("http://www.spiritconsortium.org/XMLSchema/SPIRIT/1685-2009"), "resolve", x.toString, attr) }
        case ("@{http://www.spiritconsortium.org/XMLSchema/SPIRIT/1685-2009}id", _) => __obj.spiritid foreach { x => attr = scala.xml.Attribute(__scope.getPrefix("http://www.spiritconsortium.org/XMLSchema/SPIRIT/1685-2009"), "id", x.toString, attr) }
        case ("@{http://www.spiritconsortium.org/XMLSchema/SPIRIT/1685-2009}dependency", _) => __obj.spiritdependency foreach { x => attr = scala.xml.Attribute(__scope.getPrefix("http://www.spiritconsortium.org/XMLSchema/SPIRIT/1685-2009"), "dependency", x.toString, attr) }
        case ("@{http://www.spiritconsortium.org/XMLSchema/SPIRIT/1685-2009}choiceRef", _) => __obj.spiritchoiceRef foreach { x => attr = scala.xml.Attribute(__scope.getPrefix("http://www.spiritconsortium.org/XMLSchema/SPIRIT/1685-2009"), "choiceRef", x.toString, attr) }
        case ("@{http://www.spiritconsortium.org/XMLSchema/SPIRIT/1685-2009}order", _) => __obj.spiritorder foreach { x => attr = scala.xml.Attribute(__scope.getPrefix("http://www.spiritconsortium.org/XMLSchema/SPIRIT/1685-2009"), "order", x.toString, attr) }
        case ("@{http://www.spiritconsortium.org/XMLSchema/SPIRIT/1685-2009}configGroups", _) => __obj.spiritconfigGroups foreach { x => attr = scala.xml.Attribute(__scope.getPrefix("http://www.spiritconsortium.org/XMLSchema/SPIRIT/1685-2009"), "configGroups", x.toString, attr) }
        case ("@{http://www.spiritconsortium.org/XMLSchema/SPIRIT/1685-2009}bitStringLength", _) => __obj.spiritbitStringLength foreach { x => attr = scala.xml.Attribute(__scope.getPrefix("http://www.spiritconsortium.org/XMLSchema/SPIRIT/1685-2009"), "bitStringLength", x.toString, attr) }
        case ("@{http://www.spiritconsortium.org/XMLSchema/SPIRIT/1685-2009}minimum", _) => __obj.spiritminimum foreach { x => attr = scala.xml.Attribute(__scope.getPrefix("http://www.spiritconsortium.org/XMLSchema/SPIRIT/1685-2009"), "minimum", x.toString, attr) }
        case ("@{http://www.spiritconsortium.org/XMLSchema/SPIRIT/1685-2009}maximum", _) => __obj.spiritmaximum foreach { x => attr = scala.xml.Attribute(__scope.getPrefix("http://www.spiritconsortium.org/XMLSchema/SPIRIT/1685-2009"), "maximum", x.toString, attr) }
        case ("@{http://www.spiritconsortium.org/XMLSchema/SPIRIT/1685-2009}rangeType", _) => __obj.spiritrangeType foreach { x => attr = scala.xml.Attribute(__scope.getPrefix("http://www.spiritconsortium.org/XMLSchema/SPIRIT/1685-2009"), "rangeType", x.toString, attr) }
        case ("@{http://www.spiritconsortium.org/XMLSchema/SPIRIT/1685-2009}prompt", _) => __obj.spiritprompt foreach { x => attr = scala.xml.Attribute(__scope.getPrefix("http://www.spiritconsortium.org/XMLSchema/SPIRIT/1685-2009"), "prompt", x.toString, attr) }
        case (key, x) => attr = scala.xml.Attribute((x.namespace map { __scope.getPrefix(_) }).orNull, x.key.orNull, x.value.toString, attr)
      }
      attr
    }

    def writesChildNodes(__obj: Command, __scope: scala.xml.NamespaceBinding): Seq[scala.xml.Node] =
      Seq(scala.xml.Text(__obj.value.toString))

  }

  trait Default_FlagsFormat extends IPXACT2009scalaxb.XMLFormat[Flags] with IPXACT2009scalaxb.CanWriteChildNodes[Flags] {
    val targetNamespace: Option[String] = Some("http://www.spiritconsortium.org/XMLSchema/SPIRIT/1685-2009")
    def reads(seq: scala.xml.NodeSeq, stack: List[IPXACT2009scalaxb.ElemName]): Either[String, Flags] = seq match {
      case node: scala.xml.Node => Right(Flags(IPXACT2009scalaxb.fromXML[String](node, IPXACT2009scalaxb.ElemName(node) :: stack),
        scala.collection.immutable.ListMap(List(
        (node \ "@{http://www.spiritconsortium.org/XMLSchema/SPIRIT/1685-2009}append").headOption map { x => IPXACT2009scalaxb.DataRecord(x, node, IPXACT2009scalaxb.fromXML[Boolean](x, IPXACT2009scalaxb.ElemName(node) :: stack)) } map { "@append" -> _ },
        (node \ "@{http://www.spiritconsortium.org/XMLSchema/SPIRIT/1685-2009}format").headOption map { x => IPXACT2009scalaxb.DataRecord(x, node, IPXACT2009scalaxb.fromXML[FormatType](x, IPXACT2009scalaxb.ElemName(node) :: stack)) } orElse Some(IPXACT2009scalaxb.DataRecord(None, None, IPXACT2009scalaxb.fromXML[FormatType](scala.xml.Text("string"), IPXACT2009scalaxb.ElemName(node) :: stack))) map { "@{http://www.spiritconsortium.org/XMLSchema/SPIRIT/1685-2009}format" -> _ },
        (node \ "@{http://www.spiritconsortium.org/XMLSchema/SPIRIT/1685-2009}resolve").headOption map { x => IPXACT2009scalaxb.DataRecord(x, node, IPXACT2009scalaxb.fromXML[ResolveType](x, IPXACT2009scalaxb.ElemName(node) :: stack)) } map { "@{http://www.spiritconsortium.org/XMLSchema/SPIRIT/1685-2009}resolve" -> _ },
        (node \ "@{http://www.spiritconsortium.org/XMLSchema/SPIRIT/1685-2009}id").headOption map { x => IPXACT2009scalaxb.DataRecord(x, node, IPXACT2009scalaxb.fromXML[String](x, IPXACT2009scalaxb.ElemName(node) :: stack)) } map { "@{http://www.spiritconsortium.org/XMLSchema/SPIRIT/1685-2009}id" -> _ },
        (node \ "@{http://www.spiritconsortium.org/XMLSchema/SPIRIT/1685-2009}dependency").headOption map { x => IPXACT2009scalaxb.DataRecord(x, node, IPXACT2009scalaxb.fromXML[String](x, IPXACT2009scalaxb.ElemName(node) :: stack)) } map { "@{http://www.spiritconsortium.org/XMLSchema/SPIRIT/1685-2009}dependency" -> _ },
        (node \ "@{http://www.spiritconsortium.org/XMLSchema/SPIRIT/1685-2009}choiceRef").headOption map { x => IPXACT2009scalaxb.DataRecord(x, node, IPXACT2009scalaxb.fromXML[String](x, IPXACT2009scalaxb.ElemName(node) :: stack)) } map { "@{http://www.spiritconsortium.org/XMLSchema/SPIRIT/1685-2009}choiceRef" -> _ },
        (node \ "@{http://www.spiritconsortium.org/XMLSchema/SPIRIT/1685-2009}order").headOption map { x => IPXACT2009scalaxb.DataRecord(x, node, IPXACT2009scalaxb.fromXML[Float](x, IPXACT2009scalaxb.ElemName(node) :: stack)) } map { "@{http://www.spiritconsortium.org/XMLSchema/SPIRIT/1685-2009}order" -> _ },
        (node \ "@{http://www.spiritconsortium.org/XMLSchema/SPIRIT/1685-2009}configGroups").headOption map { x => IPXACT2009scalaxb.DataRecord(x, node, IPXACT2009scalaxb.fromXML[Seq[String]](x, IPXACT2009scalaxb.ElemName(node) :: stack)) } map { "@{http://www.spiritconsortium.org/XMLSchema/SPIRIT/1685-2009}configGroups" -> _ },
        (node \ "@{http://www.spiritconsortium.org/XMLSchema/SPIRIT/1685-2009}bitStringLength").headOption map { x => IPXACT2009scalaxb.DataRecord(x, node, IPXACT2009scalaxb.fromXML[BigInt](x, IPXACT2009scalaxb.ElemName(node) :: stack)) } map { "@{http://www.spiritconsortium.org/XMLSchema/SPIRIT/1685-2009}bitStringLength" -> _ },
        (node \ "@{http://www.spiritconsortium.org/XMLSchema/SPIRIT/1685-2009}minimum").headOption map { x => IPXACT2009scalaxb.DataRecord(x, node, IPXACT2009scalaxb.fromXML[String](x, IPXACT2009scalaxb.ElemName(node) :: stack)) } map { "@{http://www.spiritconsortium.org/XMLSchema/SPIRIT/1685-2009}minimum" -> _ },
        (node \ "@{http://www.spiritconsortium.org/XMLSchema/SPIRIT/1685-2009}maximum").headOption map { x => IPXACT2009scalaxb.DataRecord(x, node, IPXACT2009scalaxb.fromXML[String](x, IPXACT2009scalaxb.ElemName(node) :: stack)) } map { "@{http://www.spiritconsortium.org/XMLSchema/SPIRIT/1685-2009}maximum" -> _ },
        (node \ "@{http://www.spiritconsortium.org/XMLSchema/SPIRIT/1685-2009}rangeType").headOption map { x => IPXACT2009scalaxb.DataRecord(x, node, IPXACT2009scalaxb.fromXML[RangeTypeType](x, IPXACT2009scalaxb.ElemName(node) :: stack)) } map { "@{http://www.spiritconsortium.org/XMLSchema/SPIRIT/1685-2009}rangeType" -> _ },
        (node \ "@{http://www.spiritconsortium.org/XMLSchema/SPIRIT/1685-2009}prompt").headOption map { x => IPXACT2009scalaxb.DataRecord(x, node, IPXACT2009scalaxb.fromXML[String](x, IPXACT2009scalaxb.ElemName(node) :: stack)) } map { "@{http://www.spiritconsortium.org/XMLSchema/SPIRIT/1685-2009}prompt" -> _ }
        ).flatten[(String, IPXACT2009scalaxb.DataRecord[Any])] ::: (node match {
          case elem: scala.xml.Elem =>
            elem.attributes.toList flatMap {
              case scala.xml.PrefixedAttribute(pre, key, value, _) if pre == elem.scope.getPrefix("http://www.spiritconsortium.org/XMLSchema/SPIRIT/1685-2009") &&
                key == "append" => Nil
              case scala.xml.PrefixedAttribute(pre, key, value, _) if pre == elem.scope.getPrefix("http://www.spiritconsortium.org/XMLSchema/SPIRIT/1685-2009") &&
                key == "format" => Nil
              case scala.xml.PrefixedAttribute(pre, key, value, _) if pre == elem.scope.getPrefix("http://www.spiritconsortium.org/XMLSchema/SPIRIT/1685-2009") &&
                key == "resolve" => Nil
              case scala.xml.PrefixedAttribute(pre, key, value, _) if pre == elem.scope.getPrefix("http://www.spiritconsortium.org/XMLSchema/SPIRIT/1685-2009") &&
                key == "id" => Nil
              case scala.xml.PrefixedAttribute(pre, key, value, _) if pre == elem.scope.getPrefix("http://www.spiritconsortium.org/XMLSchema/SPIRIT/1685-2009") &&
                key == "dependency" => Nil
              case scala.xml.PrefixedAttribute(pre, key, value, _) if pre == elem.scope.getPrefix("http://www.spiritconsortium.org/XMLSchema/SPIRIT/1685-2009") &&
                key == "choiceRef" => Nil
              case scala.xml.PrefixedAttribute(pre, key, value, _) if pre == elem.scope.getPrefix("http://www.spiritconsortium.org/XMLSchema/SPIRIT/1685-2009") &&
                key == "order" => Nil
              case scala.xml.PrefixedAttribute(pre, key, value, _) if pre == elem.scope.getPrefix("http://www.spiritconsortium.org/XMLSchema/SPIRIT/1685-2009") &&
                key == "configGroups" => Nil
              case scala.xml.PrefixedAttribute(pre, key, value, _) if pre == elem.scope.getPrefix("http://www.spiritconsortium.org/XMLSchema/SPIRIT/1685-2009") &&
                key == "bitStringLength" => Nil
              case scala.xml.PrefixedAttribute(pre, key, value, _) if pre == elem.scope.getPrefix("http://www.spiritconsortium.org/XMLSchema/SPIRIT/1685-2009") &&
                key == "minimum" => Nil
              case scala.xml.PrefixedAttribute(pre, key, value, _) if pre == elem.scope.getPrefix("http://www.spiritconsortium.org/XMLSchema/SPIRIT/1685-2009") &&
                key == "maximum" => Nil
              case scala.xml.PrefixedAttribute(pre, key, value, _) if pre == elem.scope.getPrefix("http://www.spiritconsortium.org/XMLSchema/SPIRIT/1685-2009") &&
                key == "rangeType" => Nil
              case scala.xml.PrefixedAttribute(pre, key, value, _) if pre == elem.scope.getPrefix("http://www.spiritconsortium.org/XMLSchema/SPIRIT/1685-2009") &&
                key == "prompt" => Nil
              case scala.xml.UnprefixedAttribute(key, value, _) =>
                List(("@" + key, IPXACT2009scalaxb.DataRecord(None, Some(key), value.text)))
              case scala.xml.PrefixedAttribute(pre, key, value, _) =>
                val ns = elem.scope.getURI(pre)
                List(("@{" + ns + "}" + key, IPXACT2009scalaxb.DataRecord(Option[String](ns), Some(key), value.text)))
              case _ => Nil
            }
          case _ => Nil
        }): _*)))
      case _ => Left("reads failed: seq must be scala.xml.Node")
    }
    
    override def writesAttribute(__obj: Flags, __scope: scala.xml.NamespaceBinding): scala.xml.MetaData = {
      var attr: scala.xml.MetaData  = scala.xml.Null
      __obj.attributes.toList map {
        case ("@append", _) => __obj.append foreach { x => attr = scala.xml.Attribute(__scope.getPrefix("http://www.spiritconsortium.org/XMLSchema/SPIRIT/1685-2009"), "append", x.toString, attr) }
        case ("@{http://www.spiritconsortium.org/XMLSchema/SPIRIT/1685-2009}format", _) => if (__obj.spiritformat.toString != "string") attr = scala.xml.Attribute(__scope.getPrefix("http://www.spiritconsortium.org/XMLSchema/SPIRIT/1685-2009"), "format", __obj.spiritformat.toString, attr)
        case ("@{http://www.spiritconsortium.org/XMLSchema/SPIRIT/1685-2009}resolve", _) => __obj.spiritresolve foreach { x => attr = scala.xml.Attribute(__scope.getPrefix("http://www.spiritconsortium.org/XMLSchema/SPIRIT/1685-2009"), "resolve", x.toString, attr) }
        case ("@{http://www.spiritconsortium.org/XMLSchema/SPIRIT/1685-2009}id", _) => __obj.spiritid foreach { x => attr = scala.xml.Attribute(__scope.getPrefix("http://www.spiritconsortium.org/XMLSchema/SPIRIT/1685-2009"), "id", x.toString, attr) }
        case ("@{http://www.spiritconsortium.org/XMLSchema/SPIRIT/1685-2009}dependency", _) => __obj.spiritdependency foreach { x => attr = scala.xml.Attribute(__scope.getPrefix("http://www.spiritconsortium.org/XMLSchema/SPIRIT/1685-2009"), "dependency", x.toString, attr) }
        case ("@{http://www.spiritconsortium.org/XMLSchema/SPIRIT/1685-2009}choiceRef", _) => __obj.spiritchoiceRef foreach { x => attr = scala.xml.Attribute(__scope.getPrefix("http://www.spiritconsortium.org/XMLSchema/SPIRIT/1685-2009"), "choiceRef", x.toString, attr) }
        case ("@{http://www.spiritconsortium.org/XMLSchema/SPIRIT/1685-2009}order", _) => __obj.spiritorder foreach { x => attr = scala.xml.Attribute(__scope.getPrefix("http://www.spiritconsortium.org/XMLSchema/SPIRIT/1685-2009"), "order", x.toString, attr) }
        case ("@{http://www.spiritconsortium.org/XMLSchema/SPIRIT/1685-2009}configGroups", _) => __obj.spiritconfigGroups foreach { x => attr = scala.xml.Attribute(__scope.getPrefix("http://www.spiritconsortium.org/XMLSchema/SPIRIT/1685-2009"), "configGroups", x.toString, attr) }
        case ("@{http://www.spiritconsortium.org/XMLSchema/SPIRIT/1685-2009}bitStringLength", _) => __obj.spiritbitStringLength foreach { x => attr = scala.xml.Attribute(__scope.getPrefix("http://www.spiritconsortium.org/XMLSchema/SPIRIT/1685-2009"), "bitStringLength", x.toString, attr) }
        case ("@{http://www.spiritconsortium.org/XMLSchema/SPIRIT/1685-2009}minimum", _) => __obj.spiritminimum foreach { x => attr = scala.xml.Attribute(__scope.getPrefix("http://www.spiritconsortium.org/XMLSchema/SPIRIT/1685-2009"), "minimum", x.toString, attr) }
        case ("@{http://www.spiritconsortium.org/XMLSchema/SPIRIT/1685-2009}maximum", _) => __obj.spiritmaximum foreach { x => attr = scala.xml.Attribute(__scope.getPrefix("http://www.spiritconsortium.org/XMLSchema/SPIRIT/1685-2009"), "maximum", x.toString, attr) }
        case ("@{http://www.spiritconsortium.org/XMLSchema/SPIRIT/1685-2009}rangeType", _) => __obj.spiritrangeType foreach { x => attr = scala.xml.Attribute(__scope.getPrefix("http://www.spiritconsortium.org/XMLSchema/SPIRIT/1685-2009"), "rangeType", x.toString, attr) }
        case ("@{http://www.spiritconsortium.org/XMLSchema/SPIRIT/1685-2009}prompt", _) => __obj.spiritprompt foreach { x => attr = scala.xml.Attribute(__scope.getPrefix("http://www.spiritconsortium.org/XMLSchema/SPIRIT/1685-2009"), "prompt", x.toString, attr) }
        case (key, x) => attr = scala.xml.Attribute((x.namespace map { __scope.getPrefix(_) }).orNull, x.key.orNull, x.value.toString, attr)
      }
      attr
    }

    def writesChildNodes(__obj: Flags, __scope: scala.xml.NamespaceBinding): Seq[scala.xml.Node] =
      Seq(scala.xml.Text(__obj.value.toString))

  }

  trait Default_ReplaceDefaultFlagsFormat extends IPXACT2009scalaxb.XMLFormat[ReplaceDefaultFlags] with IPXACT2009scalaxb.CanWriteChildNodes[ReplaceDefaultFlags] {
    val targetNamespace: Option[String] = Some("http://www.spiritconsortium.org/XMLSchema/SPIRIT/1685-2009")
    def reads(seq: scala.xml.NodeSeq, stack: List[IPXACT2009scalaxb.ElemName]): Either[String, ReplaceDefaultFlags] = seq match {
      case node: scala.xml.Node => Right(ReplaceDefaultFlags(IPXACT2009scalaxb.fromXML[Boolean](node, IPXACT2009scalaxb.ElemName(node) :: stack),
        scala.collection.immutable.ListMap(List(
        (node \ "@{http://www.spiritconsortium.org/XMLSchema/SPIRIT/1685-2009}format").headOption map { x => IPXACT2009scalaxb.DataRecord(x, node, IPXACT2009scalaxb.fromXML[FormatType](x, IPXACT2009scalaxb.ElemName(node) :: stack)) } orElse Some(IPXACT2009scalaxb.DataRecord(None, None, IPXACT2009scalaxb.fromXML[FormatType](scala.xml.Text("bool"), IPXACT2009scalaxb.ElemName(node) :: stack))) map { "@{http://www.spiritconsortium.org/XMLSchema/SPIRIT/1685-2009}format" -> _ },
        (node \ "@{http://www.spiritconsortium.org/XMLSchema/SPIRIT/1685-2009}resolve").headOption map { x => IPXACT2009scalaxb.DataRecord(x, node, IPXACT2009scalaxb.fromXML[ResolveType](x, IPXACT2009scalaxb.ElemName(node) :: stack)) } map { "@{http://www.spiritconsortium.org/XMLSchema/SPIRIT/1685-2009}resolve" -> _ },
        (node \ "@{http://www.spiritconsortium.org/XMLSchema/SPIRIT/1685-2009}id").headOption map { x => IPXACT2009scalaxb.DataRecord(x, node, IPXACT2009scalaxb.fromXML[String](x, IPXACT2009scalaxb.ElemName(node) :: stack)) } map { "@{http://www.spiritconsortium.org/XMLSchema/SPIRIT/1685-2009}id" -> _ },
        (node \ "@{http://www.spiritconsortium.org/XMLSchema/SPIRIT/1685-2009}dependency").headOption map { x => IPXACT2009scalaxb.DataRecord(x, node, IPXACT2009scalaxb.fromXML[String](x, IPXACT2009scalaxb.ElemName(node) :: stack)) } map { "@{http://www.spiritconsortium.org/XMLSchema/SPIRIT/1685-2009}dependency" -> _ },
        (node \ "@{http://www.spiritconsortium.org/XMLSchema/SPIRIT/1685-2009}choiceRef").headOption map { x => IPXACT2009scalaxb.DataRecord(x, node, IPXACT2009scalaxb.fromXML[String](x, IPXACT2009scalaxb.ElemName(node) :: stack)) } map { "@{http://www.spiritconsortium.org/XMLSchema/SPIRIT/1685-2009}choiceRef" -> _ },
        (node \ "@{http://www.spiritconsortium.org/XMLSchema/SPIRIT/1685-2009}order").headOption map { x => IPXACT2009scalaxb.DataRecord(x, node, IPXACT2009scalaxb.fromXML[Float](x, IPXACT2009scalaxb.ElemName(node) :: stack)) } map { "@{http://www.spiritconsortium.org/XMLSchema/SPIRIT/1685-2009}order" -> _ },
        (node \ "@{http://www.spiritconsortium.org/XMLSchema/SPIRIT/1685-2009}configGroups").headOption map { x => IPXACT2009scalaxb.DataRecord(x, node, IPXACT2009scalaxb.fromXML[Seq[String]](x, IPXACT2009scalaxb.ElemName(node) :: stack)) } map { "@{http://www.spiritconsortium.org/XMLSchema/SPIRIT/1685-2009}configGroups" -> _ },
        (node \ "@{http://www.spiritconsortium.org/XMLSchema/SPIRIT/1685-2009}bitStringLength").headOption map { x => IPXACT2009scalaxb.DataRecord(x, node, IPXACT2009scalaxb.fromXML[BigInt](x, IPXACT2009scalaxb.ElemName(node) :: stack)) } map { "@{http://www.spiritconsortium.org/XMLSchema/SPIRIT/1685-2009}bitStringLength" -> _ },
        (node \ "@{http://www.spiritconsortium.org/XMLSchema/SPIRIT/1685-2009}minimum").headOption map { x => IPXACT2009scalaxb.DataRecord(x, node, IPXACT2009scalaxb.fromXML[String](x, IPXACT2009scalaxb.ElemName(node) :: stack)) } map { "@{http://www.spiritconsortium.org/XMLSchema/SPIRIT/1685-2009}minimum" -> _ },
        (node \ "@{http://www.spiritconsortium.org/XMLSchema/SPIRIT/1685-2009}maximum").headOption map { x => IPXACT2009scalaxb.DataRecord(x, node, IPXACT2009scalaxb.fromXML[String](x, IPXACT2009scalaxb.ElemName(node) :: stack)) } map { "@{http://www.spiritconsortium.org/XMLSchema/SPIRIT/1685-2009}maximum" -> _ },
        (node \ "@{http://www.spiritconsortium.org/XMLSchema/SPIRIT/1685-2009}rangeType").headOption map { x => IPXACT2009scalaxb.DataRecord(x, node, IPXACT2009scalaxb.fromXML[RangeTypeType](x, IPXACT2009scalaxb.ElemName(node) :: stack)) } orElse Some(IPXACT2009scalaxb.DataRecord(None, None, IPXACT2009scalaxb.fromXML[RangeTypeType](scala.xml.Text("int"), IPXACT2009scalaxb.ElemName(node) :: stack))) map { "@{http://www.spiritconsortium.org/XMLSchema/SPIRIT/1685-2009}rangeType" -> _ },
        (node \ "@{http://www.spiritconsortium.org/XMLSchema/SPIRIT/1685-2009}prompt").headOption map { x => IPXACT2009scalaxb.DataRecord(x, node, IPXACT2009scalaxb.fromXML[String](x, IPXACT2009scalaxb.ElemName(node) :: stack)) } map { "@{http://www.spiritconsortium.org/XMLSchema/SPIRIT/1685-2009}prompt" -> _ }
        ).flatten[(String, IPXACT2009scalaxb.DataRecord[Any])] ::: (node match {
          case elem: scala.xml.Elem =>
            elem.attributes.toList flatMap {
              case scala.xml.PrefixedAttribute(pre, key, value, _) if pre == elem.scope.getPrefix("http://www.spiritconsortium.org/XMLSchema/SPIRIT/1685-2009") &&
                key == "format" => Nil
              case scala.xml.PrefixedAttribute(pre, key, value, _) if pre == elem.scope.getPrefix("http://www.spiritconsortium.org/XMLSchema/SPIRIT/1685-2009") &&
                key == "resolve" => Nil
              case scala.xml.PrefixedAttribute(pre, key, value, _) if pre == elem.scope.getPrefix("http://www.spiritconsortium.org/XMLSchema/SPIRIT/1685-2009") &&
                key == "id" => Nil
              case scala.xml.PrefixedAttribute(pre, key, value, _) if pre == elem.scope.getPrefix("http://www.spiritconsortium.org/XMLSchema/SPIRIT/1685-2009") &&
                key == "dependency" => Nil
              case scala.xml.PrefixedAttribute(pre, key, value, _) if pre == elem.scope.getPrefix("http://www.spiritconsortium.org/XMLSchema/SPIRIT/1685-2009") &&
                key == "choiceRef" => Nil
              case scala.xml.PrefixedAttribute(pre, key, value, _) if pre == elem.scope.getPrefix("http://www.spiritconsortium.org/XMLSchema/SPIRIT/1685-2009") &&
                key == "order" => Nil
              case scala.xml.PrefixedAttribute(pre, key, value, _) if pre == elem.scope.getPrefix("http://www.spiritconsortium.org/XMLSchema/SPIRIT/1685-2009") &&
                key == "configGroups" => Nil
              case scala.xml.PrefixedAttribute(pre, key, value, _) if pre == elem.scope.getPrefix("http://www.spiritconsortium.org/XMLSchema/SPIRIT/1685-2009") &&
                key == "bitStringLength" => Nil
              case scala.xml.PrefixedAttribute(pre, key, value, _) if pre == elem.scope.getPrefix("http://www.spiritconsortium.org/XMLSchema/SPIRIT/1685-2009") &&
                key == "minimum" => Nil
              case scala.xml.PrefixedAttribute(pre, key, value, _) if pre == elem.scope.getPrefix("http://www.spiritconsortium.org/XMLSchema/SPIRIT/1685-2009") &&
                key == "maximum" => Nil
              case scala.xml.PrefixedAttribute(pre, key, value, _) if pre == elem.scope.getPrefix("http://www.spiritconsortium.org/XMLSchema/SPIRIT/1685-2009") &&
                key == "rangeType" => Nil
              case scala.xml.PrefixedAttribute(pre, key, value, _) if pre == elem.scope.getPrefix("http://www.spiritconsortium.org/XMLSchema/SPIRIT/1685-2009") &&
                key == "prompt" => Nil
              case scala.xml.UnprefixedAttribute(key, value, _) =>
                List(("@" + key, IPXACT2009scalaxb.DataRecord(None, Some(key), value.text)))
              case scala.xml.PrefixedAttribute(pre, key, value, _) =>
                val ns = elem.scope.getURI(pre)
                List(("@{" + ns + "}" + key, IPXACT2009scalaxb.DataRecord(Option[String](ns), Some(key), value.text)))
              case _ => Nil
            }
          case _ => Nil
        }): _*)))
      case _ => Left("reads failed: seq must be scala.xml.Node")
    }
    
    override def writesAttribute(__obj: ReplaceDefaultFlags, __scope: scala.xml.NamespaceBinding): scala.xml.MetaData = {
      var attr: scala.xml.MetaData  = scala.xml.Null
      __obj.attributes.toList map {
        case ("@{http://www.spiritconsortium.org/XMLSchema/SPIRIT/1685-2009}format", _) => if (__obj.spiritformat.toString != "bool") attr = scala.xml.Attribute(__scope.getPrefix("http://www.spiritconsortium.org/XMLSchema/SPIRIT/1685-2009"), "format", __obj.spiritformat.toString, attr)
        case ("@{http://www.spiritconsortium.org/XMLSchema/SPIRIT/1685-2009}resolve", _) => __obj.spiritresolve foreach { x => attr = scala.xml.Attribute(__scope.getPrefix("http://www.spiritconsortium.org/XMLSchema/SPIRIT/1685-2009"), "resolve", x.toString, attr) }
        case ("@{http://www.spiritconsortium.org/XMLSchema/SPIRIT/1685-2009}id", _) => __obj.spiritid foreach { x => attr = scala.xml.Attribute(__scope.getPrefix("http://www.spiritconsortium.org/XMLSchema/SPIRIT/1685-2009"), "id", x.toString, attr) }
        case ("@{http://www.spiritconsortium.org/XMLSchema/SPIRIT/1685-2009}dependency", _) => __obj.spiritdependency foreach { x => attr = scala.xml.Attribute(__scope.getPrefix("http://www.spiritconsortium.org/XMLSchema/SPIRIT/1685-2009"), "dependency", x.toString, attr) }
        case ("@{http://www.spiritconsortium.org/XMLSchema/SPIRIT/1685-2009}choiceRef", _) => __obj.spiritchoiceRef foreach { x => attr = scala.xml.Attribute(__scope.getPrefix("http://www.spiritconsortium.org/XMLSchema/SPIRIT/1685-2009"), "choiceRef", x.toString, attr) }
        case ("@{http://www.spiritconsortium.org/XMLSchema/SPIRIT/1685-2009}order", _) => __obj.spiritorder foreach { x => attr = scala.xml.Attribute(__scope.getPrefix("http://www.spiritconsortium.org/XMLSchema/SPIRIT/1685-2009"), "order", x.toString, attr) }
        case ("@{http://www.spiritconsortium.org/XMLSchema/SPIRIT/1685-2009}configGroups", _) => __obj.spiritconfigGroups foreach { x => attr = scala.xml.Attribute(__scope.getPrefix("http://www.spiritconsortium.org/XMLSchema/SPIRIT/1685-2009"), "configGroups", x.toString, attr) }
        case ("@{http://www.spiritconsortium.org/XMLSchema/SPIRIT/1685-2009}bitStringLength", _) => __obj.spiritbitStringLength foreach { x => attr = scala.xml.Attribute(__scope.getPrefix("http://www.spiritconsortium.org/XMLSchema/SPIRIT/1685-2009"), "bitStringLength", x.toString, attr) }
        case ("@{http://www.spiritconsortium.org/XMLSchema/SPIRIT/1685-2009}minimum", _) => __obj.spiritminimum foreach { x => attr = scala.xml.Attribute(__scope.getPrefix("http://www.spiritconsortium.org/XMLSchema/SPIRIT/1685-2009"), "minimum", x.toString, attr) }
        case ("@{http://www.spiritconsortium.org/XMLSchema/SPIRIT/1685-2009}maximum", _) => __obj.spiritmaximum foreach { x => attr = scala.xml.Attribute(__scope.getPrefix("http://www.spiritconsortium.org/XMLSchema/SPIRIT/1685-2009"), "maximum", x.toString, attr) }
        case ("@{http://www.spiritconsortium.org/XMLSchema/SPIRIT/1685-2009}rangeType", _) => if (__obj.spiritrangeType.toString != "int") attr = scala.xml.Attribute(__scope.getPrefix("http://www.spiritconsortium.org/XMLSchema/SPIRIT/1685-2009"), "rangeType", __obj.spiritrangeType.toString, attr)
        case ("@{http://www.spiritconsortium.org/XMLSchema/SPIRIT/1685-2009}prompt", _) => __obj.spiritprompt foreach { x => attr = scala.xml.Attribute(__scope.getPrefix("http://www.spiritconsortium.org/XMLSchema/SPIRIT/1685-2009"), "prompt", x.toString, attr) }
        case (key, x) => attr = scala.xml.Attribute((x.namespace map { __scope.getPrefix(_) }).orNull, x.key.orNull, x.value.toString, attr)
      }
      attr
    }

    def writesChildNodes(__obj: ReplaceDefaultFlags, __scope: scala.xml.NamespaceBinding): Seq[scala.xml.Node] =
      Seq(scala.xml.Text(__obj.value.toString))

  }

  trait Default_TargetNameFormat extends IPXACT2009scalaxb.XMLFormat[TargetName] with IPXACT2009scalaxb.CanWriteChildNodes[TargetName] {
    val targetNamespace: Option[String] = Some("http://www.spiritconsortium.org/XMLSchema/SPIRIT/1685-2009")
    def reads(seq: scala.xml.NodeSeq, stack: List[IPXACT2009scalaxb.ElemName]): Either[String, TargetName] = seq match {
      case node: scala.xml.Node => Right(TargetName(IPXACT2009scalaxb.fromXML[String](node, IPXACT2009scalaxb.ElemName(node) :: stack),
        scala.collection.immutable.ListMap(List(
        (node \ "@{http://www.spiritconsortium.org/XMLSchema/SPIRIT/1685-2009}format").headOption map { x => IPXACT2009scalaxb.DataRecord(x, node, IPXACT2009scalaxb.fromXML[FormatType](x, IPXACT2009scalaxb.ElemName(node) :: stack)) } orElse Some(IPXACT2009scalaxb.DataRecord(None, None, IPXACT2009scalaxb.fromXML[FormatType](scala.xml.Text("string"), IPXACT2009scalaxb.ElemName(node) :: stack))) map { "@{http://www.spiritconsortium.org/XMLSchema/SPIRIT/1685-2009}format" -> _ },
        (node \ "@{http://www.spiritconsortium.org/XMLSchema/SPIRIT/1685-2009}resolve").headOption map { x => IPXACT2009scalaxb.DataRecord(x, node, IPXACT2009scalaxb.fromXML[ResolveType](x, IPXACT2009scalaxb.ElemName(node) :: stack)) } map { "@{http://www.spiritconsortium.org/XMLSchema/SPIRIT/1685-2009}resolve" -> _ },
        (node \ "@{http://www.spiritconsortium.org/XMLSchema/SPIRIT/1685-2009}id").headOption map { x => IPXACT2009scalaxb.DataRecord(x, node, IPXACT2009scalaxb.fromXML[String](x, IPXACT2009scalaxb.ElemName(node) :: stack)) } map { "@{http://www.spiritconsortium.org/XMLSchema/SPIRIT/1685-2009}id" -> _ },
        (node \ "@{http://www.spiritconsortium.org/XMLSchema/SPIRIT/1685-2009}dependency").headOption map { x => IPXACT2009scalaxb.DataRecord(x, node, IPXACT2009scalaxb.fromXML[String](x, IPXACT2009scalaxb.ElemName(node) :: stack)) } map { "@{http://www.spiritconsortium.org/XMLSchema/SPIRIT/1685-2009}dependency" -> _ },
        (node \ "@{http://www.spiritconsortium.org/XMLSchema/SPIRIT/1685-2009}choiceRef").headOption map { x => IPXACT2009scalaxb.DataRecord(x, node, IPXACT2009scalaxb.fromXML[String](x, IPXACT2009scalaxb.ElemName(node) :: stack)) } map { "@{http://www.spiritconsortium.org/XMLSchema/SPIRIT/1685-2009}choiceRef" -> _ },
        (node \ "@{http://www.spiritconsortium.org/XMLSchema/SPIRIT/1685-2009}order").headOption map { x => IPXACT2009scalaxb.DataRecord(x, node, IPXACT2009scalaxb.fromXML[Float](x, IPXACT2009scalaxb.ElemName(node) :: stack)) } map { "@{http://www.spiritconsortium.org/XMLSchema/SPIRIT/1685-2009}order" -> _ },
        (node \ "@{http://www.spiritconsortium.org/XMLSchema/SPIRIT/1685-2009}configGroups").headOption map { x => IPXACT2009scalaxb.DataRecord(x, node, IPXACT2009scalaxb.fromXML[Seq[String]](x, IPXACT2009scalaxb.ElemName(node) :: stack)) } map { "@{http://www.spiritconsortium.org/XMLSchema/SPIRIT/1685-2009}configGroups" -> _ },
        (node \ "@{http://www.spiritconsortium.org/XMLSchema/SPIRIT/1685-2009}bitStringLength").headOption map { x => IPXACT2009scalaxb.DataRecord(x, node, IPXACT2009scalaxb.fromXML[BigInt](x, IPXACT2009scalaxb.ElemName(node) :: stack)) } map { "@{http://www.spiritconsortium.org/XMLSchema/SPIRIT/1685-2009}bitStringLength" -> _ },
        (node \ "@{http://www.spiritconsortium.org/XMLSchema/SPIRIT/1685-2009}minimum").headOption map { x => IPXACT2009scalaxb.DataRecord(x, node, IPXACT2009scalaxb.fromXML[String](x, IPXACT2009scalaxb.ElemName(node) :: stack)) } map { "@{http://www.spiritconsortium.org/XMLSchema/SPIRIT/1685-2009}minimum" -> _ },
        (node \ "@{http://www.spiritconsortium.org/XMLSchema/SPIRIT/1685-2009}maximum").headOption map { x => IPXACT2009scalaxb.DataRecord(x, node, IPXACT2009scalaxb.fromXML[String](x, IPXACT2009scalaxb.ElemName(node) :: stack)) } map { "@{http://www.spiritconsortium.org/XMLSchema/SPIRIT/1685-2009}maximum" -> _ },
        (node \ "@{http://www.spiritconsortium.org/XMLSchema/SPIRIT/1685-2009}rangeType").headOption map { x => IPXACT2009scalaxb.DataRecord(x, node, IPXACT2009scalaxb.fromXML[RangeTypeType](x, IPXACT2009scalaxb.ElemName(node) :: stack)) } map { "@{http://www.spiritconsortium.org/XMLSchema/SPIRIT/1685-2009}rangeType" -> _ },
        (node \ "@{http://www.spiritconsortium.org/XMLSchema/SPIRIT/1685-2009}prompt").headOption map { x => IPXACT2009scalaxb.DataRecord(x, node, IPXACT2009scalaxb.fromXML[String](x, IPXACT2009scalaxb.ElemName(node) :: stack)) } map { "@{http://www.spiritconsortium.org/XMLSchema/SPIRIT/1685-2009}prompt" -> _ }
        ).flatten[(String, IPXACT2009scalaxb.DataRecord[Any])] ::: (node match {
          case elem: scala.xml.Elem =>
            elem.attributes.toList flatMap {
              case scala.xml.PrefixedAttribute(pre, key, value, _) if pre == elem.scope.getPrefix("http://www.spiritconsortium.org/XMLSchema/SPIRIT/1685-2009") &&
                key == "format" => Nil
              case scala.xml.PrefixedAttribute(pre, key, value, _) if pre == elem.scope.getPrefix("http://www.spiritconsortium.org/XMLSchema/SPIRIT/1685-2009") &&
                key == "resolve" => Nil
              case scala.xml.PrefixedAttribute(pre, key, value, _) if pre == elem.scope.getPrefix("http://www.spiritconsortium.org/XMLSchema/SPIRIT/1685-2009") &&
                key == "id" => Nil
              case scala.xml.PrefixedAttribute(pre, key, value, _) if pre == elem.scope.getPrefix("http://www.spiritconsortium.org/XMLSchema/SPIRIT/1685-2009") &&
                key == "dependency" => Nil
              case scala.xml.PrefixedAttribute(pre, key, value, _) if pre == elem.scope.getPrefix("http://www.spiritconsortium.org/XMLSchema/SPIRIT/1685-2009") &&
                key == "choiceRef" => Nil
              case scala.xml.PrefixedAttribute(pre, key, value, _) if pre == elem.scope.getPrefix("http://www.spiritconsortium.org/XMLSchema/SPIRIT/1685-2009") &&
                key == "order" => Nil
              case scala.xml.PrefixedAttribute(pre, key, value, _) if pre == elem.scope.getPrefix("http://www.spiritconsortium.org/XMLSchema/SPIRIT/1685-2009") &&
                key == "configGroups" => Nil
              case scala.xml.PrefixedAttribute(pre, key, value, _) if pre == elem.scope.getPrefix("http://www.spiritconsortium.org/XMLSchema/SPIRIT/1685-2009") &&
                key == "bitStringLength" => Nil
              case scala.xml.PrefixedAttribute(pre, key, value, _) if pre == elem.scope.getPrefix("http://www.spiritconsortium.org/XMLSchema/SPIRIT/1685-2009") &&
                key == "minimum" => Nil
              case scala.xml.PrefixedAttribute(pre, key, value, _) if pre == elem.scope.getPrefix("http://www.spiritconsortium.org/XMLSchema/SPIRIT/1685-2009") &&
                key == "maximum" => Nil
              case scala.xml.PrefixedAttribute(pre, key, value, _) if pre == elem.scope.getPrefix("http://www.spiritconsortium.org/XMLSchema/SPIRIT/1685-2009") &&
                key == "rangeType" => Nil
              case scala.xml.PrefixedAttribute(pre, key, value, _) if pre == elem.scope.getPrefix("http://www.spiritconsortium.org/XMLSchema/SPIRIT/1685-2009") &&
                key == "prompt" => Nil
              case scala.xml.UnprefixedAttribute(key, value, _) =>
                List(("@" + key, IPXACT2009scalaxb.DataRecord(None, Some(key), value.text)))
              case scala.xml.PrefixedAttribute(pre, key, value, _) =>
                val ns = elem.scope.getURI(pre)
                List(("@{" + ns + "}" + key, IPXACT2009scalaxb.DataRecord(Option[String](ns), Some(key), value.text)))
              case _ => Nil
            }
          case _ => Nil
        }): _*)))
      case _ => Left("reads failed: seq must be scala.xml.Node")
    }
    
    override def writesAttribute(__obj: TargetName, __scope: scala.xml.NamespaceBinding): scala.xml.MetaData = {
      var attr: scala.xml.MetaData  = scala.xml.Null
      __obj.attributes.toList map {
        case ("@{http://www.spiritconsortium.org/XMLSchema/SPIRIT/1685-2009}format", _) => if (__obj.spiritformat.toString != "string") attr = scala.xml.Attribute(__scope.getPrefix("http://www.spiritconsortium.org/XMLSchema/SPIRIT/1685-2009"), "format", __obj.spiritformat.toString, attr)
        case ("@{http://www.spiritconsortium.org/XMLSchema/SPIRIT/1685-2009}resolve", _) => __obj.spiritresolve foreach { x => attr = scala.xml.Attribute(__scope.getPrefix("http://www.spiritconsortium.org/XMLSchema/SPIRIT/1685-2009"), "resolve", x.toString, attr) }
        case ("@{http://www.spiritconsortium.org/XMLSchema/SPIRIT/1685-2009}id", _) => __obj.spiritid foreach { x => attr = scala.xml.Attribute(__scope.getPrefix("http://www.spiritconsortium.org/XMLSchema/SPIRIT/1685-2009"), "id", x.toString, attr) }
        case ("@{http://www.spiritconsortium.org/XMLSchema/SPIRIT/1685-2009}dependency", _) => __obj.spiritdependency foreach { x => attr = scala.xml.Attribute(__scope.getPrefix("http://www.spiritconsortium.org/XMLSchema/SPIRIT/1685-2009"), "dependency", x.toString, attr) }
        case ("@{http://www.spiritconsortium.org/XMLSchema/SPIRIT/1685-2009}choiceRef", _) => __obj.spiritchoiceRef foreach { x => attr = scala.xml.Attribute(__scope.getPrefix("http://www.spiritconsortium.org/XMLSchema/SPIRIT/1685-2009"), "choiceRef", x.toString, attr) }
        case ("@{http://www.spiritconsortium.org/XMLSchema/SPIRIT/1685-2009}order", _) => __obj.spiritorder foreach { x => attr = scala.xml.Attribute(__scope.getPrefix("http://www.spiritconsortium.org/XMLSchema/SPIRIT/1685-2009"), "order", x.toString, attr) }
        case ("@{http://www.spiritconsortium.org/XMLSchema/SPIRIT/1685-2009}configGroups", _) => __obj.spiritconfigGroups foreach { x => attr = scala.xml.Attribute(__scope.getPrefix("http://www.spiritconsortium.org/XMLSchema/SPIRIT/1685-2009"), "configGroups", x.toString, attr) }
        case ("@{http://www.spiritconsortium.org/XMLSchema/SPIRIT/1685-2009}bitStringLength", _) => __obj.spiritbitStringLength foreach { x => attr = scala.xml.Attribute(__scope.getPrefix("http://www.spiritconsortium.org/XMLSchema/SPIRIT/1685-2009"), "bitStringLength", x.toString, attr) }
        case ("@{http://www.spiritconsortium.org/XMLSchema/SPIRIT/1685-2009}minimum", _) => __obj.spiritminimum foreach { x => attr = scala.xml.Attribute(__scope.getPrefix("http://www.spiritconsortium.org/XMLSchema/SPIRIT/1685-2009"), "minimum", x.toString, attr) }
        case ("@{http://www.spiritconsortium.org/XMLSchema/SPIRIT/1685-2009}maximum", _) => __obj.spiritmaximum foreach { x => attr = scala.xml.Attribute(__scope.getPrefix("http://www.spiritconsortium.org/XMLSchema/SPIRIT/1685-2009"), "maximum", x.toString, attr) }
        case ("@{http://www.spiritconsortium.org/XMLSchema/SPIRIT/1685-2009}rangeType", _) => __obj.spiritrangeType foreach { x => attr = scala.xml.Attribute(__scope.getPrefix("http://www.spiritconsortium.org/XMLSchema/SPIRIT/1685-2009"), "rangeType", x.toString, attr) }
        case ("@{http://www.spiritconsortium.org/XMLSchema/SPIRIT/1685-2009}prompt", _) => __obj.spiritprompt foreach { x => attr = scala.xml.Attribute(__scope.getPrefix("http://www.spiritconsortium.org/XMLSchema/SPIRIT/1685-2009"), "prompt", x.toString, attr) }
        case (key, x) => attr = scala.xml.Attribute((x.namespace map { __scope.getPrefix(_) }).orNull, x.key.orNull, x.value.toString, attr)
      }
      attr
    }

    def writesChildNodes(__obj: TargetName, __scope: scala.xml.NamespaceBinding): Seq[scala.xml.Node] =
      Seq(scala.xml.Text(__obj.value.toString))

  }

  trait Default_BuildCommandFormat extends IPXACT2009scalaxb.ElemNameParser[BuildCommand] {
    val targetNamespace: Option[String] = Some("http://www.spiritconsortium.org/XMLSchema/SPIRIT/1685-2009")
    
    def parser(node: scala.xml.Node, stack: List[IPXACT2009scalaxb.ElemName]): Parser[BuildCommand] =
      phrase(opt(IPXACT2009scalaxb.ElemName(Some("http://www.spiritconsortium.org/XMLSchema/SPIRIT/1685-2009"), "command")) ~
      opt(IPXACT2009scalaxb.ElemName(Some("http://www.spiritconsortium.org/XMLSchema/SPIRIT/1685-2009"), "flags")) ~
      opt(IPXACT2009scalaxb.ElemName(Some("http://www.spiritconsortium.org/XMLSchema/SPIRIT/1685-2009"), "replaceDefaultFlags")) ~
      opt(IPXACT2009scalaxb.ElemName(Some("http://www.spiritconsortium.org/XMLSchema/SPIRIT/1685-2009"), "targetName")) ^^
      { case p1 ~ p2 ~ p3 ~ p4 =>
      BuildCommand(p1.headOption map { IPXACT2009scalaxb.fromXML[Command](_, IPXACT2009scalaxb.ElemName(node) :: stack) },
        p2.headOption map { IPXACT2009scalaxb.fromXML[Flags](_, IPXACT2009scalaxb.ElemName(node) :: stack) },
        p3.headOption map { IPXACT2009scalaxb.fromXML[ReplaceDefaultFlags](_, IPXACT2009scalaxb.ElemName(node) :: stack) },
        p4.headOption map { IPXACT2009scalaxb.fromXML[TargetName](_, IPXACT2009scalaxb.ElemName(node) :: stack) }) })
    
    def writesChildNodes(__obj: BuildCommand, __scope: scala.xml.NamespaceBinding): Seq[scala.xml.Node] =
      Seq.concat(__obj.command map { IPXACT2009scalaxb.toXML[Command](_, Some("http://www.spiritconsortium.org/XMLSchema/SPIRIT/1685-2009"), Some("command"), __scope, false) } getOrElse {Nil},
        __obj.flags map { IPXACT2009scalaxb.toXML[Flags](_, Some("http://www.spiritconsortium.org/XMLSchema/SPIRIT/1685-2009"), Some("flags"), __scope, false) } getOrElse {Nil},
        __obj.replaceDefaultFlags map { IPXACT2009scalaxb.toXML[ReplaceDefaultFlags](_, Some("http://www.spiritconsortium.org/XMLSchema/SPIRIT/1685-2009"), Some("replaceDefaultFlags"), __scope, false) } getOrElse {Nil},
        __obj.targetName map { IPXACT2009scalaxb.toXML[TargetName](_, Some("http://www.spiritconsortium.org/XMLSchema/SPIRIT/1685-2009"), Some("targetName"), __scope, false) } getOrElse {Nil})

  }

  trait Default_FileFormat extends IPXACT2009scalaxb.ElemNameParser[File] with _FileTypeGroupFormat {
    val targetNamespace: Option[String] = Some("http://www.spiritconsortium.org/XMLSchema/SPIRIT/1685-2009")
    
    def parser(node: scala.xml.Node, stack: List[IPXACT2009scalaxb.ElemName]): Parser[File] =
      phrase((IPXACT2009scalaxb.ElemName(Some("http://www.spiritconsortium.org/XMLSchema/SPIRIT/1685-2009"), "name")) ~
      ((safeRep(parseFileTypeGroup(node, IPXACT2009scalaxb.ElemName(node) :: stack))) ^^
        { case p1 => FileSequence1(p1: _*) }) ~ 
      opt(IPXACT2009scalaxb.ElemName(Some("http://www.spiritconsortium.org/XMLSchema/SPIRIT/1685-2009"), "isIncludeFile")) ~
      opt(IPXACT2009scalaxb.ElemName(Some("http://www.spiritconsortium.org/XMLSchema/SPIRIT/1685-2009"), "logicalName")) ~
      safeRep(IPXACT2009scalaxb.ElemName(Some("http://www.spiritconsortium.org/XMLSchema/SPIRIT/1685-2009"), "exportedName")) ~
      opt(IPXACT2009scalaxb.ElemName(Some("http://www.spiritconsortium.org/XMLSchema/SPIRIT/1685-2009"), "buildCommand")) ~
      safeRep(IPXACT2009scalaxb.ElemName(Some("http://www.spiritconsortium.org/XMLSchema/SPIRIT/1685-2009"), "dependency")) ~
      safeRep(IPXACT2009scalaxb.ElemName(Some("http://www.spiritconsortium.org/XMLSchema/SPIRIT/1685-2009"), "define")) ~
      safeRep(IPXACT2009scalaxb.ElemName(Some("http://www.spiritconsortium.org/XMLSchema/SPIRIT/1685-2009"), "imageType")) ~
      opt(IPXACT2009scalaxb.ElemName(Some("http://www.spiritconsortium.org/XMLSchema/SPIRIT/1685-2009"), "description")) ~
      opt(IPXACT2009scalaxb.ElemName(Some("http://www.spiritconsortium.org/XMLSchema/SPIRIT/1685-2009"), "vendorExtensions")) ^^
      { case p1 ~ p2 ~ p3 ~ p4 ~ p5 ~ p6 ~ p7 ~ p8 ~ p9 ~ p10 ~ p11 =>
      File(IPXACT2009scalaxb.fromXML[Name](p1, IPXACT2009scalaxb.ElemName(node) :: stack),
        p2,
        p3.headOption map { IPXACT2009scalaxb.fromXML[IsIncludeFile](_, IPXACT2009scalaxb.ElemName(node) :: stack) },
        p4.headOption map { IPXACT2009scalaxb.fromXML[LogicalName](_, IPXACT2009scalaxb.ElemName(node) :: stack) },
        p5 map { IPXACT2009scalaxb.fromXML[String](_, IPXACT2009scalaxb.ElemName(node) :: stack) },
        p6.headOption map { IPXACT2009scalaxb.fromXML[BuildCommand](_, IPXACT2009scalaxb.ElemName(node) :: stack) },
        p7 map { IPXACT2009scalaxb.fromXML[String](_, IPXACT2009scalaxb.ElemName(node) :: stack) },
        p8 map { IPXACT2009scalaxb.fromXML[NameValuePairTypable](_, IPXACT2009scalaxb.ElemName(node) :: stack) },
        p9 map { IPXACT2009scalaxb.fromXML[String](_, IPXACT2009scalaxb.ElemName(node) :: stack) },
        p10.headOption map { IPXACT2009scalaxb.fromXML[String](_, IPXACT2009scalaxb.ElemName(node) :: stack) },
        p11.headOption map { IPXACT2009scalaxb.fromXML[VendorExtensions](_, IPXACT2009scalaxb.ElemName(node) :: stack) },
        scala.collection.immutable.ListMap(List(
        (node \ "@{http://www.spiritconsortium.org/XMLSchema/SPIRIT/1685-2009}fileId").headOption map { x => IPXACT2009scalaxb.DataRecord(x, node, IPXACT2009scalaxb.fromXML[String](x, IPXACT2009scalaxb.ElemName(node) :: stack)) } map { "@fileId" -> _ }
        ).flatten[(String, IPXACT2009scalaxb.DataRecord[Any])] ::: (node match {
          case elem: scala.xml.Elem =>
            elem.attributes.toList flatMap {
              case scala.xml.PrefixedAttribute(pre, key, value, _) if pre == elem.scope.getPrefix("http://www.spiritconsortium.org/XMLSchema/SPIRIT/1685-2009") &&
                key == "fileId" => Nil
              case scala.xml.UnprefixedAttribute(key, value, _) =>
                List(("@" + key, IPXACT2009scalaxb.DataRecord(None, Some(key), value.text)))
              case scala.xml.PrefixedAttribute(pre, key, value, _) =>
                val ns = elem.scope.getURI(pre)
                List(("@{" + ns + "}" + key, IPXACT2009scalaxb.DataRecord(Option[String](ns), Some(key), value.text)))
              case _ => Nil
            }
          case _ => Nil
        }): _*)) })
    
    override def writesAttribute(__obj: File, __scope: scala.xml.NamespaceBinding): scala.xml.MetaData = {
      var attr: scala.xml.MetaData  = scala.xml.Null
      __obj.attributes.toList map {
        case ("@fileId", _) => __obj.fileId foreach { x => attr = scala.xml.Attribute(__scope.getPrefix("http://www.spiritconsortium.org/XMLSchema/SPIRIT/1685-2009"), "fileId", x.toString, attr) }
        case (key, x) => attr = scala.xml.Attribute((x.namespace map { __scope.getPrefix(_) }).orNull, x.key.orNull, x.value.toString, attr)
      }
      attr
    }

    def writesChildNodes(__obj: File, __scope: scala.xml.NamespaceBinding): Seq[scala.xml.Node] =
      Seq.concat(IPXACT2009scalaxb.toXML[Name](__obj.name, Some("http://www.spiritconsortium.org/XMLSchema/SPIRIT/1685-2009"), Some("name"), __scope, false),
        IPXACT2009scalaxb.toXML[FileSequence1](__obj.filesequence1, None, Some("filesequence1"), __scope, false),
        __obj.isIncludeFile map { IPXACT2009scalaxb.toXML[IsIncludeFile](_, Some("http://www.spiritconsortium.org/XMLSchema/SPIRIT/1685-2009"), Some("isIncludeFile"), __scope, false) } getOrElse {Nil},
        __obj.logicalName map { IPXACT2009scalaxb.toXML[LogicalName](_, Some("http://www.spiritconsortium.org/XMLSchema/SPIRIT/1685-2009"), Some("logicalName"), __scope, false) } getOrElse {Nil},
        __obj.exportedName flatMap { IPXACT2009scalaxb.toXML[String](_, Some("http://www.spiritconsortium.org/XMLSchema/SPIRIT/1685-2009"), Some("exportedName"), __scope, false) },
        __obj.buildCommand map { IPXACT2009scalaxb.toXML[BuildCommand](_, Some("http://www.spiritconsortium.org/XMLSchema/SPIRIT/1685-2009"), Some("buildCommand"), __scope, false) } getOrElse {Nil},
        __obj.dependency flatMap { IPXACT2009scalaxb.toXML[String](_, Some("http://www.spiritconsortium.org/XMLSchema/SPIRIT/1685-2009"), Some("dependency"), __scope, false) },
        __obj.define flatMap { IPXACT2009scalaxb.toXML[NameValuePairTypable](_, Some("http://www.spiritconsortium.org/XMLSchema/SPIRIT/1685-2009"), Some("define"), __scope, false) },
        __obj.imageType flatMap { IPXACT2009scalaxb.toXML[String](_, Some("http://www.spiritconsortium.org/XMLSchema/SPIRIT/1685-2009"), Some("imageType"), __scope, false) },
        __obj.description map { IPXACT2009scalaxb.toXML[String](_, Some("http://www.spiritconsortium.org/XMLSchema/SPIRIT/1685-2009"), Some("description"), __scope, false) } getOrElse {Nil},
        __obj.vendorExtensions map { IPXACT2009scalaxb.toXML[VendorExtensions](_, Some("http://www.spiritconsortium.org/XMLSchema/SPIRIT/1685-2009"), Some("vendorExtensions"), __scope, false) } getOrElse {Nil})

  }

  trait Default_FileSequence1Format extends IPXACT2009scalaxb.XMLFormat[FileSequence1] {
    def reads(seq: scala.xml.NodeSeq, stack: List[IPXACT2009scalaxb.ElemName]): Either[String, FileSequence1] = Left("don't call me.")
    
    def writes(__obj: FileSequence1, __namespace: Option[String], __elementLabel: Option[String], 
        __scope: scala.xml.NamespaceBinding, __typeAttribute: Boolean): scala.xml.NodeSeq =
      __obj.fileTypeOption1 flatMap { x => IPXACT2009scalaxb.toXML[IPXACT2009scalaxb.DataRecord[Any]](x, x.namespace, x.key, __scope, false) }

  }
  trait Default_Name2Format extends IPXACT2009scalaxb.XMLFormat[Name2] with IPXACT2009scalaxb.CanWriteChildNodes[Name2] {
    val targetNamespace: Option[String] = Some("http://www.spiritconsortium.org/XMLSchema/SPIRIT/1685-2009")
    def reads(seq: scala.xml.NodeSeq, stack: List[IPXACT2009scalaxb.ElemName]): Either[String, Name2] = seq match {
      case node: scala.xml.Node => Right(Name2(IPXACT2009scalaxb.fromXML[String](node, IPXACT2009scalaxb.ElemName(node) :: stack)))
      case _ => Left("reads failed: seq must be scala.xml.Node")
    }
    
    def writesChildNodes(__obj: Name2, __scope: scala.xml.NamespaceBinding): Seq[scala.xml.Node] =
      Seq(scala.xml.Text(__obj.value.toString))

  }
  trait Default_Command2Format extends IPXACT2009scalaxb.XMLFormat[Command2] with IPXACT2009scalaxb.CanWriteChildNodes[Command2] {
    val targetNamespace: Option[String] = Some("http://www.spiritconsortium.org/XMLSchema/SPIRIT/1685-2009")
    def reads(seq: scala.xml.NodeSeq, stack: List[IPXACT2009scalaxb.ElemName]): Either[String, Command2] = seq match {
      case node: scala.xml.Node => Right(Command2(IPXACT2009scalaxb.fromXML[String](node, IPXACT2009scalaxb.ElemName(node) :: stack),
        scala.collection.immutable.ListMap(List(
        (node \ "@{http://www.spiritconsortium.org/XMLSchema/SPIRIT/1685-2009}format").headOption map { x => IPXACT2009scalaxb.DataRecord(x, node, IPXACT2009scalaxb.fromXML[FormatType](x, IPXACT2009scalaxb.ElemName(node) :: stack)) } orElse Some(IPXACT2009scalaxb.DataRecord(None, None, IPXACT2009scalaxb.fromXML[FormatType](scala.xml.Text("string"), IPXACT2009scalaxb.ElemName(node) :: stack))) map { "@{http://www.spiritconsortium.org/XMLSchema/SPIRIT/1685-2009}format" -> _ },
        (node \ "@{http://www.spiritconsortium.org/XMLSchema/SPIRIT/1685-2009}resolve").headOption map { x => IPXACT2009scalaxb.DataRecord(x, node, IPXACT2009scalaxb.fromXML[ResolveType](x, IPXACT2009scalaxb.ElemName(node) :: stack)) } map { "@{http://www.spiritconsortium.org/XMLSchema/SPIRIT/1685-2009}resolve" -> _ },
        (node \ "@{http://www.spiritconsortium.org/XMLSchema/SPIRIT/1685-2009}id").headOption map { x => IPXACT2009scalaxb.DataRecord(x, node, IPXACT2009scalaxb.fromXML[String](x, IPXACT2009scalaxb.ElemName(node) :: stack)) } map { "@{http://www.spiritconsortium.org/XMLSchema/SPIRIT/1685-2009}id" -> _ },
        (node \ "@{http://www.spiritconsortium.org/XMLSchema/SPIRIT/1685-2009}dependency").headOption map { x => IPXACT2009scalaxb.DataRecord(x, node, IPXACT2009scalaxb.fromXML[String](x, IPXACT2009scalaxb.ElemName(node) :: stack)) } map { "@{http://www.spiritconsortium.org/XMLSchema/SPIRIT/1685-2009}dependency" -> _ },
        (node \ "@{http://www.spiritconsortium.org/XMLSchema/SPIRIT/1685-2009}choiceRef").headOption map { x => IPXACT2009scalaxb.DataRecord(x, node, IPXACT2009scalaxb.fromXML[String](x, IPXACT2009scalaxb.ElemName(node) :: stack)) } map { "@{http://www.spiritconsortium.org/XMLSchema/SPIRIT/1685-2009}choiceRef" -> _ },
        (node \ "@{http://www.spiritconsortium.org/XMLSchema/SPIRIT/1685-2009}order").headOption map { x => IPXACT2009scalaxb.DataRecord(x, node, IPXACT2009scalaxb.fromXML[Float](x, IPXACT2009scalaxb.ElemName(node) :: stack)) } map { "@{http://www.spiritconsortium.org/XMLSchema/SPIRIT/1685-2009}order" -> _ },
        (node \ "@{http://www.spiritconsortium.org/XMLSchema/SPIRIT/1685-2009}configGroups").headOption map { x => IPXACT2009scalaxb.DataRecord(x, node, IPXACT2009scalaxb.fromXML[Seq[String]](x, IPXACT2009scalaxb.ElemName(node) :: stack)) } map { "@{http://www.spiritconsortium.org/XMLSchema/SPIRIT/1685-2009}configGroups" -> _ },
        (node \ "@{http://www.spiritconsortium.org/XMLSchema/SPIRIT/1685-2009}bitStringLength").headOption map { x => IPXACT2009scalaxb.DataRecord(x, node, IPXACT2009scalaxb.fromXML[BigInt](x, IPXACT2009scalaxb.ElemName(node) :: stack)) } map { "@{http://www.spiritconsortium.org/XMLSchema/SPIRIT/1685-2009}bitStringLength" -> _ },
        (node \ "@{http://www.spiritconsortium.org/XMLSchema/SPIRIT/1685-2009}minimum").headOption map { x => IPXACT2009scalaxb.DataRecord(x, node, IPXACT2009scalaxb.fromXML[String](x, IPXACT2009scalaxb.ElemName(node) :: stack)) } map { "@{http://www.spiritconsortium.org/XMLSchema/SPIRIT/1685-2009}minimum" -> _ },
        (node \ "@{http://www.spiritconsortium.org/XMLSchema/SPIRIT/1685-2009}maximum").headOption map { x => IPXACT2009scalaxb.DataRecord(x, node, IPXACT2009scalaxb.fromXML[String](x, IPXACT2009scalaxb.ElemName(node) :: stack)) } map { "@{http://www.spiritconsortium.org/XMLSchema/SPIRIT/1685-2009}maximum" -> _ },
        (node \ "@{http://www.spiritconsortium.org/XMLSchema/SPIRIT/1685-2009}rangeType").headOption map { x => IPXACT2009scalaxb.DataRecord(x, node, IPXACT2009scalaxb.fromXML[RangeTypeType](x, IPXACT2009scalaxb.ElemName(node) :: stack)) } map { "@{http://www.spiritconsortium.org/XMLSchema/SPIRIT/1685-2009}rangeType" -> _ },
        (node \ "@{http://www.spiritconsortium.org/XMLSchema/SPIRIT/1685-2009}prompt").headOption map { x => IPXACT2009scalaxb.DataRecord(x, node, IPXACT2009scalaxb.fromXML[String](x, IPXACT2009scalaxb.ElemName(node) :: stack)) } map { "@{http://www.spiritconsortium.org/XMLSchema/SPIRIT/1685-2009}prompt" -> _ }
        ).flatten[(String, IPXACT2009scalaxb.DataRecord[Any])] ::: (node match {
          case elem: scala.xml.Elem =>
            elem.attributes.toList flatMap {
              case scala.xml.PrefixedAttribute(pre, key, value, _) if pre == elem.scope.getPrefix("http://www.spiritconsortium.org/XMLSchema/SPIRIT/1685-2009") &&
                key == "format" => Nil
              case scala.xml.PrefixedAttribute(pre, key, value, _) if pre == elem.scope.getPrefix("http://www.spiritconsortium.org/XMLSchema/SPIRIT/1685-2009") &&
                key == "resolve" => Nil
              case scala.xml.PrefixedAttribute(pre, key, value, _) if pre == elem.scope.getPrefix("http://www.spiritconsortium.org/XMLSchema/SPIRIT/1685-2009") &&
                key == "id" => Nil
              case scala.xml.PrefixedAttribute(pre, key, value, _) if pre == elem.scope.getPrefix("http://www.spiritconsortium.org/XMLSchema/SPIRIT/1685-2009") &&
                key == "dependency" => Nil
              case scala.xml.PrefixedAttribute(pre, key, value, _) if pre == elem.scope.getPrefix("http://www.spiritconsortium.org/XMLSchema/SPIRIT/1685-2009") &&
                key == "choiceRef" => Nil
              case scala.xml.PrefixedAttribute(pre, key, value, _) if pre == elem.scope.getPrefix("http://www.spiritconsortium.org/XMLSchema/SPIRIT/1685-2009") &&
                key == "order" => Nil
              case scala.xml.PrefixedAttribute(pre, key, value, _) if pre == elem.scope.getPrefix("http://www.spiritconsortium.org/XMLSchema/SPIRIT/1685-2009") &&
                key == "configGroups" => Nil
              case scala.xml.PrefixedAttribute(pre, key, value, _) if pre == elem.scope.getPrefix("http://www.spiritconsortium.org/XMLSchema/SPIRIT/1685-2009") &&
                key == "bitStringLength" => Nil
              case scala.xml.PrefixedAttribute(pre, key, value, _) if pre == elem.scope.getPrefix("http://www.spiritconsortium.org/XMLSchema/SPIRIT/1685-2009") &&
                key == "minimum" => Nil
              case scala.xml.PrefixedAttribute(pre, key, value, _) if pre == elem.scope.getPrefix("http://www.spiritconsortium.org/XMLSchema/SPIRIT/1685-2009") &&
                key == "maximum" => Nil
              case scala.xml.PrefixedAttribute(pre, key, value, _) if pre == elem.scope.getPrefix("http://www.spiritconsortium.org/XMLSchema/SPIRIT/1685-2009") &&
                key == "rangeType" => Nil
              case scala.xml.PrefixedAttribute(pre, key, value, _) if pre == elem.scope.getPrefix("http://www.spiritconsortium.org/XMLSchema/SPIRIT/1685-2009") &&
                key == "prompt" => Nil
              case scala.xml.UnprefixedAttribute(key, value, _) =>
                List(("@" + key, IPXACT2009scalaxb.DataRecord(None, Some(key), value.text)))
              case scala.xml.PrefixedAttribute(pre, key, value, _) =>
                val ns = elem.scope.getURI(pre)
                List(("@{" + ns + "}" + key, IPXACT2009scalaxb.DataRecord(Option[String](ns), Some(key), value.text)))
              case _ => Nil
            }
          case _ => Nil
        }): _*)))
      case _ => Left("reads failed: seq must be scala.xml.Node")
    }
    
    override def writesAttribute(__obj: Command2, __scope: scala.xml.NamespaceBinding): scala.xml.MetaData = {
      var attr: scala.xml.MetaData  = scala.xml.Null
      __obj.attributes.toList map {
        case ("@{http://www.spiritconsortium.org/XMLSchema/SPIRIT/1685-2009}format", _) => if (__obj.spiritformat.toString != "string") attr = scala.xml.Attribute(__scope.getPrefix("http://www.spiritconsortium.org/XMLSchema/SPIRIT/1685-2009"), "format", __obj.spiritformat.toString, attr)
        case ("@{http://www.spiritconsortium.org/XMLSchema/SPIRIT/1685-2009}resolve", _) => __obj.spiritresolve foreach { x => attr = scala.xml.Attribute(__scope.getPrefix("http://www.spiritconsortium.org/XMLSchema/SPIRIT/1685-2009"), "resolve", x.toString, attr) }
        case ("@{http://www.spiritconsortium.org/XMLSchema/SPIRIT/1685-2009}id", _) => __obj.spiritid foreach { x => attr = scala.xml.Attribute(__scope.getPrefix("http://www.spiritconsortium.org/XMLSchema/SPIRIT/1685-2009"), "id", x.toString, attr) }
        case ("@{http://www.spiritconsortium.org/XMLSchema/SPIRIT/1685-2009}dependency", _) => __obj.spiritdependency foreach { x => attr = scala.xml.Attribute(__scope.getPrefix("http://www.spiritconsortium.org/XMLSchema/SPIRIT/1685-2009"), "dependency", x.toString, attr) }
        case ("@{http://www.spiritconsortium.org/XMLSchema/SPIRIT/1685-2009}choiceRef", _) => __obj.spiritchoiceRef foreach { x => attr = scala.xml.Attribute(__scope.getPrefix("http://www.spiritconsortium.org/XMLSchema/SPIRIT/1685-2009"), "choiceRef", x.toString, attr) }
        case ("@{http://www.spiritconsortium.org/XMLSchema/SPIRIT/1685-2009}order", _) => __obj.spiritorder foreach { x => attr = scala.xml.Attribute(__scope.getPrefix("http://www.spiritconsortium.org/XMLSchema/SPIRIT/1685-2009"), "order", x.toString, attr) }
        case ("@{http://www.spiritconsortium.org/XMLSchema/SPIRIT/1685-2009}configGroups", _) => __obj.spiritconfigGroups foreach { x => attr = scala.xml.Attribute(__scope.getPrefix("http://www.spiritconsortium.org/XMLSchema/SPIRIT/1685-2009"), "configGroups", x.toString, attr) }
        case ("@{http://www.spiritconsortium.org/XMLSchema/SPIRIT/1685-2009}bitStringLength", _) => __obj.spiritbitStringLength foreach { x => attr = scala.xml.Attribute(__scope.getPrefix("http://www.spiritconsortium.org/XMLSchema/SPIRIT/1685-2009"), "bitStringLength", x.toString, attr) }
        case ("@{http://www.spiritconsortium.org/XMLSchema/SPIRIT/1685-2009}minimum", _) => __obj.spiritminimum foreach { x => attr = scala.xml.Attribute(__scope.getPrefix("http://www.spiritconsortium.org/XMLSchema/SPIRIT/1685-2009"), "minimum", x.toString, attr) }
        case ("@{http://www.spiritconsortium.org/XMLSchema/SPIRIT/1685-2009}maximum", _) => __obj.spiritmaximum foreach { x => attr = scala.xml.Attribute(__scope.getPrefix("http://www.spiritconsortium.org/XMLSchema/SPIRIT/1685-2009"), "maximum", x.toString, attr) }
        case ("@{http://www.spiritconsortium.org/XMLSchema/SPIRIT/1685-2009}rangeType", _) => __obj.spiritrangeType foreach { x => attr = scala.xml.Attribute(__scope.getPrefix("http://www.spiritconsortium.org/XMLSchema/SPIRIT/1685-2009"), "rangeType", x.toString, attr) }
        case ("@{http://www.spiritconsortium.org/XMLSchema/SPIRIT/1685-2009}prompt", _) => __obj.spiritprompt foreach { x => attr = scala.xml.Attribute(__scope.getPrefix("http://www.spiritconsortium.org/XMLSchema/SPIRIT/1685-2009"), "prompt", x.toString, attr) }
        case (key, x) => attr = scala.xml.Attribute((x.namespace map { __scope.getPrefix(_) }).orNull, x.key.orNull, x.value.toString, attr)
      }
      attr
    }

    def writesChildNodes(__obj: Command2, __scope: scala.xml.NamespaceBinding): Seq[scala.xml.Node] =
      Seq(scala.xml.Text(__obj.value.toString))

  }

  trait Default_Flags2Format extends IPXACT2009scalaxb.XMLFormat[Flags2] with IPXACT2009scalaxb.CanWriteChildNodes[Flags2] {
    val targetNamespace: Option[String] = Some("http://www.spiritconsortium.org/XMLSchema/SPIRIT/1685-2009")
    def reads(seq: scala.xml.NodeSeq, stack: List[IPXACT2009scalaxb.ElemName]): Either[String, Flags2] = seq match {
      case node: scala.xml.Node => Right(Flags2(IPXACT2009scalaxb.fromXML[String](node, IPXACT2009scalaxb.ElemName(node) :: stack),
        scala.collection.immutable.ListMap(List(
        (node \ "@{http://www.spiritconsortium.org/XMLSchema/SPIRIT/1685-2009}format").headOption map { x => IPXACT2009scalaxb.DataRecord(x, node, IPXACT2009scalaxb.fromXML[FormatType](x, IPXACT2009scalaxb.ElemName(node) :: stack)) } orElse Some(IPXACT2009scalaxb.DataRecord(None, None, IPXACT2009scalaxb.fromXML[FormatType](scala.xml.Text("string"), IPXACT2009scalaxb.ElemName(node) :: stack))) map { "@{http://www.spiritconsortium.org/XMLSchema/SPIRIT/1685-2009}format" -> _ },
        (node \ "@{http://www.spiritconsortium.org/XMLSchema/SPIRIT/1685-2009}resolve").headOption map { x => IPXACT2009scalaxb.DataRecord(x, node, IPXACT2009scalaxb.fromXML[ResolveType](x, IPXACT2009scalaxb.ElemName(node) :: stack)) } map { "@{http://www.spiritconsortium.org/XMLSchema/SPIRIT/1685-2009}resolve" -> _ },
        (node \ "@{http://www.spiritconsortium.org/XMLSchema/SPIRIT/1685-2009}id").headOption map { x => IPXACT2009scalaxb.DataRecord(x, node, IPXACT2009scalaxb.fromXML[String](x, IPXACT2009scalaxb.ElemName(node) :: stack)) } map { "@{http://www.spiritconsortium.org/XMLSchema/SPIRIT/1685-2009}id" -> _ },
        (node \ "@{http://www.spiritconsortium.org/XMLSchema/SPIRIT/1685-2009}dependency").headOption map { x => IPXACT2009scalaxb.DataRecord(x, node, IPXACT2009scalaxb.fromXML[String](x, IPXACT2009scalaxb.ElemName(node) :: stack)) } map { "@{http://www.spiritconsortium.org/XMLSchema/SPIRIT/1685-2009}dependency" -> _ },
        (node \ "@{http://www.spiritconsortium.org/XMLSchema/SPIRIT/1685-2009}choiceRef").headOption map { x => IPXACT2009scalaxb.DataRecord(x, node, IPXACT2009scalaxb.fromXML[String](x, IPXACT2009scalaxb.ElemName(node) :: stack)) } map { "@{http://www.spiritconsortium.org/XMLSchema/SPIRIT/1685-2009}choiceRef" -> _ },
        (node \ "@{http://www.spiritconsortium.org/XMLSchema/SPIRIT/1685-2009}order").headOption map { x => IPXACT2009scalaxb.DataRecord(x, node, IPXACT2009scalaxb.fromXML[Float](x, IPXACT2009scalaxb.ElemName(node) :: stack)) } map { "@{http://www.spiritconsortium.org/XMLSchema/SPIRIT/1685-2009}order" -> _ },
        (node \ "@{http://www.spiritconsortium.org/XMLSchema/SPIRIT/1685-2009}configGroups").headOption map { x => IPXACT2009scalaxb.DataRecord(x, node, IPXACT2009scalaxb.fromXML[Seq[String]](x, IPXACT2009scalaxb.ElemName(node) :: stack)) } map { "@{http://www.spiritconsortium.org/XMLSchema/SPIRIT/1685-2009}configGroups" -> _ },
        (node \ "@{http://www.spiritconsortium.org/XMLSchema/SPIRIT/1685-2009}bitStringLength").headOption map { x => IPXACT2009scalaxb.DataRecord(x, node, IPXACT2009scalaxb.fromXML[BigInt](x, IPXACT2009scalaxb.ElemName(node) :: stack)) } map { "@{http://www.spiritconsortium.org/XMLSchema/SPIRIT/1685-2009}bitStringLength" -> _ },
        (node \ "@{http://www.spiritconsortium.org/XMLSchema/SPIRIT/1685-2009}minimum").headOption map { x => IPXACT2009scalaxb.DataRecord(x, node, IPXACT2009scalaxb.fromXML[String](x, IPXACT2009scalaxb.ElemName(node) :: stack)) } map { "@{http://www.spiritconsortium.org/XMLSchema/SPIRIT/1685-2009}minimum" -> _ },
        (node \ "@{http://www.spiritconsortium.org/XMLSchema/SPIRIT/1685-2009}maximum").headOption map { x => IPXACT2009scalaxb.DataRecord(x, node, IPXACT2009scalaxb.fromXML[String](x, IPXACT2009scalaxb.ElemName(node) :: stack)) } map { "@{http://www.spiritconsortium.org/XMLSchema/SPIRIT/1685-2009}maximum" -> _ },
        (node \ "@{http://www.spiritconsortium.org/XMLSchema/SPIRIT/1685-2009}rangeType").headOption map { x => IPXACT2009scalaxb.DataRecord(x, node, IPXACT2009scalaxb.fromXML[RangeTypeType](x, IPXACT2009scalaxb.ElemName(node) :: stack)) } map { "@{http://www.spiritconsortium.org/XMLSchema/SPIRIT/1685-2009}rangeType" -> _ },
        (node \ "@{http://www.spiritconsortium.org/XMLSchema/SPIRIT/1685-2009}prompt").headOption map { x => IPXACT2009scalaxb.DataRecord(x, node, IPXACT2009scalaxb.fromXML[String](x, IPXACT2009scalaxb.ElemName(node) :: stack)) } map { "@{http://www.spiritconsortium.org/XMLSchema/SPIRIT/1685-2009}prompt" -> _ }
        ).flatten[(String, IPXACT2009scalaxb.DataRecord[Any])] ::: (node match {
          case elem: scala.xml.Elem =>
            elem.attributes.toList flatMap {
              case scala.xml.PrefixedAttribute(pre, key, value, _) if pre == elem.scope.getPrefix("http://www.spiritconsortium.org/XMLSchema/SPIRIT/1685-2009") &&
                key == "format" => Nil
              case scala.xml.PrefixedAttribute(pre, key, value, _) if pre == elem.scope.getPrefix("http://www.spiritconsortium.org/XMLSchema/SPIRIT/1685-2009") &&
                key == "resolve" => Nil
              case scala.xml.PrefixedAttribute(pre, key, value, _) if pre == elem.scope.getPrefix("http://www.spiritconsortium.org/XMLSchema/SPIRIT/1685-2009") &&
                key == "id" => Nil
              case scala.xml.PrefixedAttribute(pre, key, value, _) if pre == elem.scope.getPrefix("http://www.spiritconsortium.org/XMLSchema/SPIRIT/1685-2009") &&
                key == "dependency" => Nil
              case scala.xml.PrefixedAttribute(pre, key, value, _) if pre == elem.scope.getPrefix("http://www.spiritconsortium.org/XMLSchema/SPIRIT/1685-2009") &&
                key == "choiceRef" => Nil
              case scala.xml.PrefixedAttribute(pre, key, value, _) if pre == elem.scope.getPrefix("http://www.spiritconsortium.org/XMLSchema/SPIRIT/1685-2009") &&
                key == "order" => Nil
              case scala.xml.PrefixedAttribute(pre, key, value, _) if pre == elem.scope.getPrefix("http://www.spiritconsortium.org/XMLSchema/SPIRIT/1685-2009") &&
                key == "configGroups" => Nil
              case scala.xml.PrefixedAttribute(pre, key, value, _) if pre == elem.scope.getPrefix("http://www.spiritconsortium.org/XMLSchema/SPIRIT/1685-2009") &&
                key == "bitStringLength" => Nil
              case scala.xml.PrefixedAttribute(pre, key, value, _) if pre == elem.scope.getPrefix("http://www.spiritconsortium.org/XMLSchema/SPIRIT/1685-2009") &&
                key == "minimum" => Nil
              case scala.xml.PrefixedAttribute(pre, key, value, _) if pre == elem.scope.getPrefix("http://www.spiritconsortium.org/XMLSchema/SPIRIT/1685-2009") &&
                key == "maximum" => Nil
              case scala.xml.PrefixedAttribute(pre, key, value, _) if pre == elem.scope.getPrefix("http://www.spiritconsortium.org/XMLSchema/SPIRIT/1685-2009") &&
                key == "rangeType" => Nil
              case scala.xml.PrefixedAttribute(pre, key, value, _) if pre == elem.scope.getPrefix("http://www.spiritconsortium.org/XMLSchema/SPIRIT/1685-2009") &&
                key == "prompt" => Nil
              case scala.xml.UnprefixedAttribute(key, value, _) =>
                List(("@" + key, IPXACT2009scalaxb.DataRecord(None, Some(key), value.text)))
              case scala.xml.PrefixedAttribute(pre, key, value, _) =>
                val ns = elem.scope.getURI(pre)
                List(("@{" + ns + "}" + key, IPXACT2009scalaxb.DataRecord(Option[String](ns), Some(key), value.text)))
              case _ => Nil
            }
          case _ => Nil
        }): _*)))
      case _ => Left("reads failed: seq must be scala.xml.Node")
    }
    
    override def writesAttribute(__obj: Flags2, __scope: scala.xml.NamespaceBinding): scala.xml.MetaData = {
      var attr: scala.xml.MetaData  = scala.xml.Null
      __obj.attributes.toList map {
        case ("@{http://www.spiritconsortium.org/XMLSchema/SPIRIT/1685-2009}format", _) => if (__obj.spiritformat.toString != "string") attr = scala.xml.Attribute(__scope.getPrefix("http://www.spiritconsortium.org/XMLSchema/SPIRIT/1685-2009"), "format", __obj.spiritformat.toString, attr)
        case ("@{http://www.spiritconsortium.org/XMLSchema/SPIRIT/1685-2009}resolve", _) => __obj.spiritresolve foreach { x => attr = scala.xml.Attribute(__scope.getPrefix("http://www.spiritconsortium.org/XMLSchema/SPIRIT/1685-2009"), "resolve", x.toString, attr) }
        case ("@{http://www.spiritconsortium.org/XMLSchema/SPIRIT/1685-2009}id", _) => __obj.spiritid foreach { x => attr = scala.xml.Attribute(__scope.getPrefix("http://www.spiritconsortium.org/XMLSchema/SPIRIT/1685-2009"), "id", x.toString, attr) }
        case ("@{http://www.spiritconsortium.org/XMLSchema/SPIRIT/1685-2009}dependency", _) => __obj.spiritdependency foreach { x => attr = scala.xml.Attribute(__scope.getPrefix("http://www.spiritconsortium.org/XMLSchema/SPIRIT/1685-2009"), "dependency", x.toString, attr) }
        case ("@{http://www.spiritconsortium.org/XMLSchema/SPIRIT/1685-2009}choiceRef", _) => __obj.spiritchoiceRef foreach { x => attr = scala.xml.Attribute(__scope.getPrefix("http://www.spiritconsortium.org/XMLSchema/SPIRIT/1685-2009"), "choiceRef", x.toString, attr) }
        case ("@{http://www.spiritconsortium.org/XMLSchema/SPIRIT/1685-2009}order", _) => __obj.spiritorder foreach { x => attr = scala.xml.Attribute(__scope.getPrefix("http://www.spiritconsortium.org/XMLSchema/SPIRIT/1685-2009"), "order", x.toString, attr) }
        case ("@{http://www.spiritconsortium.org/XMLSchema/SPIRIT/1685-2009}configGroups", _) => __obj.spiritconfigGroups foreach { x => attr = scala.xml.Attribute(__scope.getPrefix("http://www.spiritconsortium.org/XMLSchema/SPIRIT/1685-2009"), "configGroups", x.toString, attr) }
        case ("@{http://www.spiritconsortium.org/XMLSchema/SPIRIT/1685-2009}bitStringLength", _) => __obj.spiritbitStringLength foreach { x => attr = scala.xml.Attribute(__scope.getPrefix("http://www.spiritconsortium.org/XMLSchema/SPIRIT/1685-2009"), "bitStringLength", x.toString, attr) }
        case ("@{http://www.spiritconsortium.org/XMLSchema/SPIRIT/1685-2009}minimum", _) => __obj.spiritminimum foreach { x => attr = scala.xml.Attribute(__scope.getPrefix("http://www.spiritconsortium.org/XMLSchema/SPIRIT/1685-2009"), "minimum", x.toString, attr) }
        case ("@{http://www.spiritconsortium.org/XMLSchema/SPIRIT/1685-2009}maximum", _) => __obj.spiritmaximum foreach { x => attr = scala.xml.Attribute(__scope.getPrefix("http://www.spiritconsortium.org/XMLSchema/SPIRIT/1685-2009"), "maximum", x.toString, attr) }
        case ("@{http://www.spiritconsortium.org/XMLSchema/SPIRIT/1685-2009}rangeType", _) => __obj.spiritrangeType foreach { x => attr = scala.xml.Attribute(__scope.getPrefix("http://www.spiritconsortium.org/XMLSchema/SPIRIT/1685-2009"), "rangeType", x.toString, attr) }
        case ("@{http://www.spiritconsortium.org/XMLSchema/SPIRIT/1685-2009}prompt", _) => __obj.spiritprompt foreach { x => attr = scala.xml.Attribute(__scope.getPrefix("http://www.spiritconsortium.org/XMLSchema/SPIRIT/1685-2009"), "prompt", x.toString, attr) }
        case (key, x) => attr = scala.xml.Attribute((x.namespace map { __scope.getPrefix(_) }).orNull, x.key.orNull, x.value.toString, attr)
      }
      attr
    }

    def writesChildNodes(__obj: Flags2, __scope: scala.xml.NamespaceBinding): Seq[scala.xml.Node] =
      Seq(scala.xml.Text(__obj.value.toString))

  }

  trait Default_ReplaceDefaultFlags2Format extends IPXACT2009scalaxb.XMLFormat[ReplaceDefaultFlags2] with IPXACT2009scalaxb.CanWriteChildNodes[ReplaceDefaultFlags2] {
    val targetNamespace: Option[String] = Some("http://www.spiritconsortium.org/XMLSchema/SPIRIT/1685-2009")
    def reads(seq: scala.xml.NodeSeq, stack: List[IPXACT2009scalaxb.ElemName]): Either[String, ReplaceDefaultFlags2] = seq match {
      case node: scala.xml.Node => Right(ReplaceDefaultFlags2(IPXACT2009scalaxb.fromXML[Boolean](node, IPXACT2009scalaxb.ElemName(node) :: stack),
        scala.collection.immutable.ListMap(List(
        (node \ "@{http://www.spiritconsortium.org/XMLSchema/SPIRIT/1685-2009}format").headOption map { x => IPXACT2009scalaxb.DataRecord(x, node, IPXACT2009scalaxb.fromXML[FormatType](x, IPXACT2009scalaxb.ElemName(node) :: stack)) } orElse Some(IPXACT2009scalaxb.DataRecord(None, None, IPXACT2009scalaxb.fromXML[FormatType](scala.xml.Text("bool"), IPXACT2009scalaxb.ElemName(node) :: stack))) map { "@{http://www.spiritconsortium.org/XMLSchema/SPIRIT/1685-2009}format" -> _ },
        (node \ "@{http://www.spiritconsortium.org/XMLSchema/SPIRIT/1685-2009}resolve").headOption map { x => IPXACT2009scalaxb.DataRecord(x, node, IPXACT2009scalaxb.fromXML[ResolveType](x, IPXACT2009scalaxb.ElemName(node) :: stack)) } map { "@{http://www.spiritconsortium.org/XMLSchema/SPIRIT/1685-2009}resolve" -> _ },
        (node \ "@{http://www.spiritconsortium.org/XMLSchema/SPIRIT/1685-2009}id").headOption map { x => IPXACT2009scalaxb.DataRecord(x, node, IPXACT2009scalaxb.fromXML[String](x, IPXACT2009scalaxb.ElemName(node) :: stack)) } map { "@{http://www.spiritconsortium.org/XMLSchema/SPIRIT/1685-2009}id" -> _ },
        (node \ "@{http://www.spiritconsortium.org/XMLSchema/SPIRIT/1685-2009}dependency").headOption map { x => IPXACT2009scalaxb.DataRecord(x, node, IPXACT2009scalaxb.fromXML[String](x, IPXACT2009scalaxb.ElemName(node) :: stack)) } map { "@{http://www.spiritconsortium.org/XMLSchema/SPIRIT/1685-2009}dependency" -> _ },
        (node \ "@{http://www.spiritconsortium.org/XMLSchema/SPIRIT/1685-2009}choiceRef").headOption map { x => IPXACT2009scalaxb.DataRecord(x, node, IPXACT2009scalaxb.fromXML[String](x, IPXACT2009scalaxb.ElemName(node) :: stack)) } map { "@{http://www.spiritconsortium.org/XMLSchema/SPIRIT/1685-2009}choiceRef" -> _ },
        (node \ "@{http://www.spiritconsortium.org/XMLSchema/SPIRIT/1685-2009}order").headOption map { x => IPXACT2009scalaxb.DataRecord(x, node, IPXACT2009scalaxb.fromXML[Float](x, IPXACT2009scalaxb.ElemName(node) :: stack)) } map { "@{http://www.spiritconsortium.org/XMLSchema/SPIRIT/1685-2009}order" -> _ },
        (node \ "@{http://www.spiritconsortium.org/XMLSchema/SPIRIT/1685-2009}configGroups").headOption map { x => IPXACT2009scalaxb.DataRecord(x, node, IPXACT2009scalaxb.fromXML[Seq[String]](x, IPXACT2009scalaxb.ElemName(node) :: stack)) } map { "@{http://www.spiritconsortium.org/XMLSchema/SPIRIT/1685-2009}configGroups" -> _ },
        (node \ "@{http://www.spiritconsortium.org/XMLSchema/SPIRIT/1685-2009}bitStringLength").headOption map { x => IPXACT2009scalaxb.DataRecord(x, node, IPXACT2009scalaxb.fromXML[BigInt](x, IPXACT2009scalaxb.ElemName(node) :: stack)) } map { "@{http://www.spiritconsortium.org/XMLSchema/SPIRIT/1685-2009}bitStringLength" -> _ },
        (node \ "@{http://www.spiritconsortium.org/XMLSchema/SPIRIT/1685-2009}minimum").headOption map { x => IPXACT2009scalaxb.DataRecord(x, node, IPXACT2009scalaxb.fromXML[String](x, IPXACT2009scalaxb.ElemName(node) :: stack)) } map { "@{http://www.spiritconsortium.org/XMLSchema/SPIRIT/1685-2009}minimum" -> _ },
        (node \ "@{http://www.spiritconsortium.org/XMLSchema/SPIRIT/1685-2009}maximum").headOption map { x => IPXACT2009scalaxb.DataRecord(x, node, IPXACT2009scalaxb.fromXML[String](x, IPXACT2009scalaxb.ElemName(node) :: stack)) } map { "@{http://www.spiritconsortium.org/XMLSchema/SPIRIT/1685-2009}maximum" -> _ },
        (node \ "@{http://www.spiritconsortium.org/XMLSchema/SPIRIT/1685-2009}rangeType").headOption map { x => IPXACT2009scalaxb.DataRecord(x, node, IPXACT2009scalaxb.fromXML[RangeTypeType](x, IPXACT2009scalaxb.ElemName(node) :: stack)) } orElse Some(IPXACT2009scalaxb.DataRecord(None, None, IPXACT2009scalaxb.fromXML[RangeTypeType](scala.xml.Text("int"), IPXACT2009scalaxb.ElemName(node) :: stack))) map { "@{http://www.spiritconsortium.org/XMLSchema/SPIRIT/1685-2009}rangeType" -> _ },
        (node \ "@{http://www.spiritconsortium.org/XMLSchema/SPIRIT/1685-2009}prompt").headOption map { x => IPXACT2009scalaxb.DataRecord(x, node, IPXACT2009scalaxb.fromXML[String](x, IPXACT2009scalaxb.ElemName(node) :: stack)) } map { "@{http://www.spiritconsortium.org/XMLSchema/SPIRIT/1685-2009}prompt" -> _ }
        ).flatten[(String, IPXACT2009scalaxb.DataRecord[Any])] ::: (node match {
          case elem: scala.xml.Elem =>
            elem.attributes.toList flatMap {
              case scala.xml.PrefixedAttribute(pre, key, value, _) if pre == elem.scope.getPrefix("http://www.spiritconsortium.org/XMLSchema/SPIRIT/1685-2009") &&
                key == "format" => Nil
              case scala.xml.PrefixedAttribute(pre, key, value, _) if pre == elem.scope.getPrefix("http://www.spiritconsortium.org/XMLSchema/SPIRIT/1685-2009") &&
                key == "resolve" => Nil
              case scala.xml.PrefixedAttribute(pre, key, value, _) if pre == elem.scope.getPrefix("http://www.spiritconsortium.org/XMLSchema/SPIRIT/1685-2009") &&
                key == "id" => Nil
              case scala.xml.PrefixedAttribute(pre, key, value, _) if pre == elem.scope.getPrefix("http://www.spiritconsortium.org/XMLSchema/SPIRIT/1685-2009") &&
                key == "dependency" => Nil
              case scala.xml.PrefixedAttribute(pre, key, value, _) if pre == elem.scope.getPrefix("http://www.spiritconsortium.org/XMLSchema/SPIRIT/1685-2009") &&
                key == "choiceRef" => Nil
              case scala.xml.PrefixedAttribute(pre, key, value, _) if pre == elem.scope.getPrefix("http://www.spiritconsortium.org/XMLSchema/SPIRIT/1685-2009") &&
                key == "order" => Nil
              case scala.xml.PrefixedAttribute(pre, key, value, _) if pre == elem.scope.getPrefix("http://www.spiritconsortium.org/XMLSchema/SPIRIT/1685-2009") &&
                key == "configGroups" => Nil
              case scala.xml.PrefixedAttribute(pre, key, value, _) if pre == elem.scope.getPrefix("http://www.spiritconsortium.org/XMLSchema/SPIRIT/1685-2009") &&
                key == "bitStringLength" => Nil
              case scala.xml.PrefixedAttribute(pre, key, value, _) if pre == elem.scope.getPrefix("http://www.spiritconsortium.org/XMLSchema/SPIRIT/1685-2009") &&
                key == "minimum" => Nil
              case scala.xml.PrefixedAttribute(pre, key, value, _) if pre == elem.scope.getPrefix("http://www.spiritconsortium.org/XMLSchema/SPIRIT/1685-2009") &&
                key == "maximum" => Nil
              case scala.xml.PrefixedAttribute(pre, key, value, _) if pre == elem.scope.getPrefix("http://www.spiritconsortium.org/XMLSchema/SPIRIT/1685-2009") &&
                key == "rangeType" => Nil
              case scala.xml.PrefixedAttribute(pre, key, value, _) if pre == elem.scope.getPrefix("http://www.spiritconsortium.org/XMLSchema/SPIRIT/1685-2009") &&
                key == "prompt" => Nil
              case scala.xml.UnprefixedAttribute(key, value, _) =>
                List(("@" + key, IPXACT2009scalaxb.DataRecord(None, Some(key), value.text)))
              case scala.xml.PrefixedAttribute(pre, key, value, _) =>
                val ns = elem.scope.getURI(pre)
                List(("@{" + ns + "}" + key, IPXACT2009scalaxb.DataRecord(Option[String](ns), Some(key), value.text)))
              case _ => Nil
            }
          case _ => Nil
        }): _*)))
      case _ => Left("reads failed: seq must be scala.xml.Node")
    }
    
    override def writesAttribute(__obj: ReplaceDefaultFlags2, __scope: scala.xml.NamespaceBinding): scala.xml.MetaData = {
      var attr: scala.xml.MetaData  = scala.xml.Null
      __obj.attributes.toList map {
        case ("@{http://www.spiritconsortium.org/XMLSchema/SPIRIT/1685-2009}format", _) => if (__obj.spiritformat.toString != "bool") attr = scala.xml.Attribute(__scope.getPrefix("http://www.spiritconsortium.org/XMLSchema/SPIRIT/1685-2009"), "format", __obj.spiritformat.toString, attr)
        case ("@{http://www.spiritconsortium.org/XMLSchema/SPIRIT/1685-2009}resolve", _) => __obj.spiritresolve foreach { x => attr = scala.xml.Attribute(__scope.getPrefix("http://www.spiritconsortium.org/XMLSchema/SPIRIT/1685-2009"), "resolve", x.toString, attr) }
        case ("@{http://www.spiritconsortium.org/XMLSchema/SPIRIT/1685-2009}id", _) => __obj.spiritid foreach { x => attr = scala.xml.Attribute(__scope.getPrefix("http://www.spiritconsortium.org/XMLSchema/SPIRIT/1685-2009"), "id", x.toString, attr) }
        case ("@{http://www.spiritconsortium.org/XMLSchema/SPIRIT/1685-2009}dependency", _) => __obj.spiritdependency foreach { x => attr = scala.xml.Attribute(__scope.getPrefix("http://www.spiritconsortium.org/XMLSchema/SPIRIT/1685-2009"), "dependency", x.toString, attr) }
        case ("@{http://www.spiritconsortium.org/XMLSchema/SPIRIT/1685-2009}choiceRef", _) => __obj.spiritchoiceRef foreach { x => attr = scala.xml.Attribute(__scope.getPrefix("http://www.spiritconsortium.org/XMLSchema/SPIRIT/1685-2009"), "choiceRef", x.toString, attr) }
        case ("@{http://www.spiritconsortium.org/XMLSchema/SPIRIT/1685-2009}order", _) => __obj.spiritorder foreach { x => attr = scala.xml.Attribute(__scope.getPrefix("http://www.spiritconsortium.org/XMLSchema/SPIRIT/1685-2009"), "order", x.toString, attr) }
        case ("@{http://www.spiritconsortium.org/XMLSchema/SPIRIT/1685-2009}configGroups", _) => __obj.spiritconfigGroups foreach { x => attr = scala.xml.Attribute(__scope.getPrefix("http://www.spiritconsortium.org/XMLSchema/SPIRIT/1685-2009"), "configGroups", x.toString, attr) }
        case ("@{http://www.spiritconsortium.org/XMLSchema/SPIRIT/1685-2009}bitStringLength", _) => __obj.spiritbitStringLength foreach { x => attr = scala.xml.Attribute(__scope.getPrefix("http://www.spiritconsortium.org/XMLSchema/SPIRIT/1685-2009"), "bitStringLength", x.toString, attr) }
        case ("@{http://www.spiritconsortium.org/XMLSchema/SPIRIT/1685-2009}minimum", _) => __obj.spiritminimum foreach { x => attr = scala.xml.Attribute(__scope.getPrefix("http://www.spiritconsortium.org/XMLSchema/SPIRIT/1685-2009"), "minimum", x.toString, attr) }
        case ("@{http://www.spiritconsortium.org/XMLSchema/SPIRIT/1685-2009}maximum", _) => __obj.spiritmaximum foreach { x => attr = scala.xml.Attribute(__scope.getPrefix("http://www.spiritconsortium.org/XMLSchema/SPIRIT/1685-2009"), "maximum", x.toString, attr) }
        case ("@{http://www.spiritconsortium.org/XMLSchema/SPIRIT/1685-2009}rangeType", _) => if (__obj.spiritrangeType.toString != "int") attr = scala.xml.Attribute(__scope.getPrefix("http://www.spiritconsortium.org/XMLSchema/SPIRIT/1685-2009"), "rangeType", __obj.spiritrangeType.toString, attr)
        case ("@{http://www.spiritconsortium.org/XMLSchema/SPIRIT/1685-2009}prompt", _) => __obj.spiritprompt foreach { x => attr = scala.xml.Attribute(__scope.getPrefix("http://www.spiritconsortium.org/XMLSchema/SPIRIT/1685-2009"), "prompt", x.toString, attr) }
        case (key, x) => attr = scala.xml.Attribute((x.namespace map { __scope.getPrefix(_) }).orNull, x.key.orNull, x.value.toString, attr)
      }
      attr
    }

    def writesChildNodes(__obj: ReplaceDefaultFlags2, __scope: scala.xml.NamespaceBinding): Seq[scala.xml.Node] =
      Seq(scala.xml.Text(__obj.value.toString))

  }

  trait Default_FileBuilderFormat extends IPXACT2009scalaxb.ElemNameParser[FileBuilder] with _FileTypeGroupFormat {
    val targetNamespace: Option[String] = Some("http://www.spiritconsortium.org/XMLSchema/SPIRIT/1685-2009")
    
    def parser(node: scala.xml.Node, stack: List[IPXACT2009scalaxb.ElemName]): Parser[FileBuilder] =
      phrase((parseFileTypeGroup(node, IPXACT2009scalaxb.ElemName(node) :: stack)) ~
      (IPXACT2009scalaxb.ElemName(Some("http://www.spiritconsortium.org/XMLSchema/SPIRIT/1685-2009"), "command")) ~
      opt(IPXACT2009scalaxb.ElemName(Some("http://www.spiritconsortium.org/XMLSchema/SPIRIT/1685-2009"), "flags")) ~
      opt(IPXACT2009scalaxb.ElemName(Some("http://www.spiritconsortium.org/XMLSchema/SPIRIT/1685-2009"), "replaceDefaultFlags")) ~
      opt(IPXACT2009scalaxb.ElemName(Some("http://www.spiritconsortium.org/XMLSchema/SPIRIT/1685-2009"), "vendorExtensions")) ^^
      { case p1 ~ p2 ~ p3 ~ p4 ~ p5 =>
      FileBuilder(p1,
        IPXACT2009scalaxb.fromXML[Command2](p2, IPXACT2009scalaxb.ElemName(node) :: stack),
        p3.headOption map { IPXACT2009scalaxb.fromXML[Flags2](_, IPXACT2009scalaxb.ElemName(node) :: stack) },
        p4.headOption map { IPXACT2009scalaxb.fromXML[ReplaceDefaultFlags2](_, IPXACT2009scalaxb.ElemName(node) :: stack) },
        p5.headOption map { IPXACT2009scalaxb.fromXML[VendorExtensions](_, IPXACT2009scalaxb.ElemName(node) :: stack) }) })
    
    def writesChildNodes(__obj: FileBuilder, __scope: scala.xml.NamespaceBinding): Seq[scala.xml.Node] =
      Seq.concat((Some(__obj.fileTypeOption1) map {x => IPXACT2009scalaxb.toXML[IPXACT2009scalaxb.DataRecord[Any]](x, x.namespace, x.key, __scope, false)}).get,
        IPXACT2009scalaxb.toXML[Command2](__obj.command, Some("http://www.spiritconsortium.org/XMLSchema/SPIRIT/1685-2009"), Some("command"), __scope, false),
        __obj.flags map { IPXACT2009scalaxb.toXML[Flags2](_, Some("http://www.spiritconsortium.org/XMLSchema/SPIRIT/1685-2009"), Some("flags"), __scope, false) } getOrElse {Nil},
        __obj.replaceDefaultFlags map { IPXACT2009scalaxb.toXML[ReplaceDefaultFlags2](_, Some("http://www.spiritconsortium.org/XMLSchema/SPIRIT/1685-2009"), Some("replaceDefaultFlags"), __scope, false) } getOrElse {Nil},
        __obj.vendorExtensions map { IPXACT2009scalaxb.toXML[VendorExtensions](_, Some("http://www.spiritconsortium.org/XMLSchema/SPIRIT/1685-2009"), Some("vendorExtensions"), __scope, false) } getOrElse {Nil})

  }

  trait Default_LinkerFormat extends IPXACT2009scalaxb.XMLFormat[Linker] with IPXACT2009scalaxb.CanWriteChildNodes[Linker] {
    val targetNamespace: Option[String] = Some("http://www.spiritconsortium.org/XMLSchema/SPIRIT/1685-2009")
    def reads(seq: scala.xml.NodeSeq, stack: List[IPXACT2009scalaxb.ElemName]): Either[String, Linker] = seq match {
      case node: scala.xml.Node => Right(Linker(IPXACT2009scalaxb.fromXML[String](node, IPXACT2009scalaxb.ElemName(node) :: stack),
        scala.collection.immutable.ListMap(List(
        (node \ "@{http://www.spiritconsortium.org/XMLSchema/SPIRIT/1685-2009}format").headOption map { x => IPXACT2009scalaxb.DataRecord(x, node, IPXACT2009scalaxb.fromXML[FormatType](x, IPXACT2009scalaxb.ElemName(node) :: stack)) } orElse Some(IPXACT2009scalaxb.DataRecord(None, None, IPXACT2009scalaxb.fromXML[FormatType](scala.xml.Text("string"), IPXACT2009scalaxb.ElemName(node) :: stack))) map { "@{http://www.spiritconsortium.org/XMLSchema/SPIRIT/1685-2009}format" -> _ },
        (node \ "@{http://www.spiritconsortium.org/XMLSchema/SPIRIT/1685-2009}resolve").headOption map { x => IPXACT2009scalaxb.DataRecord(x, node, IPXACT2009scalaxb.fromXML[ResolveType](x, IPXACT2009scalaxb.ElemName(node) :: stack)) } map { "@{http://www.spiritconsortium.org/XMLSchema/SPIRIT/1685-2009}resolve" -> _ },
        (node \ "@{http://www.spiritconsortium.org/XMLSchema/SPIRIT/1685-2009}id").headOption map { x => IPXACT2009scalaxb.DataRecord(x, node, IPXACT2009scalaxb.fromXML[String](x, IPXACT2009scalaxb.ElemName(node) :: stack)) } map { "@{http://www.spiritconsortium.org/XMLSchema/SPIRIT/1685-2009}id" -> _ },
        (node \ "@{http://www.spiritconsortium.org/XMLSchema/SPIRIT/1685-2009}dependency").headOption map { x => IPXACT2009scalaxb.DataRecord(x, node, IPXACT2009scalaxb.fromXML[String](x, IPXACT2009scalaxb.ElemName(node) :: stack)) } map { "@{http://www.spiritconsortium.org/XMLSchema/SPIRIT/1685-2009}dependency" -> _ },
        (node \ "@{http://www.spiritconsortium.org/XMLSchema/SPIRIT/1685-2009}choiceRef").headOption map { x => IPXACT2009scalaxb.DataRecord(x, node, IPXACT2009scalaxb.fromXML[String](x, IPXACT2009scalaxb.ElemName(node) :: stack)) } map { "@{http://www.spiritconsortium.org/XMLSchema/SPIRIT/1685-2009}choiceRef" -> _ },
        (node \ "@{http://www.spiritconsortium.org/XMLSchema/SPIRIT/1685-2009}order").headOption map { x => IPXACT2009scalaxb.DataRecord(x, node, IPXACT2009scalaxb.fromXML[Float](x, IPXACT2009scalaxb.ElemName(node) :: stack)) } map { "@{http://www.spiritconsortium.org/XMLSchema/SPIRIT/1685-2009}order" -> _ },
        (node \ "@{http://www.spiritconsortium.org/XMLSchema/SPIRIT/1685-2009}configGroups").headOption map { x => IPXACT2009scalaxb.DataRecord(x, node, IPXACT2009scalaxb.fromXML[Seq[String]](x, IPXACT2009scalaxb.ElemName(node) :: stack)) } map { "@{http://www.spiritconsortium.org/XMLSchema/SPIRIT/1685-2009}configGroups" -> _ },
        (node \ "@{http://www.spiritconsortium.org/XMLSchema/SPIRIT/1685-2009}bitStringLength").headOption map { x => IPXACT2009scalaxb.DataRecord(x, node, IPXACT2009scalaxb.fromXML[BigInt](x, IPXACT2009scalaxb.ElemName(node) :: stack)) } map { "@{http://www.spiritconsortium.org/XMLSchema/SPIRIT/1685-2009}bitStringLength" -> _ },
        (node \ "@{http://www.spiritconsortium.org/XMLSchema/SPIRIT/1685-2009}minimum").headOption map { x => IPXACT2009scalaxb.DataRecord(x, node, IPXACT2009scalaxb.fromXML[String](x, IPXACT2009scalaxb.ElemName(node) :: stack)) } map { "@{http://www.spiritconsortium.org/XMLSchema/SPIRIT/1685-2009}minimum" -> _ },
        (node \ "@{http://www.spiritconsortium.org/XMLSchema/SPIRIT/1685-2009}maximum").headOption map { x => IPXACT2009scalaxb.DataRecord(x, node, IPXACT2009scalaxb.fromXML[String](x, IPXACT2009scalaxb.ElemName(node) :: stack)) } map { "@{http://www.spiritconsortium.org/XMLSchema/SPIRIT/1685-2009}maximum" -> _ },
        (node \ "@{http://www.spiritconsortium.org/XMLSchema/SPIRIT/1685-2009}rangeType").headOption map { x => IPXACT2009scalaxb.DataRecord(x, node, IPXACT2009scalaxb.fromXML[RangeTypeType](x, IPXACT2009scalaxb.ElemName(node) :: stack)) } map { "@{http://www.spiritconsortium.org/XMLSchema/SPIRIT/1685-2009}rangeType" -> _ },
        (node \ "@{http://www.spiritconsortium.org/XMLSchema/SPIRIT/1685-2009}prompt").headOption map { x => IPXACT2009scalaxb.DataRecord(x, node, IPXACT2009scalaxb.fromXML[String](x, IPXACT2009scalaxb.ElemName(node) :: stack)) } map { "@{http://www.spiritconsortium.org/XMLSchema/SPIRIT/1685-2009}prompt" -> _ }
        ).flatten[(String, IPXACT2009scalaxb.DataRecord[Any])] ::: (node match {
          case elem: scala.xml.Elem =>
            elem.attributes.toList flatMap {
              case scala.xml.PrefixedAttribute(pre, key, value, _) if pre == elem.scope.getPrefix("http://www.spiritconsortium.org/XMLSchema/SPIRIT/1685-2009") &&
                key == "format" => Nil
              case scala.xml.PrefixedAttribute(pre, key, value, _) if pre == elem.scope.getPrefix("http://www.spiritconsortium.org/XMLSchema/SPIRIT/1685-2009") &&
                key == "resolve" => Nil
              case scala.xml.PrefixedAttribute(pre, key, value, _) if pre == elem.scope.getPrefix("http://www.spiritconsortium.org/XMLSchema/SPIRIT/1685-2009") &&
                key == "id" => Nil
              case scala.xml.PrefixedAttribute(pre, key, value, _) if pre == elem.scope.getPrefix("http://www.spiritconsortium.org/XMLSchema/SPIRIT/1685-2009") &&
                key == "dependency" => Nil
              case scala.xml.PrefixedAttribute(pre, key, value, _) if pre == elem.scope.getPrefix("http://www.spiritconsortium.org/XMLSchema/SPIRIT/1685-2009") &&
                key == "choiceRef" => Nil
              case scala.xml.PrefixedAttribute(pre, key, value, _) if pre == elem.scope.getPrefix("http://www.spiritconsortium.org/XMLSchema/SPIRIT/1685-2009") &&
                key == "order" => Nil
              case scala.xml.PrefixedAttribute(pre, key, value, _) if pre == elem.scope.getPrefix("http://www.spiritconsortium.org/XMLSchema/SPIRIT/1685-2009") &&
                key == "configGroups" => Nil
              case scala.xml.PrefixedAttribute(pre, key, value, _) if pre == elem.scope.getPrefix("http://www.spiritconsortium.org/XMLSchema/SPIRIT/1685-2009") &&
                key == "bitStringLength" => Nil
              case scala.xml.PrefixedAttribute(pre, key, value, _) if pre == elem.scope.getPrefix("http://www.spiritconsortium.org/XMLSchema/SPIRIT/1685-2009") &&
                key == "minimum" => Nil
              case scala.xml.PrefixedAttribute(pre, key, value, _) if pre == elem.scope.getPrefix("http://www.spiritconsortium.org/XMLSchema/SPIRIT/1685-2009") &&
                key == "maximum" => Nil
              case scala.xml.PrefixedAttribute(pre, key, value, _) if pre == elem.scope.getPrefix("http://www.spiritconsortium.org/XMLSchema/SPIRIT/1685-2009") &&
                key == "rangeType" => Nil
              case scala.xml.PrefixedAttribute(pre, key, value, _) if pre == elem.scope.getPrefix("http://www.spiritconsortium.org/XMLSchema/SPIRIT/1685-2009") &&
                key == "prompt" => Nil
              case scala.xml.UnprefixedAttribute(key, value, _) =>
                List(("@" + key, IPXACT2009scalaxb.DataRecord(None, Some(key), value.text)))
              case scala.xml.PrefixedAttribute(pre, key, value, _) =>
                val ns = elem.scope.getURI(pre)
                List(("@{" + ns + "}" + key, IPXACT2009scalaxb.DataRecord(Option[String](ns), Some(key), value.text)))
              case _ => Nil
            }
          case _ => Nil
        }): _*)))
      case _ => Left("reads failed: seq must be scala.xml.Node")
    }
    
    override def writesAttribute(__obj: Linker, __scope: scala.xml.NamespaceBinding): scala.xml.MetaData = {
      var attr: scala.xml.MetaData  = scala.xml.Null
      __obj.attributes.toList map {
        case ("@{http://www.spiritconsortium.org/XMLSchema/SPIRIT/1685-2009}format", _) => if (__obj.spiritformat.toString != "string") attr = scala.xml.Attribute(__scope.getPrefix("http://www.spiritconsortium.org/XMLSchema/SPIRIT/1685-2009"), "format", __obj.spiritformat.toString, attr)
        case ("@{http://www.spiritconsortium.org/XMLSchema/SPIRIT/1685-2009}resolve", _) => __obj.spiritresolve foreach { x => attr = scala.xml.Attribute(__scope.getPrefix("http://www.spiritconsortium.org/XMLSchema/SPIRIT/1685-2009"), "resolve", x.toString, attr) }
        case ("@{http://www.spiritconsortium.org/XMLSchema/SPIRIT/1685-2009}id", _) => __obj.spiritid foreach { x => attr = scala.xml.Attribute(__scope.getPrefix("http://www.spiritconsortium.org/XMLSchema/SPIRIT/1685-2009"), "id", x.toString, attr) }
        case ("@{http://www.spiritconsortium.org/XMLSchema/SPIRIT/1685-2009}dependency", _) => __obj.spiritdependency foreach { x => attr = scala.xml.Attribute(__scope.getPrefix("http://www.spiritconsortium.org/XMLSchema/SPIRIT/1685-2009"), "dependency", x.toString, attr) }
        case ("@{http://www.spiritconsortium.org/XMLSchema/SPIRIT/1685-2009}choiceRef", _) => __obj.spiritchoiceRef foreach { x => attr = scala.xml.Attribute(__scope.getPrefix("http://www.spiritconsortium.org/XMLSchema/SPIRIT/1685-2009"), "choiceRef", x.toString, attr) }
        case ("@{http://www.spiritconsortium.org/XMLSchema/SPIRIT/1685-2009}order", _) => __obj.spiritorder foreach { x => attr = scala.xml.Attribute(__scope.getPrefix("http://www.spiritconsortium.org/XMLSchema/SPIRIT/1685-2009"), "order", x.toString, attr) }
        case ("@{http://www.spiritconsortium.org/XMLSchema/SPIRIT/1685-2009}configGroups", _) => __obj.spiritconfigGroups foreach { x => attr = scala.xml.Attribute(__scope.getPrefix("http://www.spiritconsortium.org/XMLSchema/SPIRIT/1685-2009"), "configGroups", x.toString, attr) }
        case ("@{http://www.spiritconsortium.org/XMLSchema/SPIRIT/1685-2009}bitStringLength", _) => __obj.spiritbitStringLength foreach { x => attr = scala.xml.Attribute(__scope.getPrefix("http://www.spiritconsortium.org/XMLSchema/SPIRIT/1685-2009"), "bitStringLength", x.toString, attr) }
        case ("@{http://www.spiritconsortium.org/XMLSchema/SPIRIT/1685-2009}minimum", _) => __obj.spiritminimum foreach { x => attr = scala.xml.Attribute(__scope.getPrefix("http://www.spiritconsortium.org/XMLSchema/SPIRIT/1685-2009"), "minimum", x.toString, attr) }
        case ("@{http://www.spiritconsortium.org/XMLSchema/SPIRIT/1685-2009}maximum", _) => __obj.spiritmaximum foreach { x => attr = scala.xml.Attribute(__scope.getPrefix("http://www.spiritconsortium.org/XMLSchema/SPIRIT/1685-2009"), "maximum", x.toString, attr) }
        case ("@{http://www.spiritconsortium.org/XMLSchema/SPIRIT/1685-2009}rangeType", _) => __obj.spiritrangeType foreach { x => attr = scala.xml.Attribute(__scope.getPrefix("http://www.spiritconsortium.org/XMLSchema/SPIRIT/1685-2009"), "rangeType", x.toString, attr) }
        case ("@{http://www.spiritconsortium.org/XMLSchema/SPIRIT/1685-2009}prompt", _) => __obj.spiritprompt foreach { x => attr = scala.xml.Attribute(__scope.getPrefix("http://www.spiritconsortium.org/XMLSchema/SPIRIT/1685-2009"), "prompt", x.toString, attr) }
        case (key, x) => attr = scala.xml.Attribute((x.namespace map { __scope.getPrefix(_) }).orNull, x.key.orNull, x.value.toString, attr)
      }
      attr
    }

    def writesChildNodes(__obj: Linker, __scope: scala.xml.NamespaceBinding): Seq[scala.xml.Node] =
      Seq(scala.xml.Text(__obj.value.toString))

  }

  trait Default_LinkerFlagsFormat extends IPXACT2009scalaxb.XMLFormat[LinkerFlags] with IPXACT2009scalaxb.CanWriteChildNodes[LinkerFlags] {
    val targetNamespace: Option[String] = Some("http://www.spiritconsortium.org/XMLSchema/SPIRIT/1685-2009")
    def reads(seq: scala.xml.NodeSeq, stack: List[IPXACT2009scalaxb.ElemName]): Either[String, LinkerFlags] = seq match {
      case node: scala.xml.Node => Right(LinkerFlags(IPXACT2009scalaxb.fromXML[String](node, IPXACT2009scalaxb.ElemName(node) :: stack),
        scala.collection.immutable.ListMap(List(
        (node \ "@{http://www.spiritconsortium.org/XMLSchema/SPIRIT/1685-2009}format").headOption map { x => IPXACT2009scalaxb.DataRecord(x, node, IPXACT2009scalaxb.fromXML[FormatType](x, IPXACT2009scalaxb.ElemName(node) :: stack)) } orElse Some(IPXACT2009scalaxb.DataRecord(None, None, IPXACT2009scalaxb.fromXML[FormatType](scala.xml.Text("string"), IPXACT2009scalaxb.ElemName(node) :: stack))) map { "@{http://www.spiritconsortium.org/XMLSchema/SPIRIT/1685-2009}format" -> _ },
        (node \ "@{http://www.spiritconsortium.org/XMLSchema/SPIRIT/1685-2009}resolve").headOption map { x => IPXACT2009scalaxb.DataRecord(x, node, IPXACT2009scalaxb.fromXML[ResolveType](x, IPXACT2009scalaxb.ElemName(node) :: stack)) } map { "@{http://www.spiritconsortium.org/XMLSchema/SPIRIT/1685-2009}resolve" -> _ },
        (node \ "@{http://www.spiritconsortium.org/XMLSchema/SPIRIT/1685-2009}id").headOption map { x => IPXACT2009scalaxb.DataRecord(x, node, IPXACT2009scalaxb.fromXML[String](x, IPXACT2009scalaxb.ElemName(node) :: stack)) } map { "@{http://www.spiritconsortium.org/XMLSchema/SPIRIT/1685-2009}id" -> _ },
        (node \ "@{http://www.spiritconsortium.org/XMLSchema/SPIRIT/1685-2009}dependency").headOption map { x => IPXACT2009scalaxb.DataRecord(x, node, IPXACT2009scalaxb.fromXML[String](x, IPXACT2009scalaxb.ElemName(node) :: stack)) } map { "@{http://www.spiritconsortium.org/XMLSchema/SPIRIT/1685-2009}dependency" -> _ },
        (node \ "@{http://www.spiritconsortium.org/XMLSchema/SPIRIT/1685-2009}choiceRef").headOption map { x => IPXACT2009scalaxb.DataRecord(x, node, IPXACT2009scalaxb.fromXML[String](x, IPXACT2009scalaxb.ElemName(node) :: stack)) } map { "@{http://www.spiritconsortium.org/XMLSchema/SPIRIT/1685-2009}choiceRef" -> _ },
        (node \ "@{http://www.spiritconsortium.org/XMLSchema/SPIRIT/1685-2009}order").headOption map { x => IPXACT2009scalaxb.DataRecord(x, node, IPXACT2009scalaxb.fromXML[Float](x, IPXACT2009scalaxb.ElemName(node) :: stack)) } map { "@{http://www.spiritconsortium.org/XMLSchema/SPIRIT/1685-2009}order" -> _ },
        (node \ "@{http://www.spiritconsortium.org/XMLSchema/SPIRIT/1685-2009}configGroups").headOption map { x => IPXACT2009scalaxb.DataRecord(x, node, IPXACT2009scalaxb.fromXML[Seq[String]](x, IPXACT2009scalaxb.ElemName(node) :: stack)) } map { "@{http://www.spiritconsortium.org/XMLSchema/SPIRIT/1685-2009}configGroups" -> _ },
        (node \ "@{http://www.spiritconsortium.org/XMLSchema/SPIRIT/1685-2009}bitStringLength").headOption map { x => IPXACT2009scalaxb.DataRecord(x, node, IPXACT2009scalaxb.fromXML[BigInt](x, IPXACT2009scalaxb.ElemName(node) :: stack)) } map { "@{http://www.spiritconsortium.org/XMLSchema/SPIRIT/1685-2009}bitStringLength" -> _ },
        (node \ "@{http://www.spiritconsortium.org/XMLSchema/SPIRIT/1685-2009}minimum").headOption map { x => IPXACT2009scalaxb.DataRecord(x, node, IPXACT2009scalaxb.fromXML[String](x, IPXACT2009scalaxb.ElemName(node) :: stack)) } map { "@{http://www.spiritconsortium.org/XMLSchema/SPIRIT/1685-2009}minimum" -> _ },
        (node \ "@{http://www.spiritconsortium.org/XMLSchema/SPIRIT/1685-2009}maximum").headOption map { x => IPXACT2009scalaxb.DataRecord(x, node, IPXACT2009scalaxb.fromXML[String](x, IPXACT2009scalaxb.ElemName(node) :: stack)) } map { "@{http://www.spiritconsortium.org/XMLSchema/SPIRIT/1685-2009}maximum" -> _ },
        (node \ "@{http://www.spiritconsortium.org/XMLSchema/SPIRIT/1685-2009}rangeType").headOption map { x => IPXACT2009scalaxb.DataRecord(x, node, IPXACT2009scalaxb.fromXML[RangeTypeType](x, IPXACT2009scalaxb.ElemName(node) :: stack)) } map { "@{http://www.spiritconsortium.org/XMLSchema/SPIRIT/1685-2009}rangeType" -> _ },
        (node \ "@{http://www.spiritconsortium.org/XMLSchema/SPIRIT/1685-2009}prompt").headOption map { x => IPXACT2009scalaxb.DataRecord(x, node, IPXACT2009scalaxb.fromXML[String](x, IPXACT2009scalaxb.ElemName(node) :: stack)) } map { "@{http://www.spiritconsortium.org/XMLSchema/SPIRIT/1685-2009}prompt" -> _ }
        ).flatten[(String, IPXACT2009scalaxb.DataRecord[Any])] ::: (node match {
          case elem: scala.xml.Elem =>
            elem.attributes.toList flatMap {
              case scala.xml.PrefixedAttribute(pre, key, value, _) if pre == elem.scope.getPrefix("http://www.spiritconsortium.org/XMLSchema/SPIRIT/1685-2009") &&
                key == "format" => Nil
              case scala.xml.PrefixedAttribute(pre, key, value, _) if pre == elem.scope.getPrefix("http://www.spiritconsortium.org/XMLSchema/SPIRIT/1685-2009") &&
                key == "resolve" => Nil
              case scala.xml.PrefixedAttribute(pre, key, value, _) if pre == elem.scope.getPrefix("http://www.spiritconsortium.org/XMLSchema/SPIRIT/1685-2009") &&
                key == "id" => Nil
              case scala.xml.PrefixedAttribute(pre, key, value, _) if pre == elem.scope.getPrefix("http://www.spiritconsortium.org/XMLSchema/SPIRIT/1685-2009") &&
                key == "dependency" => Nil
              case scala.xml.PrefixedAttribute(pre, key, value, _) if pre == elem.scope.getPrefix("http://www.spiritconsortium.org/XMLSchema/SPIRIT/1685-2009") &&
                key == "choiceRef" => Nil
              case scala.xml.PrefixedAttribute(pre, key, value, _) if pre == elem.scope.getPrefix("http://www.spiritconsortium.org/XMLSchema/SPIRIT/1685-2009") &&
                key == "order" => Nil
              case scala.xml.PrefixedAttribute(pre, key, value, _) if pre == elem.scope.getPrefix("http://www.spiritconsortium.org/XMLSchema/SPIRIT/1685-2009") &&
                key == "configGroups" => Nil
              case scala.xml.PrefixedAttribute(pre, key, value, _) if pre == elem.scope.getPrefix("http://www.spiritconsortium.org/XMLSchema/SPIRIT/1685-2009") &&
                key == "bitStringLength" => Nil
              case scala.xml.PrefixedAttribute(pre, key, value, _) if pre == elem.scope.getPrefix("http://www.spiritconsortium.org/XMLSchema/SPIRIT/1685-2009") &&
                key == "minimum" => Nil
              case scala.xml.PrefixedAttribute(pre, key, value, _) if pre == elem.scope.getPrefix("http://www.spiritconsortium.org/XMLSchema/SPIRIT/1685-2009") &&
                key == "maximum" => Nil
              case scala.xml.PrefixedAttribute(pre, key, value, _) if pre == elem.scope.getPrefix("http://www.spiritconsortium.org/XMLSchema/SPIRIT/1685-2009") &&
                key == "rangeType" => Nil
              case scala.xml.PrefixedAttribute(pre, key, value, _) if pre == elem.scope.getPrefix("http://www.spiritconsortium.org/XMLSchema/SPIRIT/1685-2009") &&
                key == "prompt" => Nil
              case scala.xml.UnprefixedAttribute(key, value, _) =>
                List(("@" + key, IPXACT2009scalaxb.DataRecord(None, Some(key), value.text)))
              case scala.xml.PrefixedAttribute(pre, key, value, _) =>
                val ns = elem.scope.getURI(pre)
                List(("@{" + ns + "}" + key, IPXACT2009scalaxb.DataRecord(Option[String](ns), Some(key), value.text)))
              case _ => Nil
            }
          case _ => Nil
        }): _*)))
      case _ => Left("reads failed: seq must be scala.xml.Node")
    }
    
    override def writesAttribute(__obj: LinkerFlags, __scope: scala.xml.NamespaceBinding): scala.xml.MetaData = {
      var attr: scala.xml.MetaData  = scala.xml.Null
      __obj.attributes.toList map {
        case ("@{http://www.spiritconsortium.org/XMLSchema/SPIRIT/1685-2009}format", _) => if (__obj.spiritformat.toString != "string") attr = scala.xml.Attribute(__scope.getPrefix("http://www.spiritconsortium.org/XMLSchema/SPIRIT/1685-2009"), "format", __obj.spiritformat.toString, attr)
        case ("@{http://www.spiritconsortium.org/XMLSchema/SPIRIT/1685-2009}resolve", _) => __obj.spiritresolve foreach { x => attr = scala.xml.Attribute(__scope.getPrefix("http://www.spiritconsortium.org/XMLSchema/SPIRIT/1685-2009"), "resolve", x.toString, attr) }
        case ("@{http://www.spiritconsortium.org/XMLSchema/SPIRIT/1685-2009}id", _) => __obj.spiritid foreach { x => attr = scala.xml.Attribute(__scope.getPrefix("http://www.spiritconsortium.org/XMLSchema/SPIRIT/1685-2009"), "id", x.toString, attr) }
        case ("@{http://www.spiritconsortium.org/XMLSchema/SPIRIT/1685-2009}dependency", _) => __obj.spiritdependency foreach { x => attr = scala.xml.Attribute(__scope.getPrefix("http://www.spiritconsortium.org/XMLSchema/SPIRIT/1685-2009"), "dependency", x.toString, attr) }
        case ("@{http://www.spiritconsortium.org/XMLSchema/SPIRIT/1685-2009}choiceRef", _) => __obj.spiritchoiceRef foreach { x => attr = scala.xml.Attribute(__scope.getPrefix("http://www.spiritconsortium.org/XMLSchema/SPIRIT/1685-2009"), "choiceRef", x.toString, attr) }
        case ("@{http://www.spiritconsortium.org/XMLSchema/SPIRIT/1685-2009}order", _) => __obj.spiritorder foreach { x => attr = scala.xml.Attribute(__scope.getPrefix("http://www.spiritconsortium.org/XMLSchema/SPIRIT/1685-2009"), "order", x.toString, attr) }
        case ("@{http://www.spiritconsortium.org/XMLSchema/SPIRIT/1685-2009}configGroups", _) => __obj.spiritconfigGroups foreach { x => attr = scala.xml.Attribute(__scope.getPrefix("http://www.spiritconsortium.org/XMLSchema/SPIRIT/1685-2009"), "configGroups", x.toString, attr) }
        case ("@{http://www.spiritconsortium.org/XMLSchema/SPIRIT/1685-2009}bitStringLength", _) => __obj.spiritbitStringLength foreach { x => attr = scala.xml.Attribute(__scope.getPrefix("http://www.spiritconsortium.org/XMLSchema/SPIRIT/1685-2009"), "bitStringLength", x.toString, attr) }
        case ("@{http://www.spiritconsortium.org/XMLSchema/SPIRIT/1685-2009}minimum", _) => __obj.spiritminimum foreach { x => attr = scala.xml.Attribute(__scope.getPrefix("http://www.spiritconsortium.org/XMLSchema/SPIRIT/1685-2009"), "minimum", x.toString, attr) }
        case ("@{http://www.spiritconsortium.org/XMLSchema/SPIRIT/1685-2009}maximum", _) => __obj.spiritmaximum foreach { x => attr = scala.xml.Attribute(__scope.getPrefix("http://www.spiritconsortium.org/XMLSchema/SPIRIT/1685-2009"), "maximum", x.toString, attr) }
        case ("@{http://www.spiritconsortium.org/XMLSchema/SPIRIT/1685-2009}rangeType", _) => __obj.spiritrangeType foreach { x => attr = scala.xml.Attribute(__scope.getPrefix("http://www.spiritconsortium.org/XMLSchema/SPIRIT/1685-2009"), "rangeType", x.toString, attr) }
        case ("@{http://www.spiritconsortium.org/XMLSchema/SPIRIT/1685-2009}prompt", _) => __obj.spiritprompt foreach { x => attr = scala.xml.Attribute(__scope.getPrefix("http://www.spiritconsortium.org/XMLSchema/SPIRIT/1685-2009"), "prompt", x.toString, attr) }
        case (key, x) => attr = scala.xml.Attribute((x.namespace map { __scope.getPrefix(_) }).orNull, x.key.orNull, x.value.toString, attr)
      }
      attr
    }

    def writesChildNodes(__obj: LinkerFlags, __scope: scala.xml.NamespaceBinding): Seq[scala.xml.Node] =
      Seq(scala.xml.Text(__obj.value.toString))

  }

  trait Default_Name3Format extends IPXACT2009scalaxb.XMLFormat[Name3] with IPXACT2009scalaxb.CanWriteChildNodes[Name3] {
    val targetNamespace: Option[String] = Some("http://www.spiritconsortium.org/XMLSchema/SPIRIT/1685-2009")
    def reads(seq: scala.xml.NodeSeq, stack: List[IPXACT2009scalaxb.ElemName]): Either[String, Name3] = seq match {
      case node: scala.xml.Node => Right(Name3(IPXACT2009scalaxb.fromXML[String](node, IPXACT2009scalaxb.ElemName(node) :: stack),
        scala.collection.immutable.ListMap(List(
        (node \ "@{http://www.spiritconsortium.org/XMLSchema/SPIRIT/1685-2009}format").headOption map { x => IPXACT2009scalaxb.DataRecord(x, node, IPXACT2009scalaxb.fromXML[FormatType](x, IPXACT2009scalaxb.ElemName(node) :: stack)) } orElse Some(IPXACT2009scalaxb.DataRecord(None, None, IPXACT2009scalaxb.fromXML[FormatType](scala.xml.Text("string"), IPXACT2009scalaxb.ElemName(node) :: stack))) map { "@{http://www.spiritconsortium.org/XMLSchema/SPIRIT/1685-2009}format" -> _ },
        (node \ "@{http://www.spiritconsortium.org/XMLSchema/SPIRIT/1685-2009}resolve").headOption map { x => IPXACT2009scalaxb.DataRecord(x, node, IPXACT2009scalaxb.fromXML[ResolveType](x, IPXACT2009scalaxb.ElemName(node) :: stack)) } map { "@{http://www.spiritconsortium.org/XMLSchema/SPIRIT/1685-2009}resolve" -> _ },
        (node \ "@{http://www.spiritconsortium.org/XMLSchema/SPIRIT/1685-2009}id").headOption map { x => IPXACT2009scalaxb.DataRecord(x, node, IPXACT2009scalaxb.fromXML[String](x, IPXACT2009scalaxb.ElemName(node) :: stack)) } map { "@{http://www.spiritconsortium.org/XMLSchema/SPIRIT/1685-2009}id" -> _ },
        (node \ "@{http://www.spiritconsortium.org/XMLSchema/SPIRIT/1685-2009}dependency").headOption map { x => IPXACT2009scalaxb.DataRecord(x, node, IPXACT2009scalaxb.fromXML[String](x, IPXACT2009scalaxb.ElemName(node) :: stack)) } map { "@{http://www.spiritconsortium.org/XMLSchema/SPIRIT/1685-2009}dependency" -> _ },
        (node \ "@{http://www.spiritconsortium.org/XMLSchema/SPIRIT/1685-2009}choiceRef").headOption map { x => IPXACT2009scalaxb.DataRecord(x, node, IPXACT2009scalaxb.fromXML[String](x, IPXACT2009scalaxb.ElemName(node) :: stack)) } map { "@{http://www.spiritconsortium.org/XMLSchema/SPIRIT/1685-2009}choiceRef" -> _ },
        (node \ "@{http://www.spiritconsortium.org/XMLSchema/SPIRIT/1685-2009}order").headOption map { x => IPXACT2009scalaxb.DataRecord(x, node, IPXACT2009scalaxb.fromXML[Float](x, IPXACT2009scalaxb.ElemName(node) :: stack)) } map { "@{http://www.spiritconsortium.org/XMLSchema/SPIRIT/1685-2009}order" -> _ },
        (node \ "@{http://www.spiritconsortium.org/XMLSchema/SPIRIT/1685-2009}configGroups").headOption map { x => IPXACT2009scalaxb.DataRecord(x, node, IPXACT2009scalaxb.fromXML[Seq[String]](x, IPXACT2009scalaxb.ElemName(node) :: stack)) } map { "@{http://www.spiritconsortium.org/XMLSchema/SPIRIT/1685-2009}configGroups" -> _ },
        (node \ "@{http://www.spiritconsortium.org/XMLSchema/SPIRIT/1685-2009}bitStringLength").headOption map { x => IPXACT2009scalaxb.DataRecord(x, node, IPXACT2009scalaxb.fromXML[BigInt](x, IPXACT2009scalaxb.ElemName(node) :: stack)) } map { "@{http://www.spiritconsortium.org/XMLSchema/SPIRIT/1685-2009}bitStringLength" -> _ },
        (node \ "@{http://www.spiritconsortium.org/XMLSchema/SPIRIT/1685-2009}minimum").headOption map { x => IPXACT2009scalaxb.DataRecord(x, node, IPXACT2009scalaxb.fromXML[String](x, IPXACT2009scalaxb.ElemName(node) :: stack)) } map { "@{http://www.spiritconsortium.org/XMLSchema/SPIRIT/1685-2009}minimum" -> _ },
        (node \ "@{http://www.spiritconsortium.org/XMLSchema/SPIRIT/1685-2009}maximum").headOption map { x => IPXACT2009scalaxb.DataRecord(x, node, IPXACT2009scalaxb.fromXML[String](x, IPXACT2009scalaxb.ElemName(node) :: stack)) } map { "@{http://www.spiritconsortium.org/XMLSchema/SPIRIT/1685-2009}maximum" -> _ },
        (node \ "@{http://www.spiritconsortium.org/XMLSchema/SPIRIT/1685-2009}rangeType").headOption map { x => IPXACT2009scalaxb.DataRecord(x, node, IPXACT2009scalaxb.fromXML[RangeTypeType](x, IPXACT2009scalaxb.ElemName(node) :: stack)) } map { "@{http://www.spiritconsortium.org/XMLSchema/SPIRIT/1685-2009}rangeType" -> _ },
        (node \ "@{http://www.spiritconsortium.org/XMLSchema/SPIRIT/1685-2009}prompt").headOption map { x => IPXACT2009scalaxb.DataRecord(x, node, IPXACT2009scalaxb.fromXML[String](x, IPXACT2009scalaxb.ElemName(node) :: stack)) } map { "@{http://www.spiritconsortium.org/XMLSchema/SPIRIT/1685-2009}prompt" -> _ }
        ).flatten[(String, IPXACT2009scalaxb.DataRecord[Any])] ::: (node match {
          case elem: scala.xml.Elem =>
            elem.attributes.toList flatMap {
              case scala.xml.PrefixedAttribute(pre, key, value, _) if pre == elem.scope.getPrefix("http://www.spiritconsortium.org/XMLSchema/SPIRIT/1685-2009") &&
                key == "format" => Nil
              case scala.xml.PrefixedAttribute(pre, key, value, _) if pre == elem.scope.getPrefix("http://www.spiritconsortium.org/XMLSchema/SPIRIT/1685-2009") &&
                key == "resolve" => Nil
              case scala.xml.PrefixedAttribute(pre, key, value, _) if pre == elem.scope.getPrefix("http://www.spiritconsortium.org/XMLSchema/SPIRIT/1685-2009") &&
                key == "id" => Nil
              case scala.xml.PrefixedAttribute(pre, key, value, _) if pre == elem.scope.getPrefix("http://www.spiritconsortium.org/XMLSchema/SPIRIT/1685-2009") &&
                key == "dependency" => Nil
              case scala.xml.PrefixedAttribute(pre, key, value, _) if pre == elem.scope.getPrefix("http://www.spiritconsortium.org/XMLSchema/SPIRIT/1685-2009") &&
                key == "choiceRef" => Nil
              case scala.xml.PrefixedAttribute(pre, key, value, _) if pre == elem.scope.getPrefix("http://www.spiritconsortium.org/XMLSchema/SPIRIT/1685-2009") &&
                key == "order" => Nil
              case scala.xml.PrefixedAttribute(pre, key, value, _) if pre == elem.scope.getPrefix("http://www.spiritconsortium.org/XMLSchema/SPIRIT/1685-2009") &&
                key == "configGroups" => Nil
              case scala.xml.PrefixedAttribute(pre, key, value, _) if pre == elem.scope.getPrefix("http://www.spiritconsortium.org/XMLSchema/SPIRIT/1685-2009") &&
                key == "bitStringLength" => Nil
              case scala.xml.PrefixedAttribute(pre, key, value, _) if pre == elem.scope.getPrefix("http://www.spiritconsortium.org/XMLSchema/SPIRIT/1685-2009") &&
                key == "minimum" => Nil
              case scala.xml.PrefixedAttribute(pre, key, value, _) if pre == elem.scope.getPrefix("http://www.spiritconsortium.org/XMLSchema/SPIRIT/1685-2009") &&
                key == "maximum" => Nil
              case scala.xml.PrefixedAttribute(pre, key, value, _) if pre == elem.scope.getPrefix("http://www.spiritconsortium.org/XMLSchema/SPIRIT/1685-2009") &&
                key == "rangeType" => Nil
              case scala.xml.PrefixedAttribute(pre, key, value, _) if pre == elem.scope.getPrefix("http://www.spiritconsortium.org/XMLSchema/SPIRIT/1685-2009") &&
                key == "prompt" => Nil
              case scala.xml.UnprefixedAttribute(key, value, _) =>
                List(("@" + key, IPXACT2009scalaxb.DataRecord(None, Some(key), value.text)))
              case scala.xml.PrefixedAttribute(pre, key, value, _) =>
                val ns = elem.scope.getURI(pre)
                List(("@{" + ns + "}" + key, IPXACT2009scalaxb.DataRecord(Option[String](ns), Some(key), value.text)))
              case _ => Nil
            }
          case _ => Nil
        }): _*)))
      case _ => Left("reads failed: seq must be scala.xml.Node")
    }
    
    override def writesAttribute(__obj: Name3, __scope: scala.xml.NamespaceBinding): scala.xml.MetaData = {
      var attr: scala.xml.MetaData  = scala.xml.Null
      __obj.attributes.toList map {
        case ("@{http://www.spiritconsortium.org/XMLSchema/SPIRIT/1685-2009}format", _) => if (__obj.spiritformat.toString != "string") attr = scala.xml.Attribute(__scope.getPrefix("http://www.spiritconsortium.org/XMLSchema/SPIRIT/1685-2009"), "format", __obj.spiritformat.toString, attr)
        case ("@{http://www.spiritconsortium.org/XMLSchema/SPIRIT/1685-2009}resolve", _) => __obj.spiritresolve foreach { x => attr = scala.xml.Attribute(__scope.getPrefix("http://www.spiritconsortium.org/XMLSchema/SPIRIT/1685-2009"), "resolve", x.toString, attr) }
        case ("@{http://www.spiritconsortium.org/XMLSchema/SPIRIT/1685-2009}id", _) => __obj.spiritid foreach { x => attr = scala.xml.Attribute(__scope.getPrefix("http://www.spiritconsortium.org/XMLSchema/SPIRIT/1685-2009"), "id", x.toString, attr) }
        case ("@{http://www.spiritconsortium.org/XMLSchema/SPIRIT/1685-2009}dependency", _) => __obj.spiritdependency foreach { x => attr = scala.xml.Attribute(__scope.getPrefix("http://www.spiritconsortium.org/XMLSchema/SPIRIT/1685-2009"), "dependency", x.toString, attr) }
        case ("@{http://www.spiritconsortium.org/XMLSchema/SPIRIT/1685-2009}choiceRef", _) => __obj.spiritchoiceRef foreach { x => attr = scala.xml.Attribute(__scope.getPrefix("http://www.spiritconsortium.org/XMLSchema/SPIRIT/1685-2009"), "choiceRef", x.toString, attr) }
        case ("@{http://www.spiritconsortium.org/XMLSchema/SPIRIT/1685-2009}order", _) => __obj.spiritorder foreach { x => attr = scala.xml.Attribute(__scope.getPrefix("http://www.spiritconsortium.org/XMLSchema/SPIRIT/1685-2009"), "order", x.toString, attr) }
        case ("@{http://www.spiritconsortium.org/XMLSchema/SPIRIT/1685-2009}configGroups", _) => __obj.spiritconfigGroups foreach { x => attr = scala.xml.Attribute(__scope.getPrefix("http://www.spiritconsortium.org/XMLSchema/SPIRIT/1685-2009"), "configGroups", x.toString, attr) }
        case ("@{http://www.spiritconsortium.org/XMLSchema/SPIRIT/1685-2009}bitStringLength", _) => __obj.spiritbitStringLength foreach { x => attr = scala.xml.Attribute(__scope.getPrefix("http://www.spiritconsortium.org/XMLSchema/SPIRIT/1685-2009"), "bitStringLength", x.toString, attr) }
        case ("@{http://www.spiritconsortium.org/XMLSchema/SPIRIT/1685-2009}minimum", _) => __obj.spiritminimum foreach { x => attr = scala.xml.Attribute(__scope.getPrefix("http://www.spiritconsortium.org/XMLSchema/SPIRIT/1685-2009"), "minimum", x.toString, attr) }
        case ("@{http://www.spiritconsortium.org/XMLSchema/SPIRIT/1685-2009}maximum", _) => __obj.spiritmaximum foreach { x => attr = scala.xml.Attribute(__scope.getPrefix("http://www.spiritconsortium.org/XMLSchema/SPIRIT/1685-2009"), "maximum", x.toString, attr) }
        case ("@{http://www.spiritconsortium.org/XMLSchema/SPIRIT/1685-2009}rangeType", _) => __obj.spiritrangeType foreach { x => attr = scala.xml.Attribute(__scope.getPrefix("http://www.spiritconsortium.org/XMLSchema/SPIRIT/1685-2009"), "rangeType", x.toString, attr) }
        case ("@{http://www.spiritconsortium.org/XMLSchema/SPIRIT/1685-2009}prompt", _) => __obj.spiritprompt foreach { x => attr = scala.xml.Attribute(__scope.getPrefix("http://www.spiritconsortium.org/XMLSchema/SPIRIT/1685-2009"), "prompt", x.toString, attr) }
        case (key, x) => attr = scala.xml.Attribute((x.namespace map { __scope.getPrefix(_) }).orNull, x.key.orNull, x.value.toString, attr)
      }
      attr
    }

    def writesChildNodes(__obj: Name3, __scope: scala.xml.NamespaceBinding): Seq[scala.xml.Node] =
      Seq(scala.xml.Text(__obj.value.toString))

  }

  trait Default_CommandLineSwitchFormat extends IPXACT2009scalaxb.XMLFormat[CommandLineSwitch] with IPXACT2009scalaxb.CanWriteChildNodes[CommandLineSwitch] {
    val targetNamespace: Option[String] = Some("http://www.spiritconsortium.org/XMLSchema/SPIRIT/1685-2009")
    def reads(seq: scala.xml.NodeSeq, stack: List[IPXACT2009scalaxb.ElemName]): Either[String, CommandLineSwitch] = seq match {
      case node: scala.xml.Node => Right(CommandLineSwitch(IPXACT2009scalaxb.fromXML[String](node, IPXACT2009scalaxb.ElemName(node) :: stack),
        scala.collection.immutable.ListMap(List(
        (node \ "@{http://www.spiritconsortium.org/XMLSchema/SPIRIT/1685-2009}format").headOption map { x => IPXACT2009scalaxb.DataRecord(x, node, IPXACT2009scalaxb.fromXML[FormatType](x, IPXACT2009scalaxb.ElemName(node) :: stack)) } orElse Some(IPXACT2009scalaxb.DataRecord(None, None, IPXACT2009scalaxb.fromXML[FormatType](scala.xml.Text("string"), IPXACT2009scalaxb.ElemName(node) :: stack))) map { "@{http://www.spiritconsortium.org/XMLSchema/SPIRIT/1685-2009}format" -> _ },
        (node \ "@{http://www.spiritconsortium.org/XMLSchema/SPIRIT/1685-2009}resolve").headOption map { x => IPXACT2009scalaxb.DataRecord(x, node, IPXACT2009scalaxb.fromXML[ResolveType](x, IPXACT2009scalaxb.ElemName(node) :: stack)) } map { "@{http://www.spiritconsortium.org/XMLSchema/SPIRIT/1685-2009}resolve" -> _ },
        (node \ "@{http://www.spiritconsortium.org/XMLSchema/SPIRIT/1685-2009}id").headOption map { x => IPXACT2009scalaxb.DataRecord(x, node, IPXACT2009scalaxb.fromXML[String](x, IPXACT2009scalaxb.ElemName(node) :: stack)) } map { "@{http://www.spiritconsortium.org/XMLSchema/SPIRIT/1685-2009}id" -> _ },
        (node \ "@{http://www.spiritconsortium.org/XMLSchema/SPIRIT/1685-2009}dependency").headOption map { x => IPXACT2009scalaxb.DataRecord(x, node, IPXACT2009scalaxb.fromXML[String](x, IPXACT2009scalaxb.ElemName(node) :: stack)) } map { "@{http://www.spiritconsortium.org/XMLSchema/SPIRIT/1685-2009}dependency" -> _ },
        (node \ "@{http://www.spiritconsortium.org/XMLSchema/SPIRIT/1685-2009}choiceRef").headOption map { x => IPXACT2009scalaxb.DataRecord(x, node, IPXACT2009scalaxb.fromXML[String](x, IPXACT2009scalaxb.ElemName(node) :: stack)) } map { "@{http://www.spiritconsortium.org/XMLSchema/SPIRIT/1685-2009}choiceRef" -> _ },
        (node \ "@{http://www.spiritconsortium.org/XMLSchema/SPIRIT/1685-2009}order").headOption map { x => IPXACT2009scalaxb.DataRecord(x, node, IPXACT2009scalaxb.fromXML[Float](x, IPXACT2009scalaxb.ElemName(node) :: stack)) } map { "@{http://www.spiritconsortium.org/XMLSchema/SPIRIT/1685-2009}order" -> _ },
        (node \ "@{http://www.spiritconsortium.org/XMLSchema/SPIRIT/1685-2009}configGroups").headOption map { x => IPXACT2009scalaxb.DataRecord(x, node, IPXACT2009scalaxb.fromXML[Seq[String]](x, IPXACT2009scalaxb.ElemName(node) :: stack)) } map { "@{http://www.spiritconsortium.org/XMLSchema/SPIRIT/1685-2009}configGroups" -> _ },
        (node \ "@{http://www.spiritconsortium.org/XMLSchema/SPIRIT/1685-2009}bitStringLength").headOption map { x => IPXACT2009scalaxb.DataRecord(x, node, IPXACT2009scalaxb.fromXML[BigInt](x, IPXACT2009scalaxb.ElemName(node) :: stack)) } map { "@{http://www.spiritconsortium.org/XMLSchema/SPIRIT/1685-2009}bitStringLength" -> _ },
        (node \ "@{http://www.spiritconsortium.org/XMLSchema/SPIRIT/1685-2009}minimum").headOption map { x => IPXACT2009scalaxb.DataRecord(x, node, IPXACT2009scalaxb.fromXML[String](x, IPXACT2009scalaxb.ElemName(node) :: stack)) } map { "@{http://www.spiritconsortium.org/XMLSchema/SPIRIT/1685-2009}minimum" -> _ },
        (node \ "@{http://www.spiritconsortium.org/XMLSchema/SPIRIT/1685-2009}maximum").headOption map { x => IPXACT2009scalaxb.DataRecord(x, node, IPXACT2009scalaxb.fromXML[String](x, IPXACT2009scalaxb.ElemName(node) :: stack)) } map { "@{http://www.spiritconsortium.org/XMLSchema/SPIRIT/1685-2009}maximum" -> _ },
        (node \ "@{http://www.spiritconsortium.org/XMLSchema/SPIRIT/1685-2009}rangeType").headOption map { x => IPXACT2009scalaxb.DataRecord(x, node, IPXACT2009scalaxb.fromXML[RangeTypeType](x, IPXACT2009scalaxb.ElemName(node) :: stack)) } map { "@{http://www.spiritconsortium.org/XMLSchema/SPIRIT/1685-2009}rangeType" -> _ },
        (node \ "@{http://www.spiritconsortium.org/XMLSchema/SPIRIT/1685-2009}prompt").headOption map { x => IPXACT2009scalaxb.DataRecord(x, node, IPXACT2009scalaxb.fromXML[String](x, IPXACT2009scalaxb.ElemName(node) :: stack)) } map { "@{http://www.spiritconsortium.org/XMLSchema/SPIRIT/1685-2009}prompt" -> _ }
        ).flatten[(String, IPXACT2009scalaxb.DataRecord[Any])] ::: (node match {
          case elem: scala.xml.Elem =>
            elem.attributes.toList flatMap {
              case scala.xml.PrefixedAttribute(pre, key, value, _) if pre == elem.scope.getPrefix("http://www.spiritconsortium.org/XMLSchema/SPIRIT/1685-2009") &&
                key == "format" => Nil
              case scala.xml.PrefixedAttribute(pre, key, value, _) if pre == elem.scope.getPrefix("http://www.spiritconsortium.org/XMLSchema/SPIRIT/1685-2009") &&
                key == "resolve" => Nil
              case scala.xml.PrefixedAttribute(pre, key, value, _) if pre == elem.scope.getPrefix("http://www.spiritconsortium.org/XMLSchema/SPIRIT/1685-2009") &&
                key == "id" => Nil
              case scala.xml.PrefixedAttribute(pre, key, value, _) if pre == elem.scope.getPrefix("http://www.spiritconsortium.org/XMLSchema/SPIRIT/1685-2009") &&
                key == "dependency" => Nil
              case scala.xml.PrefixedAttribute(pre, key, value, _) if pre == elem.scope.getPrefix("http://www.spiritconsortium.org/XMLSchema/SPIRIT/1685-2009") &&
                key == "choiceRef" => Nil
              case scala.xml.PrefixedAttribute(pre, key, value, _) if pre == elem.scope.getPrefix("http://www.spiritconsortium.org/XMLSchema/SPIRIT/1685-2009") &&
                key == "order" => Nil
              case scala.xml.PrefixedAttribute(pre, key, value, _) if pre == elem.scope.getPrefix("http://www.spiritconsortium.org/XMLSchema/SPIRIT/1685-2009") &&
                key == "configGroups" => Nil
              case scala.xml.PrefixedAttribute(pre, key, value, _) if pre == elem.scope.getPrefix("http://www.spiritconsortium.org/XMLSchema/SPIRIT/1685-2009") &&
                key == "bitStringLength" => Nil
              case scala.xml.PrefixedAttribute(pre, key, value, _) if pre == elem.scope.getPrefix("http://www.spiritconsortium.org/XMLSchema/SPIRIT/1685-2009") &&
                key == "minimum" => Nil
              case scala.xml.PrefixedAttribute(pre, key, value, _) if pre == elem.scope.getPrefix("http://www.spiritconsortium.org/XMLSchema/SPIRIT/1685-2009") &&
                key == "maximum" => Nil
              case scala.xml.PrefixedAttribute(pre, key, value, _) if pre == elem.scope.getPrefix("http://www.spiritconsortium.org/XMLSchema/SPIRIT/1685-2009") &&
                key == "rangeType" => Nil
              case scala.xml.PrefixedAttribute(pre, key, value, _) if pre == elem.scope.getPrefix("http://www.spiritconsortium.org/XMLSchema/SPIRIT/1685-2009") &&
                key == "prompt" => Nil
              case scala.xml.UnprefixedAttribute(key, value, _) =>
                List(("@" + key, IPXACT2009scalaxb.DataRecord(None, Some(key), value.text)))
              case scala.xml.PrefixedAttribute(pre, key, value, _) =>
                val ns = elem.scope.getURI(pre)
                List(("@{" + ns + "}" + key, IPXACT2009scalaxb.DataRecord(Option[String](ns), Some(key), value.text)))
              case _ => Nil
            }
          case _ => Nil
        }): _*)))
      case _ => Left("reads failed: seq must be scala.xml.Node")
    }
    
    override def writesAttribute(__obj: CommandLineSwitch, __scope: scala.xml.NamespaceBinding): scala.xml.MetaData = {
      var attr: scala.xml.MetaData  = scala.xml.Null
      __obj.attributes.toList map {
        case ("@{http://www.spiritconsortium.org/XMLSchema/SPIRIT/1685-2009}format", _) => if (__obj.spiritformat.toString != "string") attr = scala.xml.Attribute(__scope.getPrefix("http://www.spiritconsortium.org/XMLSchema/SPIRIT/1685-2009"), "format", __obj.spiritformat.toString, attr)
        case ("@{http://www.spiritconsortium.org/XMLSchema/SPIRIT/1685-2009}resolve", _) => __obj.spiritresolve foreach { x => attr = scala.xml.Attribute(__scope.getPrefix("http://www.spiritconsortium.org/XMLSchema/SPIRIT/1685-2009"), "resolve", x.toString, attr) }
        case ("@{http://www.spiritconsortium.org/XMLSchema/SPIRIT/1685-2009}id", _) => __obj.spiritid foreach { x => attr = scala.xml.Attribute(__scope.getPrefix("http://www.spiritconsortium.org/XMLSchema/SPIRIT/1685-2009"), "id", x.toString, attr) }
        case ("@{http://www.spiritconsortium.org/XMLSchema/SPIRIT/1685-2009}dependency", _) => __obj.spiritdependency foreach { x => attr = scala.xml.Attribute(__scope.getPrefix("http://www.spiritconsortium.org/XMLSchema/SPIRIT/1685-2009"), "dependency", x.toString, attr) }
        case ("@{http://www.spiritconsortium.org/XMLSchema/SPIRIT/1685-2009}choiceRef", _) => __obj.spiritchoiceRef foreach { x => attr = scala.xml.Attribute(__scope.getPrefix("http://www.spiritconsortium.org/XMLSchema/SPIRIT/1685-2009"), "choiceRef", x.toString, attr) }
        case ("@{http://www.spiritconsortium.org/XMLSchema/SPIRIT/1685-2009}order", _) => __obj.spiritorder foreach { x => attr = scala.xml.Attribute(__scope.getPrefix("http://www.spiritconsortium.org/XMLSchema/SPIRIT/1685-2009"), "order", x.toString, attr) }
        case ("@{http://www.spiritconsortium.org/XMLSchema/SPIRIT/1685-2009}configGroups", _) => __obj.spiritconfigGroups foreach { x => attr = scala.xml.Attribute(__scope.getPrefix("http://www.spiritconsortium.org/XMLSchema/SPIRIT/1685-2009"), "configGroups", x.toString, attr) }
        case ("@{http://www.spiritconsortium.org/XMLSchema/SPIRIT/1685-2009}bitStringLength", _) => __obj.spiritbitStringLength foreach { x => attr = scala.xml.Attribute(__scope.getPrefix("http://www.spiritconsortium.org/XMLSchema/SPIRIT/1685-2009"), "bitStringLength", x.toString, attr) }
        case ("@{http://www.spiritconsortium.org/XMLSchema/SPIRIT/1685-2009}minimum", _) => __obj.spiritminimum foreach { x => attr = scala.xml.Attribute(__scope.getPrefix("http://www.spiritconsortium.org/XMLSchema/SPIRIT/1685-2009"), "minimum", x.toString, attr) }
        case ("@{http://www.spiritconsortium.org/XMLSchema/SPIRIT/1685-2009}maximum", _) => __obj.spiritmaximum foreach { x => attr = scala.xml.Attribute(__scope.getPrefix("http://www.spiritconsortium.org/XMLSchema/SPIRIT/1685-2009"), "maximum", x.toString, attr) }
        case ("@{http://www.spiritconsortium.org/XMLSchema/SPIRIT/1685-2009}rangeType", _) => __obj.spiritrangeType foreach { x => attr = scala.xml.Attribute(__scope.getPrefix("http://www.spiritconsortium.org/XMLSchema/SPIRIT/1685-2009"), "rangeType", x.toString, attr) }
        case ("@{http://www.spiritconsortium.org/XMLSchema/SPIRIT/1685-2009}prompt", _) => __obj.spiritprompt foreach { x => attr = scala.xml.Attribute(__scope.getPrefix("http://www.spiritconsortium.org/XMLSchema/SPIRIT/1685-2009"), "prompt", x.toString, attr) }
        case (key, x) => attr = scala.xml.Attribute((x.namespace map { __scope.getPrefix(_) }).orNull, x.key.orNull, x.value.toString, attr)
      }
      attr
    }

    def writesChildNodes(__obj: CommandLineSwitch, __scope: scala.xml.NamespaceBinding): Seq[scala.xml.Node] =
      Seq(scala.xml.Text(__obj.value.toString))

  }

  trait Default_EnableFormat extends IPXACT2009scalaxb.XMLFormat[Enable] with IPXACT2009scalaxb.CanWriteChildNodes[Enable] {
    val targetNamespace: Option[String] = Some("http://www.spiritconsortium.org/XMLSchema/SPIRIT/1685-2009")
    def reads(seq: scala.xml.NodeSeq, stack: List[IPXACT2009scalaxb.ElemName]): Either[String, Enable] = seq match {
      case node: scala.xml.Node => Right(Enable(IPXACT2009scalaxb.fromXML[Boolean](node, IPXACT2009scalaxb.ElemName(node) :: stack),
        scala.collection.immutable.ListMap(List(
        (node \ "@{http://www.spiritconsortium.org/XMLSchema/SPIRIT/1685-2009}format").headOption map { x => IPXACT2009scalaxb.DataRecord(x, node, IPXACT2009scalaxb.fromXML[FormatType](x, IPXACT2009scalaxb.ElemName(node) :: stack)) } orElse Some(IPXACT2009scalaxb.DataRecord(None, None, IPXACT2009scalaxb.fromXML[FormatType](scala.xml.Text("bool"), IPXACT2009scalaxb.ElemName(node) :: stack))) map { "@{http://www.spiritconsortium.org/XMLSchema/SPIRIT/1685-2009}format" -> _ },
        (node \ "@{http://www.spiritconsortium.org/XMLSchema/SPIRIT/1685-2009}resolve").headOption map { x => IPXACT2009scalaxb.DataRecord(x, node, IPXACT2009scalaxb.fromXML[ResolveType](x, IPXACT2009scalaxb.ElemName(node) :: stack)) } map { "@{http://www.spiritconsortium.org/XMLSchema/SPIRIT/1685-2009}resolve" -> _ },
        (node \ "@{http://www.spiritconsortium.org/XMLSchema/SPIRIT/1685-2009}id").headOption map { x => IPXACT2009scalaxb.DataRecord(x, node, IPXACT2009scalaxb.fromXML[String](x, IPXACT2009scalaxb.ElemName(node) :: stack)) } map { "@{http://www.spiritconsortium.org/XMLSchema/SPIRIT/1685-2009}id" -> _ },
        (node \ "@{http://www.spiritconsortium.org/XMLSchema/SPIRIT/1685-2009}dependency").headOption map { x => IPXACT2009scalaxb.DataRecord(x, node, IPXACT2009scalaxb.fromXML[String](x, IPXACT2009scalaxb.ElemName(node) :: stack)) } map { "@{http://www.spiritconsortium.org/XMLSchema/SPIRIT/1685-2009}dependency" -> _ },
        (node \ "@{http://www.spiritconsortium.org/XMLSchema/SPIRIT/1685-2009}choiceRef").headOption map { x => IPXACT2009scalaxb.DataRecord(x, node, IPXACT2009scalaxb.fromXML[String](x, IPXACT2009scalaxb.ElemName(node) :: stack)) } map { "@{http://www.spiritconsortium.org/XMLSchema/SPIRIT/1685-2009}choiceRef" -> _ },
        (node \ "@{http://www.spiritconsortium.org/XMLSchema/SPIRIT/1685-2009}order").headOption map { x => IPXACT2009scalaxb.DataRecord(x, node, IPXACT2009scalaxb.fromXML[Float](x, IPXACT2009scalaxb.ElemName(node) :: stack)) } map { "@{http://www.spiritconsortium.org/XMLSchema/SPIRIT/1685-2009}order" -> _ },
        (node \ "@{http://www.spiritconsortium.org/XMLSchema/SPIRIT/1685-2009}configGroups").headOption map { x => IPXACT2009scalaxb.DataRecord(x, node, IPXACT2009scalaxb.fromXML[Seq[String]](x, IPXACT2009scalaxb.ElemName(node) :: stack)) } map { "@{http://www.spiritconsortium.org/XMLSchema/SPIRIT/1685-2009}configGroups" -> _ },
        (node \ "@{http://www.spiritconsortium.org/XMLSchema/SPIRIT/1685-2009}bitStringLength").headOption map { x => IPXACT2009scalaxb.DataRecord(x, node, IPXACT2009scalaxb.fromXML[BigInt](x, IPXACT2009scalaxb.ElemName(node) :: stack)) } map { "@{http://www.spiritconsortium.org/XMLSchema/SPIRIT/1685-2009}bitStringLength" -> _ },
        (node \ "@{http://www.spiritconsortium.org/XMLSchema/SPIRIT/1685-2009}minimum").headOption map { x => IPXACT2009scalaxb.DataRecord(x, node, IPXACT2009scalaxb.fromXML[String](x, IPXACT2009scalaxb.ElemName(node) :: stack)) } map { "@{http://www.spiritconsortium.org/XMLSchema/SPIRIT/1685-2009}minimum" -> _ },
        (node \ "@{http://www.spiritconsortium.org/XMLSchema/SPIRIT/1685-2009}maximum").headOption map { x => IPXACT2009scalaxb.DataRecord(x, node, IPXACT2009scalaxb.fromXML[String](x, IPXACT2009scalaxb.ElemName(node) :: stack)) } map { "@{http://www.spiritconsortium.org/XMLSchema/SPIRIT/1685-2009}maximum" -> _ },
        (node \ "@{http://www.spiritconsortium.org/XMLSchema/SPIRIT/1685-2009}rangeType").headOption map { x => IPXACT2009scalaxb.DataRecord(x, node, IPXACT2009scalaxb.fromXML[RangeTypeType](x, IPXACT2009scalaxb.ElemName(node) :: stack)) } orElse Some(IPXACT2009scalaxb.DataRecord(None, None, IPXACT2009scalaxb.fromXML[RangeTypeType](scala.xml.Text("int"), IPXACT2009scalaxb.ElemName(node) :: stack))) map { "@{http://www.spiritconsortium.org/XMLSchema/SPIRIT/1685-2009}rangeType" -> _ },
        (node \ "@{http://www.spiritconsortium.org/XMLSchema/SPIRIT/1685-2009}prompt").headOption map { x => IPXACT2009scalaxb.DataRecord(x, node, IPXACT2009scalaxb.fromXML[String](x, IPXACT2009scalaxb.ElemName(node) :: stack)) } map { "@{http://www.spiritconsortium.org/XMLSchema/SPIRIT/1685-2009}prompt" -> _ }
        ).flatten[(String, IPXACT2009scalaxb.DataRecord[Any])] ::: (node match {
          case elem: scala.xml.Elem =>
            elem.attributes.toList flatMap {
              case scala.xml.PrefixedAttribute(pre, key, value, _) if pre == elem.scope.getPrefix("http://www.spiritconsortium.org/XMLSchema/SPIRIT/1685-2009") &&
                key == "format" => Nil
              case scala.xml.PrefixedAttribute(pre, key, value, _) if pre == elem.scope.getPrefix("http://www.spiritconsortium.org/XMLSchema/SPIRIT/1685-2009") &&
                key == "resolve" => Nil
              case scala.xml.PrefixedAttribute(pre, key, value, _) if pre == elem.scope.getPrefix("http://www.spiritconsortium.org/XMLSchema/SPIRIT/1685-2009") &&
                key == "id" => Nil
              case scala.xml.PrefixedAttribute(pre, key, value, _) if pre == elem.scope.getPrefix("http://www.spiritconsortium.org/XMLSchema/SPIRIT/1685-2009") &&
                key == "dependency" => Nil
              case scala.xml.PrefixedAttribute(pre, key, value, _) if pre == elem.scope.getPrefix("http://www.spiritconsortium.org/XMLSchema/SPIRIT/1685-2009") &&
                key == "choiceRef" => Nil
              case scala.xml.PrefixedAttribute(pre, key, value, _) if pre == elem.scope.getPrefix("http://www.spiritconsortium.org/XMLSchema/SPIRIT/1685-2009") &&
                key == "order" => Nil
              case scala.xml.PrefixedAttribute(pre, key, value, _) if pre == elem.scope.getPrefix("http://www.spiritconsortium.org/XMLSchema/SPIRIT/1685-2009") &&
                key == "configGroups" => Nil
              case scala.xml.PrefixedAttribute(pre, key, value, _) if pre == elem.scope.getPrefix("http://www.spiritconsortium.org/XMLSchema/SPIRIT/1685-2009") &&
                key == "bitStringLength" => Nil
              case scala.xml.PrefixedAttribute(pre, key, value, _) if pre == elem.scope.getPrefix("http://www.spiritconsortium.org/XMLSchema/SPIRIT/1685-2009") &&
                key == "minimum" => Nil
              case scala.xml.PrefixedAttribute(pre, key, value, _) if pre == elem.scope.getPrefix("http://www.spiritconsortium.org/XMLSchema/SPIRIT/1685-2009") &&
                key == "maximum" => Nil
              case scala.xml.PrefixedAttribute(pre, key, value, _) if pre == elem.scope.getPrefix("http://www.spiritconsortium.org/XMLSchema/SPIRIT/1685-2009") &&
                key == "rangeType" => Nil
              case scala.xml.PrefixedAttribute(pre, key, value, _) if pre == elem.scope.getPrefix("http://www.spiritconsortium.org/XMLSchema/SPIRIT/1685-2009") &&
                key == "prompt" => Nil
              case scala.xml.UnprefixedAttribute(key, value, _) =>
                List(("@" + key, IPXACT2009scalaxb.DataRecord(None, Some(key), value.text)))
              case scala.xml.PrefixedAttribute(pre, key, value, _) =>
                val ns = elem.scope.getURI(pre)
                List(("@{" + ns + "}" + key, IPXACT2009scalaxb.DataRecord(Option[String](ns), Some(key), value.text)))
              case _ => Nil
            }
          case _ => Nil
        }): _*)))
      case _ => Left("reads failed: seq must be scala.xml.Node")
    }
    
    override def writesAttribute(__obj: Enable, __scope: scala.xml.NamespaceBinding): scala.xml.MetaData = {
      var attr: scala.xml.MetaData  = scala.xml.Null
      __obj.attributes.toList map {
        case ("@{http://www.spiritconsortium.org/XMLSchema/SPIRIT/1685-2009}format", _) => if (__obj.spiritformat.toString != "bool") attr = scala.xml.Attribute(__scope.getPrefix("http://www.spiritconsortium.org/XMLSchema/SPIRIT/1685-2009"), "format", __obj.spiritformat.toString, attr)
        case ("@{http://www.spiritconsortium.org/XMLSchema/SPIRIT/1685-2009}resolve", _) => __obj.spiritresolve foreach { x => attr = scala.xml.Attribute(__scope.getPrefix("http://www.spiritconsortium.org/XMLSchema/SPIRIT/1685-2009"), "resolve", x.toString, attr) }
        case ("@{http://www.spiritconsortium.org/XMLSchema/SPIRIT/1685-2009}id", _) => __obj.spiritid foreach { x => attr = scala.xml.Attribute(__scope.getPrefix("http://www.spiritconsortium.org/XMLSchema/SPIRIT/1685-2009"), "id", x.toString, attr) }
        case ("@{http://www.spiritconsortium.org/XMLSchema/SPIRIT/1685-2009}dependency", _) => __obj.spiritdependency foreach { x => attr = scala.xml.Attribute(__scope.getPrefix("http://www.spiritconsortium.org/XMLSchema/SPIRIT/1685-2009"), "dependency", x.toString, attr) }
        case ("@{http://www.spiritconsortium.org/XMLSchema/SPIRIT/1685-2009}choiceRef", _) => __obj.spiritchoiceRef foreach { x => attr = scala.xml.Attribute(__scope.getPrefix("http://www.spiritconsortium.org/XMLSchema/SPIRIT/1685-2009"), "choiceRef", x.toString, attr) }
        case ("@{http://www.spiritconsortium.org/XMLSchema/SPIRIT/1685-2009}order", _) => __obj.spiritorder foreach { x => attr = scala.xml.Attribute(__scope.getPrefix("http://www.spiritconsortium.org/XMLSchema/SPIRIT/1685-2009"), "order", x.toString, attr) }
        case ("@{http://www.spiritconsortium.org/XMLSchema/SPIRIT/1685-2009}configGroups", _) => __obj.spiritconfigGroups foreach { x => attr = scala.xml.Attribute(__scope.getPrefix("http://www.spiritconsortium.org/XMLSchema/SPIRIT/1685-2009"), "configGroups", x.toString, attr) }
        case ("@{http://www.spiritconsortium.org/XMLSchema/SPIRIT/1685-2009}bitStringLength", _) => __obj.spiritbitStringLength foreach { x => attr = scala.xml.Attribute(__scope.getPrefix("http://www.spiritconsortium.org/XMLSchema/SPIRIT/1685-2009"), "bitStringLength", x.toString, attr) }
        case ("@{http://www.spiritconsortium.org/XMLSchema/SPIRIT/1685-2009}minimum", _) => __obj.spiritminimum foreach { x => attr = scala.xml.Attribute(__scope.getPrefix("http://www.spiritconsortium.org/XMLSchema/SPIRIT/1685-2009"), "minimum", x.toString, attr) }
        case ("@{http://www.spiritconsortium.org/XMLSchema/SPIRIT/1685-2009}maximum", _) => __obj.spiritmaximum foreach { x => attr = scala.xml.Attribute(__scope.getPrefix("http://www.spiritconsortium.org/XMLSchema/SPIRIT/1685-2009"), "maximum", x.toString, attr) }
        case ("@{http://www.spiritconsortium.org/XMLSchema/SPIRIT/1685-2009}rangeType", _) => if (__obj.spiritrangeType.toString != "int") attr = scala.xml.Attribute(__scope.getPrefix("http://www.spiritconsortium.org/XMLSchema/SPIRIT/1685-2009"), "rangeType", __obj.spiritrangeType.toString, attr)
        case ("@{http://www.spiritconsortium.org/XMLSchema/SPIRIT/1685-2009}prompt", _) => __obj.spiritprompt foreach { x => attr = scala.xml.Attribute(__scope.getPrefix("http://www.spiritconsortium.org/XMLSchema/SPIRIT/1685-2009"), "prompt", x.toString, attr) }
        case (key, x) => attr = scala.xml.Attribute((x.namespace map { __scope.getPrefix(_) }).orNull, x.key.orNull, x.value.toString, attr)
      }
      attr
    }

    def writesChildNodes(__obj: Enable, __scope: scala.xml.NamespaceBinding): Seq[scala.xml.Node] =
      Seq(scala.xml.Text(__obj.value.toString))

  }

  trait Default_LinkerCommandFileFormat extends IPXACT2009scalaxb.ElemNameParser[LinkerCommandFile] {
    val targetNamespace: Option[String] = Some("http://www.spiritconsortium.org/XMLSchema/SPIRIT/1685-2009")
    
    def parser(node: scala.xml.Node, stack: List[IPXACT2009scalaxb.ElemName]): Parser[LinkerCommandFile] =
      phrase((IPXACT2009scalaxb.ElemName(Some("http://www.spiritconsortium.org/XMLSchema/SPIRIT/1685-2009"), "name")) ~
      (IPXACT2009scalaxb.ElemName(Some("http://www.spiritconsortium.org/XMLSchema/SPIRIT/1685-2009"), "commandLineSwitch")) ~
      (IPXACT2009scalaxb.ElemName(Some("http://www.spiritconsortium.org/XMLSchema/SPIRIT/1685-2009"), "enable")) ~
      safeRep(IPXACT2009scalaxb.ElemName(Some("http://www.spiritconsortium.org/XMLSchema/SPIRIT/1685-2009"), "generatorRef")) ~
      opt(IPXACT2009scalaxb.ElemName(Some("http://www.spiritconsortium.org/XMLSchema/SPIRIT/1685-2009"), "vendorExtensions")) ^^
      { case p1 ~ p2 ~ p3 ~ p4 ~ p5 =>
      LinkerCommandFile(IPXACT2009scalaxb.fromXML[Name3](p1, IPXACT2009scalaxb.ElemName(node) :: stack),
        IPXACT2009scalaxb.fromXML[CommandLineSwitch](p2, IPXACT2009scalaxb.ElemName(node) :: stack),
        IPXACT2009scalaxb.fromXML[Enable](p3, IPXACT2009scalaxb.ElemName(node) :: stack),
        p4 map { IPXACT2009scalaxb.fromXML[String](_, IPXACT2009scalaxb.ElemName(node) :: stack) },
        p5.headOption map { IPXACT2009scalaxb.fromXML[VendorExtensions](_, IPXACT2009scalaxb.ElemName(node) :: stack) }) })
    
    def writesChildNodes(__obj: LinkerCommandFile, __scope: scala.xml.NamespaceBinding): Seq[scala.xml.Node] =
      Seq.concat(IPXACT2009scalaxb.toXML[Name3](__obj.name, Some("http://www.spiritconsortium.org/XMLSchema/SPIRIT/1685-2009"), Some("name"), __scope, false),
        IPXACT2009scalaxb.toXML[CommandLineSwitch](__obj.commandLineSwitch, Some("http://www.spiritconsortium.org/XMLSchema/SPIRIT/1685-2009"), Some("commandLineSwitch"), __scope, false),
        IPXACT2009scalaxb.toXML[Enable](__obj.enable, Some("http://www.spiritconsortium.org/XMLSchema/SPIRIT/1685-2009"), Some("enable"), __scope, false),
        __obj.generatorRef flatMap { IPXACT2009scalaxb.toXML[String](_, Some("http://www.spiritconsortium.org/XMLSchema/SPIRIT/1685-2009"), Some("generatorRef"), __scope, false) },
        __obj.vendorExtensions map { IPXACT2009scalaxb.toXML[VendorExtensions](_, Some("http://www.spiritconsortium.org/XMLSchema/SPIRIT/1685-2009"), Some("vendorExtensions"), __scope, false) } getOrElse {Nil})

  }

  trait Default_LanguageToolsFormat extends IPXACT2009scalaxb.ElemNameParser[LanguageTools] {
    val targetNamespace: Option[String] = Some("http://www.spiritconsortium.org/XMLSchema/SPIRIT/1685-2009")
    
    def parser(node: scala.xml.Node, stack: List[IPXACT2009scalaxb.ElemName]): Parser[LanguageTools] =
      phrase(safeRep(IPXACT2009scalaxb.ElemName(Some("http://www.spiritconsortium.org/XMLSchema/SPIRIT/1685-2009"), "fileBuilder")) ~
      opt(IPXACT2009scalaxb.ElemName(Some("http://www.spiritconsortium.org/XMLSchema/SPIRIT/1685-2009"), "linker")) ~
      opt(IPXACT2009scalaxb.ElemName(Some("http://www.spiritconsortium.org/XMLSchema/SPIRIT/1685-2009"), "linkerFlags")) ~
      opt(IPXACT2009scalaxb.ElemName(Some("http://www.spiritconsortium.org/XMLSchema/SPIRIT/1685-2009"), "linkerCommandFile")) ^^
      { case p1 ~ p2 ~ p3 ~ p4 =>
      LanguageTools(p1 map { IPXACT2009scalaxb.fromXML[FileBuilder](_, IPXACT2009scalaxb.ElemName(node) :: stack) },
        p2.headOption map { IPXACT2009scalaxb.fromXML[Linker](_, IPXACT2009scalaxb.ElemName(node) :: stack) },
        p3.headOption map { IPXACT2009scalaxb.fromXML[LinkerFlags](_, IPXACT2009scalaxb.ElemName(node) :: stack) },
        p4.headOption map { IPXACT2009scalaxb.fromXML[LinkerCommandFile](_, IPXACT2009scalaxb.ElemName(node) :: stack) }) })
    
    def writesChildNodes(__obj: LanguageTools, __scope: scala.xml.NamespaceBinding): Seq[scala.xml.Node] =
      Seq.concat(__obj.fileBuilder flatMap { IPXACT2009scalaxb.toXML[FileBuilder](_, Some("http://www.spiritconsortium.org/XMLSchema/SPIRIT/1685-2009"), Some("fileBuilder"), __scope, false) },
        __obj.linker map { IPXACT2009scalaxb.toXML[Linker](_, Some("http://www.spiritconsortium.org/XMLSchema/SPIRIT/1685-2009"), Some("linker"), __scope, false) } getOrElse {Nil},
        __obj.linkerFlags map { IPXACT2009scalaxb.toXML[LinkerFlags](_, Some("http://www.spiritconsortium.org/XMLSchema/SPIRIT/1685-2009"), Some("linkerFlags"), __scope, false) } getOrElse {Nil},
        __obj.linkerCommandFile map { IPXACT2009scalaxb.toXML[LinkerCommandFile](_, Some("http://www.spiritconsortium.org/XMLSchema/SPIRIT/1685-2009"), Some("linkerCommandFile"), __scope, false) } getOrElse {Nil})

  }

  trait Default_FileSetRefGroupFormat extends IPXACT2009scalaxb.ElemNameParser[FileSetRefGroup] {
    val targetNamespace: Option[String] = Some("http://www.spiritconsortium.org/XMLSchema/SPIRIT/1685-2009")
    
    def parser(node: scala.xml.Node, stack: List[IPXACT2009scalaxb.ElemName]): Parser[FileSetRefGroup] =
      phrase(safeRep(IPXACT2009scalaxb.ElemName(Some("http://www.spiritconsortium.org/XMLSchema/SPIRIT/1685-2009"), "fileSetRef")) ^^
      { case p1 =>
      FileSetRefGroup(p1 map { IPXACT2009scalaxb.fromXML[FileSetRef](_, IPXACT2009scalaxb.ElemName(node) :: stack) }) })
    
    def writesChildNodes(__obj: FileSetRefGroup, __scope: scala.xml.NamespaceBinding): Seq[scala.xml.Node] =
      (__obj.fileSetRef flatMap { IPXACT2009scalaxb.toXML[FileSetRef](_, Some("http://www.spiritconsortium.org/XMLSchema/SPIRIT/1685-2009"), Some("fileSetRef"), __scope, false) })
  }
  trait Default_ExecutableImageFormat extends IPXACT2009scalaxb.ElemNameParser[ExecutableImage] {
    val targetNamespace: Option[String] = Some("http://www.spiritconsortium.org/XMLSchema/SPIRIT/1685-2009")
    
    def parser(node: scala.xml.Node, stack: List[IPXACT2009scalaxb.ElemName]): Parser[ExecutableImage] =
      phrase((IPXACT2009scalaxb.ElemName(Some("http://www.spiritconsortium.org/XMLSchema/SPIRIT/1685-2009"), "name")) ~
      opt(IPXACT2009scalaxb.ElemName(Some("http://www.spiritconsortium.org/XMLSchema/SPIRIT/1685-2009"), "description")) ~
      opt(IPXACT2009scalaxb.ElemName(Some("http://www.spiritconsortium.org/XMLSchema/SPIRIT/1685-2009"), "parameters")) ~
      opt(IPXACT2009scalaxb.ElemName(Some("http://www.spiritconsortium.org/XMLSchema/SPIRIT/1685-2009"), "languageTools")) ~
      opt(IPXACT2009scalaxb.ElemName(Some("http://www.spiritconsortium.org/XMLSchema/SPIRIT/1685-2009"), "fileSetRefGroup")) ~
      opt(IPXACT2009scalaxb.ElemName(Some("http://www.spiritconsortium.org/XMLSchema/SPIRIT/1685-2009"), "vendorExtensions")) ^^
      { case p1 ~ p2 ~ p3 ~ p4 ~ p5 ~ p6 =>
      ExecutableImage(IPXACT2009scalaxb.fromXML[Name2](p1, IPXACT2009scalaxb.ElemName(node) :: stack),
        p2.headOption map { IPXACT2009scalaxb.fromXML[String](_, IPXACT2009scalaxb.ElemName(node) :: stack) },
        p3.headOption map { IPXACT2009scalaxb.fromXML[Parameters](_, IPXACT2009scalaxb.ElemName(node) :: stack) },
        p4.headOption map { IPXACT2009scalaxb.fromXML[LanguageTools](_, IPXACT2009scalaxb.ElemName(node) :: stack) },
        p5.headOption map { IPXACT2009scalaxb.fromXML[FileSetRefGroup](_, IPXACT2009scalaxb.ElemName(node) :: stack) },
        p6.headOption map { IPXACT2009scalaxb.fromXML[VendorExtensions](_, IPXACT2009scalaxb.ElemName(node) :: stack) },
        scala.collection.immutable.ListMap(List(
        (node \ "@{http://www.spiritconsortium.org/XMLSchema/SPIRIT/1685-2009}id").headOption map { x => IPXACT2009scalaxb.DataRecord(x, node, IPXACT2009scalaxb.fromXML[String](x, IPXACT2009scalaxb.ElemName(node) :: stack)) } map { "@id" -> _ },
        (node \ "@{http://www.spiritconsortium.org/XMLSchema/SPIRIT/1685-2009}imageType").headOption map { x => IPXACT2009scalaxb.DataRecord(x, node, IPXACT2009scalaxb.fromXML[String](x, IPXACT2009scalaxb.ElemName(node) :: stack)) } map { "@imageType" -> _ }
        ).flatten[(String, IPXACT2009scalaxb.DataRecord[Any])]: _*)) })
    
    override def writesAttribute(__obj: ExecutableImage, __scope: scala.xml.NamespaceBinding): scala.xml.MetaData = {
      var attr: scala.xml.MetaData  = scala.xml.Null
      __obj.attributes.toList map {
        case ("@id", _) => attr = scala.xml.Attribute(__scope.getPrefix("http://www.spiritconsortium.org/XMLSchema/SPIRIT/1685-2009"), "id", __obj.id.toString, attr)
        case ("@imageType", _) => __obj.imageType foreach { x => attr = scala.xml.Attribute(__scope.getPrefix("http://www.spiritconsortium.org/XMLSchema/SPIRIT/1685-2009"), "imageType", x.toString, attr) }
        case (key, x) => attr = scala.xml.Attribute((x.namespace map { __scope.getPrefix(_) }).orNull, x.key.orNull, x.value.toString, attr)
      }
      attr
    }

    def writesChildNodes(__obj: ExecutableImage, __scope: scala.xml.NamespaceBinding): Seq[scala.xml.Node] =
      Seq.concat(IPXACT2009scalaxb.toXML[Name2](__obj.name, Some("http://www.spiritconsortium.org/XMLSchema/SPIRIT/1685-2009"), Some("name"), __scope, false),
        __obj.description map { IPXACT2009scalaxb.toXML[String](_, Some("http://www.spiritconsortium.org/XMLSchema/SPIRIT/1685-2009"), Some("description"), __scope, false) } getOrElse {Nil},
        __obj.parameters map { IPXACT2009scalaxb.toXML[Parameters](_, Some("http://www.spiritconsortium.org/XMLSchema/SPIRIT/1685-2009"), Some("parameters"), __scope, false) } getOrElse {Nil},
        __obj.languageTools map { IPXACT2009scalaxb.toXML[LanguageTools](_, Some("http://www.spiritconsortium.org/XMLSchema/SPIRIT/1685-2009"), Some("languageTools"), __scope, false) } getOrElse {Nil},
        __obj.fileSetRefGroup map { IPXACT2009scalaxb.toXML[FileSetRefGroup](_, Some("http://www.spiritconsortium.org/XMLSchema/SPIRIT/1685-2009"), Some("fileSetRefGroup"), __scope, false) } getOrElse {Nil},
        __obj.vendorExtensions map { IPXACT2009scalaxb.toXML[VendorExtensions](_, Some("http://www.spiritconsortium.org/XMLSchema/SPIRIT/1685-2009"), Some("vendorExtensions"), __scope, false) } getOrElse {Nil})

  }

  trait Default_FileSetRefFormat extends IPXACT2009scalaxb.ElemNameParser[FileSetRef] {
    val targetNamespace: Option[String] = Some("http://www.spiritconsortium.org/XMLSchema/SPIRIT/1685-2009")
    
    def parser(node: scala.xml.Node, stack: List[IPXACT2009scalaxb.ElemName]): Parser[FileSetRef] =
      phrase((((IPXACT2009scalaxb.ElemName(Some("http://www.spiritconsortium.org/XMLSchema/SPIRIT/1685-2009"), "localName")) ^^
      (x => IPXACT2009scalaxb.DataRecord(x.namespace, Some(x.name), IPXACT2009scalaxb.fromXML[String](x, IPXACT2009scalaxb.ElemName(node) :: stack))))) ^^
      { case p1 =>
      FileSetRef(p1) })
    
    def writesChildNodes(__obj: FileSetRef, __scope: scala.xml.NamespaceBinding): Seq[scala.xml.Node] =
      ((Some(__obj.filesetrefoption) map {x => IPXACT2009scalaxb.toXML[IPXACT2009scalaxb.DataRecord[String]](x, x.namespace, x.key, __scope, false)}).get)
  }

  trait Default_FileSetsFormat extends IPXACT2009scalaxb.ElemNameParser[FileSets] {
    val targetNamespace: Option[String] = Some("http://www.spiritconsortium.org/XMLSchema/SPIRIT/1685-2009")
    
    def parser(node: scala.xml.Node, stack: List[IPXACT2009scalaxb.ElemName]): Parser[FileSets] =
      phrase(safeRep(IPXACT2009scalaxb.ElemName(Some("http://www.spiritconsortium.org/XMLSchema/SPIRIT/1685-2009"), "fileSet")) ^^
      { case p1 =>
      FileSets(p1 map { IPXACT2009scalaxb.fromXML[FileSetType](_, IPXACT2009scalaxb.ElemName(node) :: stack) }) })
    
    def writesChildNodes(__obj: FileSets, __scope: scala.xml.NamespaceBinding): Seq[scala.xml.Node] =
      (__obj.fileSet flatMap { IPXACT2009scalaxb.toXML[FileSetType](_, Some("http://www.spiritconsortium.org/XMLSchema/SPIRIT/1685-2009"), Some("fileSet"), __scope, false) })
  }
  trait Default_Command3Format extends IPXACT2009scalaxb.XMLFormat[Command3] with IPXACT2009scalaxb.CanWriteChildNodes[Command3] {
    val targetNamespace: Option[String] = Some("http://www.spiritconsortium.org/XMLSchema/SPIRIT/1685-2009")
    def reads(seq: scala.xml.NodeSeq, stack: List[IPXACT2009scalaxb.ElemName]): Either[String, Command3] = seq match {
      case node: scala.xml.Node => Right(Command3(IPXACT2009scalaxb.fromXML[String](node, IPXACT2009scalaxb.ElemName(node) :: stack),
        scala.collection.immutable.ListMap(List(
        (node \ "@{http://www.spiritconsortium.org/XMLSchema/SPIRIT/1685-2009}format").headOption map { x => IPXACT2009scalaxb.DataRecord(x, node, IPXACT2009scalaxb.fromXML[FormatType](x, IPXACT2009scalaxb.ElemName(node) :: stack)) } orElse Some(IPXACT2009scalaxb.DataRecord(None, None, IPXACT2009scalaxb.fromXML[FormatType](scala.xml.Text("string"), IPXACT2009scalaxb.ElemName(node) :: stack))) map { "@{http://www.spiritconsortium.org/XMLSchema/SPIRIT/1685-2009}format" -> _ },
        (node \ "@{http://www.spiritconsortium.org/XMLSchema/SPIRIT/1685-2009}resolve").headOption map { x => IPXACT2009scalaxb.DataRecord(x, node, IPXACT2009scalaxb.fromXML[ResolveType](x, IPXACT2009scalaxb.ElemName(node) :: stack)) } map { "@{http://www.spiritconsortium.org/XMLSchema/SPIRIT/1685-2009}resolve" -> _ },
        (node \ "@{http://www.spiritconsortium.org/XMLSchema/SPIRIT/1685-2009}id").headOption map { x => IPXACT2009scalaxb.DataRecord(x, node, IPXACT2009scalaxb.fromXML[String](x, IPXACT2009scalaxb.ElemName(node) :: stack)) } map { "@{http://www.spiritconsortium.org/XMLSchema/SPIRIT/1685-2009}id" -> _ },
        (node \ "@{http://www.spiritconsortium.org/XMLSchema/SPIRIT/1685-2009}dependency").headOption map { x => IPXACT2009scalaxb.DataRecord(x, node, IPXACT2009scalaxb.fromXML[String](x, IPXACT2009scalaxb.ElemName(node) :: stack)) } map { "@{http://www.spiritconsortium.org/XMLSchema/SPIRIT/1685-2009}dependency" -> _ },
        (node \ "@{http://www.spiritconsortium.org/XMLSchema/SPIRIT/1685-2009}choiceRef").headOption map { x => IPXACT2009scalaxb.DataRecord(x, node, IPXACT2009scalaxb.fromXML[String](x, IPXACT2009scalaxb.ElemName(node) :: stack)) } map { "@{http://www.spiritconsortium.org/XMLSchema/SPIRIT/1685-2009}choiceRef" -> _ },
        (node \ "@{http://www.spiritconsortium.org/XMLSchema/SPIRIT/1685-2009}order").headOption map { x => IPXACT2009scalaxb.DataRecord(x, node, IPXACT2009scalaxb.fromXML[Float](x, IPXACT2009scalaxb.ElemName(node) :: stack)) } map { "@{http://www.spiritconsortium.org/XMLSchema/SPIRIT/1685-2009}order" -> _ },
        (node \ "@{http://www.spiritconsortium.org/XMLSchema/SPIRIT/1685-2009}configGroups").headOption map { x => IPXACT2009scalaxb.DataRecord(x, node, IPXACT2009scalaxb.fromXML[Seq[String]](x, IPXACT2009scalaxb.ElemName(node) :: stack)) } map { "@{http://www.spiritconsortium.org/XMLSchema/SPIRIT/1685-2009}configGroups" -> _ },
        (node \ "@{http://www.spiritconsortium.org/XMLSchema/SPIRIT/1685-2009}bitStringLength").headOption map { x => IPXACT2009scalaxb.DataRecord(x, node, IPXACT2009scalaxb.fromXML[BigInt](x, IPXACT2009scalaxb.ElemName(node) :: stack)) } map { "@{http://www.spiritconsortium.org/XMLSchema/SPIRIT/1685-2009}bitStringLength" -> _ },
        (node \ "@{http://www.spiritconsortium.org/XMLSchema/SPIRIT/1685-2009}minimum").headOption map { x => IPXACT2009scalaxb.DataRecord(x, node, IPXACT2009scalaxb.fromXML[String](x, IPXACT2009scalaxb.ElemName(node) :: stack)) } map { "@{http://www.spiritconsortium.org/XMLSchema/SPIRIT/1685-2009}minimum" -> _ },
        (node \ "@{http://www.spiritconsortium.org/XMLSchema/SPIRIT/1685-2009}maximum").headOption map { x => IPXACT2009scalaxb.DataRecord(x, node, IPXACT2009scalaxb.fromXML[String](x, IPXACT2009scalaxb.ElemName(node) :: stack)) } map { "@{http://www.spiritconsortium.org/XMLSchema/SPIRIT/1685-2009}maximum" -> _ },
        (node \ "@{http://www.spiritconsortium.org/XMLSchema/SPIRIT/1685-2009}rangeType").headOption map { x => IPXACT2009scalaxb.DataRecord(x, node, IPXACT2009scalaxb.fromXML[RangeTypeType](x, IPXACT2009scalaxb.ElemName(node) :: stack)) } map { "@{http://www.spiritconsortium.org/XMLSchema/SPIRIT/1685-2009}rangeType" -> _ },
        (node \ "@{http://www.spiritconsortium.org/XMLSchema/SPIRIT/1685-2009}prompt").headOption map { x => IPXACT2009scalaxb.DataRecord(x, node, IPXACT2009scalaxb.fromXML[String](x, IPXACT2009scalaxb.ElemName(node) :: stack)) } map { "@{http://www.spiritconsortium.org/XMLSchema/SPIRIT/1685-2009}prompt" -> _ }
        ).flatten[(String, IPXACT2009scalaxb.DataRecord[Any])] ::: (node match {
          case elem: scala.xml.Elem =>
            elem.attributes.toList flatMap {
              case scala.xml.PrefixedAttribute(pre, key, value, _) if pre == elem.scope.getPrefix("http://www.spiritconsortium.org/XMLSchema/SPIRIT/1685-2009") &&
                key == "format" => Nil
              case scala.xml.PrefixedAttribute(pre, key, value, _) if pre == elem.scope.getPrefix("http://www.spiritconsortium.org/XMLSchema/SPIRIT/1685-2009") &&
                key == "resolve" => Nil
              case scala.xml.PrefixedAttribute(pre, key, value, _) if pre == elem.scope.getPrefix("http://www.spiritconsortium.org/XMLSchema/SPIRIT/1685-2009") &&
                key == "id" => Nil
              case scala.xml.PrefixedAttribute(pre, key, value, _) if pre == elem.scope.getPrefix("http://www.spiritconsortium.org/XMLSchema/SPIRIT/1685-2009") &&
                key == "dependency" => Nil
              case scala.xml.PrefixedAttribute(pre, key, value, _) if pre == elem.scope.getPrefix("http://www.spiritconsortium.org/XMLSchema/SPIRIT/1685-2009") &&
                key == "choiceRef" => Nil
              case scala.xml.PrefixedAttribute(pre, key, value, _) if pre == elem.scope.getPrefix("http://www.spiritconsortium.org/XMLSchema/SPIRIT/1685-2009") &&
                key == "order" => Nil
              case scala.xml.PrefixedAttribute(pre, key, value, _) if pre == elem.scope.getPrefix("http://www.spiritconsortium.org/XMLSchema/SPIRIT/1685-2009") &&
                key == "configGroups" => Nil
              case scala.xml.PrefixedAttribute(pre, key, value, _) if pre == elem.scope.getPrefix("http://www.spiritconsortium.org/XMLSchema/SPIRIT/1685-2009") &&
                key == "bitStringLength" => Nil
              case scala.xml.PrefixedAttribute(pre, key, value, _) if pre == elem.scope.getPrefix("http://www.spiritconsortium.org/XMLSchema/SPIRIT/1685-2009") &&
                key == "minimum" => Nil
              case scala.xml.PrefixedAttribute(pre, key, value, _) if pre == elem.scope.getPrefix("http://www.spiritconsortium.org/XMLSchema/SPIRIT/1685-2009") &&
                key == "maximum" => Nil
              case scala.xml.PrefixedAttribute(pre, key, value, _) if pre == elem.scope.getPrefix("http://www.spiritconsortium.org/XMLSchema/SPIRIT/1685-2009") &&
                key == "rangeType" => Nil
              case scala.xml.PrefixedAttribute(pre, key, value, _) if pre == elem.scope.getPrefix("http://www.spiritconsortium.org/XMLSchema/SPIRIT/1685-2009") &&
                key == "prompt" => Nil
              case scala.xml.UnprefixedAttribute(key, value, _) =>
                List(("@" + key, IPXACT2009scalaxb.DataRecord(None, Some(key), value.text)))
              case scala.xml.PrefixedAttribute(pre, key, value, _) =>
                val ns = elem.scope.getURI(pre)
                List(("@{" + ns + "}" + key, IPXACT2009scalaxb.DataRecord(Option[String](ns), Some(key), value.text)))
              case _ => Nil
            }
          case _ => Nil
        }): _*)))
      case _ => Left("reads failed: seq must be scala.xml.Node")
    }
    
    override def writesAttribute(__obj: Command3, __scope: scala.xml.NamespaceBinding): scala.xml.MetaData = {
      var attr: scala.xml.MetaData  = scala.xml.Null
      __obj.attributes.toList map {
        case ("@{http://www.spiritconsortium.org/XMLSchema/SPIRIT/1685-2009}format", _) => if (__obj.spiritformat.toString != "string") attr = scala.xml.Attribute(__scope.getPrefix("http://www.spiritconsortium.org/XMLSchema/SPIRIT/1685-2009"), "format", __obj.spiritformat.toString, attr)
        case ("@{http://www.spiritconsortium.org/XMLSchema/SPIRIT/1685-2009}resolve", _) => __obj.spiritresolve foreach { x => attr = scala.xml.Attribute(__scope.getPrefix("http://www.spiritconsortium.org/XMLSchema/SPIRIT/1685-2009"), "resolve", x.toString, attr) }
        case ("@{http://www.spiritconsortium.org/XMLSchema/SPIRIT/1685-2009}id", _) => __obj.spiritid foreach { x => attr = scala.xml.Attribute(__scope.getPrefix("http://www.spiritconsortium.org/XMLSchema/SPIRIT/1685-2009"), "id", x.toString, attr) }
        case ("@{http://www.spiritconsortium.org/XMLSchema/SPIRIT/1685-2009}dependency", _) => __obj.spiritdependency foreach { x => attr = scala.xml.Attribute(__scope.getPrefix("http://www.spiritconsortium.org/XMLSchema/SPIRIT/1685-2009"), "dependency", x.toString, attr) }
        case ("@{http://www.spiritconsortium.org/XMLSchema/SPIRIT/1685-2009}choiceRef", _) => __obj.spiritchoiceRef foreach { x => attr = scala.xml.Attribute(__scope.getPrefix("http://www.spiritconsortium.org/XMLSchema/SPIRIT/1685-2009"), "choiceRef", x.toString, attr) }
        case ("@{http://www.spiritconsortium.org/XMLSchema/SPIRIT/1685-2009}order", _) => __obj.spiritorder foreach { x => attr = scala.xml.Attribute(__scope.getPrefix("http://www.spiritconsortium.org/XMLSchema/SPIRIT/1685-2009"), "order", x.toString, attr) }
        case ("@{http://www.spiritconsortium.org/XMLSchema/SPIRIT/1685-2009}configGroups", _) => __obj.spiritconfigGroups foreach { x => attr = scala.xml.Attribute(__scope.getPrefix("http://www.spiritconsortium.org/XMLSchema/SPIRIT/1685-2009"), "configGroups", x.toString, attr) }
        case ("@{http://www.spiritconsortium.org/XMLSchema/SPIRIT/1685-2009}bitStringLength", _) => __obj.spiritbitStringLength foreach { x => attr = scala.xml.Attribute(__scope.getPrefix("http://www.spiritconsortium.org/XMLSchema/SPIRIT/1685-2009"), "bitStringLength", x.toString, attr) }
        case ("@{http://www.spiritconsortium.org/XMLSchema/SPIRIT/1685-2009}minimum", _) => __obj.spiritminimum foreach { x => attr = scala.xml.Attribute(__scope.getPrefix("http://www.spiritconsortium.org/XMLSchema/SPIRIT/1685-2009"), "minimum", x.toString, attr) }
        case ("@{http://www.spiritconsortium.org/XMLSchema/SPIRIT/1685-2009}maximum", _) => __obj.spiritmaximum foreach { x => attr = scala.xml.Attribute(__scope.getPrefix("http://www.spiritconsortium.org/XMLSchema/SPIRIT/1685-2009"), "maximum", x.toString, attr) }
        case ("@{http://www.spiritconsortium.org/XMLSchema/SPIRIT/1685-2009}rangeType", _) => __obj.spiritrangeType foreach { x => attr = scala.xml.Attribute(__scope.getPrefix("http://www.spiritconsortium.org/XMLSchema/SPIRIT/1685-2009"), "rangeType", x.toString, attr) }
        case ("@{http://www.spiritconsortium.org/XMLSchema/SPIRIT/1685-2009}prompt", _) => __obj.spiritprompt foreach { x => attr = scala.xml.Attribute(__scope.getPrefix("http://www.spiritconsortium.org/XMLSchema/SPIRIT/1685-2009"), "prompt", x.toString, attr) }
        case (key, x) => attr = scala.xml.Attribute((x.namespace map { __scope.getPrefix(_) }).orNull, x.key.orNull, x.value.toString, attr)
      }
      attr
    }

    def writesChildNodes(__obj: Command3, __scope: scala.xml.NamespaceBinding): Seq[scala.xml.Node] =
      Seq(scala.xml.Text(__obj.value.toString))

  }

  trait Default_Flags3Format extends IPXACT2009scalaxb.XMLFormat[Flags3] with IPXACT2009scalaxb.CanWriteChildNodes[Flags3] {
    val targetNamespace: Option[String] = Some("http://www.spiritconsortium.org/XMLSchema/SPIRIT/1685-2009")
    def reads(seq: scala.xml.NodeSeq, stack: List[IPXACT2009scalaxb.ElemName]): Either[String, Flags3] = seq match {
      case node: scala.xml.Node => Right(Flags3(IPXACT2009scalaxb.fromXML[String](node, IPXACT2009scalaxb.ElemName(node) :: stack),
        scala.collection.immutable.ListMap(List(
        (node \ "@{http://www.spiritconsortium.org/XMLSchema/SPIRIT/1685-2009}format").headOption map { x => IPXACT2009scalaxb.DataRecord(x, node, IPXACT2009scalaxb.fromXML[FormatType](x, IPXACT2009scalaxb.ElemName(node) :: stack)) } orElse Some(IPXACT2009scalaxb.DataRecord(None, None, IPXACT2009scalaxb.fromXML[FormatType](scala.xml.Text("string"), IPXACT2009scalaxb.ElemName(node) :: stack))) map { "@{http://www.spiritconsortium.org/XMLSchema/SPIRIT/1685-2009}format" -> _ },
        (node \ "@{http://www.spiritconsortium.org/XMLSchema/SPIRIT/1685-2009}resolve").headOption map { x => IPXACT2009scalaxb.DataRecord(x, node, IPXACT2009scalaxb.fromXML[ResolveType](x, IPXACT2009scalaxb.ElemName(node) :: stack)) } map { "@{http://www.spiritconsortium.org/XMLSchema/SPIRIT/1685-2009}resolve" -> _ },
        (node \ "@{http://www.spiritconsortium.org/XMLSchema/SPIRIT/1685-2009}id").headOption map { x => IPXACT2009scalaxb.DataRecord(x, node, IPXACT2009scalaxb.fromXML[String](x, IPXACT2009scalaxb.ElemName(node) :: stack)) } map { "@{http://www.spiritconsortium.org/XMLSchema/SPIRIT/1685-2009}id" -> _ },
        (node \ "@{http://www.spiritconsortium.org/XMLSchema/SPIRIT/1685-2009}dependency").headOption map { x => IPXACT2009scalaxb.DataRecord(x, node, IPXACT2009scalaxb.fromXML[String](x, IPXACT2009scalaxb.ElemName(node) :: stack)) } map { "@{http://www.spiritconsortium.org/XMLSchema/SPIRIT/1685-2009}dependency" -> _ },
        (node \ "@{http://www.spiritconsortium.org/XMLSchema/SPIRIT/1685-2009}choiceRef").headOption map { x => IPXACT2009scalaxb.DataRecord(x, node, IPXACT2009scalaxb.fromXML[String](x, IPXACT2009scalaxb.ElemName(node) :: stack)) } map { "@{http://www.spiritconsortium.org/XMLSchema/SPIRIT/1685-2009}choiceRef" -> _ },
        (node \ "@{http://www.spiritconsortium.org/XMLSchema/SPIRIT/1685-2009}order").headOption map { x => IPXACT2009scalaxb.DataRecord(x, node, IPXACT2009scalaxb.fromXML[Float](x, IPXACT2009scalaxb.ElemName(node) :: stack)) } map { "@{http://www.spiritconsortium.org/XMLSchema/SPIRIT/1685-2009}order" -> _ },
        (node \ "@{http://www.spiritconsortium.org/XMLSchema/SPIRIT/1685-2009}configGroups").headOption map { x => IPXACT2009scalaxb.DataRecord(x, node, IPXACT2009scalaxb.fromXML[Seq[String]](x, IPXACT2009scalaxb.ElemName(node) :: stack)) } map { "@{http://www.spiritconsortium.org/XMLSchema/SPIRIT/1685-2009}configGroups" -> _ },
        (node \ "@{http://www.spiritconsortium.org/XMLSchema/SPIRIT/1685-2009}bitStringLength").headOption map { x => IPXACT2009scalaxb.DataRecord(x, node, IPXACT2009scalaxb.fromXML[BigInt](x, IPXACT2009scalaxb.ElemName(node) :: stack)) } map { "@{http://www.spiritconsortium.org/XMLSchema/SPIRIT/1685-2009}bitStringLength" -> _ },
        (node \ "@{http://www.spiritconsortium.org/XMLSchema/SPIRIT/1685-2009}minimum").headOption map { x => IPXACT2009scalaxb.DataRecord(x, node, IPXACT2009scalaxb.fromXML[String](x, IPXACT2009scalaxb.ElemName(node) :: stack)) } map { "@{http://www.spiritconsortium.org/XMLSchema/SPIRIT/1685-2009}minimum" -> _ },
        (node \ "@{http://www.spiritconsortium.org/XMLSchema/SPIRIT/1685-2009}maximum").headOption map { x => IPXACT2009scalaxb.DataRecord(x, node, IPXACT2009scalaxb.fromXML[String](x, IPXACT2009scalaxb.ElemName(node) :: stack)) } map { "@{http://www.spiritconsortium.org/XMLSchema/SPIRIT/1685-2009}maximum" -> _ },
        (node \ "@{http://www.spiritconsortium.org/XMLSchema/SPIRIT/1685-2009}rangeType").headOption map { x => IPXACT2009scalaxb.DataRecord(x, node, IPXACT2009scalaxb.fromXML[RangeTypeType](x, IPXACT2009scalaxb.ElemName(node) :: stack)) } map { "@{http://www.spiritconsortium.org/XMLSchema/SPIRIT/1685-2009}rangeType" -> _ },
        (node \ "@{http://www.spiritconsortium.org/XMLSchema/SPIRIT/1685-2009}prompt").headOption map { x => IPXACT2009scalaxb.DataRecord(x, node, IPXACT2009scalaxb.fromXML[String](x, IPXACT2009scalaxb.ElemName(node) :: stack)) } map { "@{http://www.spiritconsortium.org/XMLSchema/SPIRIT/1685-2009}prompt" -> _ }
        ).flatten[(String, IPXACT2009scalaxb.DataRecord[Any])] ::: (node match {
          case elem: scala.xml.Elem =>
            elem.attributes.toList flatMap {
              case scala.xml.PrefixedAttribute(pre, key, value, _) if pre == elem.scope.getPrefix("http://www.spiritconsortium.org/XMLSchema/SPIRIT/1685-2009") &&
                key == "format" => Nil
              case scala.xml.PrefixedAttribute(pre, key, value, _) if pre == elem.scope.getPrefix("http://www.spiritconsortium.org/XMLSchema/SPIRIT/1685-2009") &&
                key == "resolve" => Nil
              case scala.xml.PrefixedAttribute(pre, key, value, _) if pre == elem.scope.getPrefix("http://www.spiritconsortium.org/XMLSchema/SPIRIT/1685-2009") &&
                key == "id" => Nil
              case scala.xml.PrefixedAttribute(pre, key, value, _) if pre == elem.scope.getPrefix("http://www.spiritconsortium.org/XMLSchema/SPIRIT/1685-2009") &&
                key == "dependency" => Nil
              case scala.xml.PrefixedAttribute(pre, key, value, _) if pre == elem.scope.getPrefix("http://www.spiritconsortium.org/XMLSchema/SPIRIT/1685-2009") &&
                key == "choiceRef" => Nil
              case scala.xml.PrefixedAttribute(pre, key, value, _) if pre == elem.scope.getPrefix("http://www.spiritconsortium.org/XMLSchema/SPIRIT/1685-2009") &&
                key == "order" => Nil
              case scala.xml.PrefixedAttribute(pre, key, value, _) if pre == elem.scope.getPrefix("http://www.spiritconsortium.org/XMLSchema/SPIRIT/1685-2009") &&
                key == "configGroups" => Nil
              case scala.xml.PrefixedAttribute(pre, key, value, _) if pre == elem.scope.getPrefix("http://www.spiritconsortium.org/XMLSchema/SPIRIT/1685-2009") &&
                key == "bitStringLength" => Nil
              case scala.xml.PrefixedAttribute(pre, key, value, _) if pre == elem.scope.getPrefix("http://www.spiritconsortium.org/XMLSchema/SPIRIT/1685-2009") &&
                key == "minimum" => Nil
              case scala.xml.PrefixedAttribute(pre, key, value, _) if pre == elem.scope.getPrefix("http://www.spiritconsortium.org/XMLSchema/SPIRIT/1685-2009") &&
                key == "maximum" => Nil
              case scala.xml.PrefixedAttribute(pre, key, value, _) if pre == elem.scope.getPrefix("http://www.spiritconsortium.org/XMLSchema/SPIRIT/1685-2009") &&
                key == "rangeType" => Nil
              case scala.xml.PrefixedAttribute(pre, key, value, _) if pre == elem.scope.getPrefix("http://www.spiritconsortium.org/XMLSchema/SPIRIT/1685-2009") &&
                key == "prompt" => Nil
              case scala.xml.UnprefixedAttribute(key, value, _) =>
                List(("@" + key, IPXACT2009scalaxb.DataRecord(None, Some(key), value.text)))
              case scala.xml.PrefixedAttribute(pre, key, value, _) =>
                val ns = elem.scope.getURI(pre)
                List(("@{" + ns + "}" + key, IPXACT2009scalaxb.DataRecord(Option[String](ns), Some(key), value.text)))
              case _ => Nil
            }
          case _ => Nil
        }): _*)))
      case _ => Left("reads failed: seq must be scala.xml.Node")
    }
    
    override def writesAttribute(__obj: Flags3, __scope: scala.xml.NamespaceBinding): scala.xml.MetaData = {
      var attr: scala.xml.MetaData  = scala.xml.Null
      __obj.attributes.toList map {
        case ("@{http://www.spiritconsortium.org/XMLSchema/SPIRIT/1685-2009}format", _) => if (__obj.spiritformat.toString != "string") attr = scala.xml.Attribute(__scope.getPrefix("http://www.spiritconsortium.org/XMLSchema/SPIRIT/1685-2009"), "format", __obj.spiritformat.toString, attr)
        case ("@{http://www.spiritconsortium.org/XMLSchema/SPIRIT/1685-2009}resolve", _) => __obj.spiritresolve foreach { x => attr = scala.xml.Attribute(__scope.getPrefix("http://www.spiritconsortium.org/XMLSchema/SPIRIT/1685-2009"), "resolve", x.toString, attr) }
        case ("@{http://www.spiritconsortium.org/XMLSchema/SPIRIT/1685-2009}id", _) => __obj.spiritid foreach { x => attr = scala.xml.Attribute(__scope.getPrefix("http://www.spiritconsortium.org/XMLSchema/SPIRIT/1685-2009"), "id", x.toString, attr) }
        case ("@{http://www.spiritconsortium.org/XMLSchema/SPIRIT/1685-2009}dependency", _) => __obj.spiritdependency foreach { x => attr = scala.xml.Attribute(__scope.getPrefix("http://www.spiritconsortium.org/XMLSchema/SPIRIT/1685-2009"), "dependency", x.toString, attr) }
        case ("@{http://www.spiritconsortium.org/XMLSchema/SPIRIT/1685-2009}choiceRef", _) => __obj.spiritchoiceRef foreach { x => attr = scala.xml.Attribute(__scope.getPrefix("http://www.spiritconsortium.org/XMLSchema/SPIRIT/1685-2009"), "choiceRef", x.toString, attr) }
        case ("@{http://www.spiritconsortium.org/XMLSchema/SPIRIT/1685-2009}order", _) => __obj.spiritorder foreach { x => attr = scala.xml.Attribute(__scope.getPrefix("http://www.spiritconsortium.org/XMLSchema/SPIRIT/1685-2009"), "order", x.toString, attr) }
        case ("@{http://www.spiritconsortium.org/XMLSchema/SPIRIT/1685-2009}configGroups", _) => __obj.spiritconfigGroups foreach { x => attr = scala.xml.Attribute(__scope.getPrefix("http://www.spiritconsortium.org/XMLSchema/SPIRIT/1685-2009"), "configGroups", x.toString, attr) }
        case ("@{http://www.spiritconsortium.org/XMLSchema/SPIRIT/1685-2009}bitStringLength", _) => __obj.spiritbitStringLength foreach { x => attr = scala.xml.Attribute(__scope.getPrefix("http://www.spiritconsortium.org/XMLSchema/SPIRIT/1685-2009"), "bitStringLength", x.toString, attr) }
        case ("@{http://www.spiritconsortium.org/XMLSchema/SPIRIT/1685-2009}minimum", _) => __obj.spiritminimum foreach { x => attr = scala.xml.Attribute(__scope.getPrefix("http://www.spiritconsortium.org/XMLSchema/SPIRIT/1685-2009"), "minimum", x.toString, attr) }
        case ("@{http://www.spiritconsortium.org/XMLSchema/SPIRIT/1685-2009}maximum", _) => __obj.spiritmaximum foreach { x => attr = scala.xml.Attribute(__scope.getPrefix("http://www.spiritconsortium.org/XMLSchema/SPIRIT/1685-2009"), "maximum", x.toString, attr) }
        case ("@{http://www.spiritconsortium.org/XMLSchema/SPIRIT/1685-2009}rangeType", _) => __obj.spiritrangeType foreach { x => attr = scala.xml.Attribute(__scope.getPrefix("http://www.spiritconsortium.org/XMLSchema/SPIRIT/1685-2009"), "rangeType", x.toString, attr) }
        case ("@{http://www.spiritconsortium.org/XMLSchema/SPIRIT/1685-2009}prompt", _) => __obj.spiritprompt foreach { x => attr = scala.xml.Attribute(__scope.getPrefix("http://www.spiritconsortium.org/XMLSchema/SPIRIT/1685-2009"), "prompt", x.toString, attr) }
        case (key, x) => attr = scala.xml.Attribute((x.namespace map { __scope.getPrefix(_) }).orNull, x.key.orNull, x.value.toString, attr)
      }
      attr
    }

    def writesChildNodes(__obj: Flags3, __scope: scala.xml.NamespaceBinding): Seq[scala.xml.Node] =
      Seq(scala.xml.Text(__obj.value.toString))

  }

  trait Default_ReplaceDefaultFlags3Format extends IPXACT2009scalaxb.XMLFormat[ReplaceDefaultFlags3] with IPXACT2009scalaxb.CanWriteChildNodes[ReplaceDefaultFlags3] {
    val targetNamespace: Option[String] = Some("http://www.spiritconsortium.org/XMLSchema/SPIRIT/1685-2009")
    def reads(seq: scala.xml.NodeSeq, stack: List[IPXACT2009scalaxb.ElemName]): Either[String, ReplaceDefaultFlags3] = seq match {
      case node: scala.xml.Node => Right(ReplaceDefaultFlags3(IPXACT2009scalaxb.fromXML[Boolean](node, IPXACT2009scalaxb.ElemName(node) :: stack),
        scala.collection.immutable.ListMap(List(
        (node \ "@{http://www.spiritconsortium.org/XMLSchema/SPIRIT/1685-2009}format").headOption map { x => IPXACT2009scalaxb.DataRecord(x, node, IPXACT2009scalaxb.fromXML[FormatType](x, IPXACT2009scalaxb.ElemName(node) :: stack)) } orElse Some(IPXACT2009scalaxb.DataRecord(None, None, IPXACT2009scalaxb.fromXML[FormatType](scala.xml.Text("bool"), IPXACT2009scalaxb.ElemName(node) :: stack))) map { "@{http://www.spiritconsortium.org/XMLSchema/SPIRIT/1685-2009}format" -> _ },
        (node \ "@{http://www.spiritconsortium.org/XMLSchema/SPIRIT/1685-2009}resolve").headOption map { x => IPXACT2009scalaxb.DataRecord(x, node, IPXACT2009scalaxb.fromXML[ResolveType](x, IPXACT2009scalaxb.ElemName(node) :: stack)) } map { "@{http://www.spiritconsortium.org/XMLSchema/SPIRIT/1685-2009}resolve" -> _ },
        (node \ "@{http://www.spiritconsortium.org/XMLSchema/SPIRIT/1685-2009}id").headOption map { x => IPXACT2009scalaxb.DataRecord(x, node, IPXACT2009scalaxb.fromXML[String](x, IPXACT2009scalaxb.ElemName(node) :: stack)) } map { "@{http://www.spiritconsortium.org/XMLSchema/SPIRIT/1685-2009}id" -> _ },
        (node \ "@{http://www.spiritconsortium.org/XMLSchema/SPIRIT/1685-2009}dependency").headOption map { x => IPXACT2009scalaxb.DataRecord(x, node, IPXACT2009scalaxb.fromXML[String](x, IPXACT2009scalaxb.ElemName(node) :: stack)) } map { "@{http://www.spiritconsortium.org/XMLSchema/SPIRIT/1685-2009}dependency" -> _ },
        (node \ "@{http://www.spiritconsortium.org/XMLSchema/SPIRIT/1685-2009}choiceRef").headOption map { x => IPXACT2009scalaxb.DataRecord(x, node, IPXACT2009scalaxb.fromXML[String](x, IPXACT2009scalaxb.ElemName(node) :: stack)) } map { "@{http://www.spiritconsortium.org/XMLSchema/SPIRIT/1685-2009}choiceRef" -> _ },
        (node \ "@{http://www.spiritconsortium.org/XMLSchema/SPIRIT/1685-2009}order").headOption map { x => IPXACT2009scalaxb.DataRecord(x, node, IPXACT2009scalaxb.fromXML[Float](x, IPXACT2009scalaxb.ElemName(node) :: stack)) } map { "@{http://www.spiritconsortium.org/XMLSchema/SPIRIT/1685-2009}order" -> _ },
        (node \ "@{http://www.spiritconsortium.org/XMLSchema/SPIRIT/1685-2009}configGroups").headOption map { x => IPXACT2009scalaxb.DataRecord(x, node, IPXACT2009scalaxb.fromXML[Seq[String]](x, IPXACT2009scalaxb.ElemName(node) :: stack)) } map { "@{http://www.spiritconsortium.org/XMLSchema/SPIRIT/1685-2009}configGroups" -> _ },
        (node \ "@{http://www.spiritconsortium.org/XMLSchema/SPIRIT/1685-2009}bitStringLength").headOption map { x => IPXACT2009scalaxb.DataRecord(x, node, IPXACT2009scalaxb.fromXML[BigInt](x, IPXACT2009scalaxb.ElemName(node) :: stack)) } map { "@{http://www.spiritconsortium.org/XMLSchema/SPIRIT/1685-2009}bitStringLength" -> _ },
        (node \ "@{http://www.spiritconsortium.org/XMLSchema/SPIRIT/1685-2009}minimum").headOption map { x => IPXACT2009scalaxb.DataRecord(x, node, IPXACT2009scalaxb.fromXML[String](x, IPXACT2009scalaxb.ElemName(node) :: stack)) } map { "@{http://www.spiritconsortium.org/XMLSchema/SPIRIT/1685-2009}minimum" -> _ },
        (node \ "@{http://www.spiritconsortium.org/XMLSchema/SPIRIT/1685-2009}maximum").headOption map { x => IPXACT2009scalaxb.DataRecord(x, node, IPXACT2009scalaxb.fromXML[String](x, IPXACT2009scalaxb.ElemName(node) :: stack)) } map { "@{http://www.spiritconsortium.org/XMLSchema/SPIRIT/1685-2009}maximum" -> _ },
        (node \ "@{http://www.spiritconsortium.org/XMLSchema/SPIRIT/1685-2009}rangeType").headOption map { x => IPXACT2009scalaxb.DataRecord(x, node, IPXACT2009scalaxb.fromXML[RangeTypeType](x, IPXACT2009scalaxb.ElemName(node) :: stack)) } orElse Some(IPXACT2009scalaxb.DataRecord(None, None, IPXACT2009scalaxb.fromXML[RangeTypeType](scala.xml.Text("int"), IPXACT2009scalaxb.ElemName(node) :: stack))) map { "@{http://www.spiritconsortium.org/XMLSchema/SPIRIT/1685-2009}rangeType" -> _ },
        (node \ "@{http://www.spiritconsortium.org/XMLSchema/SPIRIT/1685-2009}prompt").headOption map { x => IPXACT2009scalaxb.DataRecord(x, node, IPXACT2009scalaxb.fromXML[String](x, IPXACT2009scalaxb.ElemName(node) :: stack)) } map { "@{http://www.spiritconsortium.org/XMLSchema/SPIRIT/1685-2009}prompt" -> _ }
        ).flatten[(String, IPXACT2009scalaxb.DataRecord[Any])] ::: (node match {
          case elem: scala.xml.Elem =>
            elem.attributes.toList flatMap {
              case scala.xml.PrefixedAttribute(pre, key, value, _) if pre == elem.scope.getPrefix("http://www.spiritconsortium.org/XMLSchema/SPIRIT/1685-2009") &&
                key == "format" => Nil
              case scala.xml.PrefixedAttribute(pre, key, value, _) if pre == elem.scope.getPrefix("http://www.spiritconsortium.org/XMLSchema/SPIRIT/1685-2009") &&
                key == "resolve" => Nil
              case scala.xml.PrefixedAttribute(pre, key, value, _) if pre == elem.scope.getPrefix("http://www.spiritconsortium.org/XMLSchema/SPIRIT/1685-2009") &&
                key == "id" => Nil
              case scala.xml.PrefixedAttribute(pre, key, value, _) if pre == elem.scope.getPrefix("http://www.spiritconsortium.org/XMLSchema/SPIRIT/1685-2009") &&
                key == "dependency" => Nil
              case scala.xml.PrefixedAttribute(pre, key, value, _) if pre == elem.scope.getPrefix("http://www.spiritconsortium.org/XMLSchema/SPIRIT/1685-2009") &&
                key == "choiceRef" => Nil
              case scala.xml.PrefixedAttribute(pre, key, value, _) if pre == elem.scope.getPrefix("http://www.spiritconsortium.org/XMLSchema/SPIRIT/1685-2009") &&
                key == "order" => Nil
              case scala.xml.PrefixedAttribute(pre, key, value, _) if pre == elem.scope.getPrefix("http://www.spiritconsortium.org/XMLSchema/SPIRIT/1685-2009") &&
                key == "configGroups" => Nil
              case scala.xml.PrefixedAttribute(pre, key, value, _) if pre == elem.scope.getPrefix("http://www.spiritconsortium.org/XMLSchema/SPIRIT/1685-2009") &&
                key == "bitStringLength" => Nil
              case scala.xml.PrefixedAttribute(pre, key, value, _) if pre == elem.scope.getPrefix("http://www.spiritconsortium.org/XMLSchema/SPIRIT/1685-2009") &&
                key == "minimum" => Nil
              case scala.xml.PrefixedAttribute(pre, key, value, _) if pre == elem.scope.getPrefix("http://www.spiritconsortium.org/XMLSchema/SPIRIT/1685-2009") &&
                key == "maximum" => Nil
              case scala.xml.PrefixedAttribute(pre, key, value, _) if pre == elem.scope.getPrefix("http://www.spiritconsortium.org/XMLSchema/SPIRIT/1685-2009") &&
                key == "rangeType" => Nil
              case scala.xml.PrefixedAttribute(pre, key, value, _) if pre == elem.scope.getPrefix("http://www.spiritconsortium.org/XMLSchema/SPIRIT/1685-2009") &&
                key == "prompt" => Nil
              case scala.xml.UnprefixedAttribute(key, value, _) =>
                List(("@" + key, IPXACT2009scalaxb.DataRecord(None, Some(key), value.text)))
              case scala.xml.PrefixedAttribute(pre, key, value, _) =>
                val ns = elem.scope.getURI(pre)
                List(("@{" + ns + "}" + key, IPXACT2009scalaxb.DataRecord(Option[String](ns), Some(key), value.text)))
              case _ => Nil
            }
          case _ => Nil
        }): _*)))
      case _ => Left("reads failed: seq must be scala.xml.Node")
    }
    
    override def writesAttribute(__obj: ReplaceDefaultFlags3, __scope: scala.xml.NamespaceBinding): scala.xml.MetaData = {
      var attr: scala.xml.MetaData  = scala.xml.Null
      __obj.attributes.toList map {
        case ("@{http://www.spiritconsortium.org/XMLSchema/SPIRIT/1685-2009}format", _) => if (__obj.spiritformat.toString != "bool") attr = scala.xml.Attribute(__scope.getPrefix("http://www.spiritconsortium.org/XMLSchema/SPIRIT/1685-2009"), "format", __obj.spiritformat.toString, attr)
        case ("@{http://www.spiritconsortium.org/XMLSchema/SPIRIT/1685-2009}resolve", _) => __obj.spiritresolve foreach { x => attr = scala.xml.Attribute(__scope.getPrefix("http://www.spiritconsortium.org/XMLSchema/SPIRIT/1685-2009"), "resolve", x.toString, attr) }
        case ("@{http://www.spiritconsortium.org/XMLSchema/SPIRIT/1685-2009}id", _) => __obj.spiritid foreach { x => attr = scala.xml.Attribute(__scope.getPrefix("http://www.spiritconsortium.org/XMLSchema/SPIRIT/1685-2009"), "id", x.toString, attr) }
        case ("@{http://www.spiritconsortium.org/XMLSchema/SPIRIT/1685-2009}dependency", _) => __obj.spiritdependency foreach { x => attr = scala.xml.Attribute(__scope.getPrefix("http://www.spiritconsortium.org/XMLSchema/SPIRIT/1685-2009"), "dependency", x.toString, attr) }
        case ("@{http://www.spiritconsortium.org/XMLSchema/SPIRIT/1685-2009}choiceRef", _) => __obj.spiritchoiceRef foreach { x => attr = scala.xml.Attribute(__scope.getPrefix("http://www.spiritconsortium.org/XMLSchema/SPIRIT/1685-2009"), "choiceRef", x.toString, attr) }
        case ("@{http://www.spiritconsortium.org/XMLSchema/SPIRIT/1685-2009}order", _) => __obj.spiritorder foreach { x => attr = scala.xml.Attribute(__scope.getPrefix("http://www.spiritconsortium.org/XMLSchema/SPIRIT/1685-2009"), "order", x.toString, attr) }
        case ("@{http://www.spiritconsortium.org/XMLSchema/SPIRIT/1685-2009}configGroups", _) => __obj.spiritconfigGroups foreach { x => attr = scala.xml.Attribute(__scope.getPrefix("http://www.spiritconsortium.org/XMLSchema/SPIRIT/1685-2009"), "configGroups", x.toString, attr) }
        case ("@{http://www.spiritconsortium.org/XMLSchema/SPIRIT/1685-2009}bitStringLength", _) => __obj.spiritbitStringLength foreach { x => attr = scala.xml.Attribute(__scope.getPrefix("http://www.spiritconsortium.org/XMLSchema/SPIRIT/1685-2009"), "bitStringLength", x.toString, attr) }
        case ("@{http://www.spiritconsortium.org/XMLSchema/SPIRIT/1685-2009}minimum", _) => __obj.spiritminimum foreach { x => attr = scala.xml.Attribute(__scope.getPrefix("http://www.spiritconsortium.org/XMLSchema/SPIRIT/1685-2009"), "minimum", x.toString, attr) }
        case ("@{http://www.spiritconsortium.org/XMLSchema/SPIRIT/1685-2009}maximum", _) => __obj.spiritmaximum foreach { x => attr = scala.xml.Attribute(__scope.getPrefix("http://www.spiritconsortium.org/XMLSchema/SPIRIT/1685-2009"), "maximum", x.toString, attr) }
        case ("@{http://www.spiritconsortium.org/XMLSchema/SPIRIT/1685-2009}rangeType", _) => if (__obj.spiritrangeType.toString != "int") attr = scala.xml.Attribute(__scope.getPrefix("http://www.spiritconsortium.org/XMLSchema/SPIRIT/1685-2009"), "rangeType", __obj.spiritrangeType.toString, attr)
        case ("@{http://www.spiritconsortium.org/XMLSchema/SPIRIT/1685-2009}prompt", _) => __obj.spiritprompt foreach { x => attr = scala.xml.Attribute(__scope.getPrefix("http://www.spiritconsortium.org/XMLSchema/SPIRIT/1685-2009"), "prompt", x.toString, attr) }
        case (key, x) => attr = scala.xml.Attribute((x.namespace map { __scope.getPrefix(_) }).orNull, x.key.orNull, x.value.toString, attr)
      }
      attr
    }

    def writesChildNodes(__obj: ReplaceDefaultFlags3, __scope: scala.xml.NamespaceBinding): Seq[scala.xml.Node] =
      Seq(scala.xml.Text(__obj.value.toString))

  }

  trait Default_FileBuilderTypeFormat extends IPXACT2009scalaxb.ElemNameParser[FileBuilderType] with _FileTypeGroupFormat {
    val targetNamespace: Option[String] = Some("http://www.spiritconsortium.org/XMLSchema/SPIRIT/1685-2009")
    
    override def typeName: Option[String] = Some("fileBuilderType")

    def parser(node: scala.xml.Node, stack: List[IPXACT2009scalaxb.ElemName]): Parser[FileBuilderType] =
      phrase((parseFileTypeGroup(node, IPXACT2009scalaxb.ElemName(node) :: stack)) ~
      opt(IPXACT2009scalaxb.ElemName(Some("http://www.spiritconsortium.org/XMLSchema/SPIRIT/1685-2009"), "command")) ~
      opt(IPXACT2009scalaxb.ElemName(Some("http://www.spiritconsortium.org/XMLSchema/SPIRIT/1685-2009"), "flags")) ~
      opt(IPXACT2009scalaxb.ElemName(Some("http://www.spiritconsortium.org/XMLSchema/SPIRIT/1685-2009"), "replaceDefaultFlags")) ^^
      { case p1 ~ p2 ~ p3 ~ p4 =>
      FileBuilderType(p1,
        p2.headOption map { IPXACT2009scalaxb.fromXML[Command3](_, IPXACT2009scalaxb.ElemName(node) :: stack) },
        p3.headOption map { IPXACT2009scalaxb.fromXML[Flags3](_, IPXACT2009scalaxb.ElemName(node) :: stack) },
        p4.headOption map { IPXACT2009scalaxb.fromXML[ReplaceDefaultFlags3](_, IPXACT2009scalaxb.ElemName(node) :: stack) }) })
    
    def writesChildNodes(__obj: FileBuilderType, __scope: scala.xml.NamespaceBinding): Seq[scala.xml.Node] =
      Seq.concat((Some(__obj.fileTypeOption1) map {x => IPXACT2009scalaxb.toXML[IPXACT2009scalaxb.DataRecord[Any]](x, x.namespace, x.key, __scope, false)}).get,
        __obj.command map { IPXACT2009scalaxb.toXML[Command3](_, Some("http://www.spiritconsortium.org/XMLSchema/SPIRIT/1685-2009"), Some("command"), __scope, false) } getOrElse {Nil},
        __obj.flags map { IPXACT2009scalaxb.toXML[Flags3](_, Some("http://www.spiritconsortium.org/XMLSchema/SPIRIT/1685-2009"), Some("flags"), __scope, false) } getOrElse {Nil},
        __obj.replaceDefaultFlags map { IPXACT2009scalaxb.toXML[ReplaceDefaultFlags3](_, Some("http://www.spiritconsortium.org/XMLSchema/SPIRIT/1685-2009"), Some("replaceDefaultFlags"), __scope, false) } getOrElse {Nil})

  }

  def build_ReturnTypeFormat = new Default_ReturnTypeFormat {}
  trait Default_ReturnTypeFormat extends IPXACT2009scalaxb.XMLFormat[ReturnType] {
    val targetNamespace: Option[String] = Some("http://www.spiritconsortium.org/XMLSchema/SPIRIT/1685-2009")
    
    def fromString(value: String, scope: scala.xml.NamespaceBinding): ReturnType =
        (fromString0(value, scope)).apply(IPXACT2009scalaxb.fromXML[String](scala.xml.Text(value)))

    private def fromString0(value: String, scope: scala.xml.NamespaceBinding): PartialFunction[Any, ReturnType] = {
      case x: String if x == IPXACT2009scalaxb.fromXML[String](scala.xml.Text("void")) => Void
      case x: String if x == IPXACT2009scalaxb.fromXML[String](scala.xml.Text("int")) => IntTypeValue2

    }



    def reads(seq: scala.xml.NodeSeq, stack: List[IPXACT2009scalaxb.ElemName]): Either[String, ReturnType] = seq match {
      case elem: scala.xml.Elem => Right(fromString(elem.text, elem.scope))
      case _ => Right(fromString(seq.text, scala.xml.TopScope))
    }
    
    def writes(__obj: ReturnType, __namespace: Option[String], __elementLabel: Option[String],
        __scope: scala.xml.NamespaceBinding, __typeAttribute: Boolean): scala.xml.NodeSeq =
      scala.xml.Elem(IPXACT2009scalaxb.Helper.getPrefix(__namespace, __scope).orNull,
        __elementLabel getOrElse { sys.error("missing element label.") },
        scala.xml.Null, __scope, true, scala.xml.Text(__obj.toString))
  }
  trait Default_ArgumentFormat extends IPXACT2009scalaxb.ElemNameParser[Argument] with _NameGroupStringGroupFormat {
    val targetNamespace: Option[String] = Some("http://www.spiritconsortium.org/XMLSchema/SPIRIT/1685-2009")
    
    def parser(node: scala.xml.Node, stack: List[IPXACT2009scalaxb.ElemName]): Parser[Argument] =
      phrase((parseNameGroupStringGroup(node, IPXACT2009scalaxb.ElemName(node) :: stack)) ~
      (IPXACT2009scalaxb.ElemName(Some("http://www.spiritconsortium.org/XMLSchema/SPIRIT/1685-2009"), "value")) ~
      opt(IPXACT2009scalaxb.ElemName(Some("http://www.spiritconsortium.org/XMLSchema/SPIRIT/1685-2009"), "vendorExtensions")) ^^
      { case p1 ~ p2 ~ p3 =>
      Argument(p1,
        IPXACT2009scalaxb.fromXML[Value](p2, IPXACT2009scalaxb.ElemName(node) :: stack),
        p3.headOption map { IPXACT2009scalaxb.fromXML[VendorExtensions](_, IPXACT2009scalaxb.ElemName(node) :: stack) },
        scala.collection.immutable.ListMap(List(
        (node \ "@{http://www.spiritconsortium.org/XMLSchema/SPIRIT/1685-2009}dataType").headOption map { x => IPXACT2009scalaxb.DataRecord(x, node, IPXACT2009scalaxb.fromXML[DataTypeType](x, IPXACT2009scalaxb.ElemName(node) :: stack)) } map { "@dataType" -> _ }
        ).flatten[(String, IPXACT2009scalaxb.DataRecord[Any])] ::: (node match {
          case elem: scala.xml.Elem =>
            elem.attributes.toList flatMap {
              case scala.xml.PrefixedAttribute(pre, key, value, _) if pre == elem.scope.getPrefix("http://www.spiritconsortium.org/XMLSchema/SPIRIT/1685-2009") &&
                key == "dataType" => Nil
              case scala.xml.UnprefixedAttribute(key, value, _) =>
                List(("@" + key, IPXACT2009scalaxb.DataRecord(None, Some(key), value.text)))
              case scala.xml.PrefixedAttribute(pre, key, value, _) =>
                val ns = elem.scope.getURI(pre)
                List(("@{" + ns + "}" + key, IPXACT2009scalaxb.DataRecord(Option[String](ns), Some(key), value.text)))
              case _ => Nil
            }
          case _ => Nil
        }): _*)) })
    
    override def writesAttribute(__obj: Argument, __scope: scala.xml.NamespaceBinding): scala.xml.MetaData = {
      var attr: scala.xml.MetaData  = scala.xml.Null
      __obj.attributes.toList map {
        case ("@dataType", _) => attr = scala.xml.Attribute(__scope.getPrefix("http://www.spiritconsortium.org/XMLSchema/SPIRIT/1685-2009"), "dataType", __obj.dataType.toString, attr)
        case (key, x) => attr = scala.xml.Attribute((x.namespace map { __scope.getPrefix(_) }).orNull, x.key.orNull, x.value.toString, attr)
      }
      attr
    }

    def writesChildNodes(__obj: Argument, __scope: scala.xml.NamespaceBinding): Seq[scala.xml.Node] =
      Seq.concat(IPXACT2009scalaxb.toXML[NameGroupStringSequence](__obj.nameGroupStringSequence1, None, Some("nameGroupStringSequence1"), __scope, false),
        IPXACT2009scalaxb.toXML[Value](__obj.value, Some("http://www.spiritconsortium.org/XMLSchema/SPIRIT/1685-2009"), Some("value"), __scope, false),
        __obj.vendorExtensions map { IPXACT2009scalaxb.toXML[VendorExtensions](_, Some("http://www.spiritconsortium.org/XMLSchema/SPIRIT/1685-2009"), Some("vendorExtensions"), __scope, false) } getOrElse {Nil})

  }

  trait Default_DisabledFormat extends IPXACT2009scalaxb.XMLFormat[Disabled] with IPXACT2009scalaxb.CanWriteChildNodes[Disabled] {
    val targetNamespace: Option[String] = Some("http://www.spiritconsortium.org/XMLSchema/SPIRIT/1685-2009")
    def reads(seq: scala.xml.NodeSeq, stack: List[IPXACT2009scalaxb.ElemName]): Either[String, Disabled] = seq match {
      case node: scala.xml.Node => Right(Disabled(IPXACT2009scalaxb.fromXML[Boolean](node, IPXACT2009scalaxb.ElemName(node) :: stack),
        scala.collection.immutable.ListMap(List(
        (node \ "@{http://www.spiritconsortium.org/XMLSchema/SPIRIT/1685-2009}format").headOption map { x => IPXACT2009scalaxb.DataRecord(x, node, IPXACT2009scalaxb.fromXML[FormatType](x, IPXACT2009scalaxb.ElemName(node) :: stack)) } orElse Some(IPXACT2009scalaxb.DataRecord(None, None, IPXACT2009scalaxb.fromXML[FormatType](scala.xml.Text("bool"), IPXACT2009scalaxb.ElemName(node) :: stack))) map { "@{http://www.spiritconsortium.org/XMLSchema/SPIRIT/1685-2009}format" -> _ },
        (node \ "@{http://www.spiritconsortium.org/XMLSchema/SPIRIT/1685-2009}resolve").headOption map { x => IPXACT2009scalaxb.DataRecord(x, node, IPXACT2009scalaxb.fromXML[ResolveType](x, IPXACT2009scalaxb.ElemName(node) :: stack)) } map { "@{http://www.spiritconsortium.org/XMLSchema/SPIRIT/1685-2009}resolve" -> _ },
        (node \ "@{http://www.spiritconsortium.org/XMLSchema/SPIRIT/1685-2009}id").headOption map { x => IPXACT2009scalaxb.DataRecord(x, node, IPXACT2009scalaxb.fromXML[String](x, IPXACT2009scalaxb.ElemName(node) :: stack)) } map { "@{http://www.spiritconsortium.org/XMLSchema/SPIRIT/1685-2009}id" -> _ },
        (node \ "@{http://www.spiritconsortium.org/XMLSchema/SPIRIT/1685-2009}dependency").headOption map { x => IPXACT2009scalaxb.DataRecord(x, node, IPXACT2009scalaxb.fromXML[String](x, IPXACT2009scalaxb.ElemName(node) :: stack)) } map { "@{http://www.spiritconsortium.org/XMLSchema/SPIRIT/1685-2009}dependency" -> _ },
        (node \ "@{http://www.spiritconsortium.org/XMLSchema/SPIRIT/1685-2009}choiceRef").headOption map { x => IPXACT2009scalaxb.DataRecord(x, node, IPXACT2009scalaxb.fromXML[String](x, IPXACT2009scalaxb.ElemName(node) :: stack)) } map { "@{http://www.spiritconsortium.org/XMLSchema/SPIRIT/1685-2009}choiceRef" -> _ },
        (node \ "@{http://www.spiritconsortium.org/XMLSchema/SPIRIT/1685-2009}order").headOption map { x => IPXACT2009scalaxb.DataRecord(x, node, IPXACT2009scalaxb.fromXML[Float](x, IPXACT2009scalaxb.ElemName(node) :: stack)) } map { "@{http://www.spiritconsortium.org/XMLSchema/SPIRIT/1685-2009}order" -> _ },
        (node \ "@{http://www.spiritconsortium.org/XMLSchema/SPIRIT/1685-2009}configGroups").headOption map { x => IPXACT2009scalaxb.DataRecord(x, node, IPXACT2009scalaxb.fromXML[Seq[String]](x, IPXACT2009scalaxb.ElemName(node) :: stack)) } map { "@{http://www.spiritconsortium.org/XMLSchema/SPIRIT/1685-2009}configGroups" -> _ },
        (node \ "@{http://www.spiritconsortium.org/XMLSchema/SPIRIT/1685-2009}bitStringLength").headOption map { x => IPXACT2009scalaxb.DataRecord(x, node, IPXACT2009scalaxb.fromXML[BigInt](x, IPXACT2009scalaxb.ElemName(node) :: stack)) } map { "@{http://www.spiritconsortium.org/XMLSchema/SPIRIT/1685-2009}bitStringLength" -> _ },
        (node \ "@{http://www.spiritconsortium.org/XMLSchema/SPIRIT/1685-2009}minimum").headOption map { x => IPXACT2009scalaxb.DataRecord(x, node, IPXACT2009scalaxb.fromXML[String](x, IPXACT2009scalaxb.ElemName(node) :: stack)) } map { "@{http://www.spiritconsortium.org/XMLSchema/SPIRIT/1685-2009}minimum" -> _ },
        (node \ "@{http://www.spiritconsortium.org/XMLSchema/SPIRIT/1685-2009}maximum").headOption map { x => IPXACT2009scalaxb.DataRecord(x, node, IPXACT2009scalaxb.fromXML[String](x, IPXACT2009scalaxb.ElemName(node) :: stack)) } map { "@{http://www.spiritconsortium.org/XMLSchema/SPIRIT/1685-2009}maximum" -> _ },
        (node \ "@{http://www.spiritconsortium.org/XMLSchema/SPIRIT/1685-2009}rangeType").headOption map { x => IPXACT2009scalaxb.DataRecord(x, node, IPXACT2009scalaxb.fromXML[RangeTypeType](x, IPXACT2009scalaxb.ElemName(node) :: stack)) } orElse Some(IPXACT2009scalaxb.DataRecord(None, None, IPXACT2009scalaxb.fromXML[RangeTypeType](scala.xml.Text("int"), IPXACT2009scalaxb.ElemName(node) :: stack))) map { "@{http://www.spiritconsortium.org/XMLSchema/SPIRIT/1685-2009}rangeType" -> _ },
        (node \ "@{http://www.spiritconsortium.org/XMLSchema/SPIRIT/1685-2009}prompt").headOption map { x => IPXACT2009scalaxb.DataRecord(x, node, IPXACT2009scalaxb.fromXML[String](x, IPXACT2009scalaxb.ElemName(node) :: stack)) } map { "@{http://www.spiritconsortium.org/XMLSchema/SPIRIT/1685-2009}prompt" -> _ }
        ).flatten[(String, IPXACT2009scalaxb.DataRecord[Any])] ::: (node match {
          case elem: scala.xml.Elem =>
            elem.attributes.toList flatMap {
              case scala.xml.PrefixedAttribute(pre, key, value, _) if pre == elem.scope.getPrefix("http://www.spiritconsortium.org/XMLSchema/SPIRIT/1685-2009") &&
                key == "format" => Nil
              case scala.xml.PrefixedAttribute(pre, key, value, _) if pre == elem.scope.getPrefix("http://www.spiritconsortium.org/XMLSchema/SPIRIT/1685-2009") &&
                key == "resolve" => Nil
              case scala.xml.PrefixedAttribute(pre, key, value, _) if pre == elem.scope.getPrefix("http://www.spiritconsortium.org/XMLSchema/SPIRIT/1685-2009") &&
                key == "id" => Nil
              case scala.xml.PrefixedAttribute(pre, key, value, _) if pre == elem.scope.getPrefix("http://www.spiritconsortium.org/XMLSchema/SPIRIT/1685-2009") &&
                key == "dependency" => Nil
              case scala.xml.PrefixedAttribute(pre, key, value, _) if pre == elem.scope.getPrefix("http://www.spiritconsortium.org/XMLSchema/SPIRIT/1685-2009") &&
                key == "choiceRef" => Nil
              case scala.xml.PrefixedAttribute(pre, key, value, _) if pre == elem.scope.getPrefix("http://www.spiritconsortium.org/XMLSchema/SPIRIT/1685-2009") &&
                key == "order" => Nil
              case scala.xml.PrefixedAttribute(pre, key, value, _) if pre == elem.scope.getPrefix("http://www.spiritconsortium.org/XMLSchema/SPIRIT/1685-2009") &&
                key == "configGroups" => Nil
              case scala.xml.PrefixedAttribute(pre, key, value, _) if pre == elem.scope.getPrefix("http://www.spiritconsortium.org/XMLSchema/SPIRIT/1685-2009") &&
                key == "bitStringLength" => Nil
              case scala.xml.PrefixedAttribute(pre, key, value, _) if pre == elem.scope.getPrefix("http://www.spiritconsortium.org/XMLSchema/SPIRIT/1685-2009") &&
                key == "minimum" => Nil
              case scala.xml.PrefixedAttribute(pre, key, value, _) if pre == elem.scope.getPrefix("http://www.spiritconsortium.org/XMLSchema/SPIRIT/1685-2009") &&
                key == "maximum" => Nil
              case scala.xml.PrefixedAttribute(pre, key, value, _) if pre == elem.scope.getPrefix("http://www.spiritconsortium.org/XMLSchema/SPIRIT/1685-2009") &&
                key == "rangeType" => Nil
              case scala.xml.PrefixedAttribute(pre, key, value, _) if pre == elem.scope.getPrefix("http://www.spiritconsortium.org/XMLSchema/SPIRIT/1685-2009") &&
                key == "prompt" => Nil
              case scala.xml.UnprefixedAttribute(key, value, _) =>
                List(("@" + key, IPXACT2009scalaxb.DataRecord(None, Some(key), value.text)))
              case scala.xml.PrefixedAttribute(pre, key, value, _) =>
                val ns = elem.scope.getURI(pre)
                List(("@{" + ns + "}" + key, IPXACT2009scalaxb.DataRecord(Option[String](ns), Some(key), value.text)))
              case _ => Nil
            }
          case _ => Nil
        }): _*)))
      case _ => Left("reads failed: seq must be scala.xml.Node")
    }
    
    override def writesAttribute(__obj: Disabled, __scope: scala.xml.NamespaceBinding): scala.xml.MetaData = {
      var attr: scala.xml.MetaData  = scala.xml.Null
      __obj.attributes.toList map {
        case ("@{http://www.spiritconsortium.org/XMLSchema/SPIRIT/1685-2009}format", _) => if (__obj.spiritformat.toString != "bool") attr = scala.xml.Attribute(__scope.getPrefix("http://www.spiritconsortium.org/XMLSchema/SPIRIT/1685-2009"), "format", __obj.spiritformat.toString, attr)
        case ("@{http://www.spiritconsortium.org/XMLSchema/SPIRIT/1685-2009}resolve", _) => __obj.spiritresolve foreach { x => attr = scala.xml.Attribute(__scope.getPrefix("http://www.spiritconsortium.org/XMLSchema/SPIRIT/1685-2009"), "resolve", x.toString, attr) }
        case ("@{http://www.spiritconsortium.org/XMLSchema/SPIRIT/1685-2009}id", _) => __obj.spiritid foreach { x => attr = scala.xml.Attribute(__scope.getPrefix("http://www.spiritconsortium.org/XMLSchema/SPIRIT/1685-2009"), "id", x.toString, attr) }
        case ("@{http://www.spiritconsortium.org/XMLSchema/SPIRIT/1685-2009}dependency", _) => __obj.spiritdependency foreach { x => attr = scala.xml.Attribute(__scope.getPrefix("http://www.spiritconsortium.org/XMLSchema/SPIRIT/1685-2009"), "dependency", x.toString, attr) }
        case ("@{http://www.spiritconsortium.org/XMLSchema/SPIRIT/1685-2009}choiceRef", _) => __obj.spiritchoiceRef foreach { x => attr = scala.xml.Attribute(__scope.getPrefix("http://www.spiritconsortium.org/XMLSchema/SPIRIT/1685-2009"), "choiceRef", x.toString, attr) }
        case ("@{http://www.spiritconsortium.org/XMLSchema/SPIRIT/1685-2009}order", _) => __obj.spiritorder foreach { x => attr = scala.xml.Attribute(__scope.getPrefix("http://www.spiritconsortium.org/XMLSchema/SPIRIT/1685-2009"), "order", x.toString, attr) }
        case ("@{http://www.spiritconsortium.org/XMLSchema/SPIRIT/1685-2009}configGroups", _) => __obj.spiritconfigGroups foreach { x => attr = scala.xml.Attribute(__scope.getPrefix("http://www.spiritconsortium.org/XMLSchema/SPIRIT/1685-2009"), "configGroups", x.toString, attr) }
        case ("@{http://www.spiritconsortium.org/XMLSchema/SPIRIT/1685-2009}bitStringLength", _) => __obj.spiritbitStringLength foreach { x => attr = scala.xml.Attribute(__scope.getPrefix("http://www.spiritconsortium.org/XMLSchema/SPIRIT/1685-2009"), "bitStringLength", x.toString, attr) }
        case ("@{http://www.spiritconsortium.org/XMLSchema/SPIRIT/1685-2009}minimum", _) => __obj.spiritminimum foreach { x => attr = scala.xml.Attribute(__scope.getPrefix("http://www.spiritconsortium.org/XMLSchema/SPIRIT/1685-2009"), "minimum", x.toString, attr) }
        case ("@{http://www.spiritconsortium.org/XMLSchema/SPIRIT/1685-2009}maximum", _) => __obj.spiritmaximum foreach { x => attr = scala.xml.Attribute(__scope.getPrefix("http://www.spiritconsortium.org/XMLSchema/SPIRIT/1685-2009"), "maximum", x.toString, attr) }
        case ("@{http://www.spiritconsortium.org/XMLSchema/SPIRIT/1685-2009}rangeType", _) => if (__obj.spiritrangeType.toString != "int") attr = scala.xml.Attribute(__scope.getPrefix("http://www.spiritconsortium.org/XMLSchema/SPIRIT/1685-2009"), "rangeType", __obj.spiritrangeType.toString, attr)
        case ("@{http://www.spiritconsortium.org/XMLSchema/SPIRIT/1685-2009}prompt", _) => __obj.spiritprompt foreach { x => attr = scala.xml.Attribute(__scope.getPrefix("http://www.spiritconsortium.org/XMLSchema/SPIRIT/1685-2009"), "prompt", x.toString, attr) }
        case (key, x) => attr = scala.xml.Attribute((x.namespace map { __scope.getPrefix(_) }).orNull, x.key.orNull, x.value.toString, attr)
      }
      attr
    }

    def writesChildNodes(__obj: Disabled, __scope: scala.xml.NamespaceBinding): Seq[scala.xml.Node] =
      Seq(scala.xml.Text(__obj.value.toString))

  }

  trait Default_SourceNameFormat extends IPXACT2009scalaxb.XMLFormat[SourceName] with IPXACT2009scalaxb.CanWriteChildNodes[SourceName] {
    val targetNamespace: Option[String] = Some("http://www.spiritconsortium.org/XMLSchema/SPIRIT/1685-2009")
    def reads(seq: scala.xml.NodeSeq, stack: List[IPXACT2009scalaxb.ElemName]): Either[String, SourceName] = seq match {
      case node: scala.xml.Node => Right(SourceName(IPXACT2009scalaxb.fromXML[String](node, IPXACT2009scalaxb.ElemName(node) :: stack)))
      case _ => Left("reads failed: seq must be scala.xml.Node")
    }
    
    def writesChildNodes(__obj: SourceName, __scope: scala.xml.NamespaceBinding): Seq[scala.xml.Node] =
      Seq(scala.xml.Text(__obj.value.toString))

  }
  trait Default_SourceFileFormat extends IPXACT2009scalaxb.ElemNameParser[SourceFile] with _FileTypeGroupFormat {
    val targetNamespace: Option[String] = Some("http://www.spiritconsortium.org/XMLSchema/SPIRIT/1685-2009")
    
    def parser(node: scala.xml.Node, stack: List[IPXACT2009scalaxb.ElemName]): Parser[SourceFile] =
      phrase((IPXACT2009scalaxb.ElemName(Some("http://www.spiritconsortium.org/XMLSchema/SPIRIT/1685-2009"), "sourceName")) ~
      (parseFileTypeGroup(node, IPXACT2009scalaxb.ElemName(node) :: stack)) ^^
      { case p1 ~ p2 =>
      SourceFile(IPXACT2009scalaxb.fromXML[SourceName](p1, IPXACT2009scalaxb.ElemName(node) :: stack),
        p2) })
    
    def writesChildNodes(__obj: SourceFile, __scope: scala.xml.NamespaceBinding): Seq[scala.xml.Node] =
      Seq.concat(IPXACT2009scalaxb.toXML[SourceName](__obj.sourceName, Some("http://www.spiritconsortium.org/XMLSchema/SPIRIT/1685-2009"), Some("sourceName"), __scope, false),
        (Some(__obj.fileTypeOption2) map {x => IPXACT2009scalaxb.toXML[IPXACT2009scalaxb.DataRecord[Any]](x, x.namespace, x.key, __scope, false)}).get)

  }

  trait Default_FunctionTypeFormat extends IPXACT2009scalaxb.ElemNameParser[FunctionType] {
    val targetNamespace: Option[String] = Some("http://www.spiritconsortium.org/XMLSchema/SPIRIT/1685-2009")
    
    def parser(node: scala.xml.Node, stack: List[IPXACT2009scalaxb.ElemName]): Parser[FunctionType] =
      phrase(opt(IPXACT2009scalaxb.ElemName(Some("http://www.spiritconsortium.org/XMLSchema/SPIRIT/1685-2009"), "entryPoint")) ~
      (IPXACT2009scalaxb.ElemName(Some("http://www.spiritconsortium.org/XMLSchema/SPIRIT/1685-2009"), "fileRef")) ~
      opt(IPXACT2009scalaxb.ElemName(Some("http://www.spiritconsortium.org/XMLSchema/SPIRIT/1685-2009"), "returnType")) ~
      safeRep(IPXACT2009scalaxb.ElemName(Some("http://www.spiritconsortium.org/XMLSchema/SPIRIT/1685-2009"), "argument")) ~
      opt(IPXACT2009scalaxb.ElemName(Some("http://www.spiritconsortium.org/XMLSchema/SPIRIT/1685-2009"), "disabled")) ~
      safeRep(IPXACT2009scalaxb.ElemName(Some("http://www.spiritconsortium.org/XMLSchema/SPIRIT/1685-2009"), "sourceFile")) ^^
      { case p1 ~ p2 ~ p3 ~ p4 ~ p5 ~ p6 =>
      FunctionType(p1.headOption map { IPXACT2009scalaxb.fromXML[String](_, IPXACT2009scalaxb.ElemName(node) :: stack) },
        IPXACT2009scalaxb.fromXML[String](p2, IPXACT2009scalaxb.ElemName(node) :: stack),
        p3.headOption map { IPXACT2009scalaxb.fromXML[ReturnType](_, IPXACT2009scalaxb.ElemName(node) :: stack) },
        p4 map { IPXACT2009scalaxb.fromXML[Argument](_, IPXACT2009scalaxb.ElemName(node) :: stack) },
        p5.headOption map { IPXACT2009scalaxb.fromXML[Disabled](_, IPXACT2009scalaxb.ElemName(node) :: stack) },
        p6 map { IPXACT2009scalaxb.fromXML[SourceFile](_, IPXACT2009scalaxb.ElemName(node) :: stack) },
        scala.collection.immutable.ListMap(List(
        (node \ "@{http://www.spiritconsortium.org/XMLSchema/SPIRIT/1685-2009}replicate").headOption map { x => IPXACT2009scalaxb.DataRecord(x, node, IPXACT2009scalaxb.fromXML[Boolean](x, IPXACT2009scalaxb.ElemName(node) :: stack)) } orElse Some(IPXACT2009scalaxb.DataRecord(None, None, IPXACT2009scalaxb.fromXML[Boolean](scala.xml.Text("false"), IPXACT2009scalaxb.ElemName(node) :: stack))) map { "@replicate" -> _ }
        ).flatten[(String, IPXACT2009scalaxb.DataRecord[Any])]: _*)) })
    
    override def writesAttribute(__obj: FunctionType, __scope: scala.xml.NamespaceBinding): scala.xml.MetaData = {
      var attr: scala.xml.MetaData  = scala.xml.Null
      __obj.attributes.toList map {
        case ("@replicate", _) => if (__obj.replicate.toString != "false") attr = scala.xml.Attribute(__scope.getPrefix("http://www.spiritconsortium.org/XMLSchema/SPIRIT/1685-2009"), "replicate", __obj.replicate.toString, attr)
        case (key, x) => attr = scala.xml.Attribute((x.namespace map { __scope.getPrefix(_) }).orNull, x.key.orNull, x.value.toString, attr)
      }
      attr
    }

    def writesChildNodes(__obj: FunctionType, __scope: scala.xml.NamespaceBinding): Seq[scala.xml.Node] =
      Seq.concat(__obj.entryPoint map { IPXACT2009scalaxb.toXML[String](_, Some("http://www.spiritconsortium.org/XMLSchema/SPIRIT/1685-2009"), Some("entryPoint"), __scope, false) } getOrElse {Nil},
        IPXACT2009scalaxb.toXML[String](__obj.fileRef, Some("http://www.spiritconsortium.org/XMLSchema/SPIRIT/1685-2009"), Some("fileRef"), __scope, false),
        __obj.returnType map { IPXACT2009scalaxb.toXML[ReturnType](_, Some("http://www.spiritconsortium.org/XMLSchema/SPIRIT/1685-2009"), Some("returnType"), __scope, false) } getOrElse {Nil},
        __obj.argument flatMap { IPXACT2009scalaxb.toXML[Argument](_, Some("http://www.spiritconsortium.org/XMLSchema/SPIRIT/1685-2009"), Some("argument"), __scope, false) },
        __obj.disabled map { IPXACT2009scalaxb.toXML[Disabled](_, Some("http://www.spiritconsortium.org/XMLSchema/SPIRIT/1685-2009"), Some("disabled"), __scope, false) } getOrElse {Nil},
        __obj.sourceFile flatMap { IPXACT2009scalaxb.toXML[SourceFile](_, Some("http://www.spiritconsortium.org/XMLSchema/SPIRIT/1685-2009"), Some("sourceFile"), __scope, false) })

  }

  trait Default_FileSetTypeFormat extends IPXACT2009scalaxb.ElemNameParser[FileSetType] with _NameGroupGroupFormat {
    val targetNamespace: Option[String] = Some("http://www.spiritconsortium.org/XMLSchema/SPIRIT/1685-2009")
    
    override def typeName: Option[String] = Some("fileSetType")

    def parser(node: scala.xml.Node, stack: List[IPXACT2009scalaxb.ElemName]): Parser[FileSetType] =
      phrase((parseNameGroupGroup(node, IPXACT2009scalaxb.ElemName(node) :: stack)) ~
      safeRep(IPXACT2009scalaxb.ElemName(Some("http://www.spiritconsortium.org/XMLSchema/SPIRIT/1685-2009"), "group")) ~
      safeRep(IPXACT2009scalaxb.ElemName(Some("http://www.spiritconsortium.org/XMLSchema/SPIRIT/1685-2009"), "file")) ~
      safeRep(IPXACT2009scalaxb.ElemName(Some("http://www.spiritconsortium.org/XMLSchema/SPIRIT/1685-2009"), "defaultFileBuilder")) ~
      safeRep(IPXACT2009scalaxb.ElemName(Some("http://www.spiritconsortium.org/XMLSchema/SPIRIT/1685-2009"), "dependency")) ~
      safeRep(IPXACT2009scalaxb.ElemName(Some("http://www.spiritconsortium.org/XMLSchema/SPIRIT/1685-2009"), "function")) ~
      opt(IPXACT2009scalaxb.ElemName(Some("http://www.spiritconsortium.org/XMLSchema/SPIRIT/1685-2009"), "vendorExtensions")) ^^
      { case p1 ~ p2 ~ p3 ~ p4 ~ p5 ~ p6 ~ p7 =>
      FileSetType(p1,
        p2 map { IPXACT2009scalaxb.fromXML[String](_, IPXACT2009scalaxb.ElemName(node) :: stack) },
        p3 map { IPXACT2009scalaxb.fromXML[File](_, IPXACT2009scalaxb.ElemName(node) :: stack) },
        p4 map { IPXACT2009scalaxb.fromXML[FileBuilderType](_, IPXACT2009scalaxb.ElemName(node) :: stack) },
        p5 map { IPXACT2009scalaxb.fromXML[String](_, IPXACT2009scalaxb.ElemName(node) :: stack) },
        p6 map { IPXACT2009scalaxb.fromXML[FunctionType](_, IPXACT2009scalaxb.ElemName(node) :: stack) },
        p7.headOption map { IPXACT2009scalaxb.fromXML[VendorExtensions](_, IPXACT2009scalaxb.ElemName(node) :: stack) }) })
    
    def writesChildNodes(__obj: FileSetType, __scope: scala.xml.NamespaceBinding): Seq[scala.xml.Node] =
      Seq.concat(IPXACT2009scalaxb.toXML[NameGroupSequence](__obj.nameGroupSequence1, None, Some("nameGroupSequence1"), __scope, false),
        __obj.group flatMap { IPXACT2009scalaxb.toXML[String](_, Some("http://www.spiritconsortium.org/XMLSchema/SPIRIT/1685-2009"), Some("group"), __scope, false) },
        __obj.file flatMap { IPXACT2009scalaxb.toXML[File](_, Some("http://www.spiritconsortium.org/XMLSchema/SPIRIT/1685-2009"), Some("file"), __scope, false) },
        __obj.defaultFileBuilder flatMap { IPXACT2009scalaxb.toXML[FileBuilderType](_, Some("http://www.spiritconsortium.org/XMLSchema/SPIRIT/1685-2009"), Some("defaultFileBuilder"), __scope, false) },
        __obj.dependency flatMap { IPXACT2009scalaxb.toXML[String](_, Some("http://www.spiritconsortium.org/XMLSchema/SPIRIT/1685-2009"), Some("dependency"), __scope, false) },
        __obj.function flatMap { IPXACT2009scalaxb.toXML[FunctionType](_, Some("http://www.spiritconsortium.org/XMLSchema/SPIRIT/1685-2009"), Some("function"), __scope, false) },
        __obj.vendorExtensions map { IPXACT2009scalaxb.toXML[VendorExtensions](_, Some("http://www.spiritconsortium.org/XMLSchema/SPIRIT/1685-2009"), Some("vendorExtensions"), __scope, false) } getOrElse {Nil})

  }

  def build_DataTypeTypeFormat = new Default_DataTypeTypeFormat {}
  trait Default_DataTypeTypeFormat extends IPXACT2009scalaxb.XMLFormat[DataTypeType] {
    val targetNamespace: Option[String] = Some("http://www.spiritconsortium.org/XMLSchema/SPIRIT/1685-2009")
    
    def fromString(value: String, scope: scala.xml.NamespaceBinding): DataTypeType =
        (fromString0(value, scope)).apply(IPXACT2009scalaxb.fromXML[String](scala.xml.Text(value)))

    private def fromString0(value: String, scope: scala.xml.NamespaceBinding): PartialFunction[Any, DataTypeType] = {
      case x: String if x == IPXACT2009scalaxb.fromXML[String](scala.xml.Text("int")) => IntType
      case x: String if x == IPXACT2009scalaxb.fromXML[String](scala.xml.Text("unsigned int")) => Unsignedint
      case x: String if x == IPXACT2009scalaxb.fromXML[String](scala.xml.Text("long")) => LongType
      case x: String if x == IPXACT2009scalaxb.fromXML[String](scala.xml.Text("unsigned long")) => Unsignedlong
      case x: String if x == IPXACT2009scalaxb.fromXML[String](scala.xml.Text("float")) => FloatType
      case x: String if x == IPXACT2009scalaxb.fromXML[String](scala.xml.Text("double")) => DoubleType
      case x: String if x == IPXACT2009scalaxb.fromXML[String](scala.xml.Text("char *")) => Charu42
      case x: String if x == IPXACT2009scalaxb.fromXML[String](scala.xml.Text("void *")) => Voidu42

    }



    def reads(seq: scala.xml.NodeSeq, stack: List[IPXACT2009scalaxb.ElemName]): Either[String, DataTypeType] = seq match {
      case elem: scala.xml.Elem => Right(fromString(elem.text, elem.scope))
      case _ => Right(fromString(seq.text, scala.xml.TopScope))
    }
    
    def writes(__obj: DataTypeType, __namespace: Option[String], __elementLabel: Option[String],
        __scope: scala.xml.NamespaceBinding, __typeAttribute: Boolean): scala.xml.NodeSeq =
      scala.xml.Elem(IPXACT2009scalaxb.Helper.getPrefix(__namespace, __scope).orNull,
        __elementLabel getOrElse { sys.error("missing element label.") },
        scala.xml.Null, __scope, true, scala.xml.Text(__obj.toString))
  }
  def build_FileTypeFormat = new Default_FileTypeFormat {}
  trait Default_FileTypeFormat extends IPXACT2009scalaxb.XMLFormat[FileType] {
    val targetNamespace: Option[String] = Some("http://www.spiritconsortium.org/XMLSchema/SPIRIT/1685-2009")
    
    def fromString(value: String, scope: scala.xml.NamespaceBinding): FileType =
        (fromString0(value, scope)).apply(IPXACT2009scalaxb.fromXML[String](scala.xml.Text(value)))

    private def fromString0(value: String, scope: scala.xml.NamespaceBinding): PartialFunction[Any, FileType] = {
      case x: String if x == IPXACT2009scalaxb.fromXML[String](scala.xml.Text("unknown")) => Unknown
      case x: String if x == IPXACT2009scalaxb.fromXML[String](scala.xml.Text("cSource")) => CSource
      case x: String if x == IPXACT2009scalaxb.fromXML[String](scala.xml.Text("cppSource")) => CppSource
      case x: String if x == IPXACT2009scalaxb.fromXML[String](scala.xml.Text("asmSource")) => AsmSource
      case x: String if x == IPXACT2009scalaxb.fromXML[String](scala.xml.Text("vhdlSource")) => VhdlSource
      case x: String if x == IPXACT2009scalaxb.fromXML[String](scala.xml.Text("vhdlSource-87")) => VhdlSourceu4587
      case x: String if x == IPXACT2009scalaxb.fromXML[String](scala.xml.Text("vhdlSource-93")) => VhdlSourceu4593
      case x: String if x == IPXACT2009scalaxb.fromXML[String](scala.xml.Text("verilogSource")) => VerilogSource
      case x: String if x == IPXACT2009scalaxb.fromXML[String](scala.xml.Text("verilogSource-95")) => VerilogSourceu4595
      case x: String if x == IPXACT2009scalaxb.fromXML[String](scala.xml.Text("verilogSource-2001")) => VerilogSourceu452001
      case x: String if x == IPXACT2009scalaxb.fromXML[String](scala.xml.Text("swObject")) => SwObject
      case x: String if x == IPXACT2009scalaxb.fromXML[String](scala.xml.Text("swObjectLibrary")) => SwObjectLibrary
      case x: String if x == IPXACT2009scalaxb.fromXML[String](scala.xml.Text("vhdlBinaryLibrary")) => VhdlBinaryLibrary
      case x: String if x == IPXACT2009scalaxb.fromXML[String](scala.xml.Text("verilogBinaryLibrary")) => VerilogBinaryLibrary
      case x: String if x == IPXACT2009scalaxb.fromXML[String](scala.xml.Text("unelaboratedHdl")) => UnelaboratedHdl
      case x: String if x == IPXACT2009scalaxb.fromXML[String](scala.xml.Text("executableHdl")) => ExecutableHdl
      case x: String if x == IPXACT2009scalaxb.fromXML[String](scala.xml.Text("systemVerilogSource")) => SystemVerilogSource
      case x: String if x == IPXACT2009scalaxb.fromXML[String](scala.xml.Text("systemVerilogSource-3.0")) => SystemVerilogSourceu453u460
      case x: String if x == IPXACT2009scalaxb.fromXML[String](scala.xml.Text("systemVerilogSource-3.1")) => SystemVerilogSourceu453u461
      case x: String if x == IPXACT2009scalaxb.fromXML[String](scala.xml.Text("systemCSource")) => SystemCSource
      case x: String if x == IPXACT2009scalaxb.fromXML[String](scala.xml.Text("systemCSource-2.0")) => SystemCSourceu452u460
      case x: String if x == IPXACT2009scalaxb.fromXML[String](scala.xml.Text("systemCSource-2.0.1")) => SystemCSourceu452u460u461
      case x: String if x == IPXACT2009scalaxb.fromXML[String](scala.xml.Text("systemCSource-2.1")) => SystemCSourceu452u461
      case x: String if x == IPXACT2009scalaxb.fromXML[String](scala.xml.Text("systemCSource-2.2")) => SystemCSourceu452u462
      case x: String if x == IPXACT2009scalaxb.fromXML[String](scala.xml.Text("veraSource")) => VeraSource
      case x: String if x == IPXACT2009scalaxb.fromXML[String](scala.xml.Text("eSource")) => ESource
      case x: String if x == IPXACT2009scalaxb.fromXML[String](scala.xml.Text("perlSource")) => PerlSource
      case x: String if x == IPXACT2009scalaxb.fromXML[String](scala.xml.Text("tclSource")) => TclSource
      case x: String if x == IPXACT2009scalaxb.fromXML[String](scala.xml.Text("OVASource")) => OVASource
      case x: String if x == IPXACT2009scalaxb.fromXML[String](scala.xml.Text("SVASource")) => SVASource
      case x: String if x == IPXACT2009scalaxb.fromXML[String](scala.xml.Text("pslSource")) => PslSource
      case x: String if x == IPXACT2009scalaxb.fromXML[String](scala.xml.Text("systemVerilogSource-3.1a")) => SystemVerilogSourceu453u461a
      case x: String if x == IPXACT2009scalaxb.fromXML[String](scala.xml.Text("SDC")) => SDC

    }



    def reads(seq: scala.xml.NodeSeq, stack: List[IPXACT2009scalaxb.ElemName]): Either[String, FileType] = seq match {
      case elem: scala.xml.Elem => Right(fromString(elem.text, elem.scope))
      case _ => Right(fromString(seq.text, scala.xml.TopScope))
    }
    
    def writes(__obj: FileType, __namespace: Option[String], __elementLabel: Option[String],
        __scope: scala.xml.NamespaceBinding, __typeAttribute: Boolean): scala.xml.NodeSeq =
      scala.xml.Elem(IPXACT2009scalaxb.Helper.getPrefix(__namespace, __scope).orNull,
        __elementLabel getOrElse { sys.error("missing element label.") },
        scala.xml.Null, __scope, true, scala.xml.Text(__obj.toString))
  }

/** The type of a file refenced by IP-XACT.
Either: fileType - a known IP-XACT file type, or userFileType - a file type not yet known by IP-XACT. If multiple types are specified, the order is important. The first type is the primary type of the file and the latter types are types that may be embedded in the file. For example a Verilog file containing PSL assertions.
*/
  trait _FileTypeGroupFormat extends IPXACT2009scalaxb.AnyElemNameParser {
    def parseFileTypeGroup(node: scala.xml.Node, stack: List[IPXACT2009scalaxb.ElemName]): Parser[IPXACT2009scalaxb.DataRecord[Any]] =
      (((IPXACT2009scalaxb.ElemName(Some("http://www.spiritconsortium.org/XMLSchema/SPIRIT/1685-2009"), "fileType")) ^^
      (x => IPXACT2009scalaxb.DataRecord(x.namespace, Some(x.name), IPXACT2009scalaxb.fromXML[String](x, IPXACT2009scalaxb.ElemName(node) :: stack)))) |
      ((IPXACT2009scalaxb.ElemName(Some("http://www.spiritconsortium.org/XMLSchema/SPIRIT/1685-2009"), "userFileType")) ^^
      (x => IPXACT2009scalaxb.DataRecord(x.namespace, Some(x.name), IPXACT2009scalaxb.fromXML[String](x, IPXACT2009scalaxb.ElemName(node) :: stack)))))
  
    def parseFileTypeGroup(node: scala.xml.Node, stack: List[IPXACT2009scalaxb.ElemName], wrap: Boolean): Parser[IPXACT2009scalaxb.DataRecord[Any]] =
      (((IPXACT2009scalaxb.ElemName(Some("http://www.spiritconsortium.org/XMLSchema/SPIRIT/1685-2009"), "fileType")) ^^
      (x => IPXACT2009scalaxb.DataRecord(x.namespace, Some(x.name), IPXACT2009scalaxb.fromXML[String](x, IPXACT2009scalaxb.ElemName(node) :: stack)))) |
      ((IPXACT2009scalaxb.ElemName(Some("http://www.spiritconsortium.org/XMLSchema/SPIRIT/1685-2009"), "userFileType")) ^^
      (x => IPXACT2009scalaxb.DataRecord(x.namespace, Some(x.name), IPXACT2009scalaxb.fromXML[String](x, IPXACT2009scalaxb.ElemName(node) :: stack)))))
    
    def parsemixedFileTypeGroup(node: scala.xml.Node, stack: List[IPXACT2009scalaxb.ElemName]): Parser[Seq[IPXACT2009scalaxb.DataRecord[Any]]] =
      (((((IPXACT2009scalaxb.ElemName(Some("http://www.spiritconsortium.org/XMLSchema/SPIRIT/1685-2009"), "fileType")) ^^
      (x => IPXACT2009scalaxb.DataRecord(x.namespace, Some(x.name), IPXACT2009scalaxb.fromXML[String](x, IPXACT2009scalaxb.ElemName(node) :: stack)))) ~
      optTextRecord) ^^ 
        { case p1 ~ p2 => Seq.concat(Seq(p1),
        p2.toList) }) ||| 
      ((((IPXACT2009scalaxb.ElemName(Some("http://www.spiritconsortium.org/XMLSchema/SPIRIT/1685-2009"), "userFileType")) ^^
      (x => IPXACT2009scalaxb.DataRecord(x.namespace, Some(x.name), IPXACT2009scalaxb.fromXML[String](x, IPXACT2009scalaxb.ElemName(node) :: stack)))) ~
      optTextRecord) ^^ 
        { case p1 ~ p2 => Seq.concat(Seq(p1),
        p2.toList) }))
  }

  trait Default_GeneratorChainSelectorFormat extends IPXACT2009scalaxb.ElemNameParser[GeneratorChainSelector] {
    val targetNamespace: Option[String] = Some("http://www.spiritconsortium.org/XMLSchema/SPIRIT/1685-2009")
    
    def parser(node: scala.xml.Node, stack: List[IPXACT2009scalaxb.ElemName]): Parser[GeneratorChainSelector] =
      phrase((((IPXACT2009scalaxb.ElemName(Some("http://www.spiritconsortium.org/XMLSchema/SPIRIT/1685-2009"), "groupSelector")) ^^
      (x => IPXACT2009scalaxb.DataRecord(x.namespace, Some(x.name), IPXACT2009scalaxb.fromXML[GroupSelector](x, IPXACT2009scalaxb.ElemName(node) :: stack)))) |
      ((IPXACT2009scalaxb.ElemName(Some("http://www.spiritconsortium.org/XMLSchema/SPIRIT/1685-2009"), "generatorChainRef")) ^^
      (x => IPXACT2009scalaxb.DataRecord(x.namespace, Some(x.name), IPXACT2009scalaxb.fromXML[LibraryRefType](x, IPXACT2009scalaxb.ElemName(node) :: stack))))) ^^
      { case p1 =>
      GeneratorChainSelector(p1,
        scala.collection.immutable.ListMap(List(
        (node \ "@{http://www.spiritconsortium.org/XMLSchema/SPIRIT/1685-2009}unique").headOption map { x => IPXACT2009scalaxb.DataRecord(x, node, IPXACT2009scalaxb.fromXML[Boolean](x, IPXACT2009scalaxb.ElemName(node) :: stack)) } orElse Some(IPXACT2009scalaxb.DataRecord(None, None, IPXACT2009scalaxb.fromXML[Boolean](scala.xml.Text("false"), IPXACT2009scalaxb.ElemName(node) :: stack))) map { "@unique" -> _ }
        ).flatten[(String, IPXACT2009scalaxb.DataRecord[Any])]: _*)) })
    
    override def writesAttribute(__obj: GeneratorChainSelector, __scope: scala.xml.NamespaceBinding): scala.xml.MetaData = {
      var attr: scala.xml.MetaData  = scala.xml.Null
      __obj.attributes.toList map {
        case ("@unique", _) => if (__obj.unique.toString != "false") attr = scala.xml.Attribute(__scope.getPrefix("http://www.spiritconsortium.org/XMLSchema/SPIRIT/1685-2009"), "unique", __obj.unique.toString, attr)
        case (key, x) => attr = scala.xml.Attribute((x.namespace map { __scope.getPrefix(_) }).orNull, x.key.orNull, x.value.toString, attr)
      }
      attr
    }

    def writesChildNodes(__obj: GeneratorChainSelector, __scope: scala.xml.NamespaceBinding): Seq[scala.xml.Node] =
      ((Some(__obj.generatorchainselectoroption) map {x => IPXACT2009scalaxb.toXML[IPXACT2009scalaxb.DataRecord[GeneratorChainSelectorOption]](x, x.namespace, x.key, __scope, false)}).get)
  }

  trait Default_GeneratorChainFormat extends IPXACT2009scalaxb.ElemNameParser[GeneratorChain] with _VersionedIdentifierGroupFormat {
    val targetNamespace: Option[String] = Some("http://www.spiritconsortium.org/XMLSchema/SPIRIT/1685-2009")
    
    def parser(node: scala.xml.Node, stack: List[IPXACT2009scalaxb.ElemName]): Parser[GeneratorChain] =
      phrase((parseVersionedIdentifierGroup(node, IPXACT2009scalaxb.ElemName(node) :: stack)) ~
      safeRep(((IPXACT2009scalaxb.ElemName(Some("http://www.spiritconsortium.org/XMLSchema/SPIRIT/1685-2009"), "generatorChainSelector")) ^^
      (x => IPXACT2009scalaxb.DataRecord(x.namespace, Some(x.name), IPXACT2009scalaxb.fromXML[GeneratorChainSelector](x, IPXACT2009scalaxb.ElemName(node) :: stack)))) |
      ((IPXACT2009scalaxb.ElemName(Some("http://www.spiritconsortium.org/XMLSchema/SPIRIT/1685-2009"), "componentGeneratorSelector")) ^^
      (x => IPXACT2009scalaxb.DataRecord(x.namespace, Some(x.name), IPXACT2009scalaxb.fromXML[GeneratorSelectorType](x, IPXACT2009scalaxb.ElemName(node) :: stack)))) |
      ((IPXACT2009scalaxb.ElemName(Some("http://www.spiritconsortium.org/XMLSchema/SPIRIT/1685-2009"), "generator")) ^^
      (x => IPXACT2009scalaxb.DataRecord(x.namespace, Some(x.name), IPXACT2009scalaxb.fromXML[Generator](x, IPXACT2009scalaxb.ElemName(node) :: stack))))) ~
      safeRep(IPXACT2009scalaxb.ElemName(Some("http://www.spiritconsortium.org/XMLSchema/SPIRIT/1685-2009"), "chainGroup")) ~
      opt(IPXACT2009scalaxb.ElemName(Some("http://www.spiritconsortium.org/XMLSchema/SPIRIT/1685-2009"), "displayName")) ~
      opt(IPXACT2009scalaxb.ElemName(Some("http://www.spiritconsortium.org/XMLSchema/SPIRIT/1685-2009"), "description")) ~
      opt(IPXACT2009scalaxb.ElemName(Some("http://www.spiritconsortium.org/XMLSchema/SPIRIT/1685-2009"), "choices")) ~
      opt(IPXACT2009scalaxb.ElemName(Some("http://www.spiritconsortium.org/XMLSchema/SPIRIT/1685-2009"), "vendorExtensions")) ^^
      { case p1 ~ p2 ~ p3 ~ p4 ~ p5 ~ p6 ~ p7 =>
      GeneratorChain(p1,
        p2,
        p3 map { IPXACT2009scalaxb.fromXML[String](_, IPXACT2009scalaxb.ElemName(node) :: stack) },
        p4.headOption map { IPXACT2009scalaxb.fromXML[String](_, IPXACT2009scalaxb.ElemName(node) :: stack) },
        p5.headOption map { IPXACT2009scalaxb.fromXML[String](_, IPXACT2009scalaxb.ElemName(node) :: stack) },
        p6.headOption map { IPXACT2009scalaxb.fromXML[Choices](_, IPXACT2009scalaxb.ElemName(node) :: stack) },
        p7.headOption map { IPXACT2009scalaxb.fromXML[VendorExtensions](_, IPXACT2009scalaxb.ElemName(node) :: stack) },
        scala.collection.immutable.ListMap(List(
        (node \ "@{http://www.spiritconsortium.org/XMLSchema/SPIRIT/1685-2009}hidden").headOption map { x => IPXACT2009scalaxb.DataRecord(x, node, IPXACT2009scalaxb.fromXML[Boolean](x, IPXACT2009scalaxb.ElemName(node) :: stack)) } orElse Some(IPXACT2009scalaxb.DataRecord(None, None, IPXACT2009scalaxb.fromXML[Boolean](scala.xml.Text("false"), IPXACT2009scalaxb.ElemName(node) :: stack))) map { "@hidden" -> _ }
        ).flatten[(String, IPXACT2009scalaxb.DataRecord[Any])]: _*)) })
    
    override def writesAttribute(__obj: GeneratorChain, __scope: scala.xml.NamespaceBinding): scala.xml.MetaData = {
      var attr: scala.xml.MetaData  = scala.xml.Null
      __obj.attributes.toList map {
        case ("@hidden", _) => if (__obj.hidden.toString != "false") attr = scala.xml.Attribute(__scope.getPrefix("http://www.spiritconsortium.org/XMLSchema/SPIRIT/1685-2009"), "hidden", __obj.hidden.toString, attr)
        case (key, x) => attr = scala.xml.Attribute((x.namespace map { __scope.getPrefix(_) }).orNull, x.key.orNull, x.value.toString, attr)
      }
      attr
    }

    def writesChildNodes(__obj: GeneratorChain, __scope: scala.xml.NamespaceBinding): Seq[scala.xml.Node] =
      Seq.concat(IPXACT2009scalaxb.toXML[VersionedIdentifierSequence](__obj.versionedIdentifierSequence1, None, Some("versionedIdentifierSequence1"), __scope, false),
        __obj.generatorchainoption flatMap { x => IPXACT2009scalaxb.toXML[IPXACT2009scalaxb.DataRecord[GeneratorChainOption]](x, x.namespace, x.key, __scope, false) },
        __obj.chainGroup flatMap { IPXACT2009scalaxb.toXML[String](_, Some("http://www.spiritconsortium.org/XMLSchema/SPIRIT/1685-2009"), Some("chainGroup"), __scope, false) },
        __obj.displayName map { IPXACT2009scalaxb.toXML[String](_, Some("http://www.spiritconsortium.org/XMLSchema/SPIRIT/1685-2009"), Some("displayName"), __scope, false) } getOrElse {Nil},
        __obj.description map { IPXACT2009scalaxb.toXML[String](_, Some("http://www.spiritconsortium.org/XMLSchema/SPIRIT/1685-2009"), Some("description"), __scope, false) } getOrElse {Nil},
        __obj.choices map { IPXACT2009scalaxb.toXML[Choices](_, Some("http://www.spiritconsortium.org/XMLSchema/SPIRIT/1685-2009"), Some("choices"), __scope, false) } getOrElse {Nil},
        __obj.vendorExtensions map { IPXACT2009scalaxb.toXML[VendorExtensions](_, Some("http://www.spiritconsortium.org/XMLSchema/SPIRIT/1685-2009"), Some("vendorExtensions"), __scope, false) } getOrElse {Nil})

  }

  trait Default_GeneratorFormat extends IPXACT2009scalaxb.ElemNameParser[Generator] with _NameGroupGroupFormat {
    val targetNamespace: Option[String] = Some("http://www.spiritconsortium.org/XMLSchema/SPIRIT/1685-2009")
    
    def parser(node: scala.xml.Node, stack: List[IPXACT2009scalaxb.ElemName]): Parser[Generator] =
      phrase((parseNameGroupGroup(node, IPXACT2009scalaxb.ElemName(node) :: stack)) ~
      opt(IPXACT2009scalaxb.ElemName(Some("http://www.spiritconsortium.org/XMLSchema/SPIRIT/1685-2009"), "phase")) ~
      opt(IPXACT2009scalaxb.ElemName(Some("http://www.spiritconsortium.org/XMLSchema/SPIRIT/1685-2009"), "parameters")) ~
      opt(IPXACT2009scalaxb.ElemName(Some("http://www.spiritconsortium.org/XMLSchema/SPIRIT/1685-2009"), "apiType")) ~
      opt(IPXACT2009scalaxb.ElemName(Some("http://www.spiritconsortium.org/XMLSchema/SPIRIT/1685-2009"), "transportMethods")) ~
      (IPXACT2009scalaxb.ElemName(Some("http://www.spiritconsortium.org/XMLSchema/SPIRIT/1685-2009"), "generatorExe")) ~
      opt(IPXACT2009scalaxb.ElemName(Some("http://www.spiritconsortium.org/XMLSchema/SPIRIT/1685-2009"), "vendorExtensions")) ^^
      { case p1 ~ p2 ~ p3 ~ p4 ~ p5 ~ p6 ~ p7 =>
      Generator(p1,
        p2.headOption map { IPXACT2009scalaxb.fromXML[Phase](_, IPXACT2009scalaxb.ElemName(node) :: stack) },
        p3.headOption map { IPXACT2009scalaxb.fromXML[Parameters](_, IPXACT2009scalaxb.ElemName(node) :: stack) },
        p4.headOption map { IPXACT2009scalaxb.fromXML[ApiType](_, IPXACT2009scalaxb.ElemName(node) :: stack) },
        p5.headOption map { IPXACT2009scalaxb.fromXML[TransportMethods](_, IPXACT2009scalaxb.ElemName(node) :: stack) },
        IPXACT2009scalaxb.fromXML[String](p6, IPXACT2009scalaxb.ElemName(node) :: stack),
        p7.headOption map { IPXACT2009scalaxb.fromXML[VendorExtensions](_, IPXACT2009scalaxb.ElemName(node) :: stack) },
        scala.collection.immutable.ListMap(List(
        (node \ "@{http://www.spiritconsortium.org/XMLSchema/SPIRIT/1685-2009}hidden").headOption map { x => IPXACT2009scalaxb.DataRecord(x, node, IPXACT2009scalaxb.fromXML[Boolean](x, IPXACT2009scalaxb.ElemName(node) :: stack)) } orElse Some(IPXACT2009scalaxb.DataRecord(None, None, IPXACT2009scalaxb.fromXML[Boolean](scala.xml.Text("false"), IPXACT2009scalaxb.ElemName(node) :: stack))) map { "@hidden" -> _ }
        ).flatten[(String, IPXACT2009scalaxb.DataRecord[Any])]: _*)) })
    
    override def writesAttribute(__obj: Generator, __scope: scala.xml.NamespaceBinding): scala.xml.MetaData = {
      var attr: scala.xml.MetaData  = scala.xml.Null
      __obj.attributes.toList map {
        case ("@hidden", _) => if (__obj.hidden.toString != "false") attr = scala.xml.Attribute(__scope.getPrefix("http://www.spiritconsortium.org/XMLSchema/SPIRIT/1685-2009"), "hidden", __obj.hidden.toString, attr)
        case (key, x) => attr = scala.xml.Attribute((x.namespace map { __scope.getPrefix(_) }).orNull, x.key.orNull, x.value.toString, attr)
      }
      attr
    }

    def writesChildNodes(__obj: Generator, __scope: scala.xml.NamespaceBinding): Seq[scala.xml.Node] =
      Seq.concat(IPXACT2009scalaxb.toXML[NameGroupSequence](__obj.nameGroupSequence1, None, Some("nameGroupSequence1"), __scope, false),
        __obj.phase map { IPXACT2009scalaxb.toXML[Phase](_, Some("http://www.spiritconsortium.org/XMLSchema/SPIRIT/1685-2009"), Some("phase"), __scope, false) } getOrElse {Nil},
        __obj.parameters map { IPXACT2009scalaxb.toXML[Parameters](_, Some("http://www.spiritconsortium.org/XMLSchema/SPIRIT/1685-2009"), Some("parameters"), __scope, false) } getOrElse {Nil},
        __obj.apiType map { IPXACT2009scalaxb.toXML[ApiType](_, Some("http://www.spiritconsortium.org/XMLSchema/SPIRIT/1685-2009"), Some("apiType"), __scope, false) } getOrElse {Nil},
        __obj.transportMethods map { IPXACT2009scalaxb.toXML[TransportMethods](_, Some("http://www.spiritconsortium.org/XMLSchema/SPIRIT/1685-2009"), Some("transportMethods"), __scope, false) } getOrElse {Nil},
        IPXACT2009scalaxb.toXML[String](__obj.generatorExe, Some("http://www.spiritconsortium.org/XMLSchema/SPIRIT/1685-2009"), Some("generatorExe"), __scope, false),
        __obj.vendorExtensions map { IPXACT2009scalaxb.toXML[VendorExtensions](_, Some("http://www.spiritconsortium.org/XMLSchema/SPIRIT/1685-2009"), Some("vendorExtensions"), __scope, false) } getOrElse {Nil})

  }

  trait Default_ComponentGeneratorFormat extends IPXACT2009scalaxb.ElemNameParser[ComponentGenerator] with _NameGroupGroupFormat {
    val targetNamespace: Option[String] = Some("http://www.spiritconsortium.org/XMLSchema/SPIRIT/1685-2009")
    
    def parser(node: scala.xml.Node, stack: List[IPXACT2009scalaxb.ElemName]): Parser[ComponentGenerator] =
      phrase((parseNameGroupGroup(node, IPXACT2009scalaxb.ElemName(node) :: stack)) ~
      opt(IPXACT2009scalaxb.ElemName(Some("http://www.spiritconsortium.org/XMLSchema/SPIRIT/1685-2009"), "phase")) ~
      opt(IPXACT2009scalaxb.ElemName(Some("http://www.spiritconsortium.org/XMLSchema/SPIRIT/1685-2009"), "parameters")) ~
      opt(IPXACT2009scalaxb.ElemName(Some("http://www.spiritconsortium.org/XMLSchema/SPIRIT/1685-2009"), "apiType")) ~
      opt(IPXACT2009scalaxb.ElemName(Some("http://www.spiritconsortium.org/XMLSchema/SPIRIT/1685-2009"), "transportMethods")) ~
      (IPXACT2009scalaxb.ElemName(Some("http://www.spiritconsortium.org/XMLSchema/SPIRIT/1685-2009"), "generatorExe")) ~
      opt(IPXACT2009scalaxb.ElemName(Some("http://www.spiritconsortium.org/XMLSchema/SPIRIT/1685-2009"), "vendorExtensions")) ~
      safeRep(IPXACT2009scalaxb.ElemName(Some("http://www.spiritconsortium.org/XMLSchema/SPIRIT/1685-2009"), "group")) ^^
      { case p1 ~ p2 ~ p3 ~ p4 ~ p5 ~ p6 ~ p7 ~ p8 =>
      ComponentGenerator(p1,
        p2.headOption map { IPXACT2009scalaxb.fromXML[Phase](_, IPXACT2009scalaxb.ElemName(node) :: stack) },
        p3.headOption map { IPXACT2009scalaxb.fromXML[Parameters](_, IPXACT2009scalaxb.ElemName(node) :: stack) },
        p4.headOption map { IPXACT2009scalaxb.fromXML[ApiType](_, IPXACT2009scalaxb.ElemName(node) :: stack) },
        p5.headOption map { IPXACT2009scalaxb.fromXML[TransportMethods](_, IPXACT2009scalaxb.ElemName(node) :: stack) },
        IPXACT2009scalaxb.fromXML[String](p6, IPXACT2009scalaxb.ElemName(node) :: stack),
        p7.headOption map { IPXACT2009scalaxb.fromXML[VendorExtensions](_, IPXACT2009scalaxb.ElemName(node) :: stack) },
        p8 map { IPXACT2009scalaxb.fromXML[String](_, IPXACT2009scalaxb.ElemName(node) :: stack) },
        scala.collection.immutable.ListMap(List(
        (node \ "@{http://www.spiritconsortium.org/XMLSchema/SPIRIT/1685-2009}hidden").headOption map { x => IPXACT2009scalaxb.DataRecord(x, node, IPXACT2009scalaxb.fromXML[Boolean](x, IPXACT2009scalaxb.ElemName(node) :: stack)) } orElse Some(IPXACT2009scalaxb.DataRecord(None, None, IPXACT2009scalaxb.fromXML[Boolean](scala.xml.Text("false"), IPXACT2009scalaxb.ElemName(node) :: stack))) map { "@hidden" -> _ },
        (node \ "@{http://www.spiritconsortium.org/XMLSchema/SPIRIT/1685-2009}scope").headOption map { x => IPXACT2009scalaxb.DataRecord(x, node, IPXACT2009scalaxb.fromXML[Scope](x, IPXACT2009scalaxb.ElemName(node) :: stack)) } orElse Some(IPXACT2009scalaxb.DataRecord(None, None, IPXACT2009scalaxb.fromXML[Scope](scala.xml.Text("instance"), IPXACT2009scalaxb.ElemName(node) :: stack))) map { "@scope" -> _ }
        ).flatten[(String, IPXACT2009scalaxb.DataRecord[Any])]: _*)) })
    
    override def writesAttribute(__obj: ComponentGenerator, __scope: scala.xml.NamespaceBinding): scala.xml.MetaData = {
      var attr: scala.xml.MetaData  = scala.xml.Null
      __obj.attributes.toList map {
        case ("@hidden", _) => if (__obj.hidden.toString != "false") attr = scala.xml.Attribute(__scope.getPrefix("http://www.spiritconsortium.org/XMLSchema/SPIRIT/1685-2009"), "hidden", __obj.hidden.toString, attr)
        case ("@scope", _) => if (__obj.scope.toString != "instance") attr = scala.xml.Attribute(__scope.getPrefix("http://www.spiritconsortium.org/XMLSchema/SPIRIT/1685-2009"), "scope", __obj.scope.toString, attr)
        case (key, x) => attr = scala.xml.Attribute((x.namespace map { __scope.getPrefix(_) }).orNull, x.key.orNull, x.value.toString, attr)
      }
      attr
    }

    def writesChildNodes(__obj: ComponentGenerator, __scope: scala.xml.NamespaceBinding): Seq[scala.xml.Node] =
      Seq.concat(IPXACT2009scalaxb.toXML[NameGroupSequence](__obj.nameGroupSequence1, None, Some("nameGroupSequence1"), __scope, false),
        __obj.phase map { IPXACT2009scalaxb.toXML[Phase](_, Some("http://www.spiritconsortium.org/XMLSchema/SPIRIT/1685-2009"), Some("phase"), __scope, false) } getOrElse {Nil},
        __obj.parameters map { IPXACT2009scalaxb.toXML[Parameters](_, Some("http://www.spiritconsortium.org/XMLSchema/SPIRIT/1685-2009"), Some("parameters"), __scope, false) } getOrElse {Nil},
        __obj.apiType map { IPXACT2009scalaxb.toXML[ApiType](_, Some("http://www.spiritconsortium.org/XMLSchema/SPIRIT/1685-2009"), Some("apiType"), __scope, false) } getOrElse {Nil},
        __obj.transportMethods map { IPXACT2009scalaxb.toXML[TransportMethods](_, Some("http://www.spiritconsortium.org/XMLSchema/SPIRIT/1685-2009"), Some("transportMethods"), __scope, false) } getOrElse {Nil},
        IPXACT2009scalaxb.toXML[String](__obj.generatorExe, Some("http://www.spiritconsortium.org/XMLSchema/SPIRIT/1685-2009"), Some("generatorExe"), __scope, false),
        __obj.vendorExtensions map { IPXACT2009scalaxb.toXML[VendorExtensions](_, Some("http://www.spiritconsortium.org/XMLSchema/SPIRIT/1685-2009"), Some("vendorExtensions"), __scope, false) } getOrElse {Nil},
        __obj.group flatMap { IPXACT2009scalaxb.toXML[String](_, Some("http://www.spiritconsortium.org/XMLSchema/SPIRIT/1685-2009"), Some("group"), __scope, false) })

  }

  def build_MultipleGroupSelectionOperatorFormat = new Default_MultipleGroupSelectionOperatorFormat {}
  trait Default_MultipleGroupSelectionOperatorFormat extends IPXACT2009scalaxb.XMLFormat[MultipleGroupSelectionOperator] {
    val targetNamespace: Option[String] = Some("http://www.spiritconsortium.org/XMLSchema/SPIRIT/1685-2009")
    
    def fromString(value: String, scope: scala.xml.NamespaceBinding): MultipleGroupSelectionOperator =
        (fromString0(value, scope)).apply(IPXACT2009scalaxb.fromXML[String](scala.xml.Text(value)))

    private def fromString0(value: String, scope: scala.xml.NamespaceBinding): PartialFunction[Any, MultipleGroupSelectionOperator] = {
      case x: String if x == IPXACT2009scalaxb.fromXML[String](scala.xml.Text("and")) => And
      case x: String if x == IPXACT2009scalaxb.fromXML[String](scala.xml.Text("or")) => Or

    }



    def reads(seq: scala.xml.NodeSeq, stack: List[IPXACT2009scalaxb.ElemName]): Either[String, MultipleGroupSelectionOperator] = seq match {
      case elem: scala.xml.Elem => Right(fromString(elem.text, elem.scope))
      case _ => Right(fromString(seq.text, scala.xml.TopScope))
    }
    
    def writes(__obj: MultipleGroupSelectionOperator, __namespace: Option[String], __elementLabel: Option[String],
        __scope: scala.xml.NamespaceBinding, __typeAttribute: Boolean): scala.xml.NodeSeq =
      scala.xml.Elem(IPXACT2009scalaxb.Helper.getPrefix(__namespace, __scope).orNull,
        __elementLabel getOrElse { sys.error("missing element label.") },
        scala.xml.Null, __scope, true, scala.xml.Text(__obj.toString))
  }
  trait Default_GroupSelectorFormat extends IPXACT2009scalaxb.ElemNameParser[GroupSelector] {
    val targetNamespace: Option[String] = Some("http://www.spiritconsortium.org/XMLSchema/SPIRIT/1685-2009")
    
    def parser(node: scala.xml.Node, stack: List[IPXACT2009scalaxb.ElemName]): Parser[GroupSelector] =
      phrase(safeRep(IPXACT2009scalaxb.ElemName(Some("http://www.spiritconsortium.org/XMLSchema/SPIRIT/1685-2009"), "name")) ^^
      { case p1 =>
      GroupSelector(p1 map { IPXACT2009scalaxb.fromXML[String](_, IPXACT2009scalaxb.ElemName(node) :: stack) },
        scala.collection.immutable.ListMap(List(
        (node \ "@{http://www.spiritconsortium.org/XMLSchema/SPIRIT/1685-2009}multipleGroupSelectionOperator").headOption map { x => IPXACT2009scalaxb.DataRecord(x, node, IPXACT2009scalaxb.fromXML[MultipleGroupSelectionOperator](x, IPXACT2009scalaxb.ElemName(node) :: stack)) } orElse Some(IPXACT2009scalaxb.DataRecord(None, None, IPXACT2009scalaxb.fromXML[MultipleGroupSelectionOperator](scala.xml.Text("or"), IPXACT2009scalaxb.ElemName(node) :: stack))) map { "@multipleGroupSelectionOperator" -> _ }
        ).flatten[(String, IPXACT2009scalaxb.DataRecord[Any])]: _*)) })
    
    override def writesAttribute(__obj: GroupSelector, __scope: scala.xml.NamespaceBinding): scala.xml.MetaData = {
      var attr: scala.xml.MetaData  = scala.xml.Null
      __obj.attributes.toList map {
        case ("@multipleGroupSelectionOperator", _) => if (__obj.multipleGroupSelectionOperator.toString != "or") attr = scala.xml.Attribute(__scope.getPrefix("http://www.spiritconsortium.org/XMLSchema/SPIRIT/1685-2009"), "multipleGroupSelectionOperator", __obj.multipleGroupSelectionOperator.toString, attr)
        case (key, x) => attr = scala.xml.Attribute((x.namespace map { __scope.getPrefix(_) }).orNull, x.key.orNull, x.value.toString, attr)
      }
      attr
    }

    def writesChildNodes(__obj: GroupSelector, __scope: scala.xml.NamespaceBinding): Seq[scala.xml.Node] =
      (__obj.name flatMap { IPXACT2009scalaxb.toXML[String](_, Some("http://www.spiritconsortium.org/XMLSchema/SPIRIT/1685-2009"), Some("name"), __scope, false) })
  }

  trait Default_PhaseFormat extends IPXACT2009scalaxb.XMLFormat[Phase] with IPXACT2009scalaxb.CanWriteChildNodes[Phase] {
    val targetNamespace: Option[String] = Some("http://www.spiritconsortium.org/XMLSchema/SPIRIT/1685-2009")
    def reads(seq: scala.xml.NodeSeq, stack: List[IPXACT2009scalaxb.ElemName]): Either[String, Phase] = seq match {
      case node: scala.xml.Node => Right(Phase(IPXACT2009scalaxb.fromXML[Float](node, IPXACT2009scalaxb.ElemName(node) :: stack)))
      case _ => Left("reads failed: seq must be scala.xml.Node")
    }
    
    def writesChildNodes(__obj: Phase, __scope: scala.xml.NamespaceBinding): Seq[scala.xml.Node] =
      Seq(scala.xml.Text(__obj.value.toString))

  }
  def build_ScopeFormat = new Default_ScopeFormat {}
  trait Default_ScopeFormat extends IPXACT2009scalaxb.XMLFormat[Scope] {
    val targetNamespace: Option[String] = Some("http://www.spiritconsortium.org/XMLSchema/SPIRIT/1685-2009")
    
    def fromString(value: String, scope: scala.xml.NamespaceBinding): Scope =
        (fromString0(value, scope)).apply(IPXACT2009scalaxb.fromXML[String](scala.xml.Text(value)))

    private def fromString0(value: String, scope: scala.xml.NamespaceBinding): PartialFunction[Any, Scope] = {
      case x: String if x == IPXACT2009scalaxb.fromXML[String](scala.xml.Text("instance")) => Instance
      case x: String if x == IPXACT2009scalaxb.fromXML[String](scala.xml.Text("entity")) => Entity

    }



    def reads(seq: scala.xml.NodeSeq, stack: List[IPXACT2009scalaxb.ElemName]): Either[String, Scope] = seq match {
      case elem: scala.xml.Elem => Right(fromString(elem.text, elem.scope))
      case _ => Right(fromString(seq.text, scala.xml.TopScope))
    }
    
    def writes(__obj: Scope, __namespace: Option[String], __elementLabel: Option[String],
        __scope: scala.xml.NamespaceBinding, __typeAttribute: Boolean): scala.xml.NodeSeq =
      scala.xml.Elem(IPXACT2009scalaxb.Helper.getPrefix(__namespace, __scope).orNull,
        __elementLabel getOrElse { sys.error("missing element label.") },
        scala.xml.Null, __scope, true, scala.xml.Text(__obj.toString))
  }
  trait Default_InstanceGeneratorTypableFormat extends IPXACT2009scalaxb.XMLFormat[InstanceGeneratorTypable] {
    def reads(seq: scala.xml.NodeSeq, stack: List[IPXACT2009scalaxb.ElemName]): Either[String, InstanceGeneratorTypable] = seq match {
      case node: scala.xml.Node =>     
        IPXACT2009scalaxb.Helper.instanceType(node) match {
          
          case _ => Right(IPXACT2009scalaxb.fromXML[InstanceGeneratorType](node, stack))
        }
      case _ => Left("reads failed: seq must be scala.xml.Node")  
    }
    
    def writes(__obj: InstanceGeneratorTypable, __namespace: Option[String], __elementLabel: Option[String],
        __scope: scala.xml.NamespaceBinding, __typeAttribute: Boolean): scala.xml.NodeSeq = __obj match {
      case x: ComponentGenerator => IPXACT2009scalaxb.toXML[ComponentGenerator](x, __namespace, __elementLabel, __scope, true)
      case x: InstanceGeneratorType => IPXACT2009scalaxb.toXML[InstanceGeneratorType](x, __namespace, __elementLabel, __scope, __typeAttribute)
    }
  }
  trait Default_InstanceGeneratorTypeFormat extends IPXACT2009scalaxb.ElemNameParser[InstanceGeneratorType] with _NameGroupGroupFormat {
    val targetNamespace: Option[String] = Some("http://www.spiritconsortium.org/XMLSchema/SPIRIT/1685-2009")
    
    override def typeName: Option[String] = Some("instanceGeneratorType")

    def parser(node: scala.xml.Node, stack: List[IPXACT2009scalaxb.ElemName]): Parser[InstanceGeneratorType] =
      phrase((parseNameGroupGroup(node, IPXACT2009scalaxb.ElemName(node) :: stack)) ~
      opt(IPXACT2009scalaxb.ElemName(Some("http://www.spiritconsortium.org/XMLSchema/SPIRIT/1685-2009"), "phase")) ~
      opt(IPXACT2009scalaxb.ElemName(Some("http://www.spiritconsortium.org/XMLSchema/SPIRIT/1685-2009"), "parameters")) ~
      opt(IPXACT2009scalaxb.ElemName(Some("http://www.spiritconsortium.org/XMLSchema/SPIRIT/1685-2009"), "apiType")) ~
      opt(IPXACT2009scalaxb.ElemName(Some("http://www.spiritconsortium.org/XMLSchema/SPIRIT/1685-2009"), "transportMethods")) ~
      (IPXACT2009scalaxb.ElemName(Some("http://www.spiritconsortium.org/XMLSchema/SPIRIT/1685-2009"), "generatorExe")) ~
      opt(IPXACT2009scalaxb.ElemName(Some("http://www.spiritconsortium.org/XMLSchema/SPIRIT/1685-2009"), "vendorExtensions")) ~
      safeRep(IPXACT2009scalaxb.ElemName(Some("http://www.spiritconsortium.org/XMLSchema/SPIRIT/1685-2009"), "group")) ^^
      { case p1 ~ p2 ~ p3 ~ p4 ~ p5 ~ p6 ~ p7 ~ p8 =>
      InstanceGeneratorType(p1,
        p2.headOption map { IPXACT2009scalaxb.fromXML[Phase](_, IPXACT2009scalaxb.ElemName(node) :: stack) },
        p3.headOption map { IPXACT2009scalaxb.fromXML[Parameters](_, IPXACT2009scalaxb.ElemName(node) :: stack) },
        p4.headOption map { IPXACT2009scalaxb.fromXML[ApiType](_, IPXACT2009scalaxb.ElemName(node) :: stack) },
        p5.headOption map { IPXACT2009scalaxb.fromXML[TransportMethods](_, IPXACT2009scalaxb.ElemName(node) :: stack) },
        IPXACT2009scalaxb.fromXML[String](p6, IPXACT2009scalaxb.ElemName(node) :: stack),
        p7.headOption map { IPXACT2009scalaxb.fromXML[VendorExtensions](_, IPXACT2009scalaxb.ElemName(node) :: stack) },
        p8 map { IPXACT2009scalaxb.fromXML[String](_, IPXACT2009scalaxb.ElemName(node) :: stack) },
        scala.collection.immutable.ListMap(List(
        (node \ "@{http://www.spiritconsortium.org/XMLSchema/SPIRIT/1685-2009}hidden").headOption map { x => IPXACT2009scalaxb.DataRecord(x, node, IPXACT2009scalaxb.fromXML[Boolean](x, IPXACT2009scalaxb.ElemName(node) :: stack)) } orElse Some(IPXACT2009scalaxb.DataRecord(None, None, IPXACT2009scalaxb.fromXML[Boolean](scala.xml.Text("false"), IPXACT2009scalaxb.ElemName(node) :: stack))) map { "@hidden" -> _ },
        (node \ "@{http://www.spiritconsortium.org/XMLSchema/SPIRIT/1685-2009}scope").headOption map { x => IPXACT2009scalaxb.DataRecord(x, node, IPXACT2009scalaxb.fromXML[Scope](x, IPXACT2009scalaxb.ElemName(node) :: stack)) } orElse Some(IPXACT2009scalaxb.DataRecord(None, None, IPXACT2009scalaxb.fromXML[Scope](scala.xml.Text("instance"), IPXACT2009scalaxb.ElemName(node) :: stack))) map { "@scope" -> _ }
        ).flatten[(String, IPXACT2009scalaxb.DataRecord[Any])]: _*)) })
    
    override def writesAttribute(__obj: InstanceGeneratorType, __scope: scala.xml.NamespaceBinding): scala.xml.MetaData = {
      var attr: scala.xml.MetaData  = scala.xml.Null
      __obj.attributes.toList map {
        case ("@hidden", _) => if (__obj.hidden.toString != "false") attr = scala.xml.Attribute(__scope.getPrefix("http://www.spiritconsortium.org/XMLSchema/SPIRIT/1685-2009"), "hidden", __obj.hidden.toString, attr)
        case ("@scope", _) => if (__obj.scope.toString != "instance") attr = scala.xml.Attribute(__scope.getPrefix("http://www.spiritconsortium.org/XMLSchema/SPIRIT/1685-2009"), "scope", __obj.scope.toString, attr)
        case (key, x) => attr = scala.xml.Attribute((x.namespace map { __scope.getPrefix(_) }).orNull, x.key.orNull, x.value.toString, attr)
      }
      attr
    }

    def writesChildNodes(__obj: InstanceGeneratorType, __scope: scala.xml.NamespaceBinding): Seq[scala.xml.Node] =
      Seq.concat(IPXACT2009scalaxb.toXML[NameGroupSequence](__obj.nameGroupSequence1, None, Some("nameGroupSequence1"), __scope, false),
        __obj.phase map { IPXACT2009scalaxb.toXML[Phase](_, Some("http://www.spiritconsortium.org/XMLSchema/SPIRIT/1685-2009"), Some("phase"), __scope, false) } getOrElse {Nil},
        __obj.parameters map { IPXACT2009scalaxb.toXML[Parameters](_, Some("http://www.spiritconsortium.org/XMLSchema/SPIRIT/1685-2009"), Some("parameters"), __scope, false) } getOrElse {Nil},
        __obj.apiType map { IPXACT2009scalaxb.toXML[ApiType](_, Some("http://www.spiritconsortium.org/XMLSchema/SPIRIT/1685-2009"), Some("apiType"), __scope, false) } getOrElse {Nil},
        __obj.transportMethods map { IPXACT2009scalaxb.toXML[TransportMethods](_, Some("http://www.spiritconsortium.org/XMLSchema/SPIRIT/1685-2009"), Some("transportMethods"), __scope, false) } getOrElse {Nil},
        IPXACT2009scalaxb.toXML[String](__obj.generatorExe, Some("http://www.spiritconsortium.org/XMLSchema/SPIRIT/1685-2009"), Some("generatorExe"), __scope, false),
        __obj.vendorExtensions map { IPXACT2009scalaxb.toXML[VendorExtensions](_, Some("http://www.spiritconsortium.org/XMLSchema/SPIRIT/1685-2009"), Some("vendorExtensions"), __scope, false) } getOrElse {Nil},
        __obj.group flatMap { IPXACT2009scalaxb.toXML[String](_, Some("http://www.spiritconsortium.org/XMLSchema/SPIRIT/1685-2009"), Some("group"), __scope, false) })

  }

  trait Default_GeneratorSelectorTypeFormat extends IPXACT2009scalaxb.ElemNameParser[GeneratorSelectorType] {
    val targetNamespace: Option[String] = Some("http://www.spiritconsortium.org/XMLSchema/SPIRIT/1685-2009")
    
    override def typeName: Option[String] = Some("generatorSelectorType")

    def parser(node: scala.xml.Node, stack: List[IPXACT2009scalaxb.ElemName]): Parser[GeneratorSelectorType] =
      phrase((IPXACT2009scalaxb.ElemName(Some("http://www.spiritconsortium.org/XMLSchema/SPIRIT/1685-2009"), "groupSelector")) ^^
      { case p1 =>
      GeneratorSelectorType(IPXACT2009scalaxb.fromXML[GroupSelector](p1, IPXACT2009scalaxb.ElemName(node) :: stack)) })
    
    def writesChildNodes(__obj: GeneratorSelectorType, __scope: scala.xml.NamespaceBinding): Seq[scala.xml.Node] =
      (IPXACT2009scalaxb.toXML[GroupSelector](__obj.groupSelector, Some("http://www.spiritconsortium.org/XMLSchema/SPIRIT/1685-2009"), Some("groupSelector"), __scope, false))
  }

  trait Default_ComponentGeneratorsFormat extends IPXACT2009scalaxb.ElemNameParser[ComponentGenerators] {
    val targetNamespace: Option[String] = Some("http://www.spiritconsortium.org/XMLSchema/SPIRIT/1685-2009")
    
    def parser(node: scala.xml.Node, stack: List[IPXACT2009scalaxb.ElemName]): Parser[ComponentGenerators] =
      phrase(safeRep(IPXACT2009scalaxb.ElemName(Some("http://www.spiritconsortium.org/XMLSchema/SPIRIT/1685-2009"), "componentGenerator")) ^^
      { case p1 =>
      ComponentGenerators(p1 map { IPXACT2009scalaxb.fromXML[ComponentGenerator](_, IPXACT2009scalaxb.ElemName(node) :: stack) }) })
    
    def writesChildNodes(__obj: ComponentGenerators, __scope: scala.xml.NamespaceBinding): Seq[scala.xml.Node] =
      (__obj.componentGenerator flatMap { IPXACT2009scalaxb.toXML[ComponentGenerator](_, Some("http://www.spiritconsortium.org/XMLSchema/SPIRIT/1685-2009"), Some("componentGenerator"), __scope, false) })
  }
  trait Default_AbstractorGeneratorsFormat extends IPXACT2009scalaxb.ElemNameParser[AbstractorGenerators] {
    val targetNamespace: Option[String] = Some("http://www.spiritconsortium.org/XMLSchema/SPIRIT/1685-2009")
    
    def parser(node: scala.xml.Node, stack: List[IPXACT2009scalaxb.ElemName]): Parser[AbstractorGenerators] =
      phrase(safeRep(IPXACT2009scalaxb.ElemName(Some("http://www.spiritconsortium.org/XMLSchema/SPIRIT/1685-2009"), "abstractorGenerator")) ^^
      { case p1 =>
      AbstractorGenerators(p1 map { IPXACT2009scalaxb.fromXML[InstanceGeneratorTypable](_, IPXACT2009scalaxb.ElemName(node) :: stack) }) })
    
    def writesChildNodes(__obj: AbstractorGenerators, __scope: scala.xml.NamespaceBinding): Seq[scala.xml.Node] =
      (__obj.abstractorGenerator flatMap { IPXACT2009scalaxb.toXML[InstanceGeneratorTypable](_, Some("http://www.spiritconsortium.org/XMLSchema/SPIRIT/1685-2009"), Some("abstractorGenerator"), __scope, false) })
  }
  def build_ApiTypeFormat = new Default_ApiTypeFormat {}
  trait Default_ApiTypeFormat extends IPXACT2009scalaxb.XMLFormat[ApiType] {
    val targetNamespace: Option[String] = Some("http://www.spiritconsortium.org/XMLSchema/SPIRIT/1685-2009")
    
    def fromString(value: String, scope: scala.xml.NamespaceBinding): ApiType =
        (fromString0(value, scope)).apply(IPXACT2009scalaxb.fromXML[String](scala.xml.Text(value)))

    private def fromString0(value: String, scope: scala.xml.NamespaceBinding): PartialFunction[Any, ApiType] = {
      case x: String if x == IPXACT2009scalaxb.fromXML[String](scala.xml.Text("TGI")) => TGI
      case x: String if x == IPXACT2009scalaxb.fromXML[String](scala.xml.Text("none")) => NoneType

    }



    def reads(seq: scala.xml.NodeSeq, stack: List[IPXACT2009scalaxb.ElemName]): Either[String, ApiType] = seq match {
      case elem: scala.xml.Elem => Right(fromString(elem.text, elem.scope))
      case _ => Right(fromString(seq.text, scala.xml.TopScope))
    }
    
    def writes(__obj: ApiType, __namespace: Option[String], __elementLabel: Option[String],
        __scope: scala.xml.NamespaceBinding, __typeAttribute: Boolean): scala.xml.NodeSeq =
      scala.xml.Elem(IPXACT2009scalaxb.Helper.getPrefix(__namespace, __scope).orNull,
        __elementLabel getOrElse { sys.error("missing element label.") },
        scala.xml.Null, __scope, true, scala.xml.Text(__obj.toString))
  }
  def build_TransportMethodFormat = new Default_TransportMethodFormat {}
  trait Default_TransportMethodFormat extends IPXACT2009scalaxb.XMLFormat[TransportMethod] {
    val targetNamespace: Option[String] = Some("http://www.spiritconsortium.org/XMLSchema/SPIRIT/1685-2009")
    
    def fromString(value: String, scope: scala.xml.NamespaceBinding): TransportMethod =
        (fromString0(value, scope)).apply(IPXACT2009scalaxb.fromXML[String](scala.xml.Text(value)))

    private def fromString0(value: String, scope: scala.xml.NamespaceBinding): PartialFunction[Any, TransportMethod] = {
      case x: String if x == IPXACT2009scalaxb.fromXML[String](scala.xml.Text("file")) => FileValue

    }



    def reads(seq: scala.xml.NodeSeq, stack: List[IPXACT2009scalaxb.ElemName]): Either[String, TransportMethod] = seq match {
      case elem: scala.xml.Elem => Right(fromString(elem.text, elem.scope))
      case _ => Right(fromString(seq.text, scala.xml.TopScope))
    }
    
    def writes(__obj: TransportMethod, __namespace: Option[String], __elementLabel: Option[String],
        __scope: scala.xml.NamespaceBinding, __typeAttribute: Boolean): scala.xml.NodeSeq =
      scala.xml.Elem(IPXACT2009scalaxb.Helper.getPrefix(__namespace, __scope).orNull,
        __elementLabel getOrElse { sys.error("missing element label.") },
        scala.xml.Null, __scope, true, scala.xml.Text(__obj.toString))
  }
  trait Default_TransportMethodsFormat extends IPXACT2009scalaxb.ElemNameParser[TransportMethods] {
    val targetNamespace: Option[String] = Some("http://www.spiritconsortium.org/XMLSchema/SPIRIT/1685-2009")
    
    def parser(node: scala.xml.Node, stack: List[IPXACT2009scalaxb.ElemName]): Parser[TransportMethods] =
      phrase((IPXACT2009scalaxb.ElemName(Some("http://www.spiritconsortium.org/XMLSchema/SPIRIT/1685-2009"), "transportMethod")) ^^
      { case p1 =>
      TransportMethods(IPXACT2009scalaxb.fromXML[TransportMethod](p1, IPXACT2009scalaxb.ElemName(node) :: stack)) })
    
    def writesChildNodes(__obj: TransportMethods, __scope: scala.xml.NamespaceBinding): Seq[scala.xml.Node] =
      (IPXACT2009scalaxb.toXML[TransportMethod](__obj.transportMethod, Some("http://www.spiritconsortium.org/XMLSchema/SPIRIT/1685-2009"), Some("transportMethod"), __scope, false))
  }
  trait Default_GeneratorTypableFormat extends IPXACT2009scalaxb.XMLFormat[GeneratorTypable] {
    def reads(seq: scala.xml.NodeSeq, stack: List[IPXACT2009scalaxb.ElemName]): Either[String, GeneratorTypable] = seq match {
      case node: scala.xml.Node =>     
        IPXACT2009scalaxb.Helper.instanceType(node) match {
          case (Some("http://www.spiritconsortium.org/XMLSchema/SPIRIT/1685-2009"), Some("instanceGeneratorType")) => Right(IPXACT2009scalaxb.fromXML[InstanceGeneratorTypable](node, stack))
          case _ => Right(IPXACT2009scalaxb.fromXML[GeneratorType](node, stack))
        }
      case _ => Left("reads failed: seq must be scala.xml.Node")  
    }
    
    def writes(__obj: GeneratorTypable, __namespace: Option[String], __elementLabel: Option[String],
        __scope: scala.xml.NamespaceBinding, __typeAttribute: Boolean): scala.xml.NodeSeq = __obj match {
      case x: InstanceGeneratorTypable => IPXACT2009scalaxb.toXML[InstanceGeneratorTypable](x, __namespace, __elementLabel, __scope, true)
      case x: Generator => IPXACT2009scalaxb.toXML[Generator](x, __namespace, __elementLabel, __scope, true)
      case x: GeneratorType => IPXACT2009scalaxb.toXML[GeneratorType](x, __namespace, __elementLabel, __scope, __typeAttribute)
    }
  }

  trait Default_GeneratorTypeFormat extends IPXACT2009scalaxb.ElemNameParser[GeneratorType] with _NameGroupGroupFormat {
    val targetNamespace: Option[String] = Some("http://www.spiritconsortium.org/XMLSchema/SPIRIT/1685-2009")
    
    override def typeName: Option[String] = Some("generatorType")

    def parser(node: scala.xml.Node, stack: List[IPXACT2009scalaxb.ElemName]): Parser[GeneratorType] =
      phrase((parseNameGroupGroup(node, IPXACT2009scalaxb.ElemName(node) :: stack)) ~
      opt(IPXACT2009scalaxb.ElemName(Some("http://www.spiritconsortium.org/XMLSchema/SPIRIT/1685-2009"), "phase")) ~
      opt(IPXACT2009scalaxb.ElemName(Some("http://www.spiritconsortium.org/XMLSchema/SPIRIT/1685-2009"), "parameters")) ~
      opt(IPXACT2009scalaxb.ElemName(Some("http://www.spiritconsortium.org/XMLSchema/SPIRIT/1685-2009"), "apiType")) ~
      opt(IPXACT2009scalaxb.ElemName(Some("http://www.spiritconsortium.org/XMLSchema/SPIRIT/1685-2009"), "transportMethods")) ~
      (IPXACT2009scalaxb.ElemName(Some("http://www.spiritconsortium.org/XMLSchema/SPIRIT/1685-2009"), "generatorExe")) ~
      opt(IPXACT2009scalaxb.ElemName(Some("http://www.spiritconsortium.org/XMLSchema/SPIRIT/1685-2009"), "vendorExtensions")) ^^
      { case p1 ~ p2 ~ p3 ~ p4 ~ p5 ~ p6 ~ p7 =>
      GeneratorType(p1,
        p2.headOption map { IPXACT2009scalaxb.fromXML[Phase](_, IPXACT2009scalaxb.ElemName(node) :: stack) },
        p3.headOption map { IPXACT2009scalaxb.fromXML[Parameters](_, IPXACT2009scalaxb.ElemName(node) :: stack) },
        p4.headOption map { IPXACT2009scalaxb.fromXML[ApiType](_, IPXACT2009scalaxb.ElemName(node) :: stack) },
        p5.headOption map { IPXACT2009scalaxb.fromXML[TransportMethods](_, IPXACT2009scalaxb.ElemName(node) :: stack) },
        IPXACT2009scalaxb.fromXML[String](p6, IPXACT2009scalaxb.ElemName(node) :: stack),
        p7.headOption map { IPXACT2009scalaxb.fromXML[VendorExtensions](_, IPXACT2009scalaxb.ElemName(node) :: stack) },
        scala.collection.immutable.ListMap(List(
        (node \ "@{http://www.spiritconsortium.org/XMLSchema/SPIRIT/1685-2009}hidden").headOption map { x => IPXACT2009scalaxb.DataRecord(x, node, IPXACT2009scalaxb.fromXML[Boolean](x, IPXACT2009scalaxb.ElemName(node) :: stack)) } orElse Some(IPXACT2009scalaxb.DataRecord(None, None, IPXACT2009scalaxb.fromXML[Boolean](scala.xml.Text("false"), IPXACT2009scalaxb.ElemName(node) :: stack))) map { "@hidden" -> _ }
        ).flatten[(String, IPXACT2009scalaxb.DataRecord[Any])]: _*)) })
    
    override def writesAttribute(__obj: GeneratorType, __scope: scala.xml.NamespaceBinding): scala.xml.MetaData = {
      var attr: scala.xml.MetaData  = scala.xml.Null
      __obj.attributes.toList map {
        case ("@hidden", _) => if (__obj.hidden.toString != "false") attr = scala.xml.Attribute(__scope.getPrefix("http://www.spiritconsortium.org/XMLSchema/SPIRIT/1685-2009"), "hidden", __obj.hidden.toString, attr)
        case (key, x) => attr = scala.xml.Attribute((x.namespace map { __scope.getPrefix(_) }).orNull, x.key.orNull, x.value.toString, attr)
      }
      attr
    }

    def writesChildNodes(__obj: GeneratorType, __scope: scala.xml.NamespaceBinding): Seq[scala.xml.Node] =
      Seq.concat(IPXACT2009scalaxb.toXML[NameGroupSequence](__obj.nameGroupSequence1, None, Some("nameGroupSequence1"), __scope, false),
        __obj.phase map { IPXACT2009scalaxb.toXML[Phase](_, Some("http://www.spiritconsortium.org/XMLSchema/SPIRIT/1685-2009"), Some("phase"), __scope, false) } getOrElse {Nil},
        __obj.parameters map { IPXACT2009scalaxb.toXML[Parameters](_, Some("http://www.spiritconsortium.org/XMLSchema/SPIRIT/1685-2009"), Some("parameters"), __scope, false) } getOrElse {Nil},
        __obj.apiType map { IPXACT2009scalaxb.toXML[ApiType](_, Some("http://www.spiritconsortium.org/XMLSchema/SPIRIT/1685-2009"), Some("apiType"), __scope, false) } getOrElse {Nil},
        __obj.transportMethods map { IPXACT2009scalaxb.toXML[TransportMethods](_, Some("http://www.spiritconsortium.org/XMLSchema/SPIRIT/1685-2009"), Some("transportMethods"), __scope, false) } getOrElse {Nil},
        IPXACT2009scalaxb.toXML[String](__obj.generatorExe, Some("http://www.spiritconsortium.org/XMLSchema/SPIRIT/1685-2009"), Some("generatorExe"), __scope, false),
        __obj.vendorExtensions map { IPXACT2009scalaxb.toXML[VendorExtensions](_, Some("http://www.spiritconsortium.org/XMLSchema/SPIRIT/1685-2009"), Some("vendorExtensions"), __scope, false) } getOrElse {Nil})

  }

  trait Default_LibraryRefTypeFormat extends IPXACT2009scalaxb.XMLFormat[LibraryRefType] with IPXACT2009scalaxb.CanWriteChildNodes[LibraryRefType] {
    val targetNamespace: Option[String] = Some("http://www.spiritconsortium.org/XMLSchema/SPIRIT/1685-2009")
    def reads(seq: scala.xml.NodeSeq, stack: List[IPXACT2009scalaxb.ElemName]): Either[String, LibraryRefType] = seq match {
      case node: scala.xml.Node => Right(LibraryRefType(scala.collection.immutable.ListMap(List(
        (node \ "@{http://www.spiritconsortium.org/XMLSchema/SPIRIT/1685-2009}vendor").headOption map { x => IPXACT2009scalaxb.DataRecord(x, node, IPXACT2009scalaxb.fromXML[String](x, IPXACT2009scalaxb.ElemName(node) :: stack)) } map { "@vendor" -> _ },
        (node \ "@{http://www.spiritconsortium.org/XMLSchema/SPIRIT/1685-2009}library").headOption map { x => IPXACT2009scalaxb.DataRecord(x, node, IPXACT2009scalaxb.fromXML[String](x, IPXACT2009scalaxb.ElemName(node) :: stack)) } map { "@library" -> _ },
        (node \ "@{http://www.spiritconsortium.org/XMLSchema/SPIRIT/1685-2009}name").headOption map { x => IPXACT2009scalaxb.DataRecord(x, node, IPXACT2009scalaxb.fromXML[String](x, IPXACT2009scalaxb.ElemName(node) :: stack)) } map { "@name" -> _ },
        (node \ "@{http://www.spiritconsortium.org/XMLSchema/SPIRIT/1685-2009}version").headOption map { x => IPXACT2009scalaxb.DataRecord(x, node, IPXACT2009scalaxb.fromXML[String](x, IPXACT2009scalaxb.ElemName(node) :: stack)) } map { "@version" -> _ }
        ).flatten[(String, IPXACT2009scalaxb.DataRecord[Any])]: _*)))
      case _ => Left("reads failed: seq must be scala.xml.Node")
    }
    
    override def writesAttribute(__obj: LibraryRefType, __scope: scala.xml.NamespaceBinding): scala.xml.MetaData = {
      var attr: scala.xml.MetaData  = scala.xml.Null
      __obj.attributes.toList map {
        case ("@vendor", _) => attr = scala.xml.Attribute(__scope.getPrefix("http://www.spiritconsortium.org/XMLSchema/SPIRIT/1685-2009"), "vendor", __obj.vendor.toString, attr)
        case ("@library", _) => attr = scala.xml.Attribute(__scope.getPrefix("http://www.spiritconsortium.org/XMLSchema/SPIRIT/1685-2009"), "library", __obj.library.toString, attr)
        case ("@name", _) => attr = scala.xml.Attribute(__scope.getPrefix("http://www.spiritconsortium.org/XMLSchema/SPIRIT/1685-2009"), "name", __obj.name.toString, attr)
        case ("@version", _) => attr = scala.xml.Attribute(__scope.getPrefix("http://www.spiritconsortium.org/XMLSchema/SPIRIT/1685-2009"), "version", __obj.version.toString, attr)
        case (key, x) => attr = scala.xml.Attribute((x.namespace map { __scope.getPrefix(_) }).orNull, x.key.orNull, x.value.toString, attr)
      }
      attr
    }

    def writesChildNodes(__obj: LibraryRefType, __scope: scala.xml.NamespaceBinding): Seq[scala.xml.Node] =
      Nil

  }

  trait Default_ResolvedLibraryRefTypeFormat extends IPXACT2009scalaxb.XMLFormat[ResolvedLibraryRefType] with IPXACT2009scalaxb.CanWriteChildNodes[ResolvedLibraryRefType] {
    val targetNamespace: Option[String] = Some("http://www.spiritconsortium.org/XMLSchema/SPIRIT/1685-2009")
    def reads(seq: scala.xml.NodeSeq, stack: List[IPXACT2009scalaxb.ElemName]): Either[String, ResolvedLibraryRefType] = seq match {
      case node: scala.xml.Node => Right(ResolvedLibraryRefType(IPXACT2009scalaxb.fromXML[java.net.URI](node, IPXACT2009scalaxb.ElemName(node) :: stack),
        scala.collection.immutable.ListMap(List(
        (node \ "@{http://www.spiritconsortium.org/XMLSchema/SPIRIT/1685-2009}vendor").headOption map { x => IPXACT2009scalaxb.DataRecord(x, node, IPXACT2009scalaxb.fromXML[String](x, IPXACT2009scalaxb.ElemName(node) :: stack)) } map { "@vendor" -> _ },
        (node \ "@{http://www.spiritconsortium.org/XMLSchema/SPIRIT/1685-2009}library").headOption map { x => IPXACT2009scalaxb.DataRecord(x, node, IPXACT2009scalaxb.fromXML[String](x, IPXACT2009scalaxb.ElemName(node) :: stack)) } map { "@library" -> _ },
        (node \ "@{http://www.spiritconsortium.org/XMLSchema/SPIRIT/1685-2009}name").headOption map { x => IPXACT2009scalaxb.DataRecord(x, node, IPXACT2009scalaxb.fromXML[String](x, IPXACT2009scalaxb.ElemName(node) :: stack)) } map { "@name" -> _ },
        (node \ "@{http://www.spiritconsortium.org/XMLSchema/SPIRIT/1685-2009}version").headOption map { x => IPXACT2009scalaxb.DataRecord(x, node, IPXACT2009scalaxb.fromXML[String](x, IPXACT2009scalaxb.ElemName(node) :: stack)) } map { "@version" -> _ }
        ).flatten[(String, IPXACT2009scalaxb.DataRecord[Any])]: _*)))
      case _ => Left("reads failed: seq must be scala.xml.Node")
    }
    
    override def writesAttribute(__obj: ResolvedLibraryRefType, __scope: scala.xml.NamespaceBinding): scala.xml.MetaData = {
      var attr: scala.xml.MetaData  = scala.xml.Null
      __obj.attributes.toList map {
        case ("@vendor", _) => attr = scala.xml.Attribute(__scope.getPrefix("http://www.spiritconsortium.org/XMLSchema/SPIRIT/1685-2009"), "vendor", __obj.vendor.toString, attr)
        case ("@library", _) => attr = scala.xml.Attribute(__scope.getPrefix("http://www.spiritconsortium.org/XMLSchema/SPIRIT/1685-2009"), "library", __obj.library.toString, attr)
        case ("@name", _) => attr = scala.xml.Attribute(__scope.getPrefix("http://www.spiritconsortium.org/XMLSchema/SPIRIT/1685-2009"), "name", __obj.name.toString, attr)
        case ("@version", _) => attr = scala.xml.Attribute(__scope.getPrefix("http://www.spiritconsortium.org/XMLSchema/SPIRIT/1685-2009"), "version", __obj.version.toString, attr)
        case (key, x) => attr = scala.xml.Attribute((x.namespace map { __scope.getPrefix(_) }).orNull, x.key.orNull, x.value.toString, attr)
      }
      attr
    }

    def writesChildNodes(__obj: ResolvedLibraryRefType, __scope: scala.xml.NamespaceBinding): Seq[scala.xml.Node] =
      Seq(scala.xml.Text(__obj.value.toString))

  }


/** This group of elements identifies a top level item (e.g. a component or a bus definition)  with vendor, library, name and a version number. 
*/
  trait _VersionedIdentifierGroupFormat extends IPXACT2009scalaxb.AnyElemNameParser {
    def parseVersionedIdentifierGroup(node: scala.xml.Node, stack: List[IPXACT2009scalaxb.ElemName]): Parser[VersionedIdentifierSequence] =
      (((IPXACT2009scalaxb.ElemName(Some("http://www.spiritconsortium.org/XMLSchema/SPIRIT/1685-2009"), "vendor")) ~
      (IPXACT2009scalaxb.ElemName(Some("http://www.spiritconsortium.org/XMLSchema/SPIRIT/1685-2009"), "library")) ~
      (IPXACT2009scalaxb.ElemName(Some("http://www.spiritconsortium.org/XMLSchema/SPIRIT/1685-2009"), "name")) ~
      (IPXACT2009scalaxb.ElemName(Some("http://www.spiritconsortium.org/XMLSchema/SPIRIT/1685-2009"), "version"))) ^^
        { case p1 ~ p2 ~ p3 ~ p4 => VersionedIdentifierSequence(IPXACT2009scalaxb.fromXML[String](p1, IPXACT2009scalaxb.ElemName(node) :: stack),
        IPXACT2009scalaxb.fromXML[String](p2, IPXACT2009scalaxb.ElemName(node) :: stack),
        IPXACT2009scalaxb.fromXML[String](p3, IPXACT2009scalaxb.ElemName(node) :: stack),
        IPXACT2009scalaxb.fromXML[String](p4, IPXACT2009scalaxb.ElemName(node) :: stack)) })
  
    def parseVersionedIdentifierGroup(node: scala.xml.Node, stack: List[IPXACT2009scalaxb.ElemName], wrap: Boolean): Parser[IPXACT2009scalaxb.DataRecord[Any]] =
      (((IPXACT2009scalaxb.ElemName(Some("http://www.spiritconsortium.org/XMLSchema/SPIRIT/1685-2009"), "vendor")) ~
      (IPXACT2009scalaxb.ElemName(Some("http://www.spiritconsortium.org/XMLSchema/SPIRIT/1685-2009"), "library")) ~
      (IPXACT2009scalaxb.ElemName(Some("http://www.spiritconsortium.org/XMLSchema/SPIRIT/1685-2009"), "name")) ~
      (IPXACT2009scalaxb.ElemName(Some("http://www.spiritconsortium.org/XMLSchema/SPIRIT/1685-2009"), "version"))) ^^
        { case p1 ~ p2 ~ p3 ~ p4 => IPXACT2009scalaxb.DataRecord(VersionedIdentifierSequence(IPXACT2009scalaxb.fromXML[String](p1, IPXACT2009scalaxb.ElemName(node) :: stack),
        IPXACT2009scalaxb.fromXML[String](p2, IPXACT2009scalaxb.ElemName(node) :: stack),
        IPXACT2009scalaxb.fromXML[String](p3, IPXACT2009scalaxb.ElemName(node) :: stack),
        IPXACT2009scalaxb.fromXML[String](p4, IPXACT2009scalaxb.ElemName(node) :: stack))) })
    
    def parsemixedVersionedIdentifierGroup(node: scala.xml.Node, stack: List[IPXACT2009scalaxb.ElemName]): Parser[Seq[IPXACT2009scalaxb.DataRecord[Any]]] =
      ((((IPXACT2009scalaxb.ElemName(Some("http://www.spiritconsortium.org/XMLSchema/SPIRIT/1685-2009"), "vendor")) ^^
      (x => IPXACT2009scalaxb.DataRecord(x.namespace, Some(x.name), IPXACT2009scalaxb.fromXML[String](x, IPXACT2009scalaxb.ElemName(node) :: stack)))) ~
      optTextRecord ~ 
      ((IPXACT2009scalaxb.ElemName(Some("http://www.spiritconsortium.org/XMLSchema/SPIRIT/1685-2009"), "library")) ^^
      (x => IPXACT2009scalaxb.DataRecord(x.namespace, Some(x.name), IPXACT2009scalaxb.fromXML[String](x, IPXACT2009scalaxb.ElemName(node) :: stack)))) ~
      optTextRecord ~ 
      ((IPXACT2009scalaxb.ElemName(Some("http://www.spiritconsortium.org/XMLSchema/SPIRIT/1685-2009"), "name")) ^^
      (x => IPXACT2009scalaxb.DataRecord(x.namespace, Some(x.name), IPXACT2009scalaxb.fromXML[String](x, IPXACT2009scalaxb.ElemName(node) :: stack)))) ~
      optTextRecord ~ 
      ((IPXACT2009scalaxb.ElemName(Some("http://www.spiritconsortium.org/XMLSchema/SPIRIT/1685-2009"), "version")) ^^
      (x => IPXACT2009scalaxb.DataRecord(x.namespace, Some(x.name), IPXACT2009scalaxb.fromXML[String](x, IPXACT2009scalaxb.ElemName(node) :: stack)))) ~
      optTextRecord) ^^ 
        { case p1 ~ p2 ~ p3 ~ p4 ~ p5 ~ p6 ~ p7 ~ p8 => Seq.concat(Seq(p1),
        p2.toList,
        Seq(p3),
        p4.toList,
        Seq(p5),
        p6.toList,
        Seq(p7),
        p8.toList) })
  }

  trait Default_VersionedIdentifierSequenceFormat extends IPXACT2009scalaxb.XMLFormat[VersionedIdentifierSequence] {
    def reads(seq: scala.xml.NodeSeq, stack: List[IPXACT2009scalaxb.ElemName]): Either[String, VersionedIdentifierSequence] = Left("don't call me.")
    
    def writes(__obj: VersionedIdentifierSequence, __namespace: Option[String], __elementLabel: Option[String], 
        __scope: scala.xml.NamespaceBinding, __typeAttribute: Boolean): scala.xml.NodeSeq =
      Seq.concat(IPXACT2009scalaxb.toXML[String](__obj.vendor, Some("http://www.spiritconsortium.org/XMLSchema/SPIRIT/1685-2009"), Some("vendor"), __scope, false),
        IPXACT2009scalaxb.toXML[String](__obj.library, Some("http://www.spiritconsortium.org/XMLSchema/SPIRIT/1685-2009"), Some("library"), __scope, false),
        IPXACT2009scalaxb.toXML[String](__obj.name, Some("http://www.spiritconsortium.org/XMLSchema/SPIRIT/1685-2009"), Some("name"), __scope, false),
        IPXACT2009scalaxb.toXML[String](__obj.version, Some("http://www.spiritconsortium.org/XMLSchema/SPIRIT/1685-2009"), Some("version"), __scope, false))


  }

  trait Default_BaseIdentifierSequenceFormat extends IPXACT2009scalaxb.XMLFormat[BaseIdentifierSequence] {
    def reads(seq: scala.xml.NodeSeq, stack: List[IPXACT2009scalaxb.ElemName]): Either[String, BaseIdentifierSequence] = Left("don't call me.")
    
    def writes(__obj: BaseIdentifierSequence, __namespace: Option[String], __elementLabel: Option[String], 
        __scope: scala.xml.NamespaceBinding, __typeAttribute: Boolean): scala.xml.NodeSeq =
      Nil

  }
  trait Default_LibraryRefGroupFormat extends IPXACT2009scalaxb.AttributeGroupFormat[LibraryRefGroup] {
    val targetNamespace: Option[String] = Some("http://www.spiritconsortium.org/XMLSchema/SPIRIT/1685-2009")
    
    def reads(seq: scala.xml.NodeSeq, stack: List[IPXACT2009scalaxb.ElemName]): Either[String, LibraryRefGroup] = seq match {
      case node: scala.xml.Node => Right(LibraryRefGroup(IPXACT2009scalaxb.fromXML[String]((node \ "@{http://www.spiritconsortium.org/XMLSchema/SPIRIT/1685-2009}vendor"), IPXACT2009scalaxb.ElemName(node) :: stack),
      IPXACT2009scalaxb.fromXML[String]((node \ "@{http://www.spiritconsortium.org/XMLSchema/SPIRIT/1685-2009}library"), IPXACT2009scalaxb.ElemName(node) :: stack),
      IPXACT2009scalaxb.fromXML[String]((node \ "@{http://www.spiritconsortium.org/XMLSchema/SPIRIT/1685-2009}name"), IPXACT2009scalaxb.ElemName(node) :: stack),
      IPXACT2009scalaxb.fromXML[String]((node \ "@{http://www.spiritconsortium.org/XMLSchema/SPIRIT/1685-2009}version"), IPXACT2009scalaxb.ElemName(node) :: stack)))
      case _ => Left("reads failed: seq must be scala.xml.Node")
    }
    
    def toAttribute(__obj: LibraryRefGroup, __attr: scala.xml.MetaData, __scope: scala.xml.NamespaceBinding): scala.xml.MetaData = {
      var attr: scala.xml.MetaData  = __attr
      attr = scala.xml.Attribute(__scope.getPrefix("http://www.spiritconsortium.org/XMLSchema/SPIRIT/1685-2009"), "vendor", __obj.vendor.toString, attr)
    attr = scala.xml.Attribute(__scope.getPrefix("http://www.spiritconsortium.org/XMLSchema/SPIRIT/1685-2009"), "library", __obj.library.toString, attr)
    attr = scala.xml.Attribute(__scope.getPrefix("http://www.spiritconsortium.org/XMLSchema/SPIRIT/1685-2009"), "name", __obj.name.toString, attr)
    attr = scala.xml.Attribute(__scope.getPrefix("http://www.spiritconsortium.org/XMLSchema/SPIRIT/1685-2009"), "version", __obj.version.toString, attr)
      attr
    }
  }


/** This IP-XACT schema documentation is part of the IP-XACT standard deliverables. The diagrams in this documentation represent the relationships between elements of the schema together with their attributes and expected values. Valid IP-XACT XML files must have a top-level type that is one of the elements listed here.
*/
  trait _IPXACTDocumentTypesGroupFormat extends IPXACT2009scalaxb.AnyElemNameParser {
    def parseIPXACTDocumentTypesGroup(node: scala.xml.Node, stack: List[IPXACT2009scalaxb.ElemName]): Parser[IPXACT2009scalaxb.DataRecord[IPXACTDocumentTypesOption]] =
      (((IPXACT2009scalaxb.ElemName(Some("http://www.spiritconsortium.org/XMLSchema/SPIRIT/1685-2009"), "busDefinition")) ^^
      (x => IPXACT2009scalaxb.DataRecord(x.namespace, Some(x.name), IPXACT2009scalaxb.fromXML[BusDefinition](x, IPXACT2009scalaxb.ElemName(node) :: stack)))) |
      ((IPXACT2009scalaxb.ElemName(Some("http://www.spiritconsortium.org/XMLSchema/SPIRIT/1685-2009"), "abstractionDefinition")) ^^
      (x => IPXACT2009scalaxb.DataRecord(x.namespace, Some(x.name), IPXACT2009scalaxb.fromXML[AbstractionDefinition](x, IPXACT2009scalaxb.ElemName(node) :: stack)))) |
      ((IPXACT2009scalaxb.ElemName(Some("http://www.spiritconsortium.org/XMLSchema/SPIRIT/1685-2009"), "component")) ^^
      (x => IPXACT2009scalaxb.DataRecord(x.namespace, Some(x.name), IPXACT2009scalaxb.fromXML[ComponentType](x, IPXACT2009scalaxb.ElemName(node) :: stack)))) |
      ((IPXACT2009scalaxb.ElemName(Some("http://www.spiritconsortium.org/XMLSchema/SPIRIT/1685-2009"), "abstractor")) ^^
      (x => IPXACT2009scalaxb.DataRecord(x.namespace, Some(x.name), IPXACT2009scalaxb.fromXML[AbstractorType](x, IPXACT2009scalaxb.ElemName(node) :: stack)))) |
      ((IPXACT2009scalaxb.ElemName(Some("http://www.spiritconsortium.org/XMLSchema/SPIRIT/1685-2009"), "design")) ^^
      (x => IPXACT2009scalaxb.DataRecord(x.namespace, Some(x.name), IPXACT2009scalaxb.fromXML[Design](x, IPXACT2009scalaxb.ElemName(node) :: stack)))) |
      ((IPXACT2009scalaxb.ElemName(Some("http://www.spiritconsortium.org/XMLSchema/SPIRIT/1685-2009"), "generatorChain")) ^^
      (x => IPXACT2009scalaxb.DataRecord(x.namespace, Some(x.name), IPXACT2009scalaxb.fromXML[GeneratorChain](x, IPXACT2009scalaxb.ElemName(node) :: stack)))) |
      ((IPXACT2009scalaxb.ElemName(Some("http://www.spiritconsortium.org/XMLSchema/SPIRIT/1685-2009"), "designConfiguration")) ^^
      (x => IPXACT2009scalaxb.DataRecord(x.namespace, Some(x.name), IPXACT2009scalaxb.fromXML[DesignConfiguration](x, IPXACT2009scalaxb.ElemName(node) :: stack)))))
  
    def parseIPXACTDocumentTypesGroup(node: scala.xml.Node, stack: List[IPXACT2009scalaxb.ElemName], wrap: Boolean): Parser[IPXACT2009scalaxb.DataRecord[IPXACTDocumentTypesOption]] =
      (((IPXACT2009scalaxb.ElemName(Some("http://www.spiritconsortium.org/XMLSchema/SPIRIT/1685-2009"), "busDefinition")) ^^
      (x => IPXACT2009scalaxb.DataRecord(x.namespace, Some(x.name), IPXACT2009scalaxb.fromXML[BusDefinition](x, IPXACT2009scalaxb.ElemName(node) :: stack)))) |
      ((IPXACT2009scalaxb.ElemName(Some("http://www.spiritconsortium.org/XMLSchema/SPIRIT/1685-2009"), "abstractionDefinition")) ^^
      (x => IPXACT2009scalaxb.DataRecord(x.namespace, Some(x.name), IPXACT2009scalaxb.fromXML[AbstractionDefinition](x, IPXACT2009scalaxb.ElemName(node) :: stack)))) |
      ((IPXACT2009scalaxb.ElemName(Some("http://www.spiritconsortium.org/XMLSchema/SPIRIT/1685-2009"), "component")) ^^
      (x => IPXACT2009scalaxb.DataRecord(x.namespace, Some(x.name), IPXACT2009scalaxb.fromXML[ComponentType](x, IPXACT2009scalaxb.ElemName(node) :: stack)))) |
      ((IPXACT2009scalaxb.ElemName(Some("http://www.spiritconsortium.org/XMLSchema/SPIRIT/1685-2009"), "abstractor")) ^^
      (x => IPXACT2009scalaxb.DataRecord(x.namespace, Some(x.name), IPXACT2009scalaxb.fromXML[AbstractorType](x, IPXACT2009scalaxb.ElemName(node) :: stack)))) |
      ((IPXACT2009scalaxb.ElemName(Some("http://www.spiritconsortium.org/XMLSchema/SPIRIT/1685-2009"), "design")) ^^
      (x => IPXACT2009scalaxb.DataRecord(x.namespace, Some(x.name), IPXACT2009scalaxb.fromXML[Design](x, IPXACT2009scalaxb.ElemName(node) :: stack)))) |
      ((IPXACT2009scalaxb.ElemName(Some("http://www.spiritconsortium.org/XMLSchema/SPIRIT/1685-2009"), "generatorChain")) ^^
      (x => IPXACT2009scalaxb.DataRecord(x.namespace, Some(x.name), IPXACT2009scalaxb.fromXML[GeneratorChain](x, IPXACT2009scalaxb.ElemName(node) :: stack)))) |
      ((IPXACT2009scalaxb.ElemName(Some("http://www.spiritconsortium.org/XMLSchema/SPIRIT/1685-2009"), "designConfiguration")) ^^
      (x => IPXACT2009scalaxb.DataRecord(x.namespace, Some(x.name), IPXACT2009scalaxb.fromXML[DesignConfiguration](x, IPXACT2009scalaxb.ElemName(node) :: stack)))))
    
    def parsemixedIPXACTDocumentTypesGroup(node: scala.xml.Node, stack: List[IPXACT2009scalaxb.ElemName]): Parser[Seq[IPXACT2009scalaxb.DataRecord[Any]]] =
      (((((IPXACT2009scalaxb.ElemName(Some("http://www.spiritconsortium.org/XMLSchema/SPIRIT/1685-2009"), "busDefinition")) ^^
      (x => IPXACT2009scalaxb.DataRecord(x.namespace, Some(x.name), IPXACT2009scalaxb.fromXML[BusDefinition](x, IPXACT2009scalaxb.ElemName(node) :: stack)))) ~
      optTextRecord) ^^ 
        { case p1 ~ p2 => Seq.concat(Seq(p1),
        p2.toList) }) ||| 
      ((((IPXACT2009scalaxb.ElemName(Some("http://www.spiritconsortium.org/XMLSchema/SPIRIT/1685-2009"), "abstractionDefinition")) ^^
      (x => IPXACT2009scalaxb.DataRecord(x.namespace, Some(x.name), IPXACT2009scalaxb.fromXML[AbstractionDefinition](x, IPXACT2009scalaxb.ElemName(node) :: stack)))) ~
      optTextRecord) ^^ 
        { case p1 ~ p2 => Seq.concat(Seq(p1),
        p2.toList) }) ||| 
      ((((IPXACT2009scalaxb.ElemName(Some("http://www.spiritconsortium.org/XMLSchema/SPIRIT/1685-2009"), "component")) ^^
      (x => IPXACT2009scalaxb.DataRecord(x.namespace, Some(x.name), IPXACT2009scalaxb.fromXML[ComponentType](x, IPXACT2009scalaxb.ElemName(node) :: stack)))) ~
      optTextRecord) ^^ 
        { case p1 ~ p2 => Seq.concat(Seq(p1),
        p2.toList) }) ||| 
      ((((IPXACT2009scalaxb.ElemName(Some("http://www.spiritconsortium.org/XMLSchema/SPIRIT/1685-2009"), "abstractor")) ^^
      (x => IPXACT2009scalaxb.DataRecord(x.namespace, Some(x.name), IPXACT2009scalaxb.fromXML[AbstractorType](x, IPXACT2009scalaxb.ElemName(node) :: stack)))) ~
      optTextRecord) ^^ 
        { case p1 ~ p2 => Seq.concat(Seq(p1),
        p2.toList) }) ||| 
      ((((IPXACT2009scalaxb.ElemName(Some("http://www.spiritconsortium.org/XMLSchema/SPIRIT/1685-2009"), "design")) ^^
      (x => IPXACT2009scalaxb.DataRecord(x.namespace, Some(x.name), IPXACT2009scalaxb.fromXML[Design](x, IPXACT2009scalaxb.ElemName(node) :: stack)))) ~
      optTextRecord) ^^ 
        { case p1 ~ p2 => Seq.concat(Seq(p1),
        p2.toList) }) ||| 
      ((((IPXACT2009scalaxb.ElemName(Some("http://www.spiritconsortium.org/XMLSchema/SPIRIT/1685-2009"), "generatorChain")) ^^
      (x => IPXACT2009scalaxb.DataRecord(x.namespace, Some(x.name), IPXACT2009scalaxb.fromXML[GeneratorChain](x, IPXACT2009scalaxb.ElemName(node) :: stack)))) ~
      optTextRecord) ^^ 
        { case p1 ~ p2 => Seq.concat(Seq(p1),
        p2.toList) }) ||| 
      ((((IPXACT2009scalaxb.ElemName(Some("http://www.spiritconsortium.org/XMLSchema/SPIRIT/1685-2009"), "designConfiguration")) ^^
      (x => IPXACT2009scalaxb.DataRecord(x.namespace, Some(x.name), IPXACT2009scalaxb.fromXML[DesignConfiguration](x, IPXACT2009scalaxb.ElemName(node) :: stack)))) ~
      optTextRecord) ^^ 
        { case p1 ~ p2 => Seq.concat(Seq(p1),
        p2.toList) }))
  }

  def build_AccessTypeFormat = new Default_AccessTypeFormat {}
  trait Default_AccessTypeFormat extends IPXACT2009scalaxb.XMLFormat[AccessType] {
    val targetNamespace: Option[String] = Some("http://www.spiritconsortium.org/XMLSchema/SPIRIT/1685-2009")
    
    def fromString(value: String, scope: scala.xml.NamespaceBinding): AccessType =
        (fromString0(value, scope)).apply(IPXACT2009scalaxb.fromXML[String](scala.xml.Text(value)))

    private def fromString0(value: String, scope: scala.xml.NamespaceBinding): PartialFunction[Any, AccessType] = {
      case x: String if x == IPXACT2009scalaxb.fromXML[String](scala.xml.Text("read-only")) => Readu45only
      case x: String if x == IPXACT2009scalaxb.fromXML[String](scala.xml.Text("write-only")) => Writeu45only
      case x: String if x == IPXACT2009scalaxb.fromXML[String](scala.xml.Text("read-write")) => Readu45write
      case x: String if x == IPXACT2009scalaxb.fromXML[String](scala.xml.Text("writeOnce")) => WriteOnce
      case x: String if x == IPXACT2009scalaxb.fromXML[String](scala.xml.Text("read-writeOnce")) => Readu45writeOnce

    }



    def reads(seq: scala.xml.NodeSeq, stack: List[IPXACT2009scalaxb.ElemName]): Either[String, AccessType] = seq match {
      case elem: scala.xml.Elem => Right(fromString(elem.text, elem.scope))
      case _ => Right(fromString(seq.text, scala.xml.TopScope))
    }
    
    def writes(__obj: AccessType, __namespace: Option[String], __elementLabel: Option[String],
        __scope: scala.xml.NamespaceBinding, __typeAttribute: Boolean): scala.xml.NodeSeq =
      scala.xml.Elem(IPXACT2009scalaxb.Helper.getPrefix(__namespace, __scope).orNull,
        __elementLabel getOrElse { sys.error("missing element label.") },
        scala.xml.Null, __scope, true, scala.xml.Text(__obj.toString))
  }
  def build_BankAlignmentTypeFormat = new Default_BankAlignmentTypeFormat {}
  trait Default_BankAlignmentTypeFormat extends IPXACT2009scalaxb.XMLFormat[BankAlignmentType] {
    val targetNamespace: Option[String] = Some("http://www.spiritconsortium.org/XMLSchema/SPIRIT/1685-2009")
    
    def fromString(value: String, scope: scala.xml.NamespaceBinding): BankAlignmentType =
        (fromString0(value, scope)).apply(IPXACT2009scalaxb.fromXML[String](scala.xml.Text(value)))

    private def fromString0(value: String, scope: scala.xml.NamespaceBinding): PartialFunction[Any, BankAlignmentType] = {
      case x: String if x == IPXACT2009scalaxb.fromXML[String](scala.xml.Text("serial")) => Serial
      case x: String if x == IPXACT2009scalaxb.fromXML[String](scala.xml.Text("parallel")) => Parallel

    }



    def reads(seq: scala.xml.NodeSeq, stack: List[IPXACT2009scalaxb.ElemName]): Either[String, BankAlignmentType] = seq match {
      case elem: scala.xml.Elem => Right(fromString(elem.text, elem.scope))
      case _ => Right(fromString(seq.text, scala.xml.TopScope))
    }
    
    def writes(__obj: BankAlignmentType, __namespace: Option[String], __elementLabel: Option[String],
        __scope: scala.xml.NamespaceBinding, __typeAttribute: Boolean): scala.xml.NodeSeq =
      scala.xml.Elem(IPXACT2009scalaxb.Helper.getPrefix(__namespace, __scope).orNull,
        __elementLabel getOrElse { sys.error("missing element label.") },
        scala.xml.Null, __scope, true, scala.xml.Text(__obj.toString))
  }
  def build_UsageTypeFormat = new Default_UsageTypeFormat {}
  trait Default_UsageTypeFormat extends IPXACT2009scalaxb.XMLFormat[UsageType] {
    val targetNamespace: Option[String] = Some("http://www.spiritconsortium.org/XMLSchema/SPIRIT/1685-2009")
    
    def fromString(value: String, scope: scala.xml.NamespaceBinding): UsageType =
        (fromString0(value, scope)).apply(IPXACT2009scalaxb.fromXML[String](scala.xml.Text(value)))

    private def fromString0(value: String, scope: scala.xml.NamespaceBinding): PartialFunction[Any, UsageType] = {
      case x: String if x == IPXACT2009scalaxb.fromXML[String](scala.xml.Text("memory")) => Memory
      case x: String if x == IPXACT2009scalaxb.fromXML[String](scala.xml.Text("register")) => RegisterValue
      case x: String if x == IPXACT2009scalaxb.fromXML[String](scala.xml.Text("reserved")) => Reserved

    }



    def reads(seq: scala.xml.NodeSeq, stack: List[IPXACT2009scalaxb.ElemName]): Either[String, UsageType] = seq match {
      case elem: scala.xml.Elem => Right(fromString(elem.text, elem.scope))
      case _ => Right(fromString(seq.text, scala.xml.TopScope))
    }
    
    def writes(__obj: UsageType, __namespace: Option[String], __elementLabel: Option[String],
        __scope: scala.xml.NamespaceBinding, __typeAttribute: Boolean): scala.xml.NodeSeq =
      scala.xml.Elem(IPXACT2009scalaxb.Helper.getPrefix(__namespace, __scope).orNull,
        __elementLabel getOrElse { sys.error("missing element label.") },
        scala.xml.Null, __scope, true, scala.xml.Text(__obj.toString))
  }
  trait Default_AddressBankTypeFormat extends IPXACT2009scalaxb.ElemNameParser[AddressBankType] with _NameGroupGroupFormat with _AddressSpecifierGroupFormat with _BankBaseGroupFormat {
    val targetNamespace: Option[String] = Some("http://www.spiritconsortium.org/XMLSchema/SPIRIT/1685-2009")
    
    override def typeName: Option[String] = Some("addressBankType")

    def parser(node: scala.xml.Node, stack: List[IPXACT2009scalaxb.ElemName]): Parser[AddressBankType] =
      phrase((parseNameGroupGroup(node, IPXACT2009scalaxb.ElemName(node) :: stack)) ~
      (parseAddressSpecifierGroup(node, IPXACT2009scalaxb.ElemName(node) :: stack)) ~
      (parseBankBaseGroup(node, IPXACT2009scalaxb.ElemName(node) :: stack)) ^^
      { case p1 ~ p2 ~ p3 =>
      AddressBankType(p1,
        p2,
        p3,
        scala.collection.immutable.ListMap(List(
        (node \ "@{http://www.spiritconsortium.org/XMLSchema/SPIRIT/1685-2009}bankAlignment").headOption map { x => IPXACT2009scalaxb.DataRecord(x, node, IPXACT2009scalaxb.fromXML[BankAlignmentType](x, IPXACT2009scalaxb.ElemName(node) :: stack)) } map { "@{http://www.spiritconsortium.org/XMLSchema/SPIRIT/1685-2009}bankAlignment" -> _ }
        ).flatten[(String, IPXACT2009scalaxb.DataRecord[Any])]: _*)) })
    
    override def writesAttribute(__obj: AddressBankType, __scope: scala.xml.NamespaceBinding): scala.xml.MetaData = {
      var attr: scala.xml.MetaData  = scala.xml.Null
      __obj.attributes.toList map {
        case ("@{http://www.spiritconsortium.org/XMLSchema/SPIRIT/1685-2009}bankAlignment", _) => attr = scala.xml.Attribute(__scope.getPrefix("http://www.spiritconsortium.org/XMLSchema/SPIRIT/1685-2009"), "bankAlignment", __obj.spiritbankAlignment.toString, attr)
        case (key, x) => attr = scala.xml.Attribute((x.namespace map { __scope.getPrefix(_) }).orNull, x.key.orNull, x.value.toString, attr)
      }
      attr
    }

    def writesChildNodes(__obj: AddressBankType, __scope: scala.xml.NamespaceBinding): Seq[scala.xml.Node] =
      Seq.concat(IPXACT2009scalaxb.toXML[NameGroupSequence](__obj.nameGroupSequence1, None, Some("nameGroupSequence1"), __scope, false),
        IPXACT2009scalaxb.toXML[AddressSpecifierSequence](__obj.addressSpecifierSequence2, None, Some("addressSpecifierSequence2"), __scope, false),
        IPXACT2009scalaxb.toXML[BankBaseSequence](__obj.bankBaseSequence3, None, Some("bankBaseSequence3"), __scope, false))

  }

  trait Default_AddressBlockTypeFormat extends IPXACT2009scalaxb.ElemNameParser[AddressBlockType] with _NameGroupGroupFormat with _AddressSpecifierGroupFormat with _AddressBlockDefinitionGroupGroupFormat {
    val targetNamespace: Option[String] = Some("http://www.spiritconsortium.org/XMLSchema/SPIRIT/1685-2009")
    
    override def typeName: Option[String] = Some("addressBlockType")

    def parser(node: scala.xml.Node, stack: List[IPXACT2009scalaxb.ElemName]): Parser[AddressBlockType] =
      phrase((parseNameGroupGroup(node, IPXACT2009scalaxb.ElemName(node) :: stack)) ~
      (parseAddressSpecifierGroup(node, IPXACT2009scalaxb.ElemName(node) :: stack)) ~
      (parseAddressBlockDefinitionGroupGroup(node, IPXACT2009scalaxb.ElemName(node) :: stack)) ~
      opt(IPXACT2009scalaxb.ElemName(Some("http://www.spiritconsortium.org/XMLSchema/SPIRIT/1685-2009"), "vendorExtensions")) ^^
      { case p1 ~ p2 ~ p3 ~ p4 =>
      AddressBlockType(p1,
        p2,
        p3,
        p4.headOption map { IPXACT2009scalaxb.fromXML[VendorExtensions](_, IPXACT2009scalaxb.ElemName(node) :: stack) },
        scala.collection.immutable.ListMap(List(
        (node \ "@{http://www.spiritconsortium.org/XMLSchema/SPIRIT/1685-2009}id").headOption map { x => IPXACT2009scalaxb.DataRecord(x, node, IPXACT2009scalaxb.fromXML[String](x, IPXACT2009scalaxb.ElemName(node) :: stack)) } map { "@{http://www.spiritconsortium.org/XMLSchema/SPIRIT/1685-2009}id" -> _ }
        ).flatten[(String, IPXACT2009scalaxb.DataRecord[Any])]: _*)) })
    
    override def writesAttribute(__obj: AddressBlockType, __scope: scala.xml.NamespaceBinding): scala.xml.MetaData = {
      var attr: scala.xml.MetaData  = scala.xml.Null
      __obj.attributes.toList map {
        case ("@{http://www.spiritconsortium.org/XMLSchema/SPIRIT/1685-2009}id", _) => __obj.spiritid foreach { x => attr = scala.xml.Attribute(__scope.getPrefix("http://www.spiritconsortium.org/XMLSchema/SPIRIT/1685-2009"), "id", x.toString, attr) }
        case (key, x) => attr = scala.xml.Attribute((x.namespace map { __scope.getPrefix(_) }).orNull, x.key.orNull, x.value.toString, attr)
      }
      attr
    }

    def writesChildNodes(__obj: AddressBlockType, __scope: scala.xml.NamespaceBinding): Seq[scala.xml.Node] =
      Seq.concat(IPXACT2009scalaxb.toXML[NameGroupSequence](__obj.nameGroupSequence1, None, Some("nameGroupSequence1"), __scope, false),
        IPXACT2009scalaxb.toXML[AddressSpecifierSequence](__obj.addressSpecifierSequence2, None, Some("addressSpecifierSequence2"), __scope, false),
        IPXACT2009scalaxb.toXML[AddressBlockDefinitionGroupSequence](__obj.addressBlockDefinitionGroupSequence3, None, Some("addressBlockDefinitionGroupSequence3"), __scope, false),
        __obj.vendorExtensions map { IPXACT2009scalaxb.toXML[VendorExtensions](_, Some("http://www.spiritconsortium.org/XMLSchema/SPIRIT/1685-2009"), Some("vendorExtensions"), __scope, false) } getOrElse {Nil})

  }

  trait Default_AddrSpaceRefTypableFormat extends IPXACT2009scalaxb.XMLFormat[AddrSpaceRefTypable] {
    def reads(seq: scala.xml.NodeSeq, stack: List[IPXACT2009scalaxb.ElemName]): Either[String, AddrSpaceRefTypable] = seq match {
      case node: scala.xml.Node =>     
        IPXACT2009scalaxb.Helper.instanceType(node) match {
          
          case _ => Right(IPXACT2009scalaxb.fromXML[AddrSpaceRefType](node, stack))
        }
      case _ => Left("reads failed: seq must be scala.xml.Node")  
    }
    
    def writes(__obj: AddrSpaceRefTypable, __namespace: Option[String], __elementLabel: Option[String],
        __scope: scala.xml.NamespaceBinding, __typeAttribute: Boolean): scala.xml.NodeSeq = __obj match {
      case x: AddressSpaceRef => IPXACT2009scalaxb.toXML[AddressSpaceRef](x, __namespace, __elementLabel, __scope, true)
      case x: AddrSpaceRefType => IPXACT2009scalaxb.toXML[AddrSpaceRefType](x, __namespace, __elementLabel, __scope, __typeAttribute)
    }
  }
  trait Default_AddrSpaceRefTypeFormat extends IPXACT2009scalaxb.XMLFormat[AddrSpaceRefType] with IPXACT2009scalaxb.CanWriteChildNodes[AddrSpaceRefType] {
    val targetNamespace: Option[String] = Some("http://www.spiritconsortium.org/XMLSchema/SPIRIT/1685-2009")
    def reads(seq: scala.xml.NodeSeq, stack: List[IPXACT2009scalaxb.ElemName]): Either[String, AddrSpaceRefType] = seq match {
      case node: scala.xml.Node => Right(AddrSpaceRefType(scala.collection.immutable.ListMap(List(
        (node \ "@{http://www.spiritconsortium.org/XMLSchema/SPIRIT/1685-2009}addressSpaceRef").headOption map { x => IPXACT2009scalaxb.DataRecord(x, node, IPXACT2009scalaxb.fromXML[String](x, IPXACT2009scalaxb.ElemName(node) :: stack)) } map { "@{http://www.spiritconsortium.org/XMLSchema/SPIRIT/1685-2009}addressSpaceRef" -> _ }
        ).flatten[(String, IPXACT2009scalaxb.DataRecord[Any])]: _*)))
      case _ => Left("reads failed: seq must be scala.xml.Node")
    }
    
    override def writesAttribute(__obj: AddrSpaceRefType, __scope: scala.xml.NamespaceBinding): scala.xml.MetaData = {
      var attr: scala.xml.MetaData  = scala.xml.Null
      __obj.attributes.toList map {
        case ("@{http://www.spiritconsortium.org/XMLSchema/SPIRIT/1685-2009}addressSpaceRef", _) => attr = scala.xml.Attribute(__scope.getPrefix("http://www.spiritconsortium.org/XMLSchema/SPIRIT/1685-2009"), "addressSpaceRef", __obj.spiritaddressSpaceRef.toString, attr)
        case (key, x) => attr = scala.xml.Attribute((x.namespace map { __scope.getPrefix(_) }).orNull, x.key.orNull, x.value.toString, attr)
      }
      attr
    }

    def writesChildNodes(__obj: AddrSpaceRefType, __scope: scala.xml.NamespaceBinding): Seq[scala.xml.Node] =
      Nil

  }

  trait Default_MemoryMapRefTypeFormat extends IPXACT2009scalaxb.XMLFormat[MemoryMapRefType] with IPXACT2009scalaxb.CanWriteChildNodes[MemoryMapRefType] {
    val targetNamespace: Option[String] = Some("http://www.spiritconsortium.org/XMLSchema/SPIRIT/1685-2009")
    def reads(seq: scala.xml.NodeSeq, stack: List[IPXACT2009scalaxb.ElemName]): Either[String, MemoryMapRefType] = seq match {
      case node: scala.xml.Node => Right(MemoryMapRefType(scala.collection.immutable.ListMap(List(
        (node \ "@{http://www.spiritconsortium.org/XMLSchema/SPIRIT/1685-2009}memoryMapRef").headOption map { x => IPXACT2009scalaxb.DataRecord(x, node, IPXACT2009scalaxb.fromXML[String](x, IPXACT2009scalaxb.ElemName(node) :: stack)) } map { "@{http://www.spiritconsortium.org/XMLSchema/SPIRIT/1685-2009}memoryMapRef" -> _ }
        ).flatten[(String, IPXACT2009scalaxb.DataRecord[Any])]: _*)))
      case _ => Left("reads failed: seq must be scala.xml.Node")
    }
    
    override def writesAttribute(__obj: MemoryMapRefType, __scope: scala.xml.NamespaceBinding): scala.xml.MetaData = {
      var attr: scala.xml.MetaData  = scala.xml.Null
      __obj.attributes.toList map {
        case ("@{http://www.spiritconsortium.org/XMLSchema/SPIRIT/1685-2009}memoryMapRef", _) => attr = scala.xml.Attribute(__scope.getPrefix("http://www.spiritconsortium.org/XMLSchema/SPIRIT/1685-2009"), "memoryMapRef", __obj.spiritmemoryMapRef.toString, attr)
        case (key, x) => attr = scala.xml.Attribute((x.namespace map { __scope.getPrefix(_) }).orNull, x.key.orNull, x.value.toString, attr)
      }
      attr
    }

    def writesChildNodes(__obj: MemoryMapRefType, __scope: scala.xml.NamespaceBinding): Seq[scala.xml.Node] =
      Nil

  }

  trait Default_BankedBankTypeFormat extends IPXACT2009scalaxb.ElemNameParser[BankedBankType] with _NameGroupGroupFormat with _BankBaseGroupFormat {
    val targetNamespace: Option[String] = Some("http://www.spiritconsortium.org/XMLSchema/SPIRIT/1685-2009")
    
    override def typeName: Option[String] = Some("bankedBankType")

    def parser(node: scala.xml.Node, stack: List[IPXACT2009scalaxb.ElemName]): Parser[BankedBankType] =
      phrase((parseNameGroupGroup(node, IPXACT2009scalaxb.ElemName(node) :: stack)) ~
      (parseBankBaseGroup(node, IPXACT2009scalaxb.ElemName(node) :: stack)) ^^
      { case p1 ~ p2 =>
      BankedBankType(p1,
        p2,
        scala.collection.immutable.ListMap(List(
        (node \ "@{http://www.spiritconsortium.org/XMLSchema/SPIRIT/1685-2009}bankAlignment").headOption map { x => IPXACT2009scalaxb.DataRecord(x, node, IPXACT2009scalaxb.fromXML[BankAlignmentType](x, IPXACT2009scalaxb.ElemName(node) :: stack)) } map { "@{http://www.spiritconsortium.org/XMLSchema/SPIRIT/1685-2009}bankAlignment" -> _ }
        ).flatten[(String, IPXACT2009scalaxb.DataRecord[Any])]: _*)) })
    
    override def writesAttribute(__obj: BankedBankType, __scope: scala.xml.NamespaceBinding): scala.xml.MetaData = {
      var attr: scala.xml.MetaData  = scala.xml.Null
      __obj.attributes.toList map {
        case ("@{http://www.spiritconsortium.org/XMLSchema/SPIRIT/1685-2009}bankAlignment", _) => attr = scala.xml.Attribute(__scope.getPrefix("http://www.spiritconsortium.org/XMLSchema/SPIRIT/1685-2009"), "bankAlignment", __obj.spiritbankAlignment.toString, attr)
        case (key, x) => attr = scala.xml.Attribute((x.namespace map { __scope.getPrefix(_) }).orNull, x.key.orNull, x.value.toString, attr)
      }
      attr
    }

    def writesChildNodes(__obj: BankedBankType, __scope: scala.xml.NamespaceBinding): Seq[scala.xml.Node] =
      Seq.concat(IPXACT2009scalaxb.toXML[NameGroupSequence](__obj.nameGroupSequence1, None, Some("nameGroupSequence1"), __scope, false),
        IPXACT2009scalaxb.toXML[BankBaseSequence](__obj.bankBaseSequence2, None, Some("bankBaseSequence2"), __scope, false))

  }

  trait Default_BankedBlockTypeFormat extends IPXACT2009scalaxb.ElemNameParser[BankedBlockType] with _NameGroupGroupFormat with _BlockSizeGroupFormat with _AddressBlockExtensionsGroupFormat {
    val targetNamespace: Option[String] = Some("http://www.spiritconsortium.org/XMLSchema/SPIRIT/1685-2009")
    
    override def typeName: Option[String] = Some("bankedBlockType")

    def parser(node: scala.xml.Node, stack: List[IPXACT2009scalaxb.ElemName]): Parser[BankedBlockType] =
      phrase((parseNameGroupGroup(node, IPXACT2009scalaxb.ElemName(node) :: stack)) ~
      (parseBlockSizeGroup(node, IPXACT2009scalaxb.ElemName(node) :: stack)) ~
      (parseAddressBlockExtensionsGroup(node, IPXACT2009scalaxb.ElemName(node) :: stack)) ~
      opt(IPXACT2009scalaxb.ElemName(Some("http://www.spiritconsortium.org/XMLSchema/SPIRIT/1685-2009"), "vendorExtensions")) ^^
      { case p1 ~ p2 ~ p3 ~ p4 =>
      BankedBlockType(p1,
        p2,
        p3,
        p4.headOption map { IPXACT2009scalaxb.fromXML[VendorExtensions](_, IPXACT2009scalaxb.ElemName(node) :: stack) },
        scala.collection.immutable.ListMap(List(
        (node \ "@{http://www.spiritconsortium.org/XMLSchema/SPIRIT/1685-2009}id").headOption map { x => IPXACT2009scalaxb.DataRecord(x, node, IPXACT2009scalaxb.fromXML[String](x, IPXACT2009scalaxb.ElemName(node) :: stack)) } map { "@{http://www.spiritconsortium.org/XMLSchema/SPIRIT/1685-2009}id" -> _ }
        ).flatten[(String, IPXACT2009scalaxb.DataRecord[Any])]: _*)) })
    
    override def writesAttribute(__obj: BankedBlockType, __scope: scala.xml.NamespaceBinding): scala.xml.MetaData = {
      var attr: scala.xml.MetaData  = scala.xml.Null
      __obj.attributes.toList map {
        case ("@{http://www.spiritconsortium.org/XMLSchema/SPIRIT/1685-2009}id", _) => __obj.spiritid foreach { x => attr = scala.xml.Attribute(__scope.getPrefix("http://www.spiritconsortium.org/XMLSchema/SPIRIT/1685-2009"), "id", x.toString, attr) }
        case (key, x) => attr = scala.xml.Attribute((x.namespace map { __scope.getPrefix(_) }).orNull, x.key.orNull, x.value.toString, attr)
      }
      attr
    }

    def writesChildNodes(__obj: BankedBlockType, __scope: scala.xml.NamespaceBinding): Seq[scala.xml.Node] =
      Seq.concat(IPXACT2009scalaxb.toXML[NameGroupSequence](__obj.nameGroupSequence1, None, Some("nameGroupSequence1"), __scope, false),
        IPXACT2009scalaxb.toXML[BlockSizeSequence](__obj.blockSizeSequence2, None, Some("blockSizeSequence2"), __scope, false),
        IPXACT2009scalaxb.toXML[AddressBlockExtensionsSequence](__obj.addressBlockExtensionsSequence3, None, Some("addressBlockExtensionsSequence3"), __scope, false),
        __obj.vendorExtensions map { IPXACT2009scalaxb.toXML[VendorExtensions](_, Some("http://www.spiritconsortium.org/XMLSchema/SPIRIT/1685-2009"), Some("vendorExtensions"), __scope, false) } getOrElse {Nil})

  }

  trait Default_BankedSubspaceTypeFormat extends IPXACT2009scalaxb.ElemNameParser[BankedSubspaceType] with _NameGroupOptionalGroupFormat {
    val targetNamespace: Option[String] = Some("http://www.spiritconsortium.org/XMLSchema/SPIRIT/1685-2009")
    
    override def typeName: Option[String] = Some("bankedSubspaceType")

    def parser(node: scala.xml.Node, stack: List[IPXACT2009scalaxb.ElemName]): Parser[BankedSubspaceType] =
      phrase((parseNameGroupOptionalGroup(node, IPXACT2009scalaxb.ElemName(node) :: stack)) ~
      opt(IPXACT2009scalaxb.ElemName(Some("http://www.spiritconsortium.org/XMLSchema/SPIRIT/1685-2009"), "parameters")) ~
      opt(IPXACT2009scalaxb.ElemName(Some("http://www.spiritconsortium.org/XMLSchema/SPIRIT/1685-2009"), "vendorExtensions")) ^^
      { case p1 ~ p2 ~ p3 =>
      BankedSubspaceType(p1,
        p2.headOption map { IPXACT2009scalaxb.fromXML[Parameters](_, IPXACT2009scalaxb.ElemName(node) :: stack) },
        p3.headOption map { IPXACT2009scalaxb.fromXML[VendorExtensions](_, IPXACT2009scalaxb.ElemName(node) :: stack) },
        scala.collection.immutable.ListMap(List(
        (node \ "@{http://www.spiritconsortium.org/XMLSchema/SPIRIT/1685-2009}masterRef").headOption map { x => IPXACT2009scalaxb.DataRecord(x, node, IPXACT2009scalaxb.fromXML[String](x, IPXACT2009scalaxb.ElemName(node) :: stack)) } map { "@{http://www.spiritconsortium.org/XMLSchema/SPIRIT/1685-2009}masterRef" -> _ }
        ).flatten[(String, IPXACT2009scalaxb.DataRecord[Any])]: _*)) })
    
    override def writesAttribute(__obj: BankedSubspaceType, __scope: scala.xml.NamespaceBinding): scala.xml.MetaData = {
      var attr: scala.xml.MetaData  = scala.xml.Null
      __obj.attributes.toList map {
        case ("@{http://www.spiritconsortium.org/XMLSchema/SPIRIT/1685-2009}masterRef", _) => attr = scala.xml.Attribute(__scope.getPrefix("http://www.spiritconsortium.org/XMLSchema/SPIRIT/1685-2009"), "masterRef", __obj.spiritmasterRef.toString, attr)
        case (key, x) => attr = scala.xml.Attribute((x.namespace map { __scope.getPrefix(_) }).orNull, x.key.orNull, x.value.toString, attr)
      }
      attr
    }

    def writesChildNodes(__obj: BankedSubspaceType, __scope: scala.xml.NamespaceBinding): Seq[scala.xml.Node] =
      Seq.concat(IPXACT2009scalaxb.toXML[NameGroupOptionalSequence](__obj.nameGroupOptionalSequence1, None, Some("nameGroupOptionalSequence1"), __scope, false),
        __obj.parameters map { IPXACT2009scalaxb.toXML[Parameters](_, Some("http://www.spiritconsortium.org/XMLSchema/SPIRIT/1685-2009"), Some("parameters"), __scope, false) } getOrElse {Nil},
        __obj.vendorExtensions map { IPXACT2009scalaxb.toXML[VendorExtensions](_, Some("http://www.spiritconsortium.org/XMLSchema/SPIRIT/1685-2009"), Some("vendorExtensions"), __scope, false) } getOrElse {Nil})

  }

  trait Default_FieldTypeFormat extends IPXACT2009scalaxb.ElemNameParser[FieldType] with _NameGroupGroupFormat with _FieldDefinitionGroupGroupFormat {
    val targetNamespace: Option[String] = Some("http://www.spiritconsortium.org/XMLSchema/SPIRIT/1685-2009")
    
    override def typeName: Option[String] = Some("fieldType")

    def parser(node: scala.xml.Node, stack: List[IPXACT2009scalaxb.ElemName]): Parser[FieldType] =
      phrase((parseNameGroupGroup(node, IPXACT2009scalaxb.ElemName(node) :: stack)) ~
      (IPXACT2009scalaxb.ElemName(Some("http://www.spiritconsortium.org/XMLSchema/SPIRIT/1685-2009"), "bitOffset")) ~
      (parseFieldDefinitionGroupGroup(node, IPXACT2009scalaxb.ElemName(node) :: stack)) ~
      opt(IPXACT2009scalaxb.ElemName(Some("http://www.spiritconsortium.org/XMLSchema/SPIRIT/1685-2009"), "parameters")) ~
      opt(IPXACT2009scalaxb.ElemName(Some("http://www.spiritconsortium.org/XMLSchema/SPIRIT/1685-2009"), "vendorExtensions")) ^^
      { case p1 ~ p2 ~ p3 ~ p4 ~ p5 =>
      FieldType(p1,
        IPXACT2009scalaxb.fromXML[BigInt](p2, IPXACT2009scalaxb.ElemName(node) :: stack),
        p3,
        p4.headOption map { IPXACT2009scalaxb.fromXML[Parameters](_, IPXACT2009scalaxb.ElemName(node) :: stack) },
        p5.headOption map { IPXACT2009scalaxb.fromXML[VendorExtensions](_, IPXACT2009scalaxb.ElemName(node) :: stack) },
        scala.collection.immutable.ListMap(List(
        (node \ "@{http://www.spiritconsortium.org/XMLSchema/SPIRIT/1685-2009}id").headOption map { x => IPXACT2009scalaxb.DataRecord(x, node, IPXACT2009scalaxb.fromXML[String](x, IPXACT2009scalaxb.ElemName(node) :: stack)) } map { "@{http://www.spiritconsortium.org/XMLSchema/SPIRIT/1685-2009}id" -> _ }
        ).flatten[(String, IPXACT2009scalaxb.DataRecord[Any])]: _*)) })
    
    override def writesAttribute(__obj: FieldType, __scope: scala.xml.NamespaceBinding): scala.xml.MetaData = {
      var attr: scala.xml.MetaData  = scala.xml.Null
      __obj.attributes.toList map {
        case ("@{http://www.spiritconsortium.org/XMLSchema/SPIRIT/1685-2009}id", _) => __obj.spiritid foreach { x => attr = scala.xml.Attribute(__scope.getPrefix("http://www.spiritconsortium.org/XMLSchema/SPIRIT/1685-2009"), "id", x.toString, attr) }
        case (key, x) => attr = scala.xml.Attribute((x.namespace map { __scope.getPrefix(_) }).orNull, x.key.orNull, x.value.toString, attr)
      }
      attr
    }

    def writesChildNodes(__obj: FieldType, __scope: scala.xml.NamespaceBinding): Seq[scala.xml.Node] =
      Seq.concat(IPXACT2009scalaxb.toXML[NameGroupSequence](__obj.nameGroupSequence1, None, Some("nameGroupSequence1"), __scope, false),
        IPXACT2009scalaxb.toXML[BigInt](__obj.bitOffset, Some("http://www.spiritconsortium.org/XMLSchema/SPIRIT/1685-2009"), Some("bitOffset"), __scope, false),
        IPXACT2009scalaxb.toXML[FieldDefinitionGroupSequence](__obj.fieldDefinitionGroupSequence3, None, Some("fieldDefinitionGroupSequence3"), __scope, false),
        __obj.parameters map { IPXACT2009scalaxb.toXML[Parameters](_, Some("http://www.spiritconsortium.org/XMLSchema/SPIRIT/1685-2009"), Some("parameters"), __scope, false) } getOrElse {Nil},
        __obj.vendorExtensions map { IPXACT2009scalaxb.toXML[VendorExtensions](_, Some("http://www.spiritconsortium.org/XMLSchema/SPIRIT/1685-2009"), Some("vendorExtensions"), __scope, false) } getOrElse {Nil})

  }

  trait Default_MemoryMapTypeFormat extends IPXACT2009scalaxb.ElemNameParser[MemoryMapType] with _NameGroupGroupFormat with _MemoryMapGroupFormat {
    val targetNamespace: Option[String] = Some("http://www.spiritconsortium.org/XMLSchema/SPIRIT/1685-2009")
    
    override def typeName: Option[String] = Some("memoryMapType")

    def parser(node: scala.xml.Node, stack: List[IPXACT2009scalaxb.ElemName]): Parser[MemoryMapType] =
      phrase((parseNameGroupGroup(node, IPXACT2009scalaxb.ElemName(node) :: stack)) ~
      safeRep(parseMemoryMapGroup(node, IPXACT2009scalaxb.ElemName(node) :: stack)) ~
      safeRep(IPXACT2009scalaxb.ElemName(Some("http://www.spiritconsortium.org/XMLSchema/SPIRIT/1685-2009"), "memoryRemap")) ~
      opt(IPXACT2009scalaxb.ElemName(Some("http://www.spiritconsortium.org/XMLSchema/SPIRIT/1685-2009"), "addressUnitBits")) ~
      opt(IPXACT2009scalaxb.ElemName(Some("http://www.spiritconsortium.org/XMLSchema/SPIRIT/1685-2009"), "vendorExtensions")) ^^
      { case p1 ~ p2 ~ p3 ~ p4 ~ p5 =>
      MemoryMapType(p1,
        p2,
        p3 map { IPXACT2009scalaxb.fromXML[MemoryRemapType](_, IPXACT2009scalaxb.ElemName(node) :: stack) },
        p4.headOption map { IPXACT2009scalaxb.fromXML[BigInt](_, IPXACT2009scalaxb.ElemName(node) :: stack) },
        p5.headOption map { IPXACT2009scalaxb.fromXML[VendorExtensions](_, IPXACT2009scalaxb.ElemName(node) :: stack) },
        scala.collection.immutable.ListMap(List(
        (node \ "@{http://www.spiritconsortium.org/XMLSchema/SPIRIT/1685-2009}id").headOption map { x => IPXACT2009scalaxb.DataRecord(x, node, IPXACT2009scalaxb.fromXML[String](x, IPXACT2009scalaxb.ElemName(node) :: stack)) } map { "@{http://www.spiritconsortium.org/XMLSchema/SPIRIT/1685-2009}id" -> _ }
        ).flatten[(String, IPXACT2009scalaxb.DataRecord[Any])]: _*)) })
    
    override def writesAttribute(__obj: MemoryMapType, __scope: scala.xml.NamespaceBinding): scala.xml.MetaData = {
      var attr: scala.xml.MetaData  = scala.xml.Null
      __obj.attributes.toList map {
        case ("@{http://www.spiritconsortium.org/XMLSchema/SPIRIT/1685-2009}id", _) => __obj.spiritid foreach { x => attr = scala.xml.Attribute(__scope.getPrefix("http://www.spiritconsortium.org/XMLSchema/SPIRIT/1685-2009"), "id", x.toString, attr) }
        case (key, x) => attr = scala.xml.Attribute((x.namespace map { __scope.getPrefix(_) }).orNull, x.key.orNull, x.value.toString, attr)
      }
      attr
    }

    def writesChildNodes(__obj: MemoryMapType, __scope: scala.xml.NamespaceBinding): Seq[scala.xml.Node] =
      Seq.concat(IPXACT2009scalaxb.toXML[NameGroupSequence](__obj.nameGroupSequence1, None, Some("nameGroupSequence1"), __scope, false),
        __obj.memoryMapOption2 flatMap { x => IPXACT2009scalaxb.toXML[IPXACT2009scalaxb.DataRecord[MemoryMapOption]](x, x.namespace, x.key, __scope, false) },
        __obj.memoryRemap flatMap { IPXACT2009scalaxb.toXML[MemoryRemapType](_, Some("http://www.spiritconsortium.org/XMLSchema/SPIRIT/1685-2009"), Some("memoryRemap"), __scope, false) },
        __obj.addressUnitBits map { IPXACT2009scalaxb.toXML[BigInt](_, Some("http://www.spiritconsortium.org/XMLSchema/SPIRIT/1685-2009"), Some("addressUnitBits"), __scope, false) } getOrElse {Nil},
        __obj.vendorExtensions map { IPXACT2009scalaxb.toXML[VendorExtensions](_, Some("http://www.spiritconsortium.org/XMLSchema/SPIRIT/1685-2009"), Some("vendorExtensions"), __scope, false) } getOrElse {Nil})

  }

  trait Default_MemoryRemapTypeFormat extends IPXACT2009scalaxb.ElemNameParser[MemoryRemapType] with _NameGroupGroupFormat with _MemoryMapGroupFormat {
    val targetNamespace: Option[String] = Some("http://www.spiritconsortium.org/XMLSchema/SPIRIT/1685-2009")
    
    override def typeName: Option[String] = Some("memoryRemapType")

    def parser(node: scala.xml.Node, stack: List[IPXACT2009scalaxb.ElemName]): Parser[MemoryRemapType] =
      phrase((parseNameGroupGroup(node, IPXACT2009scalaxb.ElemName(node) :: stack)) ~
      safeRep(parseMemoryMapGroup(node, IPXACT2009scalaxb.ElemName(node) :: stack)) ^^
      { case p1 ~ p2 =>
      MemoryRemapType(p1,
        p2,
        scala.collection.immutable.ListMap(List(
        (node \ "@{http://www.spiritconsortium.org/XMLSchema/SPIRIT/1685-2009}state").headOption map { x => IPXACT2009scalaxb.DataRecord(x, node, IPXACT2009scalaxb.fromXML[String](x, IPXACT2009scalaxb.ElemName(node) :: stack)) } map { "@state" -> _ },
        (node \ "@{http://www.spiritconsortium.org/XMLSchema/SPIRIT/1685-2009}id").headOption map { x => IPXACT2009scalaxb.DataRecord(x, node, IPXACT2009scalaxb.fromXML[String](x, IPXACT2009scalaxb.ElemName(node) :: stack)) } map { "@{http://www.spiritconsortium.org/XMLSchema/SPIRIT/1685-2009}id" -> _ }
        ).flatten[(String, IPXACT2009scalaxb.DataRecord[Any])]: _*)) })
    
    override def writesAttribute(__obj: MemoryRemapType, __scope: scala.xml.NamespaceBinding): scala.xml.MetaData = {
      var attr: scala.xml.MetaData  = scala.xml.Null
      __obj.attributes.toList map {
        case ("@state", _) => attr = scala.xml.Attribute(__scope.getPrefix("http://www.spiritconsortium.org/XMLSchema/SPIRIT/1685-2009"), "state", __obj.state.toString, attr)
        case ("@{http://www.spiritconsortium.org/XMLSchema/SPIRIT/1685-2009}id", _) => __obj.spiritid foreach { x => attr = scala.xml.Attribute(__scope.getPrefix("http://www.spiritconsortium.org/XMLSchema/SPIRIT/1685-2009"), "id", x.toString, attr) }
        case (key, x) => attr = scala.xml.Attribute((x.namespace map { __scope.getPrefix(_) }).orNull, x.key.orNull, x.value.toString, attr)
      }
      attr
    }

    def writesChildNodes(__obj: MemoryRemapType, __scope: scala.xml.NamespaceBinding): Seq[scala.xml.Node] =
      Seq.concat(IPXACT2009scalaxb.toXML[NameGroupSequence](__obj.nameGroupSequence1, None, Some("nameGroupSequence1"), __scope, false),
        __obj.memoryMapOption2 flatMap { x => IPXACT2009scalaxb.toXML[IPXACT2009scalaxb.DataRecord[MemoryMapOption]](x, x.namespace, x.key, __scope, false) })

  }

  trait Default_LocalMemoryMapTypeFormat extends IPXACT2009scalaxb.ElemNameParser[LocalMemoryMapType] with _NameGroupGroupFormat with _MemoryMapGroupFormat {
    val targetNamespace: Option[String] = Some("http://www.spiritconsortium.org/XMLSchema/SPIRIT/1685-2009")
    
    override def typeName: Option[String] = Some("localMemoryMapType")

    def parser(node: scala.xml.Node, stack: List[IPXACT2009scalaxb.ElemName]): Parser[LocalMemoryMapType] =
      phrase((parseNameGroupGroup(node, IPXACT2009scalaxb.ElemName(node) :: stack)) ~
      safeRep(parseMemoryMapGroup(node, IPXACT2009scalaxb.ElemName(node) :: stack)) ^^
      { case p1 ~ p2 =>
      LocalMemoryMapType(p1,
        p2,
        scala.collection.immutable.ListMap(List(
        (node \ "@{http://www.spiritconsortium.org/XMLSchema/SPIRIT/1685-2009}id").headOption map { x => IPXACT2009scalaxb.DataRecord(x, node, IPXACT2009scalaxb.fromXML[String](x, IPXACT2009scalaxb.ElemName(node) :: stack)) } map { "@{http://www.spiritconsortium.org/XMLSchema/SPIRIT/1685-2009}id" -> _ }
        ).flatten[(String, IPXACT2009scalaxb.DataRecord[Any])]: _*)) })
    
    override def writesAttribute(__obj: LocalMemoryMapType, __scope: scala.xml.NamespaceBinding): scala.xml.MetaData = {
      var attr: scala.xml.MetaData  = scala.xml.Null
      __obj.attributes.toList map {
        case ("@{http://www.spiritconsortium.org/XMLSchema/SPIRIT/1685-2009}id", _) => __obj.spiritid foreach { x => attr = scala.xml.Attribute(__scope.getPrefix("http://www.spiritconsortium.org/XMLSchema/SPIRIT/1685-2009"), "id", x.toString, attr) }
        case (key, x) => attr = scala.xml.Attribute((x.namespace map { __scope.getPrefix(_) }).orNull, x.key.orNull, x.value.toString, attr)
      }
      attr
    }

    def writesChildNodes(__obj: LocalMemoryMapType, __scope: scala.xml.NamespaceBinding): Seq[scala.xml.Node] =
      Seq.concat(IPXACT2009scalaxb.toXML[NameGroupSequence](__obj.nameGroupSequence1, None, Some("nameGroupSequence1"), __scope, false),
        __obj.memoryMapOption2 flatMap { x => IPXACT2009scalaxb.toXML[IPXACT2009scalaxb.DataRecord[MemoryMapOption]](x, x.namespace, x.key, __scope, false) })

  }

  trait Default_SubspaceRefTypeFormat extends IPXACT2009scalaxb.ElemNameParser[SubspaceRefType] with _NameGroupGroupFormat with _AddressSpecifierGroupFormat {
    val targetNamespace: Option[String] = Some("http://www.spiritconsortium.org/XMLSchema/SPIRIT/1685-2009")
    
    override def typeName: Option[String] = Some("subspaceRefType")

    def parser(node: scala.xml.Node, stack: List[IPXACT2009scalaxb.ElemName]): Parser[SubspaceRefType] =
      phrase((parseNameGroupGroup(node, IPXACT2009scalaxb.ElemName(node) :: stack)) ~
      (parseAddressSpecifierGroup(node, IPXACT2009scalaxb.ElemName(node) :: stack)) ~
      opt(IPXACT2009scalaxb.ElemName(Some("http://www.spiritconsortium.org/XMLSchema/SPIRIT/1685-2009"), "parameters")) ~
      opt(IPXACT2009scalaxb.ElemName(Some("http://www.spiritconsortium.org/XMLSchema/SPIRIT/1685-2009"), "vendorExtensions")) ^^
      { case p1 ~ p2 ~ p3 ~ p4 =>
      SubspaceRefType(p1,
        p2,
        p3.headOption map { IPXACT2009scalaxb.fromXML[Parameters](_, IPXACT2009scalaxb.ElemName(node) :: stack) },
        p4.headOption map { IPXACT2009scalaxb.fromXML[VendorExtensions](_, IPXACT2009scalaxb.ElemName(node) :: stack) },
        scala.collection.immutable.ListMap(List(
        (node \ "@{http://www.spiritconsortium.org/XMLSchema/SPIRIT/1685-2009}masterRef").headOption map { x => IPXACT2009scalaxb.DataRecord(x, node, IPXACT2009scalaxb.fromXML[String](x, IPXACT2009scalaxb.ElemName(node) :: stack)) } map { "@{http://www.spiritconsortium.org/XMLSchema/SPIRIT/1685-2009}masterRef" -> _ },
        (node \ "@{http://www.spiritconsortium.org/XMLSchema/SPIRIT/1685-2009}segmentRef").headOption map { x => IPXACT2009scalaxb.DataRecord(x, node, IPXACT2009scalaxb.fromXML[String](x, IPXACT2009scalaxb.ElemName(node) :: stack)) } map { "@{http://www.spiritconsortium.org/XMLSchema/SPIRIT/1685-2009}segmentRef" -> _ }
        ).flatten[(String, IPXACT2009scalaxb.DataRecord[Any])]: _*)) })
    
    override def writesAttribute(__obj: SubspaceRefType, __scope: scala.xml.NamespaceBinding): scala.xml.MetaData = {
      var attr: scala.xml.MetaData  = scala.xml.Null
      __obj.attributes.toList map {
        case ("@{http://www.spiritconsortium.org/XMLSchema/SPIRIT/1685-2009}masterRef", _) => attr = scala.xml.Attribute(__scope.getPrefix("http://www.spiritconsortium.org/XMLSchema/SPIRIT/1685-2009"), "masterRef", __obj.spiritmasterRef.toString, attr)
        case ("@{http://www.spiritconsortium.org/XMLSchema/SPIRIT/1685-2009}segmentRef", _) => __obj.spiritsegmentRef foreach { x => attr = scala.xml.Attribute(__scope.getPrefix("http://www.spiritconsortium.org/XMLSchema/SPIRIT/1685-2009"), "segmentRef", x.toString, attr) }
        case (key, x) => attr = scala.xml.Attribute((x.namespace map { __scope.getPrefix(_) }).orNull, x.key.orNull, x.value.toString, attr)
      }
      attr
    }

    def writesChildNodes(__obj: SubspaceRefType, __scope: scala.xml.NamespaceBinding): Seq[scala.xml.Node] =
      Seq.concat(IPXACT2009scalaxb.toXML[NameGroupSequence](__obj.nameGroupSequence1, None, Some("nameGroupSequence1"), __scope, false),
        IPXACT2009scalaxb.toXML[AddressSpecifierSequence](__obj.addressSpecifierSequence2, None, Some("addressSpecifierSequence2"), __scope, false),
        __obj.parameters map { IPXACT2009scalaxb.toXML[Parameters](_, Some("http://www.spiritconsortium.org/XMLSchema/SPIRIT/1685-2009"), Some("parameters"), __scope, false) } getOrElse {Nil},
        __obj.vendorExtensions map { IPXACT2009scalaxb.toXML[VendorExtensions](_, Some("http://www.spiritconsortium.org/XMLSchema/SPIRIT/1685-2009"), Some("vendorExtensions"), __scope, false) } getOrElse {Nil})

  }

  trait Default_AddressOffsetFormat extends IPXACT2009scalaxb.XMLFormat[AddressOffset] with IPXACT2009scalaxb.CanWriteChildNodes[AddressOffset] {
    val targetNamespace: Option[String] = Some("http://www.spiritconsortium.org/XMLSchema/SPIRIT/1685-2009")
    def reads(seq: scala.xml.NodeSeq, stack: List[IPXACT2009scalaxb.ElemName]): Either[String, AddressOffset] = seq match {
      case node: scala.xml.Node => Right(AddressOffset(IPXACT2009scalaxb.fromXML[String](node, IPXACT2009scalaxb.ElemName(node) :: stack),
        scala.collection.immutable.ListMap(List(
        (node \ "@{http://www.spiritconsortium.org/XMLSchema/SPIRIT/1685-2009}format").headOption map { x => IPXACT2009scalaxb.DataRecord(x, node, IPXACT2009scalaxb.fromXML[FormatType](x, IPXACT2009scalaxb.ElemName(node) :: stack)) } orElse Some(IPXACT2009scalaxb.DataRecord(None, None, IPXACT2009scalaxb.fromXML[FormatType](scala.xml.Text("long"), IPXACT2009scalaxb.ElemName(node) :: stack))) map { "@{http://www.spiritconsortium.org/XMLSchema/SPIRIT/1685-2009}format" -> _ },
        (node \ "@{http://www.spiritconsortium.org/XMLSchema/SPIRIT/1685-2009}resolve").headOption map { x => IPXACT2009scalaxb.DataRecord(x, node, IPXACT2009scalaxb.fromXML[ResolveType](x, IPXACT2009scalaxb.ElemName(node) :: stack)) } map { "@{http://www.spiritconsortium.org/XMLSchema/SPIRIT/1685-2009}resolve" -> _ },
        (node \ "@{http://www.spiritconsortium.org/XMLSchema/SPIRIT/1685-2009}id").headOption map { x => IPXACT2009scalaxb.DataRecord(x, node, IPXACT2009scalaxb.fromXML[String](x, IPXACT2009scalaxb.ElemName(node) :: stack)) } map { "@{http://www.spiritconsortium.org/XMLSchema/SPIRIT/1685-2009}id" -> _ },
        (node \ "@{http://www.spiritconsortium.org/XMLSchema/SPIRIT/1685-2009}dependency").headOption map { x => IPXACT2009scalaxb.DataRecord(x, node, IPXACT2009scalaxb.fromXML[String](x, IPXACT2009scalaxb.ElemName(node) :: stack)) } map { "@{http://www.spiritconsortium.org/XMLSchema/SPIRIT/1685-2009}dependency" -> _ },
        (node \ "@{http://www.spiritconsortium.org/XMLSchema/SPIRIT/1685-2009}choiceRef").headOption map { x => IPXACT2009scalaxb.DataRecord(x, node, IPXACT2009scalaxb.fromXML[String](x, IPXACT2009scalaxb.ElemName(node) :: stack)) } map { "@{http://www.spiritconsortium.org/XMLSchema/SPIRIT/1685-2009}choiceRef" -> _ },
        (node \ "@{http://www.spiritconsortium.org/XMLSchema/SPIRIT/1685-2009}order").headOption map { x => IPXACT2009scalaxb.DataRecord(x, node, IPXACT2009scalaxb.fromXML[Float](x, IPXACT2009scalaxb.ElemName(node) :: stack)) } map { "@{http://www.spiritconsortium.org/XMLSchema/SPIRIT/1685-2009}order" -> _ },
        (node \ "@{http://www.spiritconsortium.org/XMLSchema/SPIRIT/1685-2009}configGroups").headOption map { x => IPXACT2009scalaxb.DataRecord(x, node, IPXACT2009scalaxb.fromXML[Seq[String]](x, IPXACT2009scalaxb.ElemName(node) :: stack)) } map { "@{http://www.spiritconsortium.org/XMLSchema/SPIRIT/1685-2009}configGroups" -> _ },
        (node \ "@{http://www.spiritconsortium.org/XMLSchema/SPIRIT/1685-2009}bitStringLength").headOption map { x => IPXACT2009scalaxb.DataRecord(x, node, IPXACT2009scalaxb.fromXML[BigInt](x, IPXACT2009scalaxb.ElemName(node) :: stack)) } map { "@{http://www.spiritconsortium.org/XMLSchema/SPIRIT/1685-2009}bitStringLength" -> _ },
        (node \ "@{http://www.spiritconsortium.org/XMLSchema/SPIRIT/1685-2009}minimum").headOption map { x => IPXACT2009scalaxb.DataRecord(x, node, IPXACT2009scalaxb.fromXML[String](x, IPXACT2009scalaxb.ElemName(node) :: stack)) } map { "@{http://www.spiritconsortium.org/XMLSchema/SPIRIT/1685-2009}minimum" -> _ },
        (node \ "@{http://www.spiritconsortium.org/XMLSchema/SPIRIT/1685-2009}maximum").headOption map { x => IPXACT2009scalaxb.DataRecord(x, node, IPXACT2009scalaxb.fromXML[String](x, IPXACT2009scalaxb.ElemName(node) :: stack)) } map { "@{http://www.spiritconsortium.org/XMLSchema/SPIRIT/1685-2009}maximum" -> _ },
        (node \ "@{http://www.spiritconsortium.org/XMLSchema/SPIRIT/1685-2009}rangeType").headOption map { x => IPXACT2009scalaxb.DataRecord(x, node, IPXACT2009scalaxb.fromXML[RangeTypeType](x, IPXACT2009scalaxb.ElemName(node) :: stack)) } orElse Some(IPXACT2009scalaxb.DataRecord(None, None, IPXACT2009scalaxb.fromXML[RangeTypeType](scala.xml.Text("float"), IPXACT2009scalaxb.ElemName(node) :: stack))) map { "@{http://www.spiritconsortium.org/XMLSchema/SPIRIT/1685-2009}rangeType" -> _ },
        (node \ "@{http://www.spiritconsortium.org/XMLSchema/SPIRIT/1685-2009}prompt").headOption map { x => IPXACT2009scalaxb.DataRecord(x, node, IPXACT2009scalaxb.fromXML[String](x, IPXACT2009scalaxb.ElemName(node) :: stack)) } map { "@{http://www.spiritconsortium.org/XMLSchema/SPIRIT/1685-2009}prompt" -> _ }
        ).flatten[(String, IPXACT2009scalaxb.DataRecord[Any])] ::: (node match {
          case elem: scala.xml.Elem =>
            elem.attributes.toList flatMap {
              case scala.xml.PrefixedAttribute(pre, key, value, _) if pre == elem.scope.getPrefix("http://www.spiritconsortium.org/XMLSchema/SPIRIT/1685-2009") &&
                key == "format" => Nil
              case scala.xml.PrefixedAttribute(pre, key, value, _) if pre == elem.scope.getPrefix("http://www.spiritconsortium.org/XMLSchema/SPIRIT/1685-2009") &&
                key == "resolve" => Nil
              case scala.xml.PrefixedAttribute(pre, key, value, _) if pre == elem.scope.getPrefix("http://www.spiritconsortium.org/XMLSchema/SPIRIT/1685-2009") &&
                key == "id" => Nil
              case scala.xml.PrefixedAttribute(pre, key, value, _) if pre == elem.scope.getPrefix("http://www.spiritconsortium.org/XMLSchema/SPIRIT/1685-2009") &&
                key == "dependency" => Nil
              case scala.xml.PrefixedAttribute(pre, key, value, _) if pre == elem.scope.getPrefix("http://www.spiritconsortium.org/XMLSchema/SPIRIT/1685-2009") &&
                key == "choiceRef" => Nil
              case scala.xml.PrefixedAttribute(pre, key, value, _) if pre == elem.scope.getPrefix("http://www.spiritconsortium.org/XMLSchema/SPIRIT/1685-2009") &&
                key == "order" => Nil
              case scala.xml.PrefixedAttribute(pre, key, value, _) if pre == elem.scope.getPrefix("http://www.spiritconsortium.org/XMLSchema/SPIRIT/1685-2009") &&
                key == "configGroups" => Nil
              case scala.xml.PrefixedAttribute(pre, key, value, _) if pre == elem.scope.getPrefix("http://www.spiritconsortium.org/XMLSchema/SPIRIT/1685-2009") &&
                key == "bitStringLength" => Nil
              case scala.xml.PrefixedAttribute(pre, key, value, _) if pre == elem.scope.getPrefix("http://www.spiritconsortium.org/XMLSchema/SPIRIT/1685-2009") &&
                key == "minimum" => Nil
              case scala.xml.PrefixedAttribute(pre, key, value, _) if pre == elem.scope.getPrefix("http://www.spiritconsortium.org/XMLSchema/SPIRIT/1685-2009") &&
                key == "maximum" => Nil
              case scala.xml.PrefixedAttribute(pre, key, value, _) if pre == elem.scope.getPrefix("http://www.spiritconsortium.org/XMLSchema/SPIRIT/1685-2009") &&
                key == "rangeType" => Nil
              case scala.xml.PrefixedAttribute(pre, key, value, _) if pre == elem.scope.getPrefix("http://www.spiritconsortium.org/XMLSchema/SPIRIT/1685-2009") &&
                key == "prompt" => Nil
              case scala.xml.UnprefixedAttribute(key, value, _) =>
                List(("@" + key, IPXACT2009scalaxb.DataRecord(None, Some(key), value.text)))
              case scala.xml.PrefixedAttribute(pre, key, value, _) =>
                val ns = elem.scope.getURI(pre)
                List(("@{" + ns + "}" + key, IPXACT2009scalaxb.DataRecord(Option[String](ns), Some(key), value.text)))
              case _ => Nil
            }
          case _ => Nil
        }): _*)))
      case _ => Left("reads failed: seq must be scala.xml.Node")
    }
    
    override def writesAttribute(__obj: AddressOffset, __scope: scala.xml.NamespaceBinding): scala.xml.MetaData = {
      var attr: scala.xml.MetaData  = scala.xml.Null
      __obj.attributes.toList map {
        case ("@{http://www.spiritconsortium.org/XMLSchema/SPIRIT/1685-2009}format", _) => if (__obj.spiritformat.toString != "long") attr = scala.xml.Attribute(__scope.getPrefix("http://www.spiritconsortium.org/XMLSchema/SPIRIT/1685-2009"), "format", __obj.spiritformat.toString, attr)
        case ("@{http://www.spiritconsortium.org/XMLSchema/SPIRIT/1685-2009}resolve", _) => __obj.spiritresolve foreach { x => attr = scala.xml.Attribute(__scope.getPrefix("http://www.spiritconsortium.org/XMLSchema/SPIRIT/1685-2009"), "resolve", x.toString, attr) }
        case ("@{http://www.spiritconsortium.org/XMLSchema/SPIRIT/1685-2009}id", _) => __obj.spiritid foreach { x => attr = scala.xml.Attribute(__scope.getPrefix("http://www.spiritconsortium.org/XMLSchema/SPIRIT/1685-2009"), "id", x.toString, attr) }
        case ("@{http://www.spiritconsortium.org/XMLSchema/SPIRIT/1685-2009}dependency", _) => __obj.spiritdependency foreach { x => attr = scala.xml.Attribute(__scope.getPrefix("http://www.spiritconsortium.org/XMLSchema/SPIRIT/1685-2009"), "dependency", x.toString, attr) }
        case ("@{http://www.spiritconsortium.org/XMLSchema/SPIRIT/1685-2009}choiceRef", _) => __obj.spiritchoiceRef foreach { x => attr = scala.xml.Attribute(__scope.getPrefix("http://www.spiritconsortium.org/XMLSchema/SPIRIT/1685-2009"), "choiceRef", x.toString, attr) }
        case ("@{http://www.spiritconsortium.org/XMLSchema/SPIRIT/1685-2009}order", _) => __obj.spiritorder foreach { x => attr = scala.xml.Attribute(__scope.getPrefix("http://www.spiritconsortium.org/XMLSchema/SPIRIT/1685-2009"), "order", x.toString, attr) }
        case ("@{http://www.spiritconsortium.org/XMLSchema/SPIRIT/1685-2009}configGroups", _) => __obj.spiritconfigGroups foreach { x => attr = scala.xml.Attribute(__scope.getPrefix("http://www.spiritconsortium.org/XMLSchema/SPIRIT/1685-2009"), "configGroups", x.toString, attr) }
        case ("@{http://www.spiritconsortium.org/XMLSchema/SPIRIT/1685-2009}bitStringLength", _) => __obj.spiritbitStringLength foreach { x => attr = scala.xml.Attribute(__scope.getPrefix("http://www.spiritconsortium.org/XMLSchema/SPIRIT/1685-2009"), "bitStringLength", x.toString, attr) }
        case ("@{http://www.spiritconsortium.org/XMLSchema/SPIRIT/1685-2009}minimum", _) => __obj.spiritminimum foreach { x => attr = scala.xml.Attribute(__scope.getPrefix("http://www.spiritconsortium.org/XMLSchema/SPIRIT/1685-2009"), "minimum", x.toString, attr) }
        case ("@{http://www.spiritconsortium.org/XMLSchema/SPIRIT/1685-2009}maximum", _) => __obj.spiritmaximum foreach { x => attr = scala.xml.Attribute(__scope.getPrefix("http://www.spiritconsortium.org/XMLSchema/SPIRIT/1685-2009"), "maximum", x.toString, attr) }
        case ("@{http://www.spiritconsortium.org/XMLSchema/SPIRIT/1685-2009}rangeType", _) => if (__obj.spiritrangeType.toString != "float") attr = scala.xml.Attribute(__scope.getPrefix("http://www.spiritconsortium.org/XMLSchema/SPIRIT/1685-2009"), "rangeType", __obj.spiritrangeType.toString, attr)
        case ("@{http://www.spiritconsortium.org/XMLSchema/SPIRIT/1685-2009}prompt", _) => __obj.spiritprompt foreach { x => attr = scala.xml.Attribute(__scope.getPrefix("http://www.spiritconsortium.org/XMLSchema/SPIRIT/1685-2009"), "prompt", x.toString, attr) }
        case (key, x) => attr = scala.xml.Attribute((x.namespace map { __scope.getPrefix(_) }).orNull, x.key.orNull, x.value.toString, attr)
      }
      attr
    }

    def writesChildNodes(__obj: AddressOffset, __scope: scala.xml.NamespaceBinding): Seq[scala.xml.Node] =
      Seq(scala.xml.Text(__obj.value.toString))

  }

  trait Default_RangeType2Format extends IPXACT2009scalaxb.XMLFormat[RangeType2] with IPXACT2009scalaxb.CanWriteChildNodes[RangeType2] {
    val targetNamespace: Option[String] = Some("http://www.spiritconsortium.org/XMLSchema/SPIRIT/1685-2009")
    def reads(seq: scala.xml.NodeSeq, stack: List[IPXACT2009scalaxb.ElemName]): Either[String, RangeType2] = seq match {
      case node: scala.xml.Node => Right(RangeType2(IPXACT2009scalaxb.fromXML[String](node, IPXACT2009scalaxb.ElemName(node) :: stack),
        scala.collection.immutable.ListMap(List(
        (node \ "@{http://www.spiritconsortium.org/XMLSchema/SPIRIT/1685-2009}format").headOption map { x => IPXACT2009scalaxb.DataRecord(x, node, IPXACT2009scalaxb.fromXML[FormatType](x, IPXACT2009scalaxb.ElemName(node) :: stack)) } orElse Some(IPXACT2009scalaxb.DataRecord(None, None, IPXACT2009scalaxb.fromXML[FormatType](scala.xml.Text("long"), IPXACT2009scalaxb.ElemName(node) :: stack))) map { "@{http://www.spiritconsortium.org/XMLSchema/SPIRIT/1685-2009}format" -> _ },
        (node \ "@{http://www.spiritconsortium.org/XMLSchema/SPIRIT/1685-2009}resolve").headOption map { x => IPXACT2009scalaxb.DataRecord(x, node, IPXACT2009scalaxb.fromXML[ResolveType](x, IPXACT2009scalaxb.ElemName(node) :: stack)) } map { "@{http://www.spiritconsortium.org/XMLSchema/SPIRIT/1685-2009}resolve" -> _ },
        (node \ "@{http://www.spiritconsortium.org/XMLSchema/SPIRIT/1685-2009}id").headOption map { x => IPXACT2009scalaxb.DataRecord(x, node, IPXACT2009scalaxb.fromXML[String](x, IPXACT2009scalaxb.ElemName(node) :: stack)) } map { "@{http://www.spiritconsortium.org/XMLSchema/SPIRIT/1685-2009}id" -> _ },
        (node \ "@{http://www.spiritconsortium.org/XMLSchema/SPIRIT/1685-2009}dependency").headOption map { x => IPXACT2009scalaxb.DataRecord(x, node, IPXACT2009scalaxb.fromXML[String](x, IPXACT2009scalaxb.ElemName(node) :: stack)) } map { "@{http://www.spiritconsortium.org/XMLSchema/SPIRIT/1685-2009}dependency" -> _ },
        (node \ "@{http://www.spiritconsortium.org/XMLSchema/SPIRIT/1685-2009}choiceRef").headOption map { x => IPXACT2009scalaxb.DataRecord(x, node, IPXACT2009scalaxb.fromXML[String](x, IPXACT2009scalaxb.ElemName(node) :: stack)) } map { "@{http://www.spiritconsortium.org/XMLSchema/SPIRIT/1685-2009}choiceRef" -> _ },
        (node \ "@{http://www.spiritconsortium.org/XMLSchema/SPIRIT/1685-2009}order").headOption map { x => IPXACT2009scalaxb.DataRecord(x, node, IPXACT2009scalaxb.fromXML[Float](x, IPXACT2009scalaxb.ElemName(node) :: stack)) } map { "@{http://www.spiritconsortium.org/XMLSchema/SPIRIT/1685-2009}order" -> _ },
        (node \ "@{http://www.spiritconsortium.org/XMLSchema/SPIRIT/1685-2009}configGroups").headOption map { x => IPXACT2009scalaxb.DataRecord(x, node, IPXACT2009scalaxb.fromXML[Seq[String]](x, IPXACT2009scalaxb.ElemName(node) :: stack)) } map { "@{http://www.spiritconsortium.org/XMLSchema/SPIRIT/1685-2009}configGroups" -> _ },
        (node \ "@{http://www.spiritconsortium.org/XMLSchema/SPIRIT/1685-2009}bitStringLength").headOption map { x => IPXACT2009scalaxb.DataRecord(x, node, IPXACT2009scalaxb.fromXML[BigInt](x, IPXACT2009scalaxb.ElemName(node) :: stack)) } map { "@{http://www.spiritconsortium.org/XMLSchema/SPIRIT/1685-2009}bitStringLength" -> _ },
        (node \ "@{http://www.spiritconsortium.org/XMLSchema/SPIRIT/1685-2009}minimum").headOption map { x => IPXACT2009scalaxb.DataRecord(x, node, IPXACT2009scalaxb.fromXML[String](x, IPXACT2009scalaxb.ElemName(node) :: stack)) } map { "@{http://www.spiritconsortium.org/XMLSchema/SPIRIT/1685-2009}minimum" -> _ },
        (node \ "@{http://www.spiritconsortium.org/XMLSchema/SPIRIT/1685-2009}maximum").headOption map { x => IPXACT2009scalaxb.DataRecord(x, node, IPXACT2009scalaxb.fromXML[String](x, IPXACT2009scalaxb.ElemName(node) :: stack)) } map { "@{http://www.spiritconsortium.org/XMLSchema/SPIRIT/1685-2009}maximum" -> _ },
        (node \ "@{http://www.spiritconsortium.org/XMLSchema/SPIRIT/1685-2009}rangeType").headOption map { x => IPXACT2009scalaxb.DataRecord(x, node, IPXACT2009scalaxb.fromXML[RangeTypeType](x, IPXACT2009scalaxb.ElemName(node) :: stack)) } orElse Some(IPXACT2009scalaxb.DataRecord(None, None, IPXACT2009scalaxb.fromXML[RangeTypeType](scala.xml.Text("float"), IPXACT2009scalaxb.ElemName(node) :: stack))) map { "@{http://www.spiritconsortium.org/XMLSchema/SPIRIT/1685-2009}rangeType" -> _ },
        (node \ "@{http://www.spiritconsortium.org/XMLSchema/SPIRIT/1685-2009}prompt").headOption map { x => IPXACT2009scalaxb.DataRecord(x, node, IPXACT2009scalaxb.fromXML[String](x, IPXACT2009scalaxb.ElemName(node) :: stack)) } map { "@{http://www.spiritconsortium.org/XMLSchema/SPIRIT/1685-2009}prompt" -> _ }
        ).flatten[(String, IPXACT2009scalaxb.DataRecord[Any])] ::: (node match {
          case elem: scala.xml.Elem =>
            elem.attributes.toList flatMap {
              case scala.xml.PrefixedAttribute(pre, key, value, _) if pre == elem.scope.getPrefix("http://www.spiritconsortium.org/XMLSchema/SPIRIT/1685-2009") &&
                key == "format" => Nil
              case scala.xml.PrefixedAttribute(pre, key, value, _) if pre == elem.scope.getPrefix("http://www.spiritconsortium.org/XMLSchema/SPIRIT/1685-2009") &&
                key == "resolve" => Nil
              case scala.xml.PrefixedAttribute(pre, key, value, _) if pre == elem.scope.getPrefix("http://www.spiritconsortium.org/XMLSchema/SPIRIT/1685-2009") &&
                key == "id" => Nil
              case scala.xml.PrefixedAttribute(pre, key, value, _) if pre == elem.scope.getPrefix("http://www.spiritconsortium.org/XMLSchema/SPIRIT/1685-2009") &&
                key == "dependency" => Nil
              case scala.xml.PrefixedAttribute(pre, key, value, _) if pre == elem.scope.getPrefix("http://www.spiritconsortium.org/XMLSchema/SPIRIT/1685-2009") &&
                key == "choiceRef" => Nil
              case scala.xml.PrefixedAttribute(pre, key, value, _) if pre == elem.scope.getPrefix("http://www.spiritconsortium.org/XMLSchema/SPIRIT/1685-2009") &&
                key == "order" => Nil
              case scala.xml.PrefixedAttribute(pre, key, value, _) if pre == elem.scope.getPrefix("http://www.spiritconsortium.org/XMLSchema/SPIRIT/1685-2009") &&
                key == "configGroups" => Nil
              case scala.xml.PrefixedAttribute(pre, key, value, _) if pre == elem.scope.getPrefix("http://www.spiritconsortium.org/XMLSchema/SPIRIT/1685-2009") &&
                key == "bitStringLength" => Nil
              case scala.xml.PrefixedAttribute(pre, key, value, _) if pre == elem.scope.getPrefix("http://www.spiritconsortium.org/XMLSchema/SPIRIT/1685-2009") &&
                key == "minimum" => Nil
              case scala.xml.PrefixedAttribute(pre, key, value, _) if pre == elem.scope.getPrefix("http://www.spiritconsortium.org/XMLSchema/SPIRIT/1685-2009") &&
                key == "maximum" => Nil
              case scala.xml.PrefixedAttribute(pre, key, value, _) if pre == elem.scope.getPrefix("http://www.spiritconsortium.org/XMLSchema/SPIRIT/1685-2009") &&
                key == "rangeType" => Nil
              case scala.xml.PrefixedAttribute(pre, key, value, _) if pre == elem.scope.getPrefix("http://www.spiritconsortium.org/XMLSchema/SPIRIT/1685-2009") &&
                key == "prompt" => Nil
              case scala.xml.UnprefixedAttribute(key, value, _) =>
                List(("@" + key, IPXACT2009scalaxb.DataRecord(None, Some(key), value.text)))
              case scala.xml.PrefixedAttribute(pre, key, value, _) =>
                val ns = elem.scope.getURI(pre)
                List(("@{" + ns + "}" + key, IPXACT2009scalaxb.DataRecord(Option[String](ns), Some(key), value.text)))
              case _ => Nil
            }
          case _ => Nil
        }): _*)))
      case _ => Left("reads failed: seq must be scala.xml.Node")
    }
    
    override def writesAttribute(__obj: RangeType2, __scope: scala.xml.NamespaceBinding): scala.xml.MetaData = {
      var attr: scala.xml.MetaData  = scala.xml.Null
      __obj.attributes.toList map {
        case ("@{http://www.spiritconsortium.org/XMLSchema/SPIRIT/1685-2009}format", _) => if (__obj.spiritformat.toString != "long") attr = scala.xml.Attribute(__scope.getPrefix("http://www.spiritconsortium.org/XMLSchema/SPIRIT/1685-2009"), "format", __obj.spiritformat.toString, attr)
        case ("@{http://www.spiritconsortium.org/XMLSchema/SPIRIT/1685-2009}resolve", _) => __obj.spiritresolve foreach { x => attr = scala.xml.Attribute(__scope.getPrefix("http://www.spiritconsortium.org/XMLSchema/SPIRIT/1685-2009"), "resolve", x.toString, attr) }
        case ("@{http://www.spiritconsortium.org/XMLSchema/SPIRIT/1685-2009}id", _) => __obj.spiritid foreach { x => attr = scala.xml.Attribute(__scope.getPrefix("http://www.spiritconsortium.org/XMLSchema/SPIRIT/1685-2009"), "id", x.toString, attr) }
        case ("@{http://www.spiritconsortium.org/XMLSchema/SPIRIT/1685-2009}dependency", _) => __obj.spiritdependency foreach { x => attr = scala.xml.Attribute(__scope.getPrefix("http://www.spiritconsortium.org/XMLSchema/SPIRIT/1685-2009"), "dependency", x.toString, attr) }
        case ("@{http://www.spiritconsortium.org/XMLSchema/SPIRIT/1685-2009}choiceRef", _) => __obj.spiritchoiceRef foreach { x => attr = scala.xml.Attribute(__scope.getPrefix("http://www.spiritconsortium.org/XMLSchema/SPIRIT/1685-2009"), "choiceRef", x.toString, attr) }
        case ("@{http://www.spiritconsortium.org/XMLSchema/SPIRIT/1685-2009}order", _) => __obj.spiritorder foreach { x => attr = scala.xml.Attribute(__scope.getPrefix("http://www.spiritconsortium.org/XMLSchema/SPIRIT/1685-2009"), "order", x.toString, attr) }
        case ("@{http://www.spiritconsortium.org/XMLSchema/SPIRIT/1685-2009}configGroups", _) => __obj.spiritconfigGroups foreach { x => attr = scala.xml.Attribute(__scope.getPrefix("http://www.spiritconsortium.org/XMLSchema/SPIRIT/1685-2009"), "configGroups", x.toString, attr) }
        case ("@{http://www.spiritconsortium.org/XMLSchema/SPIRIT/1685-2009}bitStringLength", _) => __obj.spiritbitStringLength foreach { x => attr = scala.xml.Attribute(__scope.getPrefix("http://www.spiritconsortium.org/XMLSchema/SPIRIT/1685-2009"), "bitStringLength", x.toString, attr) }
        case ("@{http://www.spiritconsortium.org/XMLSchema/SPIRIT/1685-2009}minimum", _) => __obj.spiritminimum foreach { x => attr = scala.xml.Attribute(__scope.getPrefix("http://www.spiritconsortium.org/XMLSchema/SPIRIT/1685-2009"), "minimum", x.toString, attr) }
        case ("@{http://www.spiritconsortium.org/XMLSchema/SPIRIT/1685-2009}maximum", _) => __obj.spiritmaximum foreach { x => attr = scala.xml.Attribute(__scope.getPrefix("http://www.spiritconsortium.org/XMLSchema/SPIRIT/1685-2009"), "maximum", x.toString, attr) }
        case ("@{http://www.spiritconsortium.org/XMLSchema/SPIRIT/1685-2009}rangeType", _) => if (__obj.spiritrangeType.toString != "float") attr = scala.xml.Attribute(__scope.getPrefix("http://www.spiritconsortium.org/XMLSchema/SPIRIT/1685-2009"), "rangeType", __obj.spiritrangeType.toString, attr)
        case ("@{http://www.spiritconsortium.org/XMLSchema/SPIRIT/1685-2009}prompt", _) => __obj.spiritprompt foreach { x => attr = scala.xml.Attribute(__scope.getPrefix("http://www.spiritconsortium.org/XMLSchema/SPIRIT/1685-2009"), "prompt", x.toString, attr) }
        case (key, x) => attr = scala.xml.Attribute((x.namespace map { __scope.getPrefix(_) }).orNull, x.key.orNull, x.value.toString, attr)
      }
      attr
    }

    def writesChildNodes(__obj: RangeType2, __scope: scala.xml.NamespaceBinding): Seq[scala.xml.Node] =
      Seq(scala.xml.Text(__obj.value.toString))

  }

  trait Default_SegmentFormat extends IPXACT2009scalaxb.ElemNameParser[Segment] with _NameGroupGroupFormat {
    val targetNamespace: Option[String] = Some("http://www.spiritconsortium.org/XMLSchema/SPIRIT/1685-2009")
    
    def parser(node: scala.xml.Node, stack: List[IPXACT2009scalaxb.ElemName]): Parser[Segment] =
      phrase((parseNameGroupGroup(node, IPXACT2009scalaxb.ElemName(node) :: stack)) ~
      (IPXACT2009scalaxb.ElemName(Some("http://www.spiritconsortium.org/XMLSchema/SPIRIT/1685-2009"), "addressOffset")) ~
      (IPXACT2009scalaxb.ElemName(Some("http://www.spiritconsortium.org/XMLSchema/SPIRIT/1685-2009"), "range")) ~
      opt(IPXACT2009scalaxb.ElemName(Some("http://www.spiritconsortium.org/XMLSchema/SPIRIT/1685-2009"), "vendorExtensions")) ^^
      { case p1 ~ p2 ~ p3 ~ p4 =>
      Segment(p1,
        IPXACT2009scalaxb.fromXML[AddressOffset](p2, IPXACT2009scalaxb.ElemName(node) :: stack),
        IPXACT2009scalaxb.fromXML[RangeType2](p3, IPXACT2009scalaxb.ElemName(node) :: stack),
        p4.headOption map { IPXACT2009scalaxb.fromXML[VendorExtensions](_, IPXACT2009scalaxb.ElemName(node) :: stack) }) })
    
    def writesChildNodes(__obj: Segment, __scope: scala.xml.NamespaceBinding): Seq[scala.xml.Node] =
      Seq.concat(IPXACT2009scalaxb.toXML[NameGroupSequence](__obj.nameGroupSequence1, None, Some("nameGroupSequence1"), __scope, false),
        IPXACT2009scalaxb.toXML[AddressOffset](__obj.addressOffset, Some("http://www.spiritconsortium.org/XMLSchema/SPIRIT/1685-2009"), Some("addressOffset"), __scope, false),
        IPXACT2009scalaxb.toXML[RangeType2](__obj.range, Some("http://www.spiritconsortium.org/XMLSchema/SPIRIT/1685-2009"), Some("range"), __scope, false),
        __obj.vendorExtensions map { IPXACT2009scalaxb.toXML[VendorExtensions](_, Some("http://www.spiritconsortium.org/XMLSchema/SPIRIT/1685-2009"), Some("vendorExtensions"), __scope, false) } getOrElse {Nil})

  }

  trait Default_SegmentsFormat extends IPXACT2009scalaxb.ElemNameParser[Segments] {
    val targetNamespace: Option[String] = Some("http://www.spiritconsortium.org/XMLSchema/SPIRIT/1685-2009")
    
    def parser(node: scala.xml.Node, stack: List[IPXACT2009scalaxb.ElemName]): Parser[Segments] =
      phrase(safeRep(IPXACT2009scalaxb.ElemName(Some("http://www.spiritconsortium.org/XMLSchema/SPIRIT/1685-2009"), "segment")) ^^
      { case p1 =>
      Segments(p1 map { IPXACT2009scalaxb.fromXML[Segment](_, IPXACT2009scalaxb.ElemName(node) :: stack) }) })
    
    def writesChildNodes(__obj: Segments, __scope: scala.xml.NamespaceBinding): Seq[scala.xml.Node] =
      (__obj.segment flatMap { IPXACT2009scalaxb.toXML[Segment](_, Some("http://www.spiritconsortium.org/XMLSchema/SPIRIT/1685-2009"), Some("segment"), __scope, false) })
  }
  trait Default_AddressSpaceFormat extends IPXACT2009scalaxb.ElemNameParser[AddressSpace] with _NameGroupGroupFormat with _BlockSizeGroupFormat {
    val targetNamespace: Option[String] = Some("http://www.spiritconsortium.org/XMLSchema/SPIRIT/1685-2009")
    
    def parser(node: scala.xml.Node, stack: List[IPXACT2009scalaxb.ElemName]): Parser[AddressSpace] =
      phrase((parseNameGroupGroup(node, IPXACT2009scalaxb.ElemName(node) :: stack)) ~
      (parseBlockSizeGroup(node, IPXACT2009scalaxb.ElemName(node) :: stack)) ~
      opt(IPXACT2009scalaxb.ElemName(Some("http://www.spiritconsortium.org/XMLSchema/SPIRIT/1685-2009"), "segments")) ~
      opt(IPXACT2009scalaxb.ElemName(Some("http://www.spiritconsortium.org/XMLSchema/SPIRIT/1685-2009"), "addressUnitBits")) ~
      safeRep(IPXACT2009scalaxb.ElemName(Some("http://www.spiritconsortium.org/XMLSchema/SPIRIT/1685-2009"), "executableImage")) ~
      opt(IPXACT2009scalaxb.ElemName(Some("http://www.spiritconsortium.org/XMLSchema/SPIRIT/1685-2009"), "localMemoryMap")) ~
      opt(IPXACT2009scalaxb.ElemName(Some("http://www.spiritconsortium.org/XMLSchema/SPIRIT/1685-2009"), "parameters")) ~
      opt(IPXACT2009scalaxb.ElemName(Some("http://www.spiritconsortium.org/XMLSchema/SPIRIT/1685-2009"), "vendorExtensions")) ^^
      { case p1 ~ p2 ~ p3 ~ p4 ~ p5 ~ p6 ~ p7 ~ p8 =>
      AddressSpace(p1,
        p2,
        p3.headOption map { IPXACT2009scalaxb.fromXML[Segments](_, IPXACT2009scalaxb.ElemName(node) :: stack) },
        p4.headOption map { IPXACT2009scalaxb.fromXML[BigInt](_, IPXACT2009scalaxb.ElemName(node) :: stack) },
        p5 map { IPXACT2009scalaxb.fromXML[ExecutableImage](_, IPXACT2009scalaxb.ElemName(node) :: stack) },
        p6.headOption map { IPXACT2009scalaxb.fromXML[LocalMemoryMapType](_, IPXACT2009scalaxb.ElemName(node) :: stack) },
        p7.headOption map { IPXACT2009scalaxb.fromXML[Parameters](_, IPXACT2009scalaxb.ElemName(node) :: stack) },
        p8.headOption map { IPXACT2009scalaxb.fromXML[VendorExtensions](_, IPXACT2009scalaxb.ElemName(node) :: stack) }) })
    
    def writesChildNodes(__obj: AddressSpace, __scope: scala.xml.NamespaceBinding): Seq[scala.xml.Node] =
      Seq.concat(IPXACT2009scalaxb.toXML[NameGroupSequence](__obj.nameGroupSequence1, None, Some("nameGroupSequence1"), __scope, false),
        IPXACT2009scalaxb.toXML[BlockSizeSequence](__obj.blockSizeSequence2, None, Some("blockSizeSequence2"), __scope, false),
        __obj.segments map { IPXACT2009scalaxb.toXML[Segments](_, Some("http://www.spiritconsortium.org/XMLSchema/SPIRIT/1685-2009"), Some("segments"), __scope, false) } getOrElse {Nil},
        __obj.addressUnitBits map { IPXACT2009scalaxb.toXML[BigInt](_, Some("http://www.spiritconsortium.org/XMLSchema/SPIRIT/1685-2009"), Some("addressUnitBits"), __scope, false) } getOrElse {Nil},
        __obj.executableImage flatMap { IPXACT2009scalaxb.toXML[ExecutableImage](_, Some("http://www.spiritconsortium.org/XMLSchema/SPIRIT/1685-2009"), Some("executableImage"), __scope, false) },
        __obj.localMemoryMap map { IPXACT2009scalaxb.toXML[LocalMemoryMapType](_, Some("http://www.spiritconsortium.org/XMLSchema/SPIRIT/1685-2009"), Some("localMemoryMap"), __scope, false) } getOrElse {Nil},
        __obj.parameters map { IPXACT2009scalaxb.toXML[Parameters](_, Some("http://www.spiritconsortium.org/XMLSchema/SPIRIT/1685-2009"), Some("parameters"), __scope, false) } getOrElse {Nil},
        __obj.vendorExtensions map { IPXACT2009scalaxb.toXML[VendorExtensions](_, Some("http://www.spiritconsortium.org/XMLSchema/SPIRIT/1685-2009"), Some("vendorExtensions"), __scope, false) } getOrElse {Nil})

  }

  trait Default_AddressSpacesFormat extends IPXACT2009scalaxb.ElemNameParser[AddressSpaces] {
    val targetNamespace: Option[String] = Some("http://www.spiritconsortium.org/XMLSchema/SPIRIT/1685-2009")
    
    def parser(node: scala.xml.Node, stack: List[IPXACT2009scalaxb.ElemName]): Parser[AddressSpaces] =
      phrase(safeRep(IPXACT2009scalaxb.ElemName(Some("http://www.spiritconsortium.org/XMLSchema/SPIRIT/1685-2009"), "addressSpace")) ^^
      { case p1 =>
      AddressSpaces(p1 map { IPXACT2009scalaxb.fromXML[AddressSpace](_, IPXACT2009scalaxb.ElemName(node) :: stack) }) })
    
    def writesChildNodes(__obj: AddressSpaces, __scope: scala.xml.NamespaceBinding): Seq[scala.xml.Node] =
      (__obj.addressSpace flatMap { IPXACT2009scalaxb.toXML[AddressSpace](_, Some("http://www.spiritconsortium.org/XMLSchema/SPIRIT/1685-2009"), Some("addressSpace"), __scope, false) })
  }
  trait Default_MemoryMapsFormat extends IPXACT2009scalaxb.ElemNameParser[MemoryMaps] {
    val targetNamespace: Option[String] = Some("http://www.spiritconsortium.org/XMLSchema/SPIRIT/1685-2009")
    
    def parser(node: scala.xml.Node, stack: List[IPXACT2009scalaxb.ElemName]): Parser[MemoryMaps] =
      phrase(safeRep(IPXACT2009scalaxb.ElemName(Some("http://www.spiritconsortium.org/XMLSchema/SPIRIT/1685-2009"), "memoryMap")) ^^
      { case p1 =>
      MemoryMaps(p1 map { IPXACT2009scalaxb.fromXML[MemoryMapType](_, IPXACT2009scalaxb.ElemName(node) :: stack) }) })
    
    def writesChildNodes(__obj: MemoryMaps, __scope: scala.xml.NamespaceBinding): Seq[scala.xml.Node] =
      (__obj.memoryMap flatMap { IPXACT2009scalaxb.toXML[MemoryMapType](_, Some("http://www.spiritconsortium.org/XMLSchema/SPIRIT/1685-2009"), Some("memoryMap"), __scope, false) })
  }
  trait Default_BaseAddress2Format extends IPXACT2009scalaxb.XMLFormat[BaseAddress2] with IPXACT2009scalaxb.CanWriteChildNodes[BaseAddress2] {
    val targetNamespace: Option[String] = Some("http://www.spiritconsortium.org/XMLSchema/SPIRIT/1685-2009")
    def reads(seq: scala.xml.NodeSeq, stack: List[IPXACT2009scalaxb.ElemName]): Either[String, BaseAddress2] = seq match {
      case node: scala.xml.Node => Right(BaseAddress2(IPXACT2009scalaxb.fromXML[String](node, IPXACT2009scalaxb.ElemName(node) :: stack),
        scala.collection.immutable.ListMap(List(
        (node \ "@{http://www.spiritconsortium.org/XMLSchema/SPIRIT/1685-2009}format").headOption map { x => IPXACT2009scalaxb.DataRecord(x, node, IPXACT2009scalaxb.fromXML[FormatType](x, IPXACT2009scalaxb.ElemName(node) :: stack)) } orElse Some(IPXACT2009scalaxb.DataRecord(None, None, IPXACT2009scalaxb.fromXML[FormatType](scala.xml.Text("long"), IPXACT2009scalaxb.ElemName(node) :: stack))) map { "@{http://www.spiritconsortium.org/XMLSchema/SPIRIT/1685-2009}format" -> _ },
        (node \ "@{http://www.spiritconsortium.org/XMLSchema/SPIRIT/1685-2009}resolve").headOption map { x => IPXACT2009scalaxb.DataRecord(x, node, IPXACT2009scalaxb.fromXML[ResolveType](x, IPXACT2009scalaxb.ElemName(node) :: stack)) } map { "@{http://www.spiritconsortium.org/XMLSchema/SPIRIT/1685-2009}resolve" -> _ },
        (node \ "@{http://www.spiritconsortium.org/XMLSchema/SPIRIT/1685-2009}id").headOption map { x => IPXACT2009scalaxb.DataRecord(x, node, IPXACT2009scalaxb.fromXML[String](x, IPXACT2009scalaxb.ElemName(node) :: stack)) } map { "@{http://www.spiritconsortium.org/XMLSchema/SPIRIT/1685-2009}id" -> _ },
        (node \ "@{http://www.spiritconsortium.org/XMLSchema/SPIRIT/1685-2009}dependency").headOption map { x => IPXACT2009scalaxb.DataRecord(x, node, IPXACT2009scalaxb.fromXML[String](x, IPXACT2009scalaxb.ElemName(node) :: stack)) } map { "@{http://www.spiritconsortium.org/XMLSchema/SPIRIT/1685-2009}dependency" -> _ },
        (node \ "@{http://www.spiritconsortium.org/XMLSchema/SPIRIT/1685-2009}choiceRef").headOption map { x => IPXACT2009scalaxb.DataRecord(x, node, IPXACT2009scalaxb.fromXML[String](x, IPXACT2009scalaxb.ElemName(node) :: stack)) } map { "@{http://www.spiritconsortium.org/XMLSchema/SPIRIT/1685-2009}choiceRef" -> _ },
        (node \ "@{http://www.spiritconsortium.org/XMLSchema/SPIRIT/1685-2009}order").headOption map { x => IPXACT2009scalaxb.DataRecord(x, node, IPXACT2009scalaxb.fromXML[Float](x, IPXACT2009scalaxb.ElemName(node) :: stack)) } map { "@{http://www.spiritconsortium.org/XMLSchema/SPIRIT/1685-2009}order" -> _ },
        (node \ "@{http://www.spiritconsortium.org/XMLSchema/SPIRIT/1685-2009}configGroups").headOption map { x => IPXACT2009scalaxb.DataRecord(x, node, IPXACT2009scalaxb.fromXML[Seq[String]](x, IPXACT2009scalaxb.ElemName(node) :: stack)) } map { "@{http://www.spiritconsortium.org/XMLSchema/SPIRIT/1685-2009}configGroups" -> _ },
        (node \ "@{http://www.spiritconsortium.org/XMLSchema/SPIRIT/1685-2009}bitStringLength").headOption map { x => IPXACT2009scalaxb.DataRecord(x, node, IPXACT2009scalaxb.fromXML[BigInt](x, IPXACT2009scalaxb.ElemName(node) :: stack)) } map { "@{http://www.spiritconsortium.org/XMLSchema/SPIRIT/1685-2009}bitStringLength" -> _ },
        (node \ "@{http://www.spiritconsortium.org/XMLSchema/SPIRIT/1685-2009}minimum").headOption map { x => IPXACT2009scalaxb.DataRecord(x, node, IPXACT2009scalaxb.fromXML[String](x, IPXACT2009scalaxb.ElemName(node) :: stack)) } map { "@{http://www.spiritconsortium.org/XMLSchema/SPIRIT/1685-2009}minimum" -> _ },
        (node \ "@{http://www.spiritconsortium.org/XMLSchema/SPIRIT/1685-2009}maximum").headOption map { x => IPXACT2009scalaxb.DataRecord(x, node, IPXACT2009scalaxb.fromXML[String](x, IPXACT2009scalaxb.ElemName(node) :: stack)) } map { "@{http://www.spiritconsortium.org/XMLSchema/SPIRIT/1685-2009}maximum" -> _ },
        (node \ "@{http://www.spiritconsortium.org/XMLSchema/SPIRIT/1685-2009}rangeType").headOption map { x => IPXACT2009scalaxb.DataRecord(x, node, IPXACT2009scalaxb.fromXML[RangeTypeType](x, IPXACT2009scalaxb.ElemName(node) :: stack)) } orElse Some(IPXACT2009scalaxb.DataRecord(None, None, IPXACT2009scalaxb.fromXML[RangeTypeType](scala.xml.Text("float"), IPXACT2009scalaxb.ElemName(node) :: stack))) map { "@{http://www.spiritconsortium.org/XMLSchema/SPIRIT/1685-2009}rangeType" -> _ },
        (node \ "@{http://www.spiritconsortium.org/XMLSchema/SPIRIT/1685-2009}prompt").headOption map { x => IPXACT2009scalaxb.DataRecord(x, node, IPXACT2009scalaxb.fromXML[String](x, IPXACT2009scalaxb.ElemName(node) :: stack)) } orElse Some(IPXACT2009scalaxb.DataRecord(None, None, IPXACT2009scalaxb.fromXML[String](scala.xml.Text("Base Address:"), IPXACT2009scalaxb.ElemName(node) :: stack))) map { "@{http://www.spiritconsortium.org/XMLSchema/SPIRIT/1685-2009}prompt" -> _ }
        ).flatten[(String, IPXACT2009scalaxb.DataRecord[Any])] ::: (node match {
          case elem: scala.xml.Elem =>
            elem.attributes.toList flatMap {
              case scala.xml.PrefixedAttribute(pre, key, value, _) if pre == elem.scope.getPrefix("http://www.spiritconsortium.org/XMLSchema/SPIRIT/1685-2009") &&
                key == "format" => Nil
              case scala.xml.PrefixedAttribute(pre, key, value, _) if pre == elem.scope.getPrefix("http://www.spiritconsortium.org/XMLSchema/SPIRIT/1685-2009") &&
                key == "resolve" => Nil
              case scala.xml.PrefixedAttribute(pre, key, value, _) if pre == elem.scope.getPrefix("http://www.spiritconsortium.org/XMLSchema/SPIRIT/1685-2009") &&
                key == "id" => Nil
              case scala.xml.PrefixedAttribute(pre, key, value, _) if pre == elem.scope.getPrefix("http://www.spiritconsortium.org/XMLSchema/SPIRIT/1685-2009") &&
                key == "dependency" => Nil
              case scala.xml.PrefixedAttribute(pre, key, value, _) if pre == elem.scope.getPrefix("http://www.spiritconsortium.org/XMLSchema/SPIRIT/1685-2009") &&
                key == "choiceRef" => Nil
              case scala.xml.PrefixedAttribute(pre, key, value, _) if pre == elem.scope.getPrefix("http://www.spiritconsortium.org/XMLSchema/SPIRIT/1685-2009") &&
                key == "order" => Nil
              case scala.xml.PrefixedAttribute(pre, key, value, _) if pre == elem.scope.getPrefix("http://www.spiritconsortium.org/XMLSchema/SPIRIT/1685-2009") &&
                key == "configGroups" => Nil
              case scala.xml.PrefixedAttribute(pre, key, value, _) if pre == elem.scope.getPrefix("http://www.spiritconsortium.org/XMLSchema/SPIRIT/1685-2009") &&
                key == "bitStringLength" => Nil
              case scala.xml.PrefixedAttribute(pre, key, value, _) if pre == elem.scope.getPrefix("http://www.spiritconsortium.org/XMLSchema/SPIRIT/1685-2009") &&
                key == "minimum" => Nil
              case scala.xml.PrefixedAttribute(pre, key, value, _) if pre == elem.scope.getPrefix("http://www.spiritconsortium.org/XMLSchema/SPIRIT/1685-2009") &&
                key == "maximum" => Nil
              case scala.xml.PrefixedAttribute(pre, key, value, _) if pre == elem.scope.getPrefix("http://www.spiritconsortium.org/XMLSchema/SPIRIT/1685-2009") &&
                key == "rangeType" => Nil
              case scala.xml.PrefixedAttribute(pre, key, value, _) if pre == elem.scope.getPrefix("http://www.spiritconsortium.org/XMLSchema/SPIRIT/1685-2009") &&
                key == "prompt" => Nil
              case scala.xml.UnprefixedAttribute(key, value, _) =>
                List(("@" + key, IPXACT2009scalaxb.DataRecord(None, Some(key), value.text)))
              case scala.xml.PrefixedAttribute(pre, key, value, _) =>
                val ns = elem.scope.getURI(pre)
                List(("@{" + ns + "}" + key, IPXACT2009scalaxb.DataRecord(Option[String](ns), Some(key), value.text)))
              case _ => Nil
            }
          case _ => Nil
        }): _*)))
      case _ => Left("reads failed: seq must be scala.xml.Node")
    }
    
    override def writesAttribute(__obj: BaseAddress2, __scope: scala.xml.NamespaceBinding): scala.xml.MetaData = {
      var attr: scala.xml.MetaData  = scala.xml.Null
      __obj.attributes.toList map {
        case ("@{http://www.spiritconsortium.org/XMLSchema/SPIRIT/1685-2009}format", _) => if (__obj.spiritformat.toString != "long") attr = scala.xml.Attribute(__scope.getPrefix("http://www.spiritconsortium.org/XMLSchema/SPIRIT/1685-2009"), "format", __obj.spiritformat.toString, attr)
        case ("@{http://www.spiritconsortium.org/XMLSchema/SPIRIT/1685-2009}resolve", _) => __obj.spiritresolve foreach { x => attr = scala.xml.Attribute(__scope.getPrefix("http://www.spiritconsortium.org/XMLSchema/SPIRIT/1685-2009"), "resolve", x.toString, attr) }
        case ("@{http://www.spiritconsortium.org/XMLSchema/SPIRIT/1685-2009}id", _) => __obj.spiritid foreach { x => attr = scala.xml.Attribute(__scope.getPrefix("http://www.spiritconsortium.org/XMLSchema/SPIRIT/1685-2009"), "id", x.toString, attr) }
        case ("@{http://www.spiritconsortium.org/XMLSchema/SPIRIT/1685-2009}dependency", _) => __obj.spiritdependency foreach { x => attr = scala.xml.Attribute(__scope.getPrefix("http://www.spiritconsortium.org/XMLSchema/SPIRIT/1685-2009"), "dependency", x.toString, attr) }
        case ("@{http://www.spiritconsortium.org/XMLSchema/SPIRIT/1685-2009}choiceRef", _) => __obj.spiritchoiceRef foreach { x => attr = scala.xml.Attribute(__scope.getPrefix("http://www.spiritconsortium.org/XMLSchema/SPIRIT/1685-2009"), "choiceRef", x.toString, attr) }
        case ("@{http://www.spiritconsortium.org/XMLSchema/SPIRIT/1685-2009}order", _) => __obj.spiritorder foreach { x => attr = scala.xml.Attribute(__scope.getPrefix("http://www.spiritconsortium.org/XMLSchema/SPIRIT/1685-2009"), "order", x.toString, attr) }
        case ("@{http://www.spiritconsortium.org/XMLSchema/SPIRIT/1685-2009}configGroups", _) => __obj.spiritconfigGroups foreach { x => attr = scala.xml.Attribute(__scope.getPrefix("http://www.spiritconsortium.org/XMLSchema/SPIRIT/1685-2009"), "configGroups", x.toString, attr) }
        case ("@{http://www.spiritconsortium.org/XMLSchema/SPIRIT/1685-2009}bitStringLength", _) => __obj.spiritbitStringLength foreach { x => attr = scala.xml.Attribute(__scope.getPrefix("http://www.spiritconsortium.org/XMLSchema/SPIRIT/1685-2009"), "bitStringLength", x.toString, attr) }
        case ("@{http://www.spiritconsortium.org/XMLSchema/SPIRIT/1685-2009}minimum", _) => __obj.spiritminimum foreach { x => attr = scala.xml.Attribute(__scope.getPrefix("http://www.spiritconsortium.org/XMLSchema/SPIRIT/1685-2009"), "minimum", x.toString, attr) }
        case ("@{http://www.spiritconsortium.org/XMLSchema/SPIRIT/1685-2009}maximum", _) => __obj.spiritmaximum foreach { x => attr = scala.xml.Attribute(__scope.getPrefix("http://www.spiritconsortium.org/XMLSchema/SPIRIT/1685-2009"), "maximum", x.toString, attr) }
        case ("@{http://www.spiritconsortium.org/XMLSchema/SPIRIT/1685-2009}rangeType", _) => if (__obj.spiritrangeType.toString != "float") attr = scala.xml.Attribute(__scope.getPrefix("http://www.spiritconsortium.org/XMLSchema/SPIRIT/1685-2009"), "rangeType", __obj.spiritrangeType.toString, attr)
        case ("@{http://www.spiritconsortium.org/XMLSchema/SPIRIT/1685-2009}prompt", _) => if (__obj.spiritprompt.toString != "Base Address:") attr = scala.xml.Attribute(__scope.getPrefix("http://www.spiritconsortium.org/XMLSchema/SPIRIT/1685-2009"), "prompt", __obj.spiritprompt.toString, attr)
        case (key, x) => attr = scala.xml.Attribute((x.namespace map { __scope.getPrefix(_) }).orNull, x.key.orNull, x.value.toString, attr)
      }
      attr
    }

    def writesChildNodes(__obj: BaseAddress2, __scope: scala.xml.NamespaceBinding): Seq[scala.xml.Node] =
      Seq(scala.xml.Text(__obj.value.toString))

  }

  trait Default_RangeType3Format extends IPXACT2009scalaxb.XMLFormat[RangeType3] with IPXACT2009scalaxb.CanWriteChildNodes[RangeType3] {
    val targetNamespace: Option[String] = Some("http://www.spiritconsortium.org/XMLSchema/SPIRIT/1685-2009")
    def reads(seq: scala.xml.NodeSeq, stack: List[IPXACT2009scalaxb.ElemName]): Either[String, RangeType3] = seq match {
      case node: scala.xml.Node => Right(RangeType3(IPXACT2009scalaxb.fromXML[String](node, IPXACT2009scalaxb.ElemName(node) :: stack),
        scala.collection.immutable.ListMap(List(
        (node \ "@{http://www.spiritconsortium.org/XMLSchema/SPIRIT/1685-2009}format").headOption map { x => IPXACT2009scalaxb.DataRecord(x, node, IPXACT2009scalaxb.fromXML[FormatType](x, IPXACT2009scalaxb.ElemName(node) :: stack)) } orElse Some(IPXACT2009scalaxb.DataRecord(None, None, IPXACT2009scalaxb.fromXML[FormatType](scala.xml.Text("long"), IPXACT2009scalaxb.ElemName(node) :: stack))) map { "@{http://www.spiritconsortium.org/XMLSchema/SPIRIT/1685-2009}format" -> _ },
        (node \ "@{http://www.spiritconsortium.org/XMLSchema/SPIRIT/1685-2009}resolve").headOption map { x => IPXACT2009scalaxb.DataRecord(x, node, IPXACT2009scalaxb.fromXML[ResolveType](x, IPXACT2009scalaxb.ElemName(node) :: stack)) } map { "@{http://www.spiritconsortium.org/XMLSchema/SPIRIT/1685-2009}resolve" -> _ },
        (node \ "@{http://www.spiritconsortium.org/XMLSchema/SPIRIT/1685-2009}id").headOption map { x => IPXACT2009scalaxb.DataRecord(x, node, IPXACT2009scalaxb.fromXML[String](x, IPXACT2009scalaxb.ElemName(node) :: stack)) } map { "@{http://www.spiritconsortium.org/XMLSchema/SPIRIT/1685-2009}id" -> _ },
        (node \ "@{http://www.spiritconsortium.org/XMLSchema/SPIRIT/1685-2009}dependency").headOption map { x => IPXACT2009scalaxb.DataRecord(x, node, IPXACT2009scalaxb.fromXML[String](x, IPXACT2009scalaxb.ElemName(node) :: stack)) } map { "@{http://www.spiritconsortium.org/XMLSchema/SPIRIT/1685-2009}dependency" -> _ },
        (node \ "@{http://www.spiritconsortium.org/XMLSchema/SPIRIT/1685-2009}choiceRef").headOption map { x => IPXACT2009scalaxb.DataRecord(x, node, IPXACT2009scalaxb.fromXML[String](x, IPXACT2009scalaxb.ElemName(node) :: stack)) } map { "@{http://www.spiritconsortium.org/XMLSchema/SPIRIT/1685-2009}choiceRef" -> _ },
        (node \ "@{http://www.spiritconsortium.org/XMLSchema/SPIRIT/1685-2009}order").headOption map { x => IPXACT2009scalaxb.DataRecord(x, node, IPXACT2009scalaxb.fromXML[Float](x, IPXACT2009scalaxb.ElemName(node) :: stack)) } map { "@{http://www.spiritconsortium.org/XMLSchema/SPIRIT/1685-2009}order" -> _ },
        (node \ "@{http://www.spiritconsortium.org/XMLSchema/SPIRIT/1685-2009}configGroups").headOption map { x => IPXACT2009scalaxb.DataRecord(x, node, IPXACT2009scalaxb.fromXML[Seq[String]](x, IPXACT2009scalaxb.ElemName(node) :: stack)) } map { "@{http://www.spiritconsortium.org/XMLSchema/SPIRIT/1685-2009}configGroups" -> _ },
        (node \ "@{http://www.spiritconsortium.org/XMLSchema/SPIRIT/1685-2009}bitStringLength").headOption map { x => IPXACT2009scalaxb.DataRecord(x, node, IPXACT2009scalaxb.fromXML[BigInt](x, IPXACT2009scalaxb.ElemName(node) :: stack)) } map { "@{http://www.spiritconsortium.org/XMLSchema/SPIRIT/1685-2009}bitStringLength" -> _ },
        (node \ "@{http://www.spiritconsortium.org/XMLSchema/SPIRIT/1685-2009}minimum").headOption map { x => IPXACT2009scalaxb.DataRecord(x, node, IPXACT2009scalaxb.fromXML[String](x, IPXACT2009scalaxb.ElemName(node) :: stack)) } map { "@{http://www.spiritconsortium.org/XMLSchema/SPIRIT/1685-2009}minimum" -> _ },
        (node \ "@{http://www.spiritconsortium.org/XMLSchema/SPIRIT/1685-2009}maximum").headOption map { x => IPXACT2009scalaxb.DataRecord(x, node, IPXACT2009scalaxb.fromXML[String](x, IPXACT2009scalaxb.ElemName(node) :: stack)) } map { "@{http://www.spiritconsortium.org/XMLSchema/SPIRIT/1685-2009}maximum" -> _ },
        (node \ "@{http://www.spiritconsortium.org/XMLSchema/SPIRIT/1685-2009}rangeType").headOption map { x => IPXACT2009scalaxb.DataRecord(x, node, IPXACT2009scalaxb.fromXML[RangeTypeType](x, IPXACT2009scalaxb.ElemName(node) :: stack)) } orElse Some(IPXACT2009scalaxb.DataRecord(None, None, IPXACT2009scalaxb.fromXML[RangeTypeType](scala.xml.Text("float"), IPXACT2009scalaxb.ElemName(node) :: stack))) map { "@{http://www.spiritconsortium.org/XMLSchema/SPIRIT/1685-2009}rangeType" -> _ },
        (node \ "@{http://www.spiritconsortium.org/XMLSchema/SPIRIT/1685-2009}prompt").headOption map { x => IPXACT2009scalaxb.DataRecord(x, node, IPXACT2009scalaxb.fromXML[String](x, IPXACT2009scalaxb.ElemName(node) :: stack)) } map { "@{http://www.spiritconsortium.org/XMLSchema/SPIRIT/1685-2009}prompt" -> _ }
        ).flatten[(String, IPXACT2009scalaxb.DataRecord[Any])] ::: (node match {
          case elem: scala.xml.Elem =>
            elem.attributes.toList flatMap {
              case scala.xml.PrefixedAttribute(pre, key, value, _) if pre == elem.scope.getPrefix("http://www.spiritconsortium.org/XMLSchema/SPIRIT/1685-2009") &&
                key == "format" => Nil
              case scala.xml.PrefixedAttribute(pre, key, value, _) if pre == elem.scope.getPrefix("http://www.spiritconsortium.org/XMLSchema/SPIRIT/1685-2009") &&
                key == "resolve" => Nil
              case scala.xml.PrefixedAttribute(pre, key, value, _) if pre == elem.scope.getPrefix("http://www.spiritconsortium.org/XMLSchema/SPIRIT/1685-2009") &&
                key == "id" => Nil
              case scala.xml.PrefixedAttribute(pre, key, value, _) if pre == elem.scope.getPrefix("http://www.spiritconsortium.org/XMLSchema/SPIRIT/1685-2009") &&
                key == "dependency" => Nil
              case scala.xml.PrefixedAttribute(pre, key, value, _) if pre == elem.scope.getPrefix("http://www.spiritconsortium.org/XMLSchema/SPIRIT/1685-2009") &&
                key == "choiceRef" => Nil
              case scala.xml.PrefixedAttribute(pre, key, value, _) if pre == elem.scope.getPrefix("http://www.spiritconsortium.org/XMLSchema/SPIRIT/1685-2009") &&
                key == "order" => Nil
              case scala.xml.PrefixedAttribute(pre, key, value, _) if pre == elem.scope.getPrefix("http://www.spiritconsortium.org/XMLSchema/SPIRIT/1685-2009") &&
                key == "configGroups" => Nil
              case scala.xml.PrefixedAttribute(pre, key, value, _) if pre == elem.scope.getPrefix("http://www.spiritconsortium.org/XMLSchema/SPIRIT/1685-2009") &&
                key == "bitStringLength" => Nil
              case scala.xml.PrefixedAttribute(pre, key, value, _) if pre == elem.scope.getPrefix("http://www.spiritconsortium.org/XMLSchema/SPIRIT/1685-2009") &&
                key == "minimum" => Nil
              case scala.xml.PrefixedAttribute(pre, key, value, _) if pre == elem.scope.getPrefix("http://www.spiritconsortium.org/XMLSchema/SPIRIT/1685-2009") &&
                key == "maximum" => Nil
              case scala.xml.PrefixedAttribute(pre, key, value, _) if pre == elem.scope.getPrefix("http://www.spiritconsortium.org/XMLSchema/SPIRIT/1685-2009") &&
                key == "rangeType" => Nil
              case scala.xml.PrefixedAttribute(pre, key, value, _) if pre == elem.scope.getPrefix("http://www.spiritconsortium.org/XMLSchema/SPIRIT/1685-2009") &&
                key == "prompt" => Nil
              case scala.xml.UnprefixedAttribute(key, value, _) =>
                List(("@" + key, IPXACT2009scalaxb.DataRecord(None, Some(key), value.text)))
              case scala.xml.PrefixedAttribute(pre, key, value, _) =>
                val ns = elem.scope.getURI(pre)
                List(("@{" + ns + "}" + key, IPXACT2009scalaxb.DataRecord(Option[String](ns), Some(key), value.text)))
              case _ => Nil
            }
          case _ => Nil
        }): _*)))
      case _ => Left("reads failed: seq must be scala.xml.Node")
    }
    
    override def writesAttribute(__obj: RangeType3, __scope: scala.xml.NamespaceBinding): scala.xml.MetaData = {
      var attr: scala.xml.MetaData  = scala.xml.Null
      __obj.attributes.toList map {
        case ("@{http://www.spiritconsortium.org/XMLSchema/SPIRIT/1685-2009}format", _) => if (__obj.spiritformat.toString != "long") attr = scala.xml.Attribute(__scope.getPrefix("http://www.spiritconsortium.org/XMLSchema/SPIRIT/1685-2009"), "format", __obj.spiritformat.toString, attr)
        case ("@{http://www.spiritconsortium.org/XMLSchema/SPIRIT/1685-2009}resolve", _) => __obj.spiritresolve foreach { x => attr = scala.xml.Attribute(__scope.getPrefix("http://www.spiritconsortium.org/XMLSchema/SPIRIT/1685-2009"), "resolve", x.toString, attr) }
        case ("@{http://www.spiritconsortium.org/XMLSchema/SPIRIT/1685-2009}id", _) => __obj.spiritid foreach { x => attr = scala.xml.Attribute(__scope.getPrefix("http://www.spiritconsortium.org/XMLSchema/SPIRIT/1685-2009"), "id", x.toString, attr) }
        case ("@{http://www.spiritconsortium.org/XMLSchema/SPIRIT/1685-2009}dependency", _) => __obj.spiritdependency foreach { x => attr = scala.xml.Attribute(__scope.getPrefix("http://www.spiritconsortium.org/XMLSchema/SPIRIT/1685-2009"), "dependency", x.toString, attr) }
        case ("@{http://www.spiritconsortium.org/XMLSchema/SPIRIT/1685-2009}choiceRef", _) => __obj.spiritchoiceRef foreach { x => attr = scala.xml.Attribute(__scope.getPrefix("http://www.spiritconsortium.org/XMLSchema/SPIRIT/1685-2009"), "choiceRef", x.toString, attr) }
        case ("@{http://www.spiritconsortium.org/XMLSchema/SPIRIT/1685-2009}order", _) => __obj.spiritorder foreach { x => attr = scala.xml.Attribute(__scope.getPrefix("http://www.spiritconsortium.org/XMLSchema/SPIRIT/1685-2009"), "order", x.toString, attr) }
        case ("@{http://www.spiritconsortium.org/XMLSchema/SPIRIT/1685-2009}configGroups", _) => __obj.spiritconfigGroups foreach { x => attr = scala.xml.Attribute(__scope.getPrefix("http://www.spiritconsortium.org/XMLSchema/SPIRIT/1685-2009"), "configGroups", x.toString, attr) }
        case ("@{http://www.spiritconsortium.org/XMLSchema/SPIRIT/1685-2009}bitStringLength", _) => __obj.spiritbitStringLength foreach { x => attr = scala.xml.Attribute(__scope.getPrefix("http://www.spiritconsortium.org/XMLSchema/SPIRIT/1685-2009"), "bitStringLength", x.toString, attr) }
        case ("@{http://www.spiritconsortium.org/XMLSchema/SPIRIT/1685-2009}minimum", _) => __obj.spiritminimum foreach { x => attr = scala.xml.Attribute(__scope.getPrefix("http://www.spiritconsortium.org/XMLSchema/SPIRIT/1685-2009"), "minimum", x.toString, attr) }
        case ("@{http://www.spiritconsortium.org/XMLSchema/SPIRIT/1685-2009}maximum", _) => __obj.spiritmaximum foreach { x => attr = scala.xml.Attribute(__scope.getPrefix("http://www.spiritconsortium.org/XMLSchema/SPIRIT/1685-2009"), "maximum", x.toString, attr) }
        case ("@{http://www.spiritconsortium.org/XMLSchema/SPIRIT/1685-2009}rangeType", _) => if (__obj.spiritrangeType.toString != "float") attr = scala.xml.Attribute(__scope.getPrefix("http://www.spiritconsortium.org/XMLSchema/SPIRIT/1685-2009"), "rangeType", __obj.spiritrangeType.toString, attr)
        case ("@{http://www.spiritconsortium.org/XMLSchema/SPIRIT/1685-2009}prompt", _) => __obj.spiritprompt foreach { x => attr = scala.xml.Attribute(__scope.getPrefix("http://www.spiritconsortium.org/XMLSchema/SPIRIT/1685-2009"), "prompt", x.toString, attr) }
        case (key, x) => attr = scala.xml.Attribute((x.namespace map { __scope.getPrefix(_) }).orNull, x.key.orNull, x.value.toString, attr)
      }
      attr
    }

    def writesChildNodes(__obj: RangeType3, __scope: scala.xml.NamespaceBinding): Seq[scala.xml.Node] =
      Seq(scala.xml.Text(__obj.value.toString))

  }

  trait Default_WidthFormat extends IPXACT2009scalaxb.XMLFormat[Width] with IPXACT2009scalaxb.CanWriteChildNodes[Width] {
    val targetNamespace: Option[String] = Some("http://www.spiritconsortium.org/XMLSchema/SPIRIT/1685-2009")
    def reads(seq: scala.xml.NodeSeq, stack: List[IPXACT2009scalaxb.ElemName]): Either[String, Width] = seq match {
      case node: scala.xml.Node => Right(Width(IPXACT2009scalaxb.fromXML[BigInt](node, IPXACT2009scalaxb.ElemName(node) :: stack),
        scala.collection.immutable.ListMap(List(
        (node \ "@{http://www.spiritconsortium.org/XMLSchema/SPIRIT/1685-2009}format").headOption map { x => IPXACT2009scalaxb.DataRecord(x, node, IPXACT2009scalaxb.fromXML[FormatType](x, IPXACT2009scalaxb.ElemName(node) :: stack)) } orElse Some(IPXACT2009scalaxb.DataRecord(None, None, IPXACT2009scalaxb.fromXML[FormatType](scala.xml.Text("long"), IPXACT2009scalaxb.ElemName(node) :: stack))) map { "@{http://www.spiritconsortium.org/XMLSchema/SPIRIT/1685-2009}format" -> _ },
        (node \ "@{http://www.spiritconsortium.org/XMLSchema/SPIRIT/1685-2009}resolve").headOption map { x => IPXACT2009scalaxb.DataRecord(x, node, IPXACT2009scalaxb.fromXML[ResolveType](x, IPXACT2009scalaxb.ElemName(node) :: stack)) } map { "@{http://www.spiritconsortium.org/XMLSchema/SPIRIT/1685-2009}resolve" -> _ },
        (node \ "@{http://www.spiritconsortium.org/XMLSchema/SPIRIT/1685-2009}id").headOption map { x => IPXACT2009scalaxb.DataRecord(x, node, IPXACT2009scalaxb.fromXML[String](x, IPXACT2009scalaxb.ElemName(node) :: stack)) } map { "@{http://www.spiritconsortium.org/XMLSchema/SPIRIT/1685-2009}id" -> _ },
        (node \ "@{http://www.spiritconsortium.org/XMLSchema/SPIRIT/1685-2009}dependency").headOption map { x => IPXACT2009scalaxb.DataRecord(x, node, IPXACT2009scalaxb.fromXML[String](x, IPXACT2009scalaxb.ElemName(node) :: stack)) } map { "@{http://www.spiritconsortium.org/XMLSchema/SPIRIT/1685-2009}dependency" -> _ },
        (node \ "@{http://www.spiritconsortium.org/XMLSchema/SPIRIT/1685-2009}choiceRef").headOption map { x => IPXACT2009scalaxb.DataRecord(x, node, IPXACT2009scalaxb.fromXML[String](x, IPXACT2009scalaxb.ElemName(node) :: stack)) } map { "@{http://www.spiritconsortium.org/XMLSchema/SPIRIT/1685-2009}choiceRef" -> _ },
        (node \ "@{http://www.spiritconsortium.org/XMLSchema/SPIRIT/1685-2009}order").headOption map { x => IPXACT2009scalaxb.DataRecord(x, node, IPXACT2009scalaxb.fromXML[Float](x, IPXACT2009scalaxb.ElemName(node) :: stack)) } map { "@{http://www.spiritconsortium.org/XMLSchema/SPIRIT/1685-2009}order" -> _ },
        (node \ "@{http://www.spiritconsortium.org/XMLSchema/SPIRIT/1685-2009}configGroups").headOption map { x => IPXACT2009scalaxb.DataRecord(x, node, IPXACT2009scalaxb.fromXML[Seq[String]](x, IPXACT2009scalaxb.ElemName(node) :: stack)) } map { "@{http://www.spiritconsortium.org/XMLSchema/SPIRIT/1685-2009}configGroups" -> _ },
        (node \ "@{http://www.spiritconsortium.org/XMLSchema/SPIRIT/1685-2009}bitStringLength").headOption map { x => IPXACT2009scalaxb.DataRecord(x, node, IPXACT2009scalaxb.fromXML[BigInt](x, IPXACT2009scalaxb.ElemName(node) :: stack)) } map { "@{http://www.spiritconsortium.org/XMLSchema/SPIRIT/1685-2009}bitStringLength" -> _ },
        (node \ "@{http://www.spiritconsortium.org/XMLSchema/SPIRIT/1685-2009}minimum").headOption map { x => IPXACT2009scalaxb.DataRecord(x, node, IPXACT2009scalaxb.fromXML[String](x, IPXACT2009scalaxb.ElemName(node) :: stack)) } map { "@{http://www.spiritconsortium.org/XMLSchema/SPIRIT/1685-2009}minimum" -> _ },
        (node \ "@{http://www.spiritconsortium.org/XMLSchema/SPIRIT/1685-2009}maximum").headOption map { x => IPXACT2009scalaxb.DataRecord(x, node, IPXACT2009scalaxb.fromXML[String](x, IPXACT2009scalaxb.ElemName(node) :: stack)) } map { "@{http://www.spiritconsortium.org/XMLSchema/SPIRIT/1685-2009}maximum" -> _ },
        (node \ "@{http://www.spiritconsortium.org/XMLSchema/SPIRIT/1685-2009}rangeType").headOption map { x => IPXACT2009scalaxb.DataRecord(x, node, IPXACT2009scalaxb.fromXML[RangeTypeType](x, IPXACT2009scalaxb.ElemName(node) :: stack)) } orElse Some(IPXACT2009scalaxb.DataRecord(None, None, IPXACT2009scalaxb.fromXML[RangeTypeType](scala.xml.Text("float"), IPXACT2009scalaxb.ElemName(node) :: stack))) map { "@{http://www.spiritconsortium.org/XMLSchema/SPIRIT/1685-2009}rangeType" -> _ },
        (node \ "@{http://www.spiritconsortium.org/XMLSchema/SPIRIT/1685-2009}prompt").headOption map { x => IPXACT2009scalaxb.DataRecord(x, node, IPXACT2009scalaxb.fromXML[String](x, IPXACT2009scalaxb.ElemName(node) :: stack)) } map { "@{http://www.spiritconsortium.org/XMLSchema/SPIRIT/1685-2009}prompt" -> _ }
        ).flatten[(String, IPXACT2009scalaxb.DataRecord[Any])] ::: (node match {
          case elem: scala.xml.Elem =>
            elem.attributes.toList flatMap {
              case scala.xml.PrefixedAttribute(pre, key, value, _) if pre == elem.scope.getPrefix("http://www.spiritconsortium.org/XMLSchema/SPIRIT/1685-2009") &&
                key == "format" => Nil
              case scala.xml.PrefixedAttribute(pre, key, value, _) if pre == elem.scope.getPrefix("http://www.spiritconsortium.org/XMLSchema/SPIRIT/1685-2009") &&
                key == "resolve" => Nil
              case scala.xml.PrefixedAttribute(pre, key, value, _) if pre == elem.scope.getPrefix("http://www.spiritconsortium.org/XMLSchema/SPIRIT/1685-2009") &&
                key == "id" => Nil
              case scala.xml.PrefixedAttribute(pre, key, value, _) if pre == elem.scope.getPrefix("http://www.spiritconsortium.org/XMLSchema/SPIRIT/1685-2009") &&
                key == "dependency" => Nil
              case scala.xml.PrefixedAttribute(pre, key, value, _) if pre == elem.scope.getPrefix("http://www.spiritconsortium.org/XMLSchema/SPIRIT/1685-2009") &&
                key == "choiceRef" => Nil
              case scala.xml.PrefixedAttribute(pre, key, value, _) if pre == elem.scope.getPrefix("http://www.spiritconsortium.org/XMLSchema/SPIRIT/1685-2009") &&
                key == "order" => Nil
              case scala.xml.PrefixedAttribute(pre, key, value, _) if pre == elem.scope.getPrefix("http://www.spiritconsortium.org/XMLSchema/SPIRIT/1685-2009") &&
                key == "configGroups" => Nil
              case scala.xml.PrefixedAttribute(pre, key, value, _) if pre == elem.scope.getPrefix("http://www.spiritconsortium.org/XMLSchema/SPIRIT/1685-2009") &&
                key == "bitStringLength" => Nil
              case scala.xml.PrefixedAttribute(pre, key, value, _) if pre == elem.scope.getPrefix("http://www.spiritconsortium.org/XMLSchema/SPIRIT/1685-2009") &&
                key == "minimum" => Nil
              case scala.xml.PrefixedAttribute(pre, key, value, _) if pre == elem.scope.getPrefix("http://www.spiritconsortium.org/XMLSchema/SPIRIT/1685-2009") &&
                key == "maximum" => Nil
              case scala.xml.PrefixedAttribute(pre, key, value, _) if pre == elem.scope.getPrefix("http://www.spiritconsortium.org/XMLSchema/SPIRIT/1685-2009") &&
                key == "rangeType" => Nil
              case scala.xml.PrefixedAttribute(pre, key, value, _) if pre == elem.scope.getPrefix("http://www.spiritconsortium.org/XMLSchema/SPIRIT/1685-2009") &&
                key == "prompt" => Nil
              case scala.xml.UnprefixedAttribute(key, value, _) =>
                List(("@" + key, IPXACT2009scalaxb.DataRecord(None, Some(key), value.text)))
              case scala.xml.PrefixedAttribute(pre, key, value, _) =>
                val ns = elem.scope.getURI(pre)
                List(("@{" + ns + "}" + key, IPXACT2009scalaxb.DataRecord(Option[String](ns), Some(key), value.text)))
              case _ => Nil
            }
          case _ => Nil
        }): _*)))
      case _ => Left("reads failed: seq must be scala.xml.Node")
    }
    
    override def writesAttribute(__obj: Width, __scope: scala.xml.NamespaceBinding): scala.xml.MetaData = {
      var attr: scala.xml.MetaData  = scala.xml.Null
      __obj.attributes.toList map {
        case ("@{http://www.spiritconsortium.org/XMLSchema/SPIRIT/1685-2009}format", _) => if (__obj.spiritformat.toString != "long") attr = scala.xml.Attribute(__scope.getPrefix("http://www.spiritconsortium.org/XMLSchema/SPIRIT/1685-2009"), "format", __obj.spiritformat.toString, attr)
        case ("@{http://www.spiritconsortium.org/XMLSchema/SPIRIT/1685-2009}resolve", _) => __obj.spiritresolve foreach { x => attr = scala.xml.Attribute(__scope.getPrefix("http://www.spiritconsortium.org/XMLSchema/SPIRIT/1685-2009"), "resolve", x.toString, attr) }
        case ("@{http://www.spiritconsortium.org/XMLSchema/SPIRIT/1685-2009}id", _) => __obj.spiritid foreach { x => attr = scala.xml.Attribute(__scope.getPrefix("http://www.spiritconsortium.org/XMLSchema/SPIRIT/1685-2009"), "id", x.toString, attr) }
        case ("@{http://www.spiritconsortium.org/XMLSchema/SPIRIT/1685-2009}dependency", _) => __obj.spiritdependency foreach { x => attr = scala.xml.Attribute(__scope.getPrefix("http://www.spiritconsortium.org/XMLSchema/SPIRIT/1685-2009"), "dependency", x.toString, attr) }
        case ("@{http://www.spiritconsortium.org/XMLSchema/SPIRIT/1685-2009}choiceRef", _) => __obj.spiritchoiceRef foreach { x => attr = scala.xml.Attribute(__scope.getPrefix("http://www.spiritconsortium.org/XMLSchema/SPIRIT/1685-2009"), "choiceRef", x.toString, attr) }
        case ("@{http://www.spiritconsortium.org/XMLSchema/SPIRIT/1685-2009}order", _) => __obj.spiritorder foreach { x => attr = scala.xml.Attribute(__scope.getPrefix("http://www.spiritconsortium.org/XMLSchema/SPIRIT/1685-2009"), "order", x.toString, attr) }
        case ("@{http://www.spiritconsortium.org/XMLSchema/SPIRIT/1685-2009}configGroups", _) => __obj.spiritconfigGroups foreach { x => attr = scala.xml.Attribute(__scope.getPrefix("http://www.spiritconsortium.org/XMLSchema/SPIRIT/1685-2009"), "configGroups", x.toString, attr) }
        case ("@{http://www.spiritconsortium.org/XMLSchema/SPIRIT/1685-2009}bitStringLength", _) => __obj.spiritbitStringLength foreach { x => attr = scala.xml.Attribute(__scope.getPrefix("http://www.spiritconsortium.org/XMLSchema/SPIRIT/1685-2009"), "bitStringLength", x.toString, attr) }
        case ("@{http://www.spiritconsortium.org/XMLSchema/SPIRIT/1685-2009}minimum", _) => __obj.spiritminimum foreach { x => attr = scala.xml.Attribute(__scope.getPrefix("http://www.spiritconsortium.org/XMLSchema/SPIRIT/1685-2009"), "minimum", x.toString, attr) }
        case ("@{http://www.spiritconsortium.org/XMLSchema/SPIRIT/1685-2009}maximum", _) => __obj.spiritmaximum foreach { x => attr = scala.xml.Attribute(__scope.getPrefix("http://www.spiritconsortium.org/XMLSchema/SPIRIT/1685-2009"), "maximum", x.toString, attr) }
        case ("@{http://www.spiritconsortium.org/XMLSchema/SPIRIT/1685-2009}rangeType", _) => if (__obj.spiritrangeType.toString != "float") attr = scala.xml.Attribute(__scope.getPrefix("http://www.spiritconsortium.org/XMLSchema/SPIRIT/1685-2009"), "rangeType", __obj.spiritrangeType.toString, attr)
        case ("@{http://www.spiritconsortium.org/XMLSchema/SPIRIT/1685-2009}prompt", _) => __obj.spiritprompt foreach { x => attr = scala.xml.Attribute(__scope.getPrefix("http://www.spiritconsortium.org/XMLSchema/SPIRIT/1685-2009"), "prompt", x.toString, attr) }
        case (key, x) => attr = scala.xml.Attribute((x.namespace map { __scope.getPrefix(_) }).orNull, x.key.orNull, x.value.toString, attr)
      }
      attr
    }

    def writesChildNodes(__obj: Width, __scope: scala.xml.NamespaceBinding): Seq[scala.xml.Node] =
      Seq(scala.xml.Text(__obj.value.toString))

  }

  trait Default_AlternateGroupsFormat extends IPXACT2009scalaxb.ElemNameParser[AlternateGroups] {
    val targetNamespace: Option[String] = Some("http://www.spiritconsortium.org/XMLSchema/SPIRIT/1685-2009")
    
    def parser(node: scala.xml.Node, stack: List[IPXACT2009scalaxb.ElemName]): Parser[AlternateGroups] =
      phrase(safeRep(IPXACT2009scalaxb.ElemName(Some("http://www.spiritconsortium.org/XMLSchema/SPIRIT/1685-2009"), "alternateGroup")) ^^
      { case p1 =>
      AlternateGroups(p1 map { IPXACT2009scalaxb.fromXML[String](_, IPXACT2009scalaxb.ElemName(node) :: stack) }) })
    
    def writesChildNodes(__obj: AlternateGroups, __scope: scala.xml.NamespaceBinding): Seq[scala.xml.Node] =
      (__obj.alternateGroup flatMap { IPXACT2009scalaxb.toXML[String](_, Some("http://www.spiritconsortium.org/XMLSchema/SPIRIT/1685-2009"), Some("alternateGroup"), __scope, false) })
  }
  trait Default_AlternateRegisterFormat extends IPXACT2009scalaxb.ElemNameParser[AlternateRegister] with _NameGroupGroupFormat with _AlternateRegisterDefinitionGroupGroupFormat {
    val targetNamespace: Option[String] = Some("http://www.spiritconsortium.org/XMLSchema/SPIRIT/1685-2009")
    
    def parser(node: scala.xml.Node, stack: List[IPXACT2009scalaxb.ElemName]): Parser[AlternateRegister] =
      phrase((parseNameGroupGroup(node, IPXACT2009scalaxb.ElemName(node) :: stack)) ~
      (IPXACT2009scalaxb.ElemName(Some("http://www.spiritconsortium.org/XMLSchema/SPIRIT/1685-2009"), "alternateGroups")) ~
      (parseAlternateRegisterDefinitionGroupGroup(node, IPXACT2009scalaxb.ElemName(node) :: stack)) ~
      opt(IPXACT2009scalaxb.ElemName(Some("http://www.spiritconsortium.org/XMLSchema/SPIRIT/1685-2009"), "parameters")) ~
      opt(IPXACT2009scalaxb.ElemName(Some("http://www.spiritconsortium.org/XMLSchema/SPIRIT/1685-2009"), "vendorExtensions")) ^^
      { case p1 ~ p2 ~ p3 ~ p4 ~ p5 =>
      AlternateRegister(p1,
        IPXACT2009scalaxb.fromXML[AlternateGroups](p2, IPXACT2009scalaxb.ElemName(node) :: stack),
        p3,
        p4.headOption map { IPXACT2009scalaxb.fromXML[Parameters](_, IPXACT2009scalaxb.ElemName(node) :: stack) },
        p5.headOption map { IPXACT2009scalaxb.fromXML[VendorExtensions](_, IPXACT2009scalaxb.ElemName(node) :: stack) },
        scala.collection.immutable.ListMap(List(
        (node \ "@{http://www.spiritconsortium.org/XMLSchema/SPIRIT/1685-2009}id").headOption map { x => IPXACT2009scalaxb.DataRecord(x, node, IPXACT2009scalaxb.fromXML[String](x, IPXACT2009scalaxb.ElemName(node) :: stack)) } map { "@{http://www.spiritconsortium.org/XMLSchema/SPIRIT/1685-2009}id" -> _ }
        ).flatten[(String, IPXACT2009scalaxb.DataRecord[Any])]: _*)) })
    
    override def writesAttribute(__obj: AlternateRegister, __scope: scala.xml.NamespaceBinding): scala.xml.MetaData = {
      var attr: scala.xml.MetaData  = scala.xml.Null
      __obj.attributes.toList map {
        case ("@{http://www.spiritconsortium.org/XMLSchema/SPIRIT/1685-2009}id", _) => __obj.spiritid foreach { x => attr = scala.xml.Attribute(__scope.getPrefix("http://www.spiritconsortium.org/XMLSchema/SPIRIT/1685-2009"), "id", x.toString, attr) }
        case (key, x) => attr = scala.xml.Attribute((x.namespace map { __scope.getPrefix(_) }).orNull, x.key.orNull, x.value.toString, attr)
      }
      attr
    }

    def writesChildNodes(__obj: AlternateRegister, __scope: scala.xml.NamespaceBinding): Seq[scala.xml.Node] =
      Seq.concat(IPXACT2009scalaxb.toXML[NameGroupSequence](__obj.nameGroupSequence1, None, Some("nameGroupSequence1"), __scope, false),
        IPXACT2009scalaxb.toXML[AlternateGroups](__obj.alternateGroups, Some("http://www.spiritconsortium.org/XMLSchema/SPIRIT/1685-2009"), Some("alternateGroups"), __scope, false),
        IPXACT2009scalaxb.toXML[AlternateRegisterDefinitionGroupSequence](__obj.alternateRegisterDefinitionGroupSequence3, None, Some("alternateRegisterDefinitionGroupSequence3"), __scope, false),
        __obj.parameters map { IPXACT2009scalaxb.toXML[Parameters](_, Some("http://www.spiritconsortium.org/XMLSchema/SPIRIT/1685-2009"), Some("parameters"), __scope, false) } getOrElse {Nil},
        __obj.vendorExtensions map { IPXACT2009scalaxb.toXML[VendorExtensions](_, Some("http://www.spiritconsortium.org/XMLSchema/SPIRIT/1685-2009"), Some("vendorExtensions"), __scope, false) } getOrElse {Nil})

  }

  trait Default_AlternateRegistersFormat extends IPXACT2009scalaxb.ElemNameParser[AlternateRegisters] {
    val targetNamespace: Option[String] = Some("http://www.spiritconsortium.org/XMLSchema/SPIRIT/1685-2009")
    
    def parser(node: scala.xml.Node, stack: List[IPXACT2009scalaxb.ElemName]): Parser[AlternateRegisters] =
      phrase(safeRep(IPXACT2009scalaxb.ElemName(Some("http://www.spiritconsortium.org/XMLSchema/SPIRIT/1685-2009"), "alternateRegister")) ^^
      { case p1 =>
      AlternateRegisters(p1 map { IPXACT2009scalaxb.fromXML[AlternateRegister](_, IPXACT2009scalaxb.ElemName(node) :: stack) }) })
    
    def writesChildNodes(__obj: AlternateRegisters, __scope: scala.xml.NamespaceBinding): Seq[scala.xml.Node] =
      (__obj.alternateRegister flatMap { IPXACT2009scalaxb.toXML[AlternateRegister](_, Some("http://www.spiritconsortium.org/XMLSchema/SPIRIT/1685-2009"), Some("alternateRegister"), __scope, false) })
  }
  trait Default_RegisterFormat extends IPXACT2009scalaxb.ElemNameParser[Register] with _NameGroupGroupFormat with _RegisterDefinitionGroupGroupFormat {
    val targetNamespace: Option[String] = Some("http://www.spiritconsortium.org/XMLSchema/SPIRIT/1685-2009")
    
    def parser(node: scala.xml.Node, stack: List[IPXACT2009scalaxb.ElemName]): Parser[Register] =
      phrase((parseNameGroupGroup(node, IPXACT2009scalaxb.ElemName(node) :: stack)) ~
      safeRep(IPXACT2009scalaxb.ElemName(Some("http://www.spiritconsortium.org/XMLSchema/SPIRIT/1685-2009"), "dim")) ~
      (IPXACT2009scalaxb.ElemName(Some("http://www.spiritconsortium.org/XMLSchema/SPIRIT/1685-2009"), "addressOffset")) ~
      (parseRegisterDefinitionGroupGroup(node, IPXACT2009scalaxb.ElemName(node) :: stack)) ~
      opt(IPXACT2009scalaxb.ElemName(Some("http://www.spiritconsortium.org/XMLSchema/SPIRIT/1685-2009"), "alternateRegisters")) ~
      opt(IPXACT2009scalaxb.ElemName(Some("http://www.spiritconsortium.org/XMLSchema/SPIRIT/1685-2009"), "parameters")) ~
      opt(IPXACT2009scalaxb.ElemName(Some("http://www.spiritconsortium.org/XMLSchema/SPIRIT/1685-2009"), "vendorExtensions")) ^^
      { case p1 ~ p2 ~ p3 ~ p4 ~ p5 ~ p6 ~ p7 =>
      Register(p1,
        p2 map { IPXACT2009scalaxb.fromXML[BigInt](_, IPXACT2009scalaxb.ElemName(node) :: stack) },
        IPXACT2009scalaxb.fromXML[String](p3, IPXACT2009scalaxb.ElemName(node) :: stack),
        p4,
        p5.headOption map { IPXACT2009scalaxb.fromXML[AlternateRegisters](_, IPXACT2009scalaxb.ElemName(node) :: stack) },
        p6.headOption map { IPXACT2009scalaxb.fromXML[Parameters](_, IPXACT2009scalaxb.ElemName(node) :: stack) },
        p7.headOption map { IPXACT2009scalaxb.fromXML[VendorExtensions](_, IPXACT2009scalaxb.ElemName(node) :: stack) },
        scala.collection.immutable.ListMap(List(
        (node \ "@{http://www.spiritconsortium.org/XMLSchema/SPIRIT/1685-2009}id").headOption map { x => IPXACT2009scalaxb.DataRecord(x, node, IPXACT2009scalaxb.fromXML[String](x, IPXACT2009scalaxb.ElemName(node) :: stack)) } map { "@{http://www.spiritconsortium.org/XMLSchema/SPIRIT/1685-2009}id" -> _ }
        ).flatten[(String, IPXACT2009scalaxb.DataRecord[Any])]: _*)) })
    
    override def writesAttribute(__obj: Register, __scope: scala.xml.NamespaceBinding): scala.xml.MetaData = {
      var attr: scala.xml.MetaData  = scala.xml.Null
      __obj.attributes.toList map {
        case ("@{http://www.spiritconsortium.org/XMLSchema/SPIRIT/1685-2009}id", _) => __obj.spiritid foreach { x => attr = scala.xml.Attribute(__scope.getPrefix("http://www.spiritconsortium.org/XMLSchema/SPIRIT/1685-2009"), "id", x.toString, attr) }
        case (key, x) => attr = scala.xml.Attribute((x.namespace map { __scope.getPrefix(_) }).orNull, x.key.orNull, x.value.toString, attr)
      }
      attr
    }

    def writesChildNodes(__obj: Register, __scope: scala.xml.NamespaceBinding): Seq[scala.xml.Node] =
      Seq.concat(IPXACT2009scalaxb.toXML[NameGroupSequence](__obj.nameGroupSequence1, None, Some("nameGroupSequence1"), __scope, false),
        __obj.dim flatMap { IPXACT2009scalaxb.toXML[BigInt](_, Some("http://www.spiritconsortium.org/XMLSchema/SPIRIT/1685-2009"), Some("dim"), __scope, false) },
        IPXACT2009scalaxb.toXML[String](__obj.addressOffset, Some("http://www.spiritconsortium.org/XMLSchema/SPIRIT/1685-2009"), Some("addressOffset"), __scope, false),
        IPXACT2009scalaxb.toXML[RegisterDefinitionGroupSequence](__obj.registerDefinitionGroupSequence4, None, Some("registerDefinitionGroupSequence4"), __scope, false),
        __obj.alternateRegisters map { IPXACT2009scalaxb.toXML[AlternateRegisters](_, Some("http://www.spiritconsortium.org/XMLSchema/SPIRIT/1685-2009"), Some("alternateRegisters"), __scope, false) } getOrElse {Nil},
        __obj.parameters map { IPXACT2009scalaxb.toXML[Parameters](_, Some("http://www.spiritconsortium.org/XMLSchema/SPIRIT/1685-2009"), Some("parameters"), __scope, false) } getOrElse {Nil},
        __obj.vendorExtensions map { IPXACT2009scalaxb.toXML[VendorExtensions](_, Some("http://www.spiritconsortium.org/XMLSchema/SPIRIT/1685-2009"), Some("vendorExtensions"), __scope, false) } getOrElse {Nil})

  }

  def build_UsageFormat = new Default_UsageFormat {}
  trait Default_UsageFormat extends IPXACT2009scalaxb.XMLFormat[Usage] {
    val targetNamespace: Option[String] = Some("http://www.spiritconsortium.org/XMLSchema/SPIRIT/1685-2009")
    
    def fromString(value: String, scope: scala.xml.NamespaceBinding): Usage =
        (fromString0(value, scope)).apply(IPXACT2009scalaxb.fromXML[String](scala.xml.Text(value)))

    private def fromString0(value: String, scope: scala.xml.NamespaceBinding): PartialFunction[Any, Usage] = {
      case x: String if x == IPXACT2009scalaxb.fromXML[String](scala.xml.Text("read")) => Read
      case x: String if x == IPXACT2009scalaxb.fromXML[String](scala.xml.Text("write")) => Write
      case x: String if x == IPXACT2009scalaxb.fromXML[String](scala.xml.Text("read-write")) => Readu45writeValue

    }



    def reads(seq: scala.xml.NodeSeq, stack: List[IPXACT2009scalaxb.ElemName]): Either[String, Usage] = seq match {
      case elem: scala.xml.Elem => Right(fromString(elem.text, elem.scope))
      case _ => Right(fromString(seq.text, scala.xml.TopScope))
    }
    
    def writes(__obj: Usage, __namespace: Option[String], __elementLabel: Option[String],
        __scope: scala.xml.NamespaceBinding, __typeAttribute: Boolean): scala.xml.NodeSeq =
      scala.xml.Elem(IPXACT2009scalaxb.Helper.getPrefix(__namespace, __scope).orNull,
        __elementLabel getOrElse { sys.error("missing element label.") },
        scala.xml.Null, __scope, true, scala.xml.Text(__obj.toString))
  }
  trait Default_EnumeratedValueFormat extends IPXACT2009scalaxb.ElemNameParser[EnumeratedValue] with _NameGroupGroupFormat {
    val targetNamespace: Option[String] = Some("http://www.spiritconsortium.org/XMLSchema/SPIRIT/1685-2009")
    
    def parser(node: scala.xml.Node, stack: List[IPXACT2009scalaxb.ElemName]): Parser[EnumeratedValue] =
      phrase((parseNameGroupGroup(node, IPXACT2009scalaxb.ElemName(node) :: stack)) ~
      (IPXACT2009scalaxb.ElemName(Some("http://www.spiritconsortium.org/XMLSchema/SPIRIT/1685-2009"), "value")) ~
      opt(IPXACT2009scalaxb.ElemName(Some("http://www.spiritconsortium.org/XMLSchema/SPIRIT/1685-2009"), "vendorExtensions")) ^^
      { case p1 ~ p2 ~ p3 =>
      EnumeratedValue(p1,
        IPXACT2009scalaxb.fromXML[String](p2, IPXACT2009scalaxb.ElemName(node) :: stack),
        p3.headOption map { IPXACT2009scalaxb.fromXML[VendorExtensions](_, IPXACT2009scalaxb.ElemName(node) :: stack) },
        scala.collection.immutable.ListMap(List(
        (node \ "@{http://www.spiritconsortium.org/XMLSchema/SPIRIT/1685-2009}usage").headOption map { x => IPXACT2009scalaxb.DataRecord(x, node, IPXACT2009scalaxb.fromXML[Usage](x, IPXACT2009scalaxb.ElemName(node) :: stack)) } orElse Some(IPXACT2009scalaxb.DataRecord(None, None, IPXACT2009scalaxb.fromXML[Usage](scala.xml.Text("read-write"), IPXACT2009scalaxb.ElemName(node) :: stack))) map { "@usage" -> _ }
        ).flatten[(String, IPXACT2009scalaxb.DataRecord[Any])]: _*)) })
    
    override def writesAttribute(__obj: EnumeratedValue, __scope: scala.xml.NamespaceBinding): scala.xml.MetaData = {
      var attr: scala.xml.MetaData  = scala.xml.Null
      __obj.attributes.toList map {
        case ("@usage", _) => if (__obj.usage.toString != "read-write") attr = scala.xml.Attribute(__scope.getPrefix("http://www.spiritconsortium.org/XMLSchema/SPIRIT/1685-2009"), "usage", __obj.usage.toString, attr)
        case (key, x) => attr = scala.xml.Attribute((x.namespace map { __scope.getPrefix(_) }).orNull, x.key.orNull, x.value.toString, attr)
      }
      attr
    }

    def writesChildNodes(__obj: EnumeratedValue, __scope: scala.xml.NamespaceBinding): Seq[scala.xml.Node] =
      Seq.concat(IPXACT2009scalaxb.toXML[NameGroupSequence](__obj.nameGroupSequence1, None, Some("nameGroupSequence1"), __scope, false),
        IPXACT2009scalaxb.toXML[String](__obj.value, Some("http://www.spiritconsortium.org/XMLSchema/SPIRIT/1685-2009"), Some("value"), __scope, false),
        __obj.vendorExtensions map { IPXACT2009scalaxb.toXML[VendorExtensions](_, Some("http://www.spiritconsortium.org/XMLSchema/SPIRIT/1685-2009"), Some("vendorExtensions"), __scope, false) } getOrElse {Nil})

  }

  trait Default_EnumeratedValuesFormat extends IPXACT2009scalaxb.ElemNameParser[EnumeratedValues] {
    val targetNamespace: Option[String] = Some("http://www.spiritconsortium.org/XMLSchema/SPIRIT/1685-2009")
    
    def parser(node: scala.xml.Node, stack: List[IPXACT2009scalaxb.ElemName]): Parser[EnumeratedValues] =
      phrase(safeRep(IPXACT2009scalaxb.ElemName(Some("http://www.spiritconsortium.org/XMLSchema/SPIRIT/1685-2009"), "enumeratedValue")) ^^
      { case p1 =>
      EnumeratedValues(p1 map { IPXACT2009scalaxb.fromXML[EnumeratedValue](_, IPXACT2009scalaxb.ElemName(node) :: stack) }) })
    
    def writesChildNodes(__obj: EnumeratedValues, __scope: scala.xml.NamespaceBinding): Seq[scala.xml.Node] =
      (__obj.enumeratedValue flatMap { IPXACT2009scalaxb.toXML[EnumeratedValue](_, Some("http://www.spiritconsortium.org/XMLSchema/SPIRIT/1685-2009"), Some("enumeratedValue"), __scope, false) })
  }
  trait Default_ValueMaskConfigTypeFormat extends IPXACT2009scalaxb.XMLFormat[ValueMaskConfigType] with IPXACT2009scalaxb.CanWriteChildNodes[ValueMaskConfigType] {
    val targetNamespace: Option[String] = Some("http://www.spiritconsortium.org/XMLSchema/SPIRIT/1685-2009")
    def reads(seq: scala.xml.NodeSeq, stack: List[IPXACT2009scalaxb.ElemName]): Either[String, ValueMaskConfigType] = seq match {
      case node: scala.xml.Node => Right(ValueMaskConfigType())
      case _ => Left("reads failed: seq must be scala.xml.Node")
    }
    
    def writesChildNodes(__obj: ValueMaskConfigType, __scope: scala.xml.NamespaceBinding): Seq[scala.xml.Node] =
      Nil

  }
  def build_ModifiedWriteValueFormat = new Default_ModifiedWriteValueFormat {}
  trait Default_ModifiedWriteValueFormat extends IPXACT2009scalaxb.XMLFormat[ModifiedWriteValue] {
    val targetNamespace: Option[String] = Some("http://www.spiritconsortium.org/XMLSchema/SPIRIT/1685-2009")
    
    def fromString(value: String, scope: scala.xml.NamespaceBinding): ModifiedWriteValue =
        (fromString0(value, scope)).apply(IPXACT2009scalaxb.fromXML[String](scala.xml.Text(value)))

    private def fromString0(value: String, scope: scala.xml.NamespaceBinding): PartialFunction[Any, ModifiedWriteValue] = {
      case x: String if x == IPXACT2009scalaxb.fromXML[String](scala.xml.Text("oneToClear")) => OneToClear
      case x: String if x == IPXACT2009scalaxb.fromXML[String](scala.xml.Text("oneToSet")) => OneToSet
      case x: String if x == IPXACT2009scalaxb.fromXML[String](scala.xml.Text("oneToToggle")) => OneToToggle
      case x: String if x == IPXACT2009scalaxb.fromXML[String](scala.xml.Text("zeroToClear")) => ZeroToClear
      case x: String if x == IPXACT2009scalaxb.fromXML[String](scala.xml.Text("zeroToSet")) => ZeroToSet
      case x: String if x == IPXACT2009scalaxb.fromXML[String](scala.xml.Text("zeroToToggle")) => ZeroToToggle
      case x: String if x == IPXACT2009scalaxb.fromXML[String](scala.xml.Text("clear")) => Clear
      case x: String if x == IPXACT2009scalaxb.fromXML[String](scala.xml.Text("set")) => SetType
      case x: String if x == IPXACT2009scalaxb.fromXML[String](scala.xml.Text("modify")) => Modify

    }



    def reads(seq: scala.xml.NodeSeq, stack: List[IPXACT2009scalaxb.ElemName]): Either[String, ModifiedWriteValue] = seq match {
      case elem: scala.xml.Elem => Right(fromString(elem.text, elem.scope))
      case _ => Right(fromString(seq.text, scala.xml.TopScope))
    }
    
    def writes(__obj: ModifiedWriteValue, __namespace: Option[String], __elementLabel: Option[String],
        __scope: scala.xml.NamespaceBinding, __typeAttribute: Boolean): scala.xml.NodeSeq =
      scala.xml.Elem(IPXACT2009scalaxb.Helper.getPrefix(__namespace, __scope).orNull,
        __elementLabel getOrElse { sys.error("missing element label.") },
        scala.xml.Null, __scope, true, scala.xml.Text(__obj.toString))
  }
  def build_ReadActionFormat = new Default_ReadActionFormat {}
  trait Default_ReadActionFormat extends IPXACT2009scalaxb.XMLFormat[ReadAction] {
    val targetNamespace: Option[String] = Some("http://www.spiritconsortium.org/XMLSchema/SPIRIT/1685-2009")
    
    def fromString(value: String, scope: scala.xml.NamespaceBinding): ReadAction =
        (fromString0(value, scope)).apply(IPXACT2009scalaxb.fromXML[String](scala.xml.Text(value)))

    private def fromString0(value: String, scope: scala.xml.NamespaceBinding): PartialFunction[Any, ReadAction] = {
      case x: String if x == IPXACT2009scalaxb.fromXML[String](scala.xml.Text("clear")) => ClearValue
      case x: String if x == IPXACT2009scalaxb.fromXML[String](scala.xml.Text("set")) => SetTypeValue
      case x: String if x == IPXACT2009scalaxb.fromXML[String](scala.xml.Text("modify")) => ModifyValue

    }



    def reads(seq: scala.xml.NodeSeq, stack: List[IPXACT2009scalaxb.ElemName]): Either[String, ReadAction] = seq match {
      case elem: scala.xml.Elem => Right(fromString(elem.text, elem.scope))
      case _ => Right(fromString(seq.text, scala.xml.TopScope))
    }
    
    def writes(__obj: ReadAction, __namespace: Option[String], __elementLabel: Option[String],
        __scope: scala.xml.NamespaceBinding, __typeAttribute: Boolean): scala.xml.NodeSeq =
      scala.xml.Elem(IPXACT2009scalaxb.Helper.getPrefix(__namespace, __scope).orNull,
        __elementLabel getOrElse { sys.error("missing element label.") },
        scala.xml.Null, __scope, true, scala.xml.Text(__obj.toString))
  }
  def build_TestConstraintFormat = new Default_TestConstraintFormat {}
  trait Default_TestConstraintFormat extends IPXACT2009scalaxb.XMLFormat[TestConstraint] {
    val targetNamespace: Option[String] = Some("http://www.spiritconsortium.org/XMLSchema/SPIRIT/1685-2009")
    
    def fromString(value: String, scope: scala.xml.NamespaceBinding): TestConstraint =
        (fromString0(value, scope)).apply(IPXACT2009scalaxb.fromXML[String](scala.xml.Text(value)))

    private def fromString0(value: String, scope: scala.xml.NamespaceBinding): PartialFunction[Any, TestConstraint] = {
      case x: String if x == IPXACT2009scalaxb.fromXML[String](scala.xml.Text("unconstrained")) => Unconstrained
      case x: String if x == IPXACT2009scalaxb.fromXML[String](scala.xml.Text("restore")) => Restore
      case x: String if x == IPXACT2009scalaxb.fromXML[String](scala.xml.Text("writeAsRead")) => WriteAsRead
      case x: String if x == IPXACT2009scalaxb.fromXML[String](scala.xml.Text("readOnly")) => ReadOnly

    }



    def reads(seq: scala.xml.NodeSeq, stack: List[IPXACT2009scalaxb.ElemName]): Either[String, TestConstraint] = seq match {
      case elem: scala.xml.Elem => Right(fromString(elem.text, elem.scope))
      case _ => Right(fromString(seq.text, scala.xml.TopScope))
    }
    
    def writes(__obj: TestConstraint, __namespace: Option[String], __elementLabel: Option[String],
        __scope: scala.xml.NamespaceBinding, __typeAttribute: Boolean): scala.xml.NodeSeq =
      scala.xml.Elem(IPXACT2009scalaxb.Helper.getPrefix(__namespace, __scope).orNull,
        __elementLabel getOrElse { sys.error("missing element label.") },
        scala.xml.Null, __scope, true, scala.xml.Text(__obj.toString))
  }
  trait Default_TestableFormat extends IPXACT2009scalaxb.XMLFormat[Testable] with IPXACT2009scalaxb.CanWriteChildNodes[Testable] {
    val targetNamespace: Option[String] = Some("http://www.spiritconsortium.org/XMLSchema/SPIRIT/1685-2009")
    def reads(seq: scala.xml.NodeSeq, stack: List[IPXACT2009scalaxb.ElemName]): Either[String, Testable] = seq match {
      case node: scala.xml.Node => Right(Testable(IPXACT2009scalaxb.fromXML[Boolean](node, IPXACT2009scalaxb.ElemName(node) :: stack),
        scala.collection.immutable.ListMap(List(
        (node \ "@{http://www.spiritconsortium.org/XMLSchema/SPIRIT/1685-2009}testConstraint").headOption map { x => IPXACT2009scalaxb.DataRecord(x, node, IPXACT2009scalaxb.fromXML[TestConstraint](x, IPXACT2009scalaxb.ElemName(node) :: stack)) } orElse Some(IPXACT2009scalaxb.DataRecord(None, None, IPXACT2009scalaxb.fromXML[TestConstraint](scala.xml.Text("unconstrained"), IPXACT2009scalaxb.ElemName(node) :: stack))) map { "@testConstraint" -> _ }
        ).flatten[(String, IPXACT2009scalaxb.DataRecord[Any])]: _*)))
      case _ => Left("reads failed: seq must be scala.xml.Node")
    }
    
    override def writesAttribute(__obj: Testable, __scope: scala.xml.NamespaceBinding): scala.xml.MetaData = {
      var attr: scala.xml.MetaData  = scala.xml.Null
      __obj.attributes.toList map {
        case ("@testConstraint", _) => if (__obj.testConstraint.toString != "unconstrained") attr = scala.xml.Attribute(__scope.getPrefix("http://www.spiritconsortium.org/XMLSchema/SPIRIT/1685-2009"), "testConstraint", __obj.testConstraint.toString, attr)
        case (key, x) => attr = scala.xml.Attribute((x.namespace map { __scope.getPrefix(_) }).orNull, x.key.orNull, x.value.toString, attr)
      }
      attr
    }

    def writesChildNodes(__obj: Testable, __scope: scala.xml.NamespaceBinding): Seq[scala.xml.Node] =
      Seq(scala.xml.Text(__obj.value.toString))

  }

  trait Default_MinimumFormat extends IPXACT2009scalaxb.XMLFormat[Minimum] with IPXACT2009scalaxb.CanWriteChildNodes[Minimum] {
    val targetNamespace: Option[String] = Some("http://www.spiritconsortium.org/XMLSchema/SPIRIT/1685-2009")
    def reads(seq: scala.xml.NodeSeq, stack: List[IPXACT2009scalaxb.ElemName]): Either[String, Minimum] = seq match {
      case node: scala.xml.Node => Right(Minimum(IPXACT2009scalaxb.fromXML[String](node, IPXACT2009scalaxb.ElemName(node) :: stack),
        scala.collection.immutable.ListMap(List(
        (node \ "@{http://www.spiritconsortium.org/XMLSchema/SPIRIT/1685-2009}format").headOption map { x => IPXACT2009scalaxb.DataRecord(x, node, IPXACT2009scalaxb.fromXML[FormatType](x, IPXACT2009scalaxb.ElemName(node) :: stack)) } orElse Some(IPXACT2009scalaxb.DataRecord(None, None, IPXACT2009scalaxb.fromXML[FormatType](scala.xml.Text("long"), IPXACT2009scalaxb.ElemName(node) :: stack))) map { "@{http://www.spiritconsortium.org/XMLSchema/SPIRIT/1685-2009}format" -> _ },
        (node \ "@{http://www.spiritconsortium.org/XMLSchema/SPIRIT/1685-2009}resolve").headOption map { x => IPXACT2009scalaxb.DataRecord(x, node, IPXACT2009scalaxb.fromXML[ResolveType](x, IPXACT2009scalaxb.ElemName(node) :: stack)) } map { "@{http://www.spiritconsortium.org/XMLSchema/SPIRIT/1685-2009}resolve" -> _ },
        (node \ "@{http://www.spiritconsortium.org/XMLSchema/SPIRIT/1685-2009}id").headOption map { x => IPXACT2009scalaxb.DataRecord(x, node, IPXACT2009scalaxb.fromXML[String](x, IPXACT2009scalaxb.ElemName(node) :: stack)) } map { "@{http://www.spiritconsortium.org/XMLSchema/SPIRIT/1685-2009}id" -> _ },
        (node \ "@{http://www.spiritconsortium.org/XMLSchema/SPIRIT/1685-2009}dependency").headOption map { x => IPXACT2009scalaxb.DataRecord(x, node, IPXACT2009scalaxb.fromXML[String](x, IPXACT2009scalaxb.ElemName(node) :: stack)) } map { "@{http://www.spiritconsortium.org/XMLSchema/SPIRIT/1685-2009}dependency" -> _ },
        (node \ "@{http://www.spiritconsortium.org/XMLSchema/SPIRIT/1685-2009}choiceRef").headOption map { x => IPXACT2009scalaxb.DataRecord(x, node, IPXACT2009scalaxb.fromXML[String](x, IPXACT2009scalaxb.ElemName(node) :: stack)) } map { "@{http://www.spiritconsortium.org/XMLSchema/SPIRIT/1685-2009}choiceRef" -> _ },
        (node \ "@{http://www.spiritconsortium.org/XMLSchema/SPIRIT/1685-2009}order").headOption map { x => IPXACT2009scalaxb.DataRecord(x, node, IPXACT2009scalaxb.fromXML[Float](x, IPXACT2009scalaxb.ElemName(node) :: stack)) } map { "@{http://www.spiritconsortium.org/XMLSchema/SPIRIT/1685-2009}order" -> _ },
        (node \ "@{http://www.spiritconsortium.org/XMLSchema/SPIRIT/1685-2009}configGroups").headOption map { x => IPXACT2009scalaxb.DataRecord(x, node, IPXACT2009scalaxb.fromXML[Seq[String]](x, IPXACT2009scalaxb.ElemName(node) :: stack)) } map { "@{http://www.spiritconsortium.org/XMLSchema/SPIRIT/1685-2009}configGroups" -> _ },
        (node \ "@{http://www.spiritconsortium.org/XMLSchema/SPIRIT/1685-2009}bitStringLength").headOption map { x => IPXACT2009scalaxb.DataRecord(x, node, IPXACT2009scalaxb.fromXML[BigInt](x, IPXACT2009scalaxb.ElemName(node) :: stack)) } map { "@{http://www.spiritconsortium.org/XMLSchema/SPIRIT/1685-2009}bitStringLength" -> _ },
        (node \ "@{http://www.spiritconsortium.org/XMLSchema/SPIRIT/1685-2009}minimum").headOption map { x => IPXACT2009scalaxb.DataRecord(x, node, IPXACT2009scalaxb.fromXML[String](x, IPXACT2009scalaxb.ElemName(node) :: stack)) } map { "@{http://www.spiritconsortium.org/XMLSchema/SPIRIT/1685-2009}minimum" -> _ },
        (node \ "@{http://www.spiritconsortium.org/XMLSchema/SPIRIT/1685-2009}maximum").headOption map { x => IPXACT2009scalaxb.DataRecord(x, node, IPXACT2009scalaxb.fromXML[String](x, IPXACT2009scalaxb.ElemName(node) :: stack)) } map { "@{http://www.spiritconsortium.org/XMLSchema/SPIRIT/1685-2009}maximum" -> _ },
        (node \ "@{http://www.spiritconsortium.org/XMLSchema/SPIRIT/1685-2009}rangeType").headOption map { x => IPXACT2009scalaxb.DataRecord(x, node, IPXACT2009scalaxb.fromXML[RangeTypeType](x, IPXACT2009scalaxb.ElemName(node) :: stack)) } orElse Some(IPXACT2009scalaxb.DataRecord(None, None, IPXACT2009scalaxb.fromXML[RangeTypeType](scala.xml.Text("float"), IPXACT2009scalaxb.ElemName(node) :: stack))) map { "@{http://www.spiritconsortium.org/XMLSchema/SPIRIT/1685-2009}rangeType" -> _ },
        (node \ "@{http://www.spiritconsortium.org/XMLSchema/SPIRIT/1685-2009}prompt").headOption map { x => IPXACT2009scalaxb.DataRecord(x, node, IPXACT2009scalaxb.fromXML[String](x, IPXACT2009scalaxb.ElemName(node) :: stack)) } map { "@{http://www.spiritconsortium.org/XMLSchema/SPIRIT/1685-2009}prompt" -> _ }
        ).flatten[(String, IPXACT2009scalaxb.DataRecord[Any])] ::: (node match {
          case elem: scala.xml.Elem =>
            elem.attributes.toList flatMap {
              case scala.xml.PrefixedAttribute(pre, key, value, _) if pre == elem.scope.getPrefix("http://www.spiritconsortium.org/XMLSchema/SPIRIT/1685-2009") &&
                key == "format" => Nil
              case scala.xml.PrefixedAttribute(pre, key, value, _) if pre == elem.scope.getPrefix("http://www.spiritconsortium.org/XMLSchema/SPIRIT/1685-2009") &&
                key == "resolve" => Nil
              case scala.xml.PrefixedAttribute(pre, key, value, _) if pre == elem.scope.getPrefix("http://www.spiritconsortium.org/XMLSchema/SPIRIT/1685-2009") &&
                key == "id" => Nil
              case scala.xml.PrefixedAttribute(pre, key, value, _) if pre == elem.scope.getPrefix("http://www.spiritconsortium.org/XMLSchema/SPIRIT/1685-2009") &&
                key == "dependency" => Nil
              case scala.xml.PrefixedAttribute(pre, key, value, _) if pre == elem.scope.getPrefix("http://www.spiritconsortium.org/XMLSchema/SPIRIT/1685-2009") &&
                key == "choiceRef" => Nil
              case scala.xml.PrefixedAttribute(pre, key, value, _) if pre == elem.scope.getPrefix("http://www.spiritconsortium.org/XMLSchema/SPIRIT/1685-2009") &&
                key == "order" => Nil
              case scala.xml.PrefixedAttribute(pre, key, value, _) if pre == elem.scope.getPrefix("http://www.spiritconsortium.org/XMLSchema/SPIRIT/1685-2009") &&
                key == "configGroups" => Nil
              case scala.xml.PrefixedAttribute(pre, key, value, _) if pre == elem.scope.getPrefix("http://www.spiritconsortium.org/XMLSchema/SPIRIT/1685-2009") &&
                key == "bitStringLength" => Nil
              case scala.xml.PrefixedAttribute(pre, key, value, _) if pre == elem.scope.getPrefix("http://www.spiritconsortium.org/XMLSchema/SPIRIT/1685-2009") &&
                key == "minimum" => Nil
              case scala.xml.PrefixedAttribute(pre, key, value, _) if pre == elem.scope.getPrefix("http://www.spiritconsortium.org/XMLSchema/SPIRIT/1685-2009") &&
                key == "maximum" => Nil
              case scala.xml.PrefixedAttribute(pre, key, value, _) if pre == elem.scope.getPrefix("http://www.spiritconsortium.org/XMLSchema/SPIRIT/1685-2009") &&
                key == "rangeType" => Nil
              case scala.xml.PrefixedAttribute(pre, key, value, _) if pre == elem.scope.getPrefix("http://www.spiritconsortium.org/XMLSchema/SPIRIT/1685-2009") &&
                key == "prompt" => Nil
              case scala.xml.UnprefixedAttribute(key, value, _) =>
                List(("@" + key, IPXACT2009scalaxb.DataRecord(None, Some(key), value.text)))
              case scala.xml.PrefixedAttribute(pre, key, value, _) =>
                val ns = elem.scope.getURI(pre)
                List(("@{" + ns + "}" + key, IPXACT2009scalaxb.DataRecord(Option[String](ns), Some(key), value.text)))
              case _ => Nil
            }
          case _ => Nil
        }): _*)))
      case _ => Left("reads failed: seq must be scala.xml.Node")
    }
    
    override def writesAttribute(__obj: Minimum, __scope: scala.xml.NamespaceBinding): scala.xml.MetaData = {
      var attr: scala.xml.MetaData  = scala.xml.Null
      __obj.attributes.toList map {
        case ("@{http://www.spiritconsortium.org/XMLSchema/SPIRIT/1685-2009}format", _) => if (__obj.spiritformat.toString != "long") attr = scala.xml.Attribute(__scope.getPrefix("http://www.spiritconsortium.org/XMLSchema/SPIRIT/1685-2009"), "format", __obj.spiritformat.toString, attr)
        case ("@{http://www.spiritconsortium.org/XMLSchema/SPIRIT/1685-2009}resolve", _) => __obj.spiritresolve foreach { x => attr = scala.xml.Attribute(__scope.getPrefix("http://www.spiritconsortium.org/XMLSchema/SPIRIT/1685-2009"), "resolve", x.toString, attr) }
        case ("@{http://www.spiritconsortium.org/XMLSchema/SPIRIT/1685-2009}id", _) => __obj.spiritid foreach { x => attr = scala.xml.Attribute(__scope.getPrefix("http://www.spiritconsortium.org/XMLSchema/SPIRIT/1685-2009"), "id", x.toString, attr) }
        case ("@{http://www.spiritconsortium.org/XMLSchema/SPIRIT/1685-2009}dependency", _) => __obj.spiritdependency foreach { x => attr = scala.xml.Attribute(__scope.getPrefix("http://www.spiritconsortium.org/XMLSchema/SPIRIT/1685-2009"), "dependency", x.toString, attr) }
        case ("@{http://www.spiritconsortium.org/XMLSchema/SPIRIT/1685-2009}choiceRef", _) => __obj.spiritchoiceRef foreach { x => attr = scala.xml.Attribute(__scope.getPrefix("http://www.spiritconsortium.org/XMLSchema/SPIRIT/1685-2009"), "choiceRef", x.toString, attr) }
        case ("@{http://www.spiritconsortium.org/XMLSchema/SPIRIT/1685-2009}order", _) => __obj.spiritorder foreach { x => attr = scala.xml.Attribute(__scope.getPrefix("http://www.spiritconsortium.org/XMLSchema/SPIRIT/1685-2009"), "order", x.toString, attr) }
        case ("@{http://www.spiritconsortium.org/XMLSchema/SPIRIT/1685-2009}configGroups", _) => __obj.spiritconfigGroups foreach { x => attr = scala.xml.Attribute(__scope.getPrefix("http://www.spiritconsortium.org/XMLSchema/SPIRIT/1685-2009"), "configGroups", x.toString, attr) }
        case ("@{http://www.spiritconsortium.org/XMLSchema/SPIRIT/1685-2009}bitStringLength", _) => __obj.spiritbitStringLength foreach { x => attr = scala.xml.Attribute(__scope.getPrefix("http://www.spiritconsortium.org/XMLSchema/SPIRIT/1685-2009"), "bitStringLength", x.toString, attr) }
        case ("@{http://www.spiritconsortium.org/XMLSchema/SPIRIT/1685-2009}minimum", _) => __obj.spiritminimum foreach { x => attr = scala.xml.Attribute(__scope.getPrefix("http://www.spiritconsortium.org/XMLSchema/SPIRIT/1685-2009"), "minimum", x.toString, attr) }
        case ("@{http://www.spiritconsortium.org/XMLSchema/SPIRIT/1685-2009}maximum", _) => __obj.spiritmaximum foreach { x => attr = scala.xml.Attribute(__scope.getPrefix("http://www.spiritconsortium.org/XMLSchema/SPIRIT/1685-2009"), "maximum", x.toString, attr) }
        case ("@{http://www.spiritconsortium.org/XMLSchema/SPIRIT/1685-2009}rangeType", _) => if (__obj.spiritrangeType.toString != "float") attr = scala.xml.Attribute(__scope.getPrefix("http://www.spiritconsortium.org/XMLSchema/SPIRIT/1685-2009"), "rangeType", __obj.spiritrangeType.toString, attr)
        case ("@{http://www.spiritconsortium.org/XMLSchema/SPIRIT/1685-2009}prompt", _) => __obj.spiritprompt foreach { x => attr = scala.xml.Attribute(__scope.getPrefix("http://www.spiritconsortium.org/XMLSchema/SPIRIT/1685-2009"), "prompt", x.toString, attr) }
        case (key, x) => attr = scala.xml.Attribute((x.namespace map { __scope.getPrefix(_) }).orNull, x.key.orNull, x.value.toString, attr)
      }
      attr
    }

    def writesChildNodes(__obj: Minimum, __scope: scala.xml.NamespaceBinding): Seq[scala.xml.Node] =
      Seq(scala.xml.Text(__obj.value.toString))

  }

  trait Default_MaximumFormat extends IPXACT2009scalaxb.XMLFormat[Maximum] with IPXACT2009scalaxb.CanWriteChildNodes[Maximum] {
    val targetNamespace: Option[String] = Some("http://www.spiritconsortium.org/XMLSchema/SPIRIT/1685-2009")
    def reads(seq: scala.xml.NodeSeq, stack: List[IPXACT2009scalaxb.ElemName]): Either[String, Maximum] = seq match {
      case node: scala.xml.Node => Right(Maximum(IPXACT2009scalaxb.fromXML[String](node, IPXACT2009scalaxb.ElemName(node) :: stack),
        scala.collection.immutable.ListMap(List(
        (node \ "@{http://www.spiritconsortium.org/XMLSchema/SPIRIT/1685-2009}format").headOption map { x => IPXACT2009scalaxb.DataRecord(x, node, IPXACT2009scalaxb.fromXML[FormatType](x, IPXACT2009scalaxb.ElemName(node) :: stack)) } orElse Some(IPXACT2009scalaxb.DataRecord(None, None, IPXACT2009scalaxb.fromXML[FormatType](scala.xml.Text("long"), IPXACT2009scalaxb.ElemName(node) :: stack))) map { "@{http://www.spiritconsortium.org/XMLSchema/SPIRIT/1685-2009}format" -> _ },
        (node \ "@{http://www.spiritconsortium.org/XMLSchema/SPIRIT/1685-2009}resolve").headOption map { x => IPXACT2009scalaxb.DataRecord(x, node, IPXACT2009scalaxb.fromXML[ResolveType](x, IPXACT2009scalaxb.ElemName(node) :: stack)) } map { "@{http://www.spiritconsortium.org/XMLSchema/SPIRIT/1685-2009}resolve" -> _ },
        (node \ "@{http://www.spiritconsortium.org/XMLSchema/SPIRIT/1685-2009}id").headOption map { x => IPXACT2009scalaxb.DataRecord(x, node, IPXACT2009scalaxb.fromXML[String](x, IPXACT2009scalaxb.ElemName(node) :: stack)) } map { "@{http://www.spiritconsortium.org/XMLSchema/SPIRIT/1685-2009}id" -> _ },
        (node \ "@{http://www.spiritconsortium.org/XMLSchema/SPIRIT/1685-2009}dependency").headOption map { x => IPXACT2009scalaxb.DataRecord(x, node, IPXACT2009scalaxb.fromXML[String](x, IPXACT2009scalaxb.ElemName(node) :: stack)) } map { "@{http://www.spiritconsortium.org/XMLSchema/SPIRIT/1685-2009}dependency" -> _ },
        (node \ "@{http://www.spiritconsortium.org/XMLSchema/SPIRIT/1685-2009}choiceRef").headOption map { x => IPXACT2009scalaxb.DataRecord(x, node, IPXACT2009scalaxb.fromXML[String](x, IPXACT2009scalaxb.ElemName(node) :: stack)) } map { "@{http://www.spiritconsortium.org/XMLSchema/SPIRIT/1685-2009}choiceRef" -> _ },
        (node \ "@{http://www.spiritconsortium.org/XMLSchema/SPIRIT/1685-2009}order").headOption map { x => IPXACT2009scalaxb.DataRecord(x, node, IPXACT2009scalaxb.fromXML[Float](x, IPXACT2009scalaxb.ElemName(node) :: stack)) } map { "@{http://www.spiritconsortium.org/XMLSchema/SPIRIT/1685-2009}order" -> _ },
        (node \ "@{http://www.spiritconsortium.org/XMLSchema/SPIRIT/1685-2009}configGroups").headOption map { x => IPXACT2009scalaxb.DataRecord(x, node, IPXACT2009scalaxb.fromXML[Seq[String]](x, IPXACT2009scalaxb.ElemName(node) :: stack)) } map { "@{http://www.spiritconsortium.org/XMLSchema/SPIRIT/1685-2009}configGroups" -> _ },
        (node \ "@{http://www.spiritconsortium.org/XMLSchema/SPIRIT/1685-2009}bitStringLength").headOption map { x => IPXACT2009scalaxb.DataRecord(x, node, IPXACT2009scalaxb.fromXML[BigInt](x, IPXACT2009scalaxb.ElemName(node) :: stack)) } map { "@{http://www.spiritconsortium.org/XMLSchema/SPIRIT/1685-2009}bitStringLength" -> _ },
        (node \ "@{http://www.spiritconsortium.org/XMLSchema/SPIRIT/1685-2009}minimum").headOption map { x => IPXACT2009scalaxb.DataRecord(x, node, IPXACT2009scalaxb.fromXML[String](x, IPXACT2009scalaxb.ElemName(node) :: stack)) } map { "@{http://www.spiritconsortium.org/XMLSchema/SPIRIT/1685-2009}minimum" -> _ },
        (node \ "@{http://www.spiritconsortium.org/XMLSchema/SPIRIT/1685-2009}maximum").headOption map { x => IPXACT2009scalaxb.DataRecord(x, node, IPXACT2009scalaxb.fromXML[String](x, IPXACT2009scalaxb.ElemName(node) :: stack)) } map { "@{http://www.spiritconsortium.org/XMLSchema/SPIRIT/1685-2009}maximum" -> _ },
        (node \ "@{http://www.spiritconsortium.org/XMLSchema/SPIRIT/1685-2009}rangeType").headOption map { x => IPXACT2009scalaxb.DataRecord(x, node, IPXACT2009scalaxb.fromXML[RangeTypeType](x, IPXACT2009scalaxb.ElemName(node) :: stack)) } orElse Some(IPXACT2009scalaxb.DataRecord(None, None, IPXACT2009scalaxb.fromXML[RangeTypeType](scala.xml.Text("float"), IPXACT2009scalaxb.ElemName(node) :: stack))) map { "@{http://www.spiritconsortium.org/XMLSchema/SPIRIT/1685-2009}rangeType" -> _ },
        (node \ "@{http://www.spiritconsortium.org/XMLSchema/SPIRIT/1685-2009}prompt").headOption map { x => IPXACT2009scalaxb.DataRecord(x, node, IPXACT2009scalaxb.fromXML[String](x, IPXACT2009scalaxb.ElemName(node) :: stack)) } map { "@{http://www.spiritconsortium.org/XMLSchema/SPIRIT/1685-2009}prompt" -> _ }
        ).flatten[(String, IPXACT2009scalaxb.DataRecord[Any])] ::: (node match {
          case elem: scala.xml.Elem =>
            elem.attributes.toList flatMap {
              case scala.xml.PrefixedAttribute(pre, key, value, _) if pre == elem.scope.getPrefix("http://www.spiritconsortium.org/XMLSchema/SPIRIT/1685-2009") &&
                key == "format" => Nil
              case scala.xml.PrefixedAttribute(pre, key, value, _) if pre == elem.scope.getPrefix("http://www.spiritconsortium.org/XMLSchema/SPIRIT/1685-2009") &&
                key == "resolve" => Nil
              case scala.xml.PrefixedAttribute(pre, key, value, _) if pre == elem.scope.getPrefix("http://www.spiritconsortium.org/XMLSchema/SPIRIT/1685-2009") &&
                key == "id" => Nil
              case scala.xml.PrefixedAttribute(pre, key, value, _) if pre == elem.scope.getPrefix("http://www.spiritconsortium.org/XMLSchema/SPIRIT/1685-2009") &&
                key == "dependency" => Nil
              case scala.xml.PrefixedAttribute(pre, key, value, _) if pre == elem.scope.getPrefix("http://www.spiritconsortium.org/XMLSchema/SPIRIT/1685-2009") &&
                key == "choiceRef" => Nil
              case scala.xml.PrefixedAttribute(pre, key, value, _) if pre == elem.scope.getPrefix("http://www.spiritconsortium.org/XMLSchema/SPIRIT/1685-2009") &&
                key == "order" => Nil
              case scala.xml.PrefixedAttribute(pre, key, value, _) if pre == elem.scope.getPrefix("http://www.spiritconsortium.org/XMLSchema/SPIRIT/1685-2009") &&
                key == "configGroups" => Nil
              case scala.xml.PrefixedAttribute(pre, key, value, _) if pre == elem.scope.getPrefix("http://www.spiritconsortium.org/XMLSchema/SPIRIT/1685-2009") &&
                key == "bitStringLength" => Nil
              case scala.xml.PrefixedAttribute(pre, key, value, _) if pre == elem.scope.getPrefix("http://www.spiritconsortium.org/XMLSchema/SPIRIT/1685-2009") &&
                key == "minimum" => Nil
              case scala.xml.PrefixedAttribute(pre, key, value, _) if pre == elem.scope.getPrefix("http://www.spiritconsortium.org/XMLSchema/SPIRIT/1685-2009") &&
                key == "maximum" => Nil
              case scala.xml.PrefixedAttribute(pre, key, value, _) if pre == elem.scope.getPrefix("http://www.spiritconsortium.org/XMLSchema/SPIRIT/1685-2009") &&
                key == "rangeType" => Nil
              case scala.xml.PrefixedAttribute(pre, key, value, _) if pre == elem.scope.getPrefix("http://www.spiritconsortium.org/XMLSchema/SPIRIT/1685-2009") &&
                key == "prompt" => Nil
              case scala.xml.UnprefixedAttribute(key, value, _) =>
                List(("@" + key, IPXACT2009scalaxb.DataRecord(None, Some(key), value.text)))
              case scala.xml.PrefixedAttribute(pre, key, value, _) =>
                val ns = elem.scope.getURI(pre)
                List(("@{" + ns + "}" + key, IPXACT2009scalaxb.DataRecord(Option[String](ns), Some(key), value.text)))
              case _ => Nil
            }
          case _ => Nil
        }): _*)))
      case _ => Left("reads failed: seq must be scala.xml.Node")
    }
    
    override def writesAttribute(__obj: Maximum, __scope: scala.xml.NamespaceBinding): scala.xml.MetaData = {
      var attr: scala.xml.MetaData  = scala.xml.Null
      __obj.attributes.toList map {
        case ("@{http://www.spiritconsortium.org/XMLSchema/SPIRIT/1685-2009}format", _) => if (__obj.spiritformat.toString != "long") attr = scala.xml.Attribute(__scope.getPrefix("http://www.spiritconsortium.org/XMLSchema/SPIRIT/1685-2009"), "format", __obj.spiritformat.toString, attr)
        case ("@{http://www.spiritconsortium.org/XMLSchema/SPIRIT/1685-2009}resolve", _) => __obj.spiritresolve foreach { x => attr = scala.xml.Attribute(__scope.getPrefix("http://www.spiritconsortium.org/XMLSchema/SPIRIT/1685-2009"), "resolve", x.toString, attr) }
        case ("@{http://www.spiritconsortium.org/XMLSchema/SPIRIT/1685-2009}id", _) => __obj.spiritid foreach { x => attr = scala.xml.Attribute(__scope.getPrefix("http://www.spiritconsortium.org/XMLSchema/SPIRIT/1685-2009"), "id", x.toString, attr) }
        case ("@{http://www.spiritconsortium.org/XMLSchema/SPIRIT/1685-2009}dependency", _) => __obj.spiritdependency foreach { x => attr = scala.xml.Attribute(__scope.getPrefix("http://www.spiritconsortium.org/XMLSchema/SPIRIT/1685-2009"), "dependency", x.toString, attr) }
        case ("@{http://www.spiritconsortium.org/XMLSchema/SPIRIT/1685-2009}choiceRef", _) => __obj.spiritchoiceRef foreach { x => attr = scala.xml.Attribute(__scope.getPrefix("http://www.spiritconsortium.org/XMLSchema/SPIRIT/1685-2009"), "choiceRef", x.toString, attr) }
        case ("@{http://www.spiritconsortium.org/XMLSchema/SPIRIT/1685-2009}order", _) => __obj.spiritorder foreach { x => attr = scala.xml.Attribute(__scope.getPrefix("http://www.spiritconsortium.org/XMLSchema/SPIRIT/1685-2009"), "order", x.toString, attr) }
        case ("@{http://www.spiritconsortium.org/XMLSchema/SPIRIT/1685-2009}configGroups", _) => __obj.spiritconfigGroups foreach { x => attr = scala.xml.Attribute(__scope.getPrefix("http://www.spiritconsortium.org/XMLSchema/SPIRIT/1685-2009"), "configGroups", x.toString, attr) }
        case ("@{http://www.spiritconsortium.org/XMLSchema/SPIRIT/1685-2009}bitStringLength", _) => __obj.spiritbitStringLength foreach { x => attr = scala.xml.Attribute(__scope.getPrefix("http://www.spiritconsortium.org/XMLSchema/SPIRIT/1685-2009"), "bitStringLength", x.toString, attr) }
        case ("@{http://www.spiritconsortium.org/XMLSchema/SPIRIT/1685-2009}minimum", _) => __obj.spiritminimum foreach { x => attr = scala.xml.Attribute(__scope.getPrefix("http://www.spiritconsortium.org/XMLSchema/SPIRIT/1685-2009"), "minimum", x.toString, attr) }
        case ("@{http://www.spiritconsortium.org/XMLSchema/SPIRIT/1685-2009}maximum", _) => __obj.spiritmaximum foreach { x => attr = scala.xml.Attribute(__scope.getPrefix("http://www.spiritconsortium.org/XMLSchema/SPIRIT/1685-2009"), "maximum", x.toString, attr) }
        case ("@{http://www.spiritconsortium.org/XMLSchema/SPIRIT/1685-2009}rangeType", _) => if (__obj.spiritrangeType.toString != "float") attr = scala.xml.Attribute(__scope.getPrefix("http://www.spiritconsortium.org/XMLSchema/SPIRIT/1685-2009"), "rangeType", __obj.spiritrangeType.toString, attr)
        case ("@{http://www.spiritconsortium.org/XMLSchema/SPIRIT/1685-2009}prompt", _) => __obj.spiritprompt foreach { x => attr = scala.xml.Attribute(__scope.getPrefix("http://www.spiritconsortium.org/XMLSchema/SPIRIT/1685-2009"), "prompt", x.toString, attr) }
        case (key, x) => attr = scala.xml.Attribute((x.namespace map { __scope.getPrefix(_) }).orNull, x.key.orNull, x.value.toString, attr)
      }
      attr
    }

    def writesChildNodes(__obj: Maximum, __scope: scala.xml.NamespaceBinding): Seq[scala.xml.Node] =
      Seq(scala.xml.Text(__obj.value.toString))

  }

  trait Default_WriteValueConstraintTypeFormat extends IPXACT2009scalaxb.ElemNameParser[WriteValueConstraintType] {
    val targetNamespace: Option[String] = Some("http://www.spiritconsortium.org/XMLSchema/SPIRIT/1685-2009")
    
    override def typeName: Option[String] = Some("writeValueConstraintType")

    def parser(node: scala.xml.Node, stack: List[IPXACT2009scalaxb.ElemName]): Parser[WriteValueConstraintType] =
      phrase((((IPXACT2009scalaxb.ElemName(Some("http://www.spiritconsortium.org/XMLSchema/SPIRIT/1685-2009"), "writeAsRead")) ^^
      (x => IPXACT2009scalaxb.DataRecord(x.namespace, Some(x.name), IPXACT2009scalaxb.fromXML[Boolean](x, IPXACT2009scalaxb.ElemName(node) :: stack)))) |||
      ((IPXACT2009scalaxb.ElemName(Some("http://www.spiritconsortium.org/XMLSchema/SPIRIT/1685-2009"), "useEnumeratedValues")) ^^
      (x => IPXACT2009scalaxb.DataRecord(x.namespace, Some(x.name), IPXACT2009scalaxb.fromXML[Boolean](x, IPXACT2009scalaxb.ElemName(node) :: stack)))) |||
      (((IPXACT2009scalaxb.ElemName(Some("http://www.spiritconsortium.org/XMLSchema/SPIRIT/1685-2009"), "minimum")) ~
      (IPXACT2009scalaxb.ElemName(Some("http://www.spiritconsortium.org/XMLSchema/SPIRIT/1685-2009"), "maximum"))) ^^
        { case p1 ~ p2 => IPXACT2009scalaxb.DataRecord(WriteValueConstraintTypeSequence1(IPXACT2009scalaxb.fromXML[Minimum](p1, IPXACT2009scalaxb.ElemName(node) :: stack),
        IPXACT2009scalaxb.fromXML[Maximum](p2, IPXACT2009scalaxb.ElemName(node) :: stack))) })) ^^
      { case p1 =>
      WriteValueConstraintType(p1) })
    
    def writesChildNodes(__obj: WriteValueConstraintType, __scope: scala.xml.NamespaceBinding): Seq[scala.xml.Node] =
      ((Some(__obj.writevalueconstrainttypeoption) map {x => IPXACT2009scalaxb.toXML[IPXACT2009scalaxb.DataRecord[Any]](x, x.namespace, x.key, __scope, false)}).get)
  }

  trait Default_WriteValueConstraintTypeSequence1Format extends IPXACT2009scalaxb.XMLFormat[WriteValueConstraintTypeSequence1] {
    def reads(seq: scala.xml.NodeSeq, stack: List[IPXACT2009scalaxb.ElemName]): Either[String, WriteValueConstraintTypeSequence1] = Left("don't call me.")
    
    def writes(__obj: WriteValueConstraintTypeSequence1, __namespace: Option[String], __elementLabel: Option[String], 
        __scope: scala.xml.NamespaceBinding, __typeAttribute: Boolean): scala.xml.NodeSeq =
      Seq.concat(IPXACT2009scalaxb.toXML[Minimum](__obj.minimum, Some("http://www.spiritconsortium.org/XMLSchema/SPIRIT/1685-2009"), Some("minimum"), __scope, false),
        IPXACT2009scalaxb.toXML[Maximum](__obj.maximum, Some("http://www.spiritconsortium.org/XMLSchema/SPIRIT/1685-2009"), Some("maximum"), __scope, false))


  }

  trait Default_RegisterFileFormat extends IPXACT2009scalaxb.ElemNameParser[RegisterFile] with _NameGroupGroupFormat with _RegisterFileDefinitionGroupGroupFormat {
    val targetNamespace: Option[String] = Some("http://www.spiritconsortium.org/XMLSchema/SPIRIT/1685-2009")
    
    def parser(node: scala.xml.Node, stack: List[IPXACT2009scalaxb.ElemName]): Parser[RegisterFile] =
      phrase((parseNameGroupGroup(node, IPXACT2009scalaxb.ElemName(node) :: stack)) ~
      safeRep(IPXACT2009scalaxb.ElemName(Some("http://www.spiritconsortium.org/XMLSchema/SPIRIT/1685-2009"), "dim")) ~
      (IPXACT2009scalaxb.ElemName(Some("http://www.spiritconsortium.org/XMLSchema/SPIRIT/1685-2009"), "addressOffset")) ~
      (parseRegisterFileDefinitionGroupGroup(node, IPXACT2009scalaxb.ElemName(node) :: stack)) ~
      opt(IPXACT2009scalaxb.ElemName(Some("http://www.spiritconsortium.org/XMLSchema/SPIRIT/1685-2009"), "parameters")) ~
      opt(IPXACT2009scalaxb.ElemName(Some("http://www.spiritconsortium.org/XMLSchema/SPIRIT/1685-2009"), "vendorExtensions")) ^^
      { case p1 ~ p2 ~ p3 ~ p4 ~ p5 ~ p6 =>
      RegisterFile(p1,
        p2 map { IPXACT2009scalaxb.fromXML[BigInt](_, IPXACT2009scalaxb.ElemName(node) :: stack) },
        IPXACT2009scalaxb.fromXML[String](p3, IPXACT2009scalaxb.ElemName(node) :: stack),
        p4,
        p5.headOption map { IPXACT2009scalaxb.fromXML[Parameters](_, IPXACT2009scalaxb.ElemName(node) :: stack) },
        p6.headOption map { IPXACT2009scalaxb.fromXML[VendorExtensions](_, IPXACT2009scalaxb.ElemName(node) :: stack) },
        scala.collection.immutable.ListMap(List(
        (node \ "@{http://www.spiritconsortium.org/XMLSchema/SPIRIT/1685-2009}id").headOption map { x => IPXACT2009scalaxb.DataRecord(x, node, IPXACT2009scalaxb.fromXML[String](x, IPXACT2009scalaxb.ElemName(node) :: stack)) } map { "@{http://www.spiritconsortium.org/XMLSchema/SPIRIT/1685-2009}id" -> _ }
        ).flatten[(String, IPXACT2009scalaxb.DataRecord[Any])]: _*)) })
    
    override def writesAttribute(__obj: RegisterFile, __scope: scala.xml.NamespaceBinding): scala.xml.MetaData = {
      var attr: scala.xml.MetaData  = scala.xml.Null
      __obj.attributes.toList map {
        case ("@{http://www.spiritconsortium.org/XMLSchema/SPIRIT/1685-2009}id", _) => __obj.spiritid foreach { x => attr = scala.xml.Attribute(__scope.getPrefix("http://www.spiritconsortium.org/XMLSchema/SPIRIT/1685-2009"), "id", x.toString, attr) }
        case (key, x) => attr = scala.xml.Attribute((x.namespace map { __scope.getPrefix(_) }).orNull, x.key.orNull, x.value.toString, attr)
      }
      attr
    }

    def writesChildNodes(__obj: RegisterFile, __scope: scala.xml.NamespaceBinding): Seq[scala.xml.Node] =
      Seq.concat(IPXACT2009scalaxb.toXML[NameGroupSequence](__obj.nameGroupSequence1, None, Some("nameGroupSequence1"), __scope, false),
        __obj.dim flatMap { IPXACT2009scalaxb.toXML[BigInt](_, Some("http://www.spiritconsortium.org/XMLSchema/SPIRIT/1685-2009"), Some("dim"), __scope, false) },
        IPXACT2009scalaxb.toXML[String](__obj.addressOffset, Some("http://www.spiritconsortium.org/XMLSchema/SPIRIT/1685-2009"), Some("addressOffset"), __scope, false),
        IPXACT2009scalaxb.toXML[RegisterFileDefinitionGroupSequence](__obj.registerFileDefinitionGroupSequence4, None, Some("registerFileDefinitionGroupSequence4"), __scope, false),
        __obj.parameters map { IPXACT2009scalaxb.toXML[Parameters](_, Some("http://www.spiritconsortium.org/XMLSchema/SPIRIT/1685-2009"), Some("parameters"), __scope, false) } getOrElse {Nil},
        __obj.vendorExtensions map { IPXACT2009scalaxb.toXML[VendorExtensions](_, Some("http://www.spiritconsortium.org/XMLSchema/SPIRIT/1685-2009"), Some("vendorExtensions"), __scope, false) } getOrElse {Nil})

  }

  trait Default_BitWidthFormat extends IPXACT2009scalaxb.XMLFormat[BitWidth] with IPXACT2009scalaxb.CanWriteChildNodes[BitWidth] {
    val targetNamespace: Option[String] = Some("http://www.spiritconsortium.org/XMLSchema/SPIRIT/1685-2009")
    def reads(seq: scala.xml.NodeSeq, stack: List[IPXACT2009scalaxb.ElemName]): Either[String, BitWidth] = seq match {
      case node: scala.xml.Node => Right(BitWidth(IPXACT2009scalaxb.fromXML[BigInt](node, IPXACT2009scalaxb.ElemName(node) :: stack),
        scala.collection.immutable.ListMap(List(
        (node \ "@{http://www.spiritconsortium.org/XMLSchema/SPIRIT/1685-2009}format").headOption map { x => IPXACT2009scalaxb.DataRecord(x, node, IPXACT2009scalaxb.fromXML[FormatType](x, IPXACT2009scalaxb.ElemName(node) :: stack)) } orElse Some(IPXACT2009scalaxb.DataRecord(None, None, IPXACT2009scalaxb.fromXML[FormatType](scala.xml.Text("long"), IPXACT2009scalaxb.ElemName(node) :: stack))) map { "@{http://www.spiritconsortium.org/XMLSchema/SPIRIT/1685-2009}format" -> _ },
        (node \ "@{http://www.spiritconsortium.org/XMLSchema/SPIRIT/1685-2009}resolve").headOption map { x => IPXACT2009scalaxb.DataRecord(x, node, IPXACT2009scalaxb.fromXML[ResolveType](x, IPXACT2009scalaxb.ElemName(node) :: stack)) } map { "@{http://www.spiritconsortium.org/XMLSchema/SPIRIT/1685-2009}resolve" -> _ },
        (node \ "@{http://www.spiritconsortium.org/XMLSchema/SPIRIT/1685-2009}id").headOption map { x => IPXACT2009scalaxb.DataRecord(x, node, IPXACT2009scalaxb.fromXML[String](x, IPXACT2009scalaxb.ElemName(node) :: stack)) } map { "@{http://www.spiritconsortium.org/XMLSchema/SPIRIT/1685-2009}id" -> _ },
        (node \ "@{http://www.spiritconsortium.org/XMLSchema/SPIRIT/1685-2009}dependency").headOption map { x => IPXACT2009scalaxb.DataRecord(x, node, IPXACT2009scalaxb.fromXML[String](x, IPXACT2009scalaxb.ElemName(node) :: stack)) } map { "@{http://www.spiritconsortium.org/XMLSchema/SPIRIT/1685-2009}dependency" -> _ },
        (node \ "@{http://www.spiritconsortium.org/XMLSchema/SPIRIT/1685-2009}choiceRef").headOption map { x => IPXACT2009scalaxb.DataRecord(x, node, IPXACT2009scalaxb.fromXML[String](x, IPXACT2009scalaxb.ElemName(node) :: stack)) } map { "@{http://www.spiritconsortium.org/XMLSchema/SPIRIT/1685-2009}choiceRef" -> _ },
        (node \ "@{http://www.spiritconsortium.org/XMLSchema/SPIRIT/1685-2009}order").headOption map { x => IPXACT2009scalaxb.DataRecord(x, node, IPXACT2009scalaxb.fromXML[Float](x, IPXACT2009scalaxb.ElemName(node) :: stack)) } map { "@{http://www.spiritconsortium.org/XMLSchema/SPIRIT/1685-2009}order" -> _ },
        (node \ "@{http://www.spiritconsortium.org/XMLSchema/SPIRIT/1685-2009}configGroups").headOption map { x => IPXACT2009scalaxb.DataRecord(x, node, IPXACT2009scalaxb.fromXML[Seq[String]](x, IPXACT2009scalaxb.ElemName(node) :: stack)) } map { "@{http://www.spiritconsortium.org/XMLSchema/SPIRIT/1685-2009}configGroups" -> _ },
        (node \ "@{http://www.spiritconsortium.org/XMLSchema/SPIRIT/1685-2009}bitStringLength").headOption map { x => IPXACT2009scalaxb.DataRecord(x, node, IPXACT2009scalaxb.fromXML[BigInt](x, IPXACT2009scalaxb.ElemName(node) :: stack)) } map { "@{http://www.spiritconsortium.org/XMLSchema/SPIRIT/1685-2009}bitStringLength" -> _ },
        (node \ "@{http://www.spiritconsortium.org/XMLSchema/SPIRIT/1685-2009}minimum").headOption map { x => IPXACT2009scalaxb.DataRecord(x, node, IPXACT2009scalaxb.fromXML[String](x, IPXACT2009scalaxb.ElemName(node) :: stack)) } map { "@{http://www.spiritconsortium.org/XMLSchema/SPIRIT/1685-2009}minimum" -> _ },
        (node \ "@{http://www.spiritconsortium.org/XMLSchema/SPIRIT/1685-2009}maximum").headOption map { x => IPXACT2009scalaxb.DataRecord(x, node, IPXACT2009scalaxb.fromXML[String](x, IPXACT2009scalaxb.ElemName(node) :: stack)) } map { "@{http://www.spiritconsortium.org/XMLSchema/SPIRIT/1685-2009}maximum" -> _ },
        (node \ "@{http://www.spiritconsortium.org/XMLSchema/SPIRIT/1685-2009}rangeType").headOption map { x => IPXACT2009scalaxb.DataRecord(x, node, IPXACT2009scalaxb.fromXML[RangeTypeType](x, IPXACT2009scalaxb.ElemName(node) :: stack)) } orElse Some(IPXACT2009scalaxb.DataRecord(None, None, IPXACT2009scalaxb.fromXML[RangeTypeType](scala.xml.Text("float"), IPXACT2009scalaxb.ElemName(node) :: stack))) map { "@{http://www.spiritconsortium.org/XMLSchema/SPIRIT/1685-2009}rangeType" -> _ },
        (node \ "@{http://www.spiritconsortium.org/XMLSchema/SPIRIT/1685-2009}prompt").headOption map { x => IPXACT2009scalaxb.DataRecord(x, node, IPXACT2009scalaxb.fromXML[String](x, IPXACT2009scalaxb.ElemName(node) :: stack)) } map { "@{http://www.spiritconsortium.org/XMLSchema/SPIRIT/1685-2009}prompt" -> _ }
        ).flatten[(String, IPXACT2009scalaxb.DataRecord[Any])] ::: (node match {
          case elem: scala.xml.Elem =>
            elem.attributes.toList flatMap {
              case scala.xml.PrefixedAttribute(pre, key, value, _) if pre == elem.scope.getPrefix("http://www.spiritconsortium.org/XMLSchema/SPIRIT/1685-2009") &&
                key == "format" => Nil
              case scala.xml.PrefixedAttribute(pre, key, value, _) if pre == elem.scope.getPrefix("http://www.spiritconsortium.org/XMLSchema/SPIRIT/1685-2009") &&
                key == "resolve" => Nil
              case scala.xml.PrefixedAttribute(pre, key, value, _) if pre == elem.scope.getPrefix("http://www.spiritconsortium.org/XMLSchema/SPIRIT/1685-2009") &&
                key == "id" => Nil
              case scala.xml.PrefixedAttribute(pre, key, value, _) if pre == elem.scope.getPrefix("http://www.spiritconsortium.org/XMLSchema/SPIRIT/1685-2009") &&
                key == "dependency" => Nil
              case scala.xml.PrefixedAttribute(pre, key, value, _) if pre == elem.scope.getPrefix("http://www.spiritconsortium.org/XMLSchema/SPIRIT/1685-2009") &&
                key == "choiceRef" => Nil
              case scala.xml.PrefixedAttribute(pre, key, value, _) if pre == elem.scope.getPrefix("http://www.spiritconsortium.org/XMLSchema/SPIRIT/1685-2009") &&
                key == "order" => Nil
              case scala.xml.PrefixedAttribute(pre, key, value, _) if pre == elem.scope.getPrefix("http://www.spiritconsortium.org/XMLSchema/SPIRIT/1685-2009") &&
                key == "configGroups" => Nil
              case scala.xml.PrefixedAttribute(pre, key, value, _) if pre == elem.scope.getPrefix("http://www.spiritconsortium.org/XMLSchema/SPIRIT/1685-2009") &&
                key == "bitStringLength" => Nil
              case scala.xml.PrefixedAttribute(pre, key, value, _) if pre == elem.scope.getPrefix("http://www.spiritconsortium.org/XMLSchema/SPIRIT/1685-2009") &&
                key == "minimum" => Nil
              case scala.xml.PrefixedAttribute(pre, key, value, _) if pre == elem.scope.getPrefix("http://www.spiritconsortium.org/XMLSchema/SPIRIT/1685-2009") &&
                key == "maximum" => Nil
              case scala.xml.PrefixedAttribute(pre, key, value, _) if pre == elem.scope.getPrefix("http://www.spiritconsortium.org/XMLSchema/SPIRIT/1685-2009") &&
                key == "rangeType" => Nil
              case scala.xml.PrefixedAttribute(pre, key, value, _) if pre == elem.scope.getPrefix("http://www.spiritconsortium.org/XMLSchema/SPIRIT/1685-2009") &&
                key == "prompt" => Nil
              case scala.xml.UnprefixedAttribute(key, value, _) =>
                List(("@" + key, IPXACT2009scalaxb.DataRecord(None, Some(key), value.text)))
              case scala.xml.PrefixedAttribute(pre, key, value, _) =>
                val ns = elem.scope.getURI(pre)
                List(("@{" + ns + "}" + key, IPXACT2009scalaxb.DataRecord(Option[String](ns), Some(key), value.text)))
              case _ => Nil
            }
          case _ => Nil
        }): _*)))
      case _ => Left("reads failed: seq must be scala.xml.Node")
    }
    
    override def writesAttribute(__obj: BitWidth, __scope: scala.xml.NamespaceBinding): scala.xml.MetaData = {
      var attr: scala.xml.MetaData  = scala.xml.Null
      __obj.attributes.toList map {
        case ("@{http://www.spiritconsortium.org/XMLSchema/SPIRIT/1685-2009}format", _) => if (__obj.spiritformat.toString != "long") attr = scala.xml.Attribute(__scope.getPrefix("http://www.spiritconsortium.org/XMLSchema/SPIRIT/1685-2009"), "format", __obj.spiritformat.toString, attr)
        case ("@{http://www.spiritconsortium.org/XMLSchema/SPIRIT/1685-2009}resolve", _) => __obj.spiritresolve foreach { x => attr = scala.xml.Attribute(__scope.getPrefix("http://www.spiritconsortium.org/XMLSchema/SPIRIT/1685-2009"), "resolve", x.toString, attr) }
        case ("@{http://www.spiritconsortium.org/XMLSchema/SPIRIT/1685-2009}id", _) => __obj.spiritid foreach { x => attr = scala.xml.Attribute(__scope.getPrefix("http://www.spiritconsortium.org/XMLSchema/SPIRIT/1685-2009"), "id", x.toString, attr) }
        case ("@{http://www.spiritconsortium.org/XMLSchema/SPIRIT/1685-2009}dependency", _) => __obj.spiritdependency foreach { x => attr = scala.xml.Attribute(__scope.getPrefix("http://www.spiritconsortium.org/XMLSchema/SPIRIT/1685-2009"), "dependency", x.toString, attr) }
        case ("@{http://www.spiritconsortium.org/XMLSchema/SPIRIT/1685-2009}choiceRef", _) => __obj.spiritchoiceRef foreach { x => attr = scala.xml.Attribute(__scope.getPrefix("http://www.spiritconsortium.org/XMLSchema/SPIRIT/1685-2009"), "choiceRef", x.toString, attr) }
        case ("@{http://www.spiritconsortium.org/XMLSchema/SPIRIT/1685-2009}order", _) => __obj.spiritorder foreach { x => attr = scala.xml.Attribute(__scope.getPrefix("http://www.spiritconsortium.org/XMLSchema/SPIRIT/1685-2009"), "order", x.toString, attr) }
        case ("@{http://www.spiritconsortium.org/XMLSchema/SPIRIT/1685-2009}configGroups", _) => __obj.spiritconfigGroups foreach { x => attr = scala.xml.Attribute(__scope.getPrefix("http://www.spiritconsortium.org/XMLSchema/SPIRIT/1685-2009"), "configGroups", x.toString, attr) }
        case ("@{http://www.spiritconsortium.org/XMLSchema/SPIRIT/1685-2009}bitStringLength", _) => __obj.spiritbitStringLength foreach { x => attr = scala.xml.Attribute(__scope.getPrefix("http://www.spiritconsortium.org/XMLSchema/SPIRIT/1685-2009"), "bitStringLength", x.toString, attr) }
        case ("@{http://www.spiritconsortium.org/XMLSchema/SPIRIT/1685-2009}minimum", _) => __obj.spiritminimum foreach { x => attr = scala.xml.Attribute(__scope.getPrefix("http://www.spiritconsortium.org/XMLSchema/SPIRIT/1685-2009"), "minimum", x.toString, attr) }
        case ("@{http://www.spiritconsortium.org/XMLSchema/SPIRIT/1685-2009}maximum", _) => __obj.spiritmaximum foreach { x => attr = scala.xml.Attribute(__scope.getPrefix("http://www.spiritconsortium.org/XMLSchema/SPIRIT/1685-2009"), "maximum", x.toString, attr) }
        case ("@{http://www.spiritconsortium.org/XMLSchema/SPIRIT/1685-2009}rangeType", _) => if (__obj.spiritrangeType.toString != "float") attr = scala.xml.Attribute(__scope.getPrefix("http://www.spiritconsortium.org/XMLSchema/SPIRIT/1685-2009"), "rangeType", __obj.spiritrangeType.toString, attr)
        case ("@{http://www.spiritconsortium.org/XMLSchema/SPIRIT/1685-2009}prompt", _) => __obj.spiritprompt foreach { x => attr = scala.xml.Attribute(__scope.getPrefix("http://www.spiritconsortium.org/XMLSchema/SPIRIT/1685-2009"), "prompt", x.toString, attr) }
        case (key, x) => attr = scala.xml.Attribute((x.namespace map { __scope.getPrefix(_) }).orNull, x.key.orNull, x.value.toString, attr)
      }
      attr
    }

    def writesChildNodes(__obj: BitWidth, __scope: scala.xml.NamespaceBinding): Seq[scala.xml.Node] =
      Seq(scala.xml.Text(__obj.value.toString))

  }

  trait Default_RangeType4Format extends IPXACT2009scalaxb.XMLFormat[RangeType4] with IPXACT2009scalaxb.CanWriteChildNodes[RangeType4] {
    val targetNamespace: Option[String] = Some("http://www.spiritconsortium.org/XMLSchema/SPIRIT/1685-2009")
    def reads(seq: scala.xml.NodeSeq, stack: List[IPXACT2009scalaxb.ElemName]): Either[String, RangeType4] = seq match {
      case node: scala.xml.Node => Right(RangeType4(IPXACT2009scalaxb.fromXML[String](node, IPXACT2009scalaxb.ElemName(node) :: stack),
        scala.collection.immutable.ListMap(List(
        (node \ "@{http://www.spiritconsortium.org/XMLSchema/SPIRIT/1685-2009}format").headOption map { x => IPXACT2009scalaxb.DataRecord(x, node, IPXACT2009scalaxb.fromXML[FormatType](x, IPXACT2009scalaxb.ElemName(node) :: stack)) } orElse Some(IPXACT2009scalaxb.DataRecord(None, None, IPXACT2009scalaxb.fromXML[FormatType](scala.xml.Text("long"), IPXACT2009scalaxb.ElemName(node) :: stack))) map { "@{http://www.spiritconsortium.org/XMLSchema/SPIRIT/1685-2009}format" -> _ },
        (node \ "@{http://www.spiritconsortium.org/XMLSchema/SPIRIT/1685-2009}resolve").headOption map { x => IPXACT2009scalaxb.DataRecord(x, node, IPXACT2009scalaxb.fromXML[ResolveType](x, IPXACT2009scalaxb.ElemName(node) :: stack)) } map { "@{http://www.spiritconsortium.org/XMLSchema/SPIRIT/1685-2009}resolve" -> _ },
        (node \ "@{http://www.spiritconsortium.org/XMLSchema/SPIRIT/1685-2009}id").headOption map { x => IPXACT2009scalaxb.DataRecord(x, node, IPXACT2009scalaxb.fromXML[String](x, IPXACT2009scalaxb.ElemName(node) :: stack)) } map { "@{http://www.spiritconsortium.org/XMLSchema/SPIRIT/1685-2009}id" -> _ },
        (node \ "@{http://www.spiritconsortium.org/XMLSchema/SPIRIT/1685-2009}dependency").headOption map { x => IPXACT2009scalaxb.DataRecord(x, node, IPXACT2009scalaxb.fromXML[String](x, IPXACT2009scalaxb.ElemName(node) :: stack)) } map { "@{http://www.spiritconsortium.org/XMLSchema/SPIRIT/1685-2009}dependency" -> _ },
        (node \ "@{http://www.spiritconsortium.org/XMLSchema/SPIRIT/1685-2009}choiceRef").headOption map { x => IPXACT2009scalaxb.DataRecord(x, node, IPXACT2009scalaxb.fromXML[String](x, IPXACT2009scalaxb.ElemName(node) :: stack)) } map { "@{http://www.spiritconsortium.org/XMLSchema/SPIRIT/1685-2009}choiceRef" -> _ },
        (node \ "@{http://www.spiritconsortium.org/XMLSchema/SPIRIT/1685-2009}order").headOption map { x => IPXACT2009scalaxb.DataRecord(x, node, IPXACT2009scalaxb.fromXML[Float](x, IPXACT2009scalaxb.ElemName(node) :: stack)) } map { "@{http://www.spiritconsortium.org/XMLSchema/SPIRIT/1685-2009}order" -> _ },
        (node \ "@{http://www.spiritconsortium.org/XMLSchema/SPIRIT/1685-2009}configGroups").headOption map { x => IPXACT2009scalaxb.DataRecord(x, node, IPXACT2009scalaxb.fromXML[Seq[String]](x, IPXACT2009scalaxb.ElemName(node) :: stack)) } map { "@{http://www.spiritconsortium.org/XMLSchema/SPIRIT/1685-2009}configGroups" -> _ },
        (node \ "@{http://www.spiritconsortium.org/XMLSchema/SPIRIT/1685-2009}bitStringLength").headOption map { x => IPXACT2009scalaxb.DataRecord(x, node, IPXACT2009scalaxb.fromXML[BigInt](x, IPXACT2009scalaxb.ElemName(node) :: stack)) } map { "@{http://www.spiritconsortium.org/XMLSchema/SPIRIT/1685-2009}bitStringLength" -> _ },
        (node \ "@{http://www.spiritconsortium.org/XMLSchema/SPIRIT/1685-2009}minimum").headOption map { x => IPXACT2009scalaxb.DataRecord(x, node, IPXACT2009scalaxb.fromXML[String](x, IPXACT2009scalaxb.ElemName(node) :: stack)) } map { "@{http://www.spiritconsortium.org/XMLSchema/SPIRIT/1685-2009}minimum" -> _ },
        (node \ "@{http://www.spiritconsortium.org/XMLSchema/SPIRIT/1685-2009}maximum").headOption map { x => IPXACT2009scalaxb.DataRecord(x, node, IPXACT2009scalaxb.fromXML[String](x, IPXACT2009scalaxb.ElemName(node) :: stack)) } map { "@{http://www.spiritconsortium.org/XMLSchema/SPIRIT/1685-2009}maximum" -> _ },
        (node \ "@{http://www.spiritconsortium.org/XMLSchema/SPIRIT/1685-2009}rangeType").headOption map { x => IPXACT2009scalaxb.DataRecord(x, node, IPXACT2009scalaxb.fromXML[RangeTypeType](x, IPXACT2009scalaxb.ElemName(node) :: stack)) } orElse Some(IPXACT2009scalaxb.DataRecord(None, None, IPXACT2009scalaxb.fromXML[RangeTypeType](scala.xml.Text("float"), IPXACT2009scalaxb.ElemName(node) :: stack))) map { "@{http://www.spiritconsortium.org/XMLSchema/SPIRIT/1685-2009}rangeType" -> _ },
        (node \ "@{http://www.spiritconsortium.org/XMLSchema/SPIRIT/1685-2009}prompt").headOption map { x => IPXACT2009scalaxb.DataRecord(x, node, IPXACT2009scalaxb.fromXML[String](x, IPXACT2009scalaxb.ElemName(node) :: stack)) } map { "@{http://www.spiritconsortium.org/XMLSchema/SPIRIT/1685-2009}prompt" -> _ }
        ).flatten[(String, IPXACT2009scalaxb.DataRecord[Any])] ::: (node match {
          case elem: scala.xml.Elem =>
            elem.attributes.toList flatMap {
              case scala.xml.PrefixedAttribute(pre, key, value, _) if pre == elem.scope.getPrefix("http://www.spiritconsortium.org/XMLSchema/SPIRIT/1685-2009") &&
                key == "format" => Nil
              case scala.xml.PrefixedAttribute(pre, key, value, _) if pre == elem.scope.getPrefix("http://www.spiritconsortium.org/XMLSchema/SPIRIT/1685-2009") &&
                key == "resolve" => Nil
              case scala.xml.PrefixedAttribute(pre, key, value, _) if pre == elem.scope.getPrefix("http://www.spiritconsortium.org/XMLSchema/SPIRIT/1685-2009") &&
                key == "id" => Nil
              case scala.xml.PrefixedAttribute(pre, key, value, _) if pre == elem.scope.getPrefix("http://www.spiritconsortium.org/XMLSchema/SPIRIT/1685-2009") &&
                key == "dependency" => Nil
              case scala.xml.PrefixedAttribute(pre, key, value, _) if pre == elem.scope.getPrefix("http://www.spiritconsortium.org/XMLSchema/SPIRIT/1685-2009") &&
                key == "choiceRef" => Nil
              case scala.xml.PrefixedAttribute(pre, key, value, _) if pre == elem.scope.getPrefix("http://www.spiritconsortium.org/XMLSchema/SPIRIT/1685-2009") &&
                key == "order" => Nil
              case scala.xml.PrefixedAttribute(pre, key, value, _) if pre == elem.scope.getPrefix("http://www.spiritconsortium.org/XMLSchema/SPIRIT/1685-2009") &&
                key == "configGroups" => Nil
              case scala.xml.PrefixedAttribute(pre, key, value, _) if pre == elem.scope.getPrefix("http://www.spiritconsortium.org/XMLSchema/SPIRIT/1685-2009") &&
                key == "bitStringLength" => Nil
              case scala.xml.PrefixedAttribute(pre, key, value, _) if pre == elem.scope.getPrefix("http://www.spiritconsortium.org/XMLSchema/SPIRIT/1685-2009") &&
                key == "minimum" => Nil
              case scala.xml.PrefixedAttribute(pre, key, value, _) if pre == elem.scope.getPrefix("http://www.spiritconsortium.org/XMLSchema/SPIRIT/1685-2009") &&
                key == "maximum" => Nil
              case scala.xml.PrefixedAttribute(pre, key, value, _) if pre == elem.scope.getPrefix("http://www.spiritconsortium.org/XMLSchema/SPIRIT/1685-2009") &&
                key == "rangeType" => Nil
              case scala.xml.PrefixedAttribute(pre, key, value, _) if pre == elem.scope.getPrefix("http://www.spiritconsortium.org/XMLSchema/SPIRIT/1685-2009") &&
                key == "prompt" => Nil
              case scala.xml.UnprefixedAttribute(key, value, _) =>
                List(("@" + key, IPXACT2009scalaxb.DataRecord(None, Some(key), value.text)))
              case scala.xml.PrefixedAttribute(pre, key, value, _) =>
                val ns = elem.scope.getURI(pre)
                List(("@{" + ns + "}" + key, IPXACT2009scalaxb.DataRecord(Option[String](ns), Some(key), value.text)))
              case _ => Nil
            }
          case _ => Nil
        }): _*)))
      case _ => Left("reads failed: seq must be scala.xml.Node")
    }
    
    override def writesAttribute(__obj: RangeType4, __scope: scala.xml.NamespaceBinding): scala.xml.MetaData = {
      var attr: scala.xml.MetaData  = scala.xml.Null
      __obj.attributes.toList map {
        case ("@{http://www.spiritconsortium.org/XMLSchema/SPIRIT/1685-2009}format", _) => if (__obj.spiritformat.toString != "long") attr = scala.xml.Attribute(__scope.getPrefix("http://www.spiritconsortium.org/XMLSchema/SPIRIT/1685-2009"), "format", __obj.spiritformat.toString, attr)
        case ("@{http://www.spiritconsortium.org/XMLSchema/SPIRIT/1685-2009}resolve", _) => __obj.spiritresolve foreach { x => attr = scala.xml.Attribute(__scope.getPrefix("http://www.spiritconsortium.org/XMLSchema/SPIRIT/1685-2009"), "resolve", x.toString, attr) }
        case ("@{http://www.spiritconsortium.org/XMLSchema/SPIRIT/1685-2009}id", _) => __obj.spiritid foreach { x => attr = scala.xml.Attribute(__scope.getPrefix("http://www.spiritconsortium.org/XMLSchema/SPIRIT/1685-2009"), "id", x.toString, attr) }
        case ("@{http://www.spiritconsortium.org/XMLSchema/SPIRIT/1685-2009}dependency", _) => __obj.spiritdependency foreach { x => attr = scala.xml.Attribute(__scope.getPrefix("http://www.spiritconsortium.org/XMLSchema/SPIRIT/1685-2009"), "dependency", x.toString, attr) }
        case ("@{http://www.spiritconsortium.org/XMLSchema/SPIRIT/1685-2009}choiceRef", _) => __obj.spiritchoiceRef foreach { x => attr = scala.xml.Attribute(__scope.getPrefix("http://www.spiritconsortium.org/XMLSchema/SPIRIT/1685-2009"), "choiceRef", x.toString, attr) }
        case ("@{http://www.spiritconsortium.org/XMLSchema/SPIRIT/1685-2009}order", _) => __obj.spiritorder foreach { x => attr = scala.xml.Attribute(__scope.getPrefix("http://www.spiritconsortium.org/XMLSchema/SPIRIT/1685-2009"), "order", x.toString, attr) }
        case ("@{http://www.spiritconsortium.org/XMLSchema/SPIRIT/1685-2009}configGroups", _) => __obj.spiritconfigGroups foreach { x => attr = scala.xml.Attribute(__scope.getPrefix("http://www.spiritconsortium.org/XMLSchema/SPIRIT/1685-2009"), "configGroups", x.toString, attr) }
        case ("@{http://www.spiritconsortium.org/XMLSchema/SPIRIT/1685-2009}bitStringLength", _) => __obj.spiritbitStringLength foreach { x => attr = scala.xml.Attribute(__scope.getPrefix("http://www.spiritconsortium.org/XMLSchema/SPIRIT/1685-2009"), "bitStringLength", x.toString, attr) }
        case ("@{http://www.spiritconsortium.org/XMLSchema/SPIRIT/1685-2009}minimum", _) => __obj.spiritminimum foreach { x => attr = scala.xml.Attribute(__scope.getPrefix("http://www.spiritconsortium.org/XMLSchema/SPIRIT/1685-2009"), "minimum", x.toString, attr) }
        case ("@{http://www.spiritconsortium.org/XMLSchema/SPIRIT/1685-2009}maximum", _) => __obj.spiritmaximum foreach { x => attr = scala.xml.Attribute(__scope.getPrefix("http://www.spiritconsortium.org/XMLSchema/SPIRIT/1685-2009"), "maximum", x.toString, attr) }
        case ("@{http://www.spiritconsortium.org/XMLSchema/SPIRIT/1685-2009}rangeType", _) => if (__obj.spiritrangeType.toString != "float") attr = scala.xml.Attribute(__scope.getPrefix("http://www.spiritconsortium.org/XMLSchema/SPIRIT/1685-2009"), "rangeType", __obj.spiritrangeType.toString, attr)
        case ("@{http://www.spiritconsortium.org/XMLSchema/SPIRIT/1685-2009}prompt", _) => __obj.spiritprompt foreach { x => attr = scala.xml.Attribute(__scope.getPrefix("http://www.spiritconsortium.org/XMLSchema/SPIRIT/1685-2009"), "prompt", x.toString, attr) }
        case (key, x) => attr = scala.xml.Attribute((x.namespace map { __scope.getPrefix(_) }).orNull, x.key.orNull, x.value.toString, attr)
      }
      attr
    }

    def writesChildNodes(__obj: RangeType4, __scope: scala.xml.NamespaceBinding): Seq[scala.xml.Node] =
      Seq(scala.xml.Text(__obj.value.toString))

  }

  trait Default_SizeFormat extends IPXACT2009scalaxb.XMLFormat[Size] with IPXACT2009scalaxb.CanWriteChildNodes[Size] {
    val targetNamespace: Option[String] = Some("http://www.spiritconsortium.org/XMLSchema/SPIRIT/1685-2009")
    def reads(seq: scala.xml.NodeSeq, stack: List[IPXACT2009scalaxb.ElemName]): Either[String, Size] = seq match {
      case node: scala.xml.Node => Right(Size(IPXACT2009scalaxb.fromXML[BigInt](node, IPXACT2009scalaxb.ElemName(node) :: stack),
        scala.collection.immutable.ListMap(List(
        (node \ "@{http://www.spiritconsortium.org/XMLSchema/SPIRIT/1685-2009}format").headOption map { x => IPXACT2009scalaxb.DataRecord(x, node, IPXACT2009scalaxb.fromXML[FormatType](x, IPXACT2009scalaxb.ElemName(node) :: stack)) } orElse Some(IPXACT2009scalaxb.DataRecord(None, None, IPXACT2009scalaxb.fromXML[FormatType](scala.xml.Text("long"), IPXACT2009scalaxb.ElemName(node) :: stack))) map { "@{http://www.spiritconsortium.org/XMLSchema/SPIRIT/1685-2009}format" -> _ },
        (node \ "@{http://www.spiritconsortium.org/XMLSchema/SPIRIT/1685-2009}resolve").headOption map { x => IPXACT2009scalaxb.DataRecord(x, node, IPXACT2009scalaxb.fromXML[ResolveType](x, IPXACT2009scalaxb.ElemName(node) :: stack)) } map { "@{http://www.spiritconsortium.org/XMLSchema/SPIRIT/1685-2009}resolve" -> _ },
        (node \ "@{http://www.spiritconsortium.org/XMLSchema/SPIRIT/1685-2009}id").headOption map { x => IPXACT2009scalaxb.DataRecord(x, node, IPXACT2009scalaxb.fromXML[String](x, IPXACT2009scalaxb.ElemName(node) :: stack)) } map { "@{http://www.spiritconsortium.org/XMLSchema/SPIRIT/1685-2009}id" -> _ },
        (node \ "@{http://www.spiritconsortium.org/XMLSchema/SPIRIT/1685-2009}dependency").headOption map { x => IPXACT2009scalaxb.DataRecord(x, node, IPXACT2009scalaxb.fromXML[String](x, IPXACT2009scalaxb.ElemName(node) :: stack)) } map { "@{http://www.spiritconsortium.org/XMLSchema/SPIRIT/1685-2009}dependency" -> _ },
        (node \ "@{http://www.spiritconsortium.org/XMLSchema/SPIRIT/1685-2009}choiceRef").headOption map { x => IPXACT2009scalaxb.DataRecord(x, node, IPXACT2009scalaxb.fromXML[String](x, IPXACT2009scalaxb.ElemName(node) :: stack)) } map { "@{http://www.spiritconsortium.org/XMLSchema/SPIRIT/1685-2009}choiceRef" -> _ },
        (node \ "@{http://www.spiritconsortium.org/XMLSchema/SPIRIT/1685-2009}order").headOption map { x => IPXACT2009scalaxb.DataRecord(x, node, IPXACT2009scalaxb.fromXML[Float](x, IPXACT2009scalaxb.ElemName(node) :: stack)) } map { "@{http://www.spiritconsortium.org/XMLSchema/SPIRIT/1685-2009}order" -> _ },
        (node \ "@{http://www.spiritconsortium.org/XMLSchema/SPIRIT/1685-2009}configGroups").headOption map { x => IPXACT2009scalaxb.DataRecord(x, node, IPXACT2009scalaxb.fromXML[Seq[String]](x, IPXACT2009scalaxb.ElemName(node) :: stack)) } map { "@{http://www.spiritconsortium.org/XMLSchema/SPIRIT/1685-2009}configGroups" -> _ },
        (node \ "@{http://www.spiritconsortium.org/XMLSchema/SPIRIT/1685-2009}bitStringLength").headOption map { x => IPXACT2009scalaxb.DataRecord(x, node, IPXACT2009scalaxb.fromXML[BigInt](x, IPXACT2009scalaxb.ElemName(node) :: stack)) } map { "@{http://www.spiritconsortium.org/XMLSchema/SPIRIT/1685-2009}bitStringLength" -> _ },
        (node \ "@{http://www.spiritconsortium.org/XMLSchema/SPIRIT/1685-2009}minimum").headOption map { x => IPXACT2009scalaxb.DataRecord(x, node, IPXACT2009scalaxb.fromXML[String](x, IPXACT2009scalaxb.ElemName(node) :: stack)) } map { "@{http://www.spiritconsortium.org/XMLSchema/SPIRIT/1685-2009}minimum" -> _ },
        (node \ "@{http://www.spiritconsortium.org/XMLSchema/SPIRIT/1685-2009}maximum").headOption map { x => IPXACT2009scalaxb.DataRecord(x, node, IPXACT2009scalaxb.fromXML[String](x, IPXACT2009scalaxb.ElemName(node) :: stack)) } map { "@{http://www.spiritconsortium.org/XMLSchema/SPIRIT/1685-2009}maximum" -> _ },
        (node \ "@{http://www.spiritconsortium.org/XMLSchema/SPIRIT/1685-2009}rangeType").headOption map { x => IPXACT2009scalaxb.DataRecord(x, node, IPXACT2009scalaxb.fromXML[RangeTypeType](x, IPXACT2009scalaxb.ElemName(node) :: stack)) } orElse Some(IPXACT2009scalaxb.DataRecord(None, None, IPXACT2009scalaxb.fromXML[RangeTypeType](scala.xml.Text("float"), IPXACT2009scalaxb.ElemName(node) :: stack))) map { "@{http://www.spiritconsortium.org/XMLSchema/SPIRIT/1685-2009}rangeType" -> _ },
        (node \ "@{http://www.spiritconsortium.org/XMLSchema/SPIRIT/1685-2009}prompt").headOption map { x => IPXACT2009scalaxb.DataRecord(x, node, IPXACT2009scalaxb.fromXML[String](x, IPXACT2009scalaxb.ElemName(node) :: stack)) } map { "@{http://www.spiritconsortium.org/XMLSchema/SPIRIT/1685-2009}prompt" -> _ }
        ).flatten[(String, IPXACT2009scalaxb.DataRecord[Any])] ::: (node match {
          case elem: scala.xml.Elem =>
            elem.attributes.toList flatMap {
              case scala.xml.PrefixedAttribute(pre, key, value, _) if pre == elem.scope.getPrefix("http://www.spiritconsortium.org/XMLSchema/SPIRIT/1685-2009") &&
                key == "format" => Nil
              case scala.xml.PrefixedAttribute(pre, key, value, _) if pre == elem.scope.getPrefix("http://www.spiritconsortium.org/XMLSchema/SPIRIT/1685-2009") &&
                key == "resolve" => Nil
              case scala.xml.PrefixedAttribute(pre, key, value, _) if pre == elem.scope.getPrefix("http://www.spiritconsortium.org/XMLSchema/SPIRIT/1685-2009") &&
                key == "id" => Nil
              case scala.xml.PrefixedAttribute(pre, key, value, _) if pre == elem.scope.getPrefix("http://www.spiritconsortium.org/XMLSchema/SPIRIT/1685-2009") &&
                key == "dependency" => Nil
              case scala.xml.PrefixedAttribute(pre, key, value, _) if pre == elem.scope.getPrefix("http://www.spiritconsortium.org/XMLSchema/SPIRIT/1685-2009") &&
                key == "choiceRef" => Nil
              case scala.xml.PrefixedAttribute(pre, key, value, _) if pre == elem.scope.getPrefix("http://www.spiritconsortium.org/XMLSchema/SPIRIT/1685-2009") &&
                key == "order" => Nil
              case scala.xml.PrefixedAttribute(pre, key, value, _) if pre == elem.scope.getPrefix("http://www.spiritconsortium.org/XMLSchema/SPIRIT/1685-2009") &&
                key == "configGroups" => Nil
              case scala.xml.PrefixedAttribute(pre, key, value, _) if pre == elem.scope.getPrefix("http://www.spiritconsortium.org/XMLSchema/SPIRIT/1685-2009") &&
                key == "bitStringLength" => Nil
              case scala.xml.PrefixedAttribute(pre, key, value, _) if pre == elem.scope.getPrefix("http://www.spiritconsortium.org/XMLSchema/SPIRIT/1685-2009") &&
                key == "minimum" => Nil
              case scala.xml.PrefixedAttribute(pre, key, value, _) if pre == elem.scope.getPrefix("http://www.spiritconsortium.org/XMLSchema/SPIRIT/1685-2009") &&
                key == "maximum" => Nil
              case scala.xml.PrefixedAttribute(pre, key, value, _) if pre == elem.scope.getPrefix("http://www.spiritconsortium.org/XMLSchema/SPIRIT/1685-2009") &&
                key == "rangeType" => Nil
              case scala.xml.PrefixedAttribute(pre, key, value, _) if pre == elem.scope.getPrefix("http://www.spiritconsortium.org/XMLSchema/SPIRIT/1685-2009") &&
                key == "prompt" => Nil
              case scala.xml.UnprefixedAttribute(key, value, _) =>
                List(("@" + key, IPXACT2009scalaxb.DataRecord(None, Some(key), value.text)))
              case scala.xml.PrefixedAttribute(pre, key, value, _) =>
                val ns = elem.scope.getURI(pre)
                List(("@{" + ns + "}" + key, IPXACT2009scalaxb.DataRecord(Option[String](ns), Some(key), value.text)))
              case _ => Nil
            }
          case _ => Nil
        }): _*)))
      case _ => Left("reads failed: seq must be scala.xml.Node")
    }
    
    override def writesAttribute(__obj: Size, __scope: scala.xml.NamespaceBinding): scala.xml.MetaData = {
      var attr: scala.xml.MetaData  = scala.xml.Null
      __obj.attributes.toList map {
        case ("@{http://www.spiritconsortium.org/XMLSchema/SPIRIT/1685-2009}format", _) => if (__obj.spiritformat.toString != "long") attr = scala.xml.Attribute(__scope.getPrefix("http://www.spiritconsortium.org/XMLSchema/SPIRIT/1685-2009"), "format", __obj.spiritformat.toString, attr)
        case ("@{http://www.spiritconsortium.org/XMLSchema/SPIRIT/1685-2009}resolve", _) => __obj.spiritresolve foreach { x => attr = scala.xml.Attribute(__scope.getPrefix("http://www.spiritconsortium.org/XMLSchema/SPIRIT/1685-2009"), "resolve", x.toString, attr) }
        case ("@{http://www.spiritconsortium.org/XMLSchema/SPIRIT/1685-2009}id", _) => __obj.spiritid foreach { x => attr = scala.xml.Attribute(__scope.getPrefix("http://www.spiritconsortium.org/XMLSchema/SPIRIT/1685-2009"), "id", x.toString, attr) }
        case ("@{http://www.spiritconsortium.org/XMLSchema/SPIRIT/1685-2009}dependency", _) => __obj.spiritdependency foreach { x => attr = scala.xml.Attribute(__scope.getPrefix("http://www.spiritconsortium.org/XMLSchema/SPIRIT/1685-2009"), "dependency", x.toString, attr) }
        case ("@{http://www.spiritconsortium.org/XMLSchema/SPIRIT/1685-2009}choiceRef", _) => __obj.spiritchoiceRef foreach { x => attr = scala.xml.Attribute(__scope.getPrefix("http://www.spiritconsortium.org/XMLSchema/SPIRIT/1685-2009"), "choiceRef", x.toString, attr) }
        case ("@{http://www.spiritconsortium.org/XMLSchema/SPIRIT/1685-2009}order", _) => __obj.spiritorder foreach { x => attr = scala.xml.Attribute(__scope.getPrefix("http://www.spiritconsortium.org/XMLSchema/SPIRIT/1685-2009"), "order", x.toString, attr) }
        case ("@{http://www.spiritconsortium.org/XMLSchema/SPIRIT/1685-2009}configGroups", _) => __obj.spiritconfigGroups foreach { x => attr = scala.xml.Attribute(__scope.getPrefix("http://www.spiritconsortium.org/XMLSchema/SPIRIT/1685-2009"), "configGroups", x.toString, attr) }
        case ("@{http://www.spiritconsortium.org/XMLSchema/SPIRIT/1685-2009}bitStringLength", _) => __obj.spiritbitStringLength foreach { x => attr = scala.xml.Attribute(__scope.getPrefix("http://www.spiritconsortium.org/XMLSchema/SPIRIT/1685-2009"), "bitStringLength", x.toString, attr) }
        case ("@{http://www.spiritconsortium.org/XMLSchema/SPIRIT/1685-2009}minimum", _) => __obj.spiritminimum foreach { x => attr = scala.xml.Attribute(__scope.getPrefix("http://www.spiritconsortium.org/XMLSchema/SPIRIT/1685-2009"), "minimum", x.toString, attr) }
        case ("@{http://www.spiritconsortium.org/XMLSchema/SPIRIT/1685-2009}maximum", _) => __obj.spiritmaximum foreach { x => attr = scala.xml.Attribute(__scope.getPrefix("http://www.spiritconsortium.org/XMLSchema/SPIRIT/1685-2009"), "maximum", x.toString, attr) }
        case ("@{http://www.spiritconsortium.org/XMLSchema/SPIRIT/1685-2009}rangeType", _) => if (__obj.spiritrangeType.toString != "float") attr = scala.xml.Attribute(__scope.getPrefix("http://www.spiritconsortium.org/XMLSchema/SPIRIT/1685-2009"), "rangeType", __obj.spiritrangeType.toString, attr)
        case ("@{http://www.spiritconsortium.org/XMLSchema/SPIRIT/1685-2009}prompt", _) => __obj.spiritprompt foreach { x => attr = scala.xml.Attribute(__scope.getPrefix("http://www.spiritconsortium.org/XMLSchema/SPIRIT/1685-2009"), "prompt", x.toString, attr) }
        case (key, x) => attr = scala.xml.Attribute((x.namespace map { __scope.getPrefix(_) }).orNull, x.key.orNull, x.value.toString, attr)
      }
      attr
    }

    def writesChildNodes(__obj: Size, __scope: scala.xml.NamespaceBinding): Seq[scala.xml.Node] =
      Seq(scala.xml.Text(__obj.value.toString))

  }

  trait Default_Value2Format extends IPXACT2009scalaxb.XMLFormat[Value2] with IPXACT2009scalaxb.CanWriteChildNodes[Value2] {
    val targetNamespace: Option[String] = Some("http://www.spiritconsortium.org/XMLSchema/SPIRIT/1685-2009")
    def reads(seq: scala.xml.NodeSeq, stack: List[IPXACT2009scalaxb.ElemName]): Either[String, Value2] = seq match {
      case node: scala.xml.Node => Right(Value2(IPXACT2009scalaxb.fromXML[String](node, IPXACT2009scalaxb.ElemName(node) :: stack),
        scala.collection.immutable.ListMap(List(
        (node \ "@{http://www.spiritconsortium.org/XMLSchema/SPIRIT/1685-2009}format").headOption map { x => IPXACT2009scalaxb.DataRecord(x, node, IPXACT2009scalaxb.fromXML[FormatType](x, IPXACT2009scalaxb.ElemName(node) :: stack)) } orElse Some(IPXACT2009scalaxb.DataRecord(None, None, IPXACT2009scalaxb.fromXML[FormatType](scala.xml.Text("long"), IPXACT2009scalaxb.ElemName(node) :: stack))) map { "@{http://www.spiritconsortium.org/XMLSchema/SPIRIT/1685-2009}format" -> _ },
        (node \ "@{http://www.spiritconsortium.org/XMLSchema/SPIRIT/1685-2009}resolve").headOption map { x => IPXACT2009scalaxb.DataRecord(x, node, IPXACT2009scalaxb.fromXML[ResolveType](x, IPXACT2009scalaxb.ElemName(node) :: stack)) } map { "@{http://www.spiritconsortium.org/XMLSchema/SPIRIT/1685-2009}resolve" -> _ },
        (node \ "@{http://www.spiritconsortium.org/XMLSchema/SPIRIT/1685-2009}id").headOption map { x => IPXACT2009scalaxb.DataRecord(x, node, IPXACT2009scalaxb.fromXML[String](x, IPXACT2009scalaxb.ElemName(node) :: stack)) } map { "@{http://www.spiritconsortium.org/XMLSchema/SPIRIT/1685-2009}id" -> _ },
        (node \ "@{http://www.spiritconsortium.org/XMLSchema/SPIRIT/1685-2009}dependency").headOption map { x => IPXACT2009scalaxb.DataRecord(x, node, IPXACT2009scalaxb.fromXML[String](x, IPXACT2009scalaxb.ElemName(node) :: stack)) } map { "@{http://www.spiritconsortium.org/XMLSchema/SPIRIT/1685-2009}dependency" -> _ },
        (node \ "@{http://www.spiritconsortium.org/XMLSchema/SPIRIT/1685-2009}choiceRef").headOption map { x => IPXACT2009scalaxb.DataRecord(x, node, IPXACT2009scalaxb.fromXML[String](x, IPXACT2009scalaxb.ElemName(node) :: stack)) } map { "@{http://www.spiritconsortium.org/XMLSchema/SPIRIT/1685-2009}choiceRef" -> _ },
        (node \ "@{http://www.spiritconsortium.org/XMLSchema/SPIRIT/1685-2009}order").headOption map { x => IPXACT2009scalaxb.DataRecord(x, node, IPXACT2009scalaxb.fromXML[Float](x, IPXACT2009scalaxb.ElemName(node) :: stack)) } map { "@{http://www.spiritconsortium.org/XMLSchema/SPIRIT/1685-2009}order" -> _ },
        (node \ "@{http://www.spiritconsortium.org/XMLSchema/SPIRIT/1685-2009}configGroups").headOption map { x => IPXACT2009scalaxb.DataRecord(x, node, IPXACT2009scalaxb.fromXML[Seq[String]](x, IPXACT2009scalaxb.ElemName(node) :: stack)) } map { "@{http://www.spiritconsortium.org/XMLSchema/SPIRIT/1685-2009}configGroups" -> _ },
        (node \ "@{http://www.spiritconsortium.org/XMLSchema/SPIRIT/1685-2009}bitStringLength").headOption map { x => IPXACT2009scalaxb.DataRecord(x, node, IPXACT2009scalaxb.fromXML[BigInt](x, IPXACT2009scalaxb.ElemName(node) :: stack)) } map { "@{http://www.spiritconsortium.org/XMLSchema/SPIRIT/1685-2009}bitStringLength" -> _ },
        (node \ "@{http://www.spiritconsortium.org/XMLSchema/SPIRIT/1685-2009}minimum").headOption map { x => IPXACT2009scalaxb.DataRecord(x, node, IPXACT2009scalaxb.fromXML[String](x, IPXACT2009scalaxb.ElemName(node) :: stack)) } map { "@{http://www.spiritconsortium.org/XMLSchema/SPIRIT/1685-2009}minimum" -> _ },
        (node \ "@{http://www.spiritconsortium.org/XMLSchema/SPIRIT/1685-2009}maximum").headOption map { x => IPXACT2009scalaxb.DataRecord(x, node, IPXACT2009scalaxb.fromXML[String](x, IPXACT2009scalaxb.ElemName(node) :: stack)) } map { "@{http://www.spiritconsortium.org/XMLSchema/SPIRIT/1685-2009}maximum" -> _ },
        (node \ "@{http://www.spiritconsortium.org/XMLSchema/SPIRIT/1685-2009}rangeType").headOption map { x => IPXACT2009scalaxb.DataRecord(x, node, IPXACT2009scalaxb.fromXML[RangeTypeType](x, IPXACT2009scalaxb.ElemName(node) :: stack)) } orElse Some(IPXACT2009scalaxb.DataRecord(None, None, IPXACT2009scalaxb.fromXML[RangeTypeType](scala.xml.Text("float"), IPXACT2009scalaxb.ElemName(node) :: stack))) map { "@{http://www.spiritconsortium.org/XMLSchema/SPIRIT/1685-2009}rangeType" -> _ },
        (node \ "@{http://www.spiritconsortium.org/XMLSchema/SPIRIT/1685-2009}prompt").headOption map { x => IPXACT2009scalaxb.DataRecord(x, node, IPXACT2009scalaxb.fromXML[String](x, IPXACT2009scalaxb.ElemName(node) :: stack)) } map { "@{http://www.spiritconsortium.org/XMLSchema/SPIRIT/1685-2009}prompt" -> _ }
        ).flatten[(String, IPXACT2009scalaxb.DataRecord[Any])] ::: (node match {
          case elem: scala.xml.Elem =>
            elem.attributes.toList flatMap {
              case scala.xml.PrefixedAttribute(pre, key, value, _) if pre == elem.scope.getPrefix("http://www.spiritconsortium.org/XMLSchema/SPIRIT/1685-2009") &&
                key == "format" => Nil
              case scala.xml.PrefixedAttribute(pre, key, value, _) if pre == elem.scope.getPrefix("http://www.spiritconsortium.org/XMLSchema/SPIRIT/1685-2009") &&
                key == "resolve" => Nil
              case scala.xml.PrefixedAttribute(pre, key, value, _) if pre == elem.scope.getPrefix("http://www.spiritconsortium.org/XMLSchema/SPIRIT/1685-2009") &&
                key == "id" => Nil
              case scala.xml.PrefixedAttribute(pre, key, value, _) if pre == elem.scope.getPrefix("http://www.spiritconsortium.org/XMLSchema/SPIRIT/1685-2009") &&
                key == "dependency" => Nil
              case scala.xml.PrefixedAttribute(pre, key, value, _) if pre == elem.scope.getPrefix("http://www.spiritconsortium.org/XMLSchema/SPIRIT/1685-2009") &&
                key == "choiceRef" => Nil
              case scala.xml.PrefixedAttribute(pre, key, value, _) if pre == elem.scope.getPrefix("http://www.spiritconsortium.org/XMLSchema/SPIRIT/1685-2009") &&
                key == "order" => Nil
              case scala.xml.PrefixedAttribute(pre, key, value, _) if pre == elem.scope.getPrefix("http://www.spiritconsortium.org/XMLSchema/SPIRIT/1685-2009") &&
                key == "configGroups" => Nil
              case scala.xml.PrefixedAttribute(pre, key, value, _) if pre == elem.scope.getPrefix("http://www.spiritconsortium.org/XMLSchema/SPIRIT/1685-2009") &&
                key == "bitStringLength" => Nil
              case scala.xml.PrefixedAttribute(pre, key, value, _) if pre == elem.scope.getPrefix("http://www.spiritconsortium.org/XMLSchema/SPIRIT/1685-2009") &&
                key == "minimum" => Nil
              case scala.xml.PrefixedAttribute(pre, key, value, _) if pre == elem.scope.getPrefix("http://www.spiritconsortium.org/XMLSchema/SPIRIT/1685-2009") &&
                key == "maximum" => Nil
              case scala.xml.PrefixedAttribute(pre, key, value, _) if pre == elem.scope.getPrefix("http://www.spiritconsortium.org/XMLSchema/SPIRIT/1685-2009") &&
                key == "rangeType" => Nil
              case scala.xml.PrefixedAttribute(pre, key, value, _) if pre == elem.scope.getPrefix("http://www.spiritconsortium.org/XMLSchema/SPIRIT/1685-2009") &&
                key == "prompt" => Nil
              case scala.xml.UnprefixedAttribute(key, value, _) =>
                List(("@" + key, IPXACT2009scalaxb.DataRecord(None, Some(key), value.text)))
              case scala.xml.PrefixedAttribute(pre, key, value, _) =>
                val ns = elem.scope.getURI(pre)
                List(("@{" + ns + "}" + key, IPXACT2009scalaxb.DataRecord(Option[String](ns), Some(key), value.text)))
              case _ => Nil
            }
          case _ => Nil
        }): _*)))
      case _ => Left("reads failed: seq must be scala.xml.Node")
    }
    
    override def writesAttribute(__obj: Value2, __scope: scala.xml.NamespaceBinding): scala.xml.MetaData = {
      var attr: scala.xml.MetaData  = scala.xml.Null
      __obj.attributes.toList map {
        case ("@{http://www.spiritconsortium.org/XMLSchema/SPIRIT/1685-2009}format", _) => if (__obj.spiritformat.toString != "long") attr = scala.xml.Attribute(__scope.getPrefix("http://www.spiritconsortium.org/XMLSchema/SPIRIT/1685-2009"), "format", __obj.spiritformat.toString, attr)
        case ("@{http://www.spiritconsortium.org/XMLSchema/SPIRIT/1685-2009}resolve", _) => __obj.spiritresolve foreach { x => attr = scala.xml.Attribute(__scope.getPrefix("http://www.spiritconsortium.org/XMLSchema/SPIRIT/1685-2009"), "resolve", x.toString, attr) }
        case ("@{http://www.spiritconsortium.org/XMLSchema/SPIRIT/1685-2009}id", _) => __obj.spiritid foreach { x => attr = scala.xml.Attribute(__scope.getPrefix("http://www.spiritconsortium.org/XMLSchema/SPIRIT/1685-2009"), "id", x.toString, attr) }
        case ("@{http://www.spiritconsortium.org/XMLSchema/SPIRIT/1685-2009}dependency", _) => __obj.spiritdependency foreach { x => attr = scala.xml.Attribute(__scope.getPrefix("http://www.spiritconsortium.org/XMLSchema/SPIRIT/1685-2009"), "dependency", x.toString, attr) }
        case ("@{http://www.spiritconsortium.org/XMLSchema/SPIRIT/1685-2009}choiceRef", _) => __obj.spiritchoiceRef foreach { x => attr = scala.xml.Attribute(__scope.getPrefix("http://www.spiritconsortium.org/XMLSchema/SPIRIT/1685-2009"), "choiceRef", x.toString, attr) }
        case ("@{http://www.spiritconsortium.org/XMLSchema/SPIRIT/1685-2009}order", _) => __obj.spiritorder foreach { x => attr = scala.xml.Attribute(__scope.getPrefix("http://www.spiritconsortium.org/XMLSchema/SPIRIT/1685-2009"), "order", x.toString, attr) }
        case ("@{http://www.spiritconsortium.org/XMLSchema/SPIRIT/1685-2009}configGroups", _) => __obj.spiritconfigGroups foreach { x => attr = scala.xml.Attribute(__scope.getPrefix("http://www.spiritconsortium.org/XMLSchema/SPIRIT/1685-2009"), "configGroups", x.toString, attr) }
        case ("@{http://www.spiritconsortium.org/XMLSchema/SPIRIT/1685-2009}bitStringLength", _) => __obj.spiritbitStringLength foreach { x => attr = scala.xml.Attribute(__scope.getPrefix("http://www.spiritconsortium.org/XMLSchema/SPIRIT/1685-2009"), "bitStringLength", x.toString, attr) }
        case ("@{http://www.spiritconsortium.org/XMLSchema/SPIRIT/1685-2009}minimum", _) => __obj.spiritminimum foreach { x => attr = scala.xml.Attribute(__scope.getPrefix("http://www.spiritconsortium.org/XMLSchema/SPIRIT/1685-2009"), "minimum", x.toString, attr) }
        case ("@{http://www.spiritconsortium.org/XMLSchema/SPIRIT/1685-2009}maximum", _) => __obj.spiritmaximum foreach { x => attr = scala.xml.Attribute(__scope.getPrefix("http://www.spiritconsortium.org/XMLSchema/SPIRIT/1685-2009"), "maximum", x.toString, attr) }
        case ("@{http://www.spiritconsortium.org/XMLSchema/SPIRIT/1685-2009}rangeType", _) => if (__obj.spiritrangeType.toString != "float") attr = scala.xml.Attribute(__scope.getPrefix("http://www.spiritconsortium.org/XMLSchema/SPIRIT/1685-2009"), "rangeType", __obj.spiritrangeType.toString, attr)
        case ("@{http://www.spiritconsortium.org/XMLSchema/SPIRIT/1685-2009}prompt", _) => __obj.spiritprompt foreach { x => attr = scala.xml.Attribute(__scope.getPrefix("http://www.spiritconsortium.org/XMLSchema/SPIRIT/1685-2009"), "prompt", x.toString, attr) }
        case (key, x) => attr = scala.xml.Attribute((x.namespace map { __scope.getPrefix(_) }).orNull, x.key.orNull, x.value.toString, attr)
      }
      attr
    }

    def writesChildNodes(__obj: Value2, __scope: scala.xml.NamespaceBinding): Seq[scala.xml.Node] =
      Seq(scala.xml.Text(__obj.value.toString))

  }

  trait Default_MaskFormat extends IPXACT2009scalaxb.XMLFormat[Mask] with IPXACT2009scalaxb.CanWriteChildNodes[Mask] {
    val targetNamespace: Option[String] = Some("http://www.spiritconsortium.org/XMLSchema/SPIRIT/1685-2009")
    def reads(seq: scala.xml.NodeSeq, stack: List[IPXACT2009scalaxb.ElemName]): Either[String, Mask] = seq match {
      case node: scala.xml.Node => Right(Mask(IPXACT2009scalaxb.fromXML[String](node, IPXACT2009scalaxb.ElemName(node) :: stack),
        scala.collection.immutable.ListMap(List(
        (node \ "@{http://www.spiritconsortium.org/XMLSchema/SPIRIT/1685-2009}format").headOption map { x => IPXACT2009scalaxb.DataRecord(x, node, IPXACT2009scalaxb.fromXML[FormatType](x, IPXACT2009scalaxb.ElemName(node) :: stack)) } orElse Some(IPXACT2009scalaxb.DataRecord(None, None, IPXACT2009scalaxb.fromXML[FormatType](scala.xml.Text("long"), IPXACT2009scalaxb.ElemName(node) :: stack))) map { "@{http://www.spiritconsortium.org/XMLSchema/SPIRIT/1685-2009}format" -> _ },
        (node \ "@{http://www.spiritconsortium.org/XMLSchema/SPIRIT/1685-2009}resolve").headOption map { x => IPXACT2009scalaxb.DataRecord(x, node, IPXACT2009scalaxb.fromXML[ResolveType](x, IPXACT2009scalaxb.ElemName(node) :: stack)) } map { "@{http://www.spiritconsortium.org/XMLSchema/SPIRIT/1685-2009}resolve" -> _ },
        (node \ "@{http://www.spiritconsortium.org/XMLSchema/SPIRIT/1685-2009}id").headOption map { x => IPXACT2009scalaxb.DataRecord(x, node, IPXACT2009scalaxb.fromXML[String](x, IPXACT2009scalaxb.ElemName(node) :: stack)) } map { "@{http://www.spiritconsortium.org/XMLSchema/SPIRIT/1685-2009}id" -> _ },
        (node \ "@{http://www.spiritconsortium.org/XMLSchema/SPIRIT/1685-2009}dependency").headOption map { x => IPXACT2009scalaxb.DataRecord(x, node, IPXACT2009scalaxb.fromXML[String](x, IPXACT2009scalaxb.ElemName(node) :: stack)) } map { "@{http://www.spiritconsortium.org/XMLSchema/SPIRIT/1685-2009}dependency" -> _ },
        (node \ "@{http://www.spiritconsortium.org/XMLSchema/SPIRIT/1685-2009}choiceRef").headOption map { x => IPXACT2009scalaxb.DataRecord(x, node, IPXACT2009scalaxb.fromXML[String](x, IPXACT2009scalaxb.ElemName(node) :: stack)) } map { "@{http://www.spiritconsortium.org/XMLSchema/SPIRIT/1685-2009}choiceRef" -> _ },
        (node \ "@{http://www.spiritconsortium.org/XMLSchema/SPIRIT/1685-2009}order").headOption map { x => IPXACT2009scalaxb.DataRecord(x, node, IPXACT2009scalaxb.fromXML[Float](x, IPXACT2009scalaxb.ElemName(node) :: stack)) } map { "@{http://www.spiritconsortium.org/XMLSchema/SPIRIT/1685-2009}order" -> _ },
        (node \ "@{http://www.spiritconsortium.org/XMLSchema/SPIRIT/1685-2009}configGroups").headOption map { x => IPXACT2009scalaxb.DataRecord(x, node, IPXACT2009scalaxb.fromXML[Seq[String]](x, IPXACT2009scalaxb.ElemName(node) :: stack)) } map { "@{http://www.spiritconsortium.org/XMLSchema/SPIRIT/1685-2009}configGroups" -> _ },
        (node \ "@{http://www.spiritconsortium.org/XMLSchema/SPIRIT/1685-2009}bitStringLength").headOption map { x => IPXACT2009scalaxb.DataRecord(x, node, IPXACT2009scalaxb.fromXML[BigInt](x, IPXACT2009scalaxb.ElemName(node) :: stack)) } map { "@{http://www.spiritconsortium.org/XMLSchema/SPIRIT/1685-2009}bitStringLength" -> _ },
        (node \ "@{http://www.spiritconsortium.org/XMLSchema/SPIRIT/1685-2009}minimum").headOption map { x => IPXACT2009scalaxb.DataRecord(x, node, IPXACT2009scalaxb.fromXML[String](x, IPXACT2009scalaxb.ElemName(node) :: stack)) } map { "@{http://www.spiritconsortium.org/XMLSchema/SPIRIT/1685-2009}minimum" -> _ },
        (node \ "@{http://www.spiritconsortium.org/XMLSchema/SPIRIT/1685-2009}maximum").headOption map { x => IPXACT2009scalaxb.DataRecord(x, node, IPXACT2009scalaxb.fromXML[String](x, IPXACT2009scalaxb.ElemName(node) :: stack)) } map { "@{http://www.spiritconsortium.org/XMLSchema/SPIRIT/1685-2009}maximum" -> _ },
        (node \ "@{http://www.spiritconsortium.org/XMLSchema/SPIRIT/1685-2009}rangeType").headOption map { x => IPXACT2009scalaxb.DataRecord(x, node, IPXACT2009scalaxb.fromXML[RangeTypeType](x, IPXACT2009scalaxb.ElemName(node) :: stack)) } orElse Some(IPXACT2009scalaxb.DataRecord(None, None, IPXACT2009scalaxb.fromXML[RangeTypeType](scala.xml.Text("float"), IPXACT2009scalaxb.ElemName(node) :: stack))) map { "@{http://www.spiritconsortium.org/XMLSchema/SPIRIT/1685-2009}rangeType" -> _ },
        (node \ "@{http://www.spiritconsortium.org/XMLSchema/SPIRIT/1685-2009}prompt").headOption map { x => IPXACT2009scalaxb.DataRecord(x, node, IPXACT2009scalaxb.fromXML[String](x, IPXACT2009scalaxb.ElemName(node) :: stack)) } map { "@{http://www.spiritconsortium.org/XMLSchema/SPIRIT/1685-2009}prompt" -> _ }
        ).flatten[(String, IPXACT2009scalaxb.DataRecord[Any])] ::: (node match {
          case elem: scala.xml.Elem =>
            elem.attributes.toList flatMap {
              case scala.xml.PrefixedAttribute(pre, key, value, _) if pre == elem.scope.getPrefix("http://www.spiritconsortium.org/XMLSchema/SPIRIT/1685-2009") &&
                key == "format" => Nil
              case scala.xml.PrefixedAttribute(pre, key, value, _) if pre == elem.scope.getPrefix("http://www.spiritconsortium.org/XMLSchema/SPIRIT/1685-2009") &&
                key == "resolve" => Nil
              case scala.xml.PrefixedAttribute(pre, key, value, _) if pre == elem.scope.getPrefix("http://www.spiritconsortium.org/XMLSchema/SPIRIT/1685-2009") &&
                key == "id" => Nil
              case scala.xml.PrefixedAttribute(pre, key, value, _) if pre == elem.scope.getPrefix("http://www.spiritconsortium.org/XMLSchema/SPIRIT/1685-2009") &&
                key == "dependency" => Nil
              case scala.xml.PrefixedAttribute(pre, key, value, _) if pre == elem.scope.getPrefix("http://www.spiritconsortium.org/XMLSchema/SPIRIT/1685-2009") &&
                key == "choiceRef" => Nil
              case scala.xml.PrefixedAttribute(pre, key, value, _) if pre == elem.scope.getPrefix("http://www.spiritconsortium.org/XMLSchema/SPIRIT/1685-2009") &&
                key == "order" => Nil
              case scala.xml.PrefixedAttribute(pre, key, value, _) if pre == elem.scope.getPrefix("http://www.spiritconsortium.org/XMLSchema/SPIRIT/1685-2009") &&
                key == "configGroups" => Nil
              case scala.xml.PrefixedAttribute(pre, key, value, _) if pre == elem.scope.getPrefix("http://www.spiritconsortium.org/XMLSchema/SPIRIT/1685-2009") &&
                key == "bitStringLength" => Nil
              case scala.xml.PrefixedAttribute(pre, key, value, _) if pre == elem.scope.getPrefix("http://www.spiritconsortium.org/XMLSchema/SPIRIT/1685-2009") &&
                key == "minimum" => Nil
              case scala.xml.PrefixedAttribute(pre, key, value, _) if pre == elem.scope.getPrefix("http://www.spiritconsortium.org/XMLSchema/SPIRIT/1685-2009") &&
                key == "maximum" => Nil
              case scala.xml.PrefixedAttribute(pre, key, value, _) if pre == elem.scope.getPrefix("http://www.spiritconsortium.org/XMLSchema/SPIRIT/1685-2009") &&
                key == "rangeType" => Nil
              case scala.xml.PrefixedAttribute(pre, key, value, _) if pre == elem.scope.getPrefix("http://www.spiritconsortium.org/XMLSchema/SPIRIT/1685-2009") &&
                key == "prompt" => Nil
              case scala.xml.UnprefixedAttribute(key, value, _) =>
                List(("@" + key, IPXACT2009scalaxb.DataRecord(None, Some(key), value.text)))
              case scala.xml.PrefixedAttribute(pre, key, value, _) =>
                val ns = elem.scope.getURI(pre)
                List(("@{" + ns + "}" + key, IPXACT2009scalaxb.DataRecord(Option[String](ns), Some(key), value.text)))
              case _ => Nil
            }
          case _ => Nil
        }): _*)))
      case _ => Left("reads failed: seq must be scala.xml.Node")
    }
    
    override def writesAttribute(__obj: Mask, __scope: scala.xml.NamespaceBinding): scala.xml.MetaData = {
      var attr: scala.xml.MetaData  = scala.xml.Null
      __obj.attributes.toList map {
        case ("@{http://www.spiritconsortium.org/XMLSchema/SPIRIT/1685-2009}format", _) => if (__obj.spiritformat.toString != "long") attr = scala.xml.Attribute(__scope.getPrefix("http://www.spiritconsortium.org/XMLSchema/SPIRIT/1685-2009"), "format", __obj.spiritformat.toString, attr)
        case ("@{http://www.spiritconsortium.org/XMLSchema/SPIRIT/1685-2009}resolve", _) => __obj.spiritresolve foreach { x => attr = scala.xml.Attribute(__scope.getPrefix("http://www.spiritconsortium.org/XMLSchema/SPIRIT/1685-2009"), "resolve", x.toString, attr) }
        case ("@{http://www.spiritconsortium.org/XMLSchema/SPIRIT/1685-2009}id", _) => __obj.spiritid foreach { x => attr = scala.xml.Attribute(__scope.getPrefix("http://www.spiritconsortium.org/XMLSchema/SPIRIT/1685-2009"), "id", x.toString, attr) }
        case ("@{http://www.spiritconsortium.org/XMLSchema/SPIRIT/1685-2009}dependency", _) => __obj.spiritdependency foreach { x => attr = scala.xml.Attribute(__scope.getPrefix("http://www.spiritconsortium.org/XMLSchema/SPIRIT/1685-2009"), "dependency", x.toString, attr) }
        case ("@{http://www.spiritconsortium.org/XMLSchema/SPIRIT/1685-2009}choiceRef", _) => __obj.spiritchoiceRef foreach { x => attr = scala.xml.Attribute(__scope.getPrefix("http://www.spiritconsortium.org/XMLSchema/SPIRIT/1685-2009"), "choiceRef", x.toString, attr) }
        case ("@{http://www.spiritconsortium.org/XMLSchema/SPIRIT/1685-2009}order", _) => __obj.spiritorder foreach { x => attr = scala.xml.Attribute(__scope.getPrefix("http://www.spiritconsortium.org/XMLSchema/SPIRIT/1685-2009"), "order", x.toString, attr) }
        case ("@{http://www.spiritconsortium.org/XMLSchema/SPIRIT/1685-2009}configGroups", _) => __obj.spiritconfigGroups foreach { x => attr = scala.xml.Attribute(__scope.getPrefix("http://www.spiritconsortium.org/XMLSchema/SPIRIT/1685-2009"), "configGroups", x.toString, attr) }
        case ("@{http://www.spiritconsortium.org/XMLSchema/SPIRIT/1685-2009}bitStringLength", _) => __obj.spiritbitStringLength foreach { x => attr = scala.xml.Attribute(__scope.getPrefix("http://www.spiritconsortium.org/XMLSchema/SPIRIT/1685-2009"), "bitStringLength", x.toString, attr) }
        case ("@{http://www.spiritconsortium.org/XMLSchema/SPIRIT/1685-2009}minimum", _) => __obj.spiritminimum foreach { x => attr = scala.xml.Attribute(__scope.getPrefix("http://www.spiritconsortium.org/XMLSchema/SPIRIT/1685-2009"), "minimum", x.toString, attr) }
        case ("@{http://www.spiritconsortium.org/XMLSchema/SPIRIT/1685-2009}maximum", _) => __obj.spiritmaximum foreach { x => attr = scala.xml.Attribute(__scope.getPrefix("http://www.spiritconsortium.org/XMLSchema/SPIRIT/1685-2009"), "maximum", x.toString, attr) }
        case ("@{http://www.spiritconsortium.org/XMLSchema/SPIRIT/1685-2009}rangeType", _) => if (__obj.spiritrangeType.toString != "float") attr = scala.xml.Attribute(__scope.getPrefix("http://www.spiritconsortium.org/XMLSchema/SPIRIT/1685-2009"), "rangeType", __obj.spiritrangeType.toString, attr)
        case ("@{http://www.spiritconsortium.org/XMLSchema/SPIRIT/1685-2009}prompt", _) => __obj.spiritprompt foreach { x => attr = scala.xml.Attribute(__scope.getPrefix("http://www.spiritconsortium.org/XMLSchema/SPIRIT/1685-2009"), "prompt", x.toString, attr) }
        case (key, x) => attr = scala.xml.Attribute((x.namespace map { __scope.getPrefix(_) }).orNull, x.key.orNull, x.value.toString, attr)
      }
      attr
    }

    def writesChildNodes(__obj: Mask, __scope: scala.xml.NamespaceBinding): Seq[scala.xml.Node] =
      Seq(scala.xml.Text(__obj.value.toString))

  }

  trait Default_ResetFormat extends IPXACT2009scalaxb.ElemNameParser[Reset] {
    val targetNamespace: Option[String] = Some("http://www.spiritconsortium.org/XMLSchema/SPIRIT/1685-2009")
    
    def parser(node: scala.xml.Node, stack: List[IPXACT2009scalaxb.ElemName]): Parser[Reset] =
      phrase((IPXACT2009scalaxb.ElemName(Some("http://www.spiritconsortium.org/XMLSchema/SPIRIT/1685-2009"), "value")) ~
      opt(IPXACT2009scalaxb.ElemName(Some("http://www.spiritconsortium.org/XMLSchema/SPIRIT/1685-2009"), "mask")) ^^
      { case p1 ~ p2 =>
      Reset(IPXACT2009scalaxb.fromXML[Value2](p1, IPXACT2009scalaxb.ElemName(node) :: stack),
        p2.headOption map { IPXACT2009scalaxb.fromXML[Mask](_, IPXACT2009scalaxb.ElemName(node) :: stack) }) })
    
    def writesChildNodes(__obj: Reset, __scope: scala.xml.NamespaceBinding): Seq[scala.xml.Node] =
      Seq.concat(IPXACT2009scalaxb.toXML[Value2](__obj.value, Some("http://www.spiritconsortium.org/XMLSchema/SPIRIT/1685-2009"), Some("value"), __scope, false),
        __obj.mask map { IPXACT2009scalaxb.toXML[Mask](_, Some("http://www.spiritconsortium.org/XMLSchema/SPIRIT/1685-2009"), Some("mask"), __scope, false) } getOrElse {Nil})

  }

  trait Default_Value3Format extends IPXACT2009scalaxb.XMLFormat[Value3] with IPXACT2009scalaxb.CanWriteChildNodes[Value3] {
    val targetNamespace: Option[String] = Some("http://www.spiritconsortium.org/XMLSchema/SPIRIT/1685-2009")
    def reads(seq: scala.xml.NodeSeq, stack: List[IPXACT2009scalaxb.ElemName]): Either[String, Value3] = seq match {
      case node: scala.xml.Node => Right(Value3(IPXACT2009scalaxb.fromXML[String](node, IPXACT2009scalaxb.ElemName(node) :: stack),
        scala.collection.immutable.ListMap(List(
        (node \ "@{http://www.spiritconsortium.org/XMLSchema/SPIRIT/1685-2009}format").headOption map { x => IPXACT2009scalaxb.DataRecord(x, node, IPXACT2009scalaxb.fromXML[FormatType](x, IPXACT2009scalaxb.ElemName(node) :: stack)) } orElse Some(IPXACT2009scalaxb.DataRecord(None, None, IPXACT2009scalaxb.fromXML[FormatType](scala.xml.Text("long"), IPXACT2009scalaxb.ElemName(node) :: stack))) map { "@{http://www.spiritconsortium.org/XMLSchema/SPIRIT/1685-2009}format" -> _ },
        (node \ "@{http://www.spiritconsortium.org/XMLSchema/SPIRIT/1685-2009}resolve").headOption map { x => IPXACT2009scalaxb.DataRecord(x, node, IPXACT2009scalaxb.fromXML[ResolveType](x, IPXACT2009scalaxb.ElemName(node) :: stack)) } map { "@{http://www.spiritconsortium.org/XMLSchema/SPIRIT/1685-2009}resolve" -> _ },
        (node \ "@{http://www.spiritconsortium.org/XMLSchema/SPIRIT/1685-2009}id").headOption map { x => IPXACT2009scalaxb.DataRecord(x, node, IPXACT2009scalaxb.fromXML[String](x, IPXACT2009scalaxb.ElemName(node) :: stack)) } map { "@{http://www.spiritconsortium.org/XMLSchema/SPIRIT/1685-2009}id" -> _ },
        (node \ "@{http://www.spiritconsortium.org/XMLSchema/SPIRIT/1685-2009}dependency").headOption map { x => IPXACT2009scalaxb.DataRecord(x, node, IPXACT2009scalaxb.fromXML[String](x, IPXACT2009scalaxb.ElemName(node) :: stack)) } map { "@{http://www.spiritconsortium.org/XMLSchema/SPIRIT/1685-2009}dependency" -> _ },
        (node \ "@{http://www.spiritconsortium.org/XMLSchema/SPIRIT/1685-2009}choiceRef").headOption map { x => IPXACT2009scalaxb.DataRecord(x, node, IPXACT2009scalaxb.fromXML[String](x, IPXACT2009scalaxb.ElemName(node) :: stack)) } map { "@{http://www.spiritconsortium.org/XMLSchema/SPIRIT/1685-2009}choiceRef" -> _ },
        (node \ "@{http://www.spiritconsortium.org/XMLSchema/SPIRIT/1685-2009}order").headOption map { x => IPXACT2009scalaxb.DataRecord(x, node, IPXACT2009scalaxb.fromXML[Float](x, IPXACT2009scalaxb.ElemName(node) :: stack)) } map { "@{http://www.spiritconsortium.org/XMLSchema/SPIRIT/1685-2009}order" -> _ },
        (node \ "@{http://www.spiritconsortium.org/XMLSchema/SPIRIT/1685-2009}configGroups").headOption map { x => IPXACT2009scalaxb.DataRecord(x, node, IPXACT2009scalaxb.fromXML[Seq[String]](x, IPXACT2009scalaxb.ElemName(node) :: stack)) } map { "@{http://www.spiritconsortium.org/XMLSchema/SPIRIT/1685-2009}configGroups" -> _ },
        (node \ "@{http://www.spiritconsortium.org/XMLSchema/SPIRIT/1685-2009}bitStringLength").headOption map { x => IPXACT2009scalaxb.DataRecord(x, node, IPXACT2009scalaxb.fromXML[BigInt](x, IPXACT2009scalaxb.ElemName(node) :: stack)) } map { "@{http://www.spiritconsortium.org/XMLSchema/SPIRIT/1685-2009}bitStringLength" -> _ },
        (node \ "@{http://www.spiritconsortium.org/XMLSchema/SPIRIT/1685-2009}minimum").headOption map { x => IPXACT2009scalaxb.DataRecord(x, node, IPXACT2009scalaxb.fromXML[String](x, IPXACT2009scalaxb.ElemName(node) :: stack)) } map { "@{http://www.spiritconsortium.org/XMLSchema/SPIRIT/1685-2009}minimum" -> _ },
        (node \ "@{http://www.spiritconsortium.org/XMLSchema/SPIRIT/1685-2009}maximum").headOption map { x => IPXACT2009scalaxb.DataRecord(x, node, IPXACT2009scalaxb.fromXML[String](x, IPXACT2009scalaxb.ElemName(node) :: stack)) } map { "@{http://www.spiritconsortium.org/XMLSchema/SPIRIT/1685-2009}maximum" -> _ },
        (node \ "@{http://www.spiritconsortium.org/XMLSchema/SPIRIT/1685-2009}rangeType").headOption map { x => IPXACT2009scalaxb.DataRecord(x, node, IPXACT2009scalaxb.fromXML[RangeTypeType](x, IPXACT2009scalaxb.ElemName(node) :: stack)) } orElse Some(IPXACT2009scalaxb.DataRecord(None, None, IPXACT2009scalaxb.fromXML[RangeTypeType](scala.xml.Text("float"), IPXACT2009scalaxb.ElemName(node) :: stack))) map { "@{http://www.spiritconsortium.org/XMLSchema/SPIRIT/1685-2009}rangeType" -> _ },
        (node \ "@{http://www.spiritconsortium.org/XMLSchema/SPIRIT/1685-2009}prompt").headOption map { x => IPXACT2009scalaxb.DataRecord(x, node, IPXACT2009scalaxb.fromXML[String](x, IPXACT2009scalaxb.ElemName(node) :: stack)) } map { "@{http://www.spiritconsortium.org/XMLSchema/SPIRIT/1685-2009}prompt" -> _ }
        ).flatten[(String, IPXACT2009scalaxb.DataRecord[Any])] ::: (node match {
          case elem: scala.xml.Elem =>
            elem.attributes.toList flatMap {
              case scala.xml.PrefixedAttribute(pre, key, value, _) if pre == elem.scope.getPrefix("http://www.spiritconsortium.org/XMLSchema/SPIRIT/1685-2009") &&
                key == "format" => Nil
              case scala.xml.PrefixedAttribute(pre, key, value, _) if pre == elem.scope.getPrefix("http://www.spiritconsortium.org/XMLSchema/SPIRIT/1685-2009") &&
                key == "resolve" => Nil
              case scala.xml.PrefixedAttribute(pre, key, value, _) if pre == elem.scope.getPrefix("http://www.spiritconsortium.org/XMLSchema/SPIRIT/1685-2009") &&
                key == "id" => Nil
              case scala.xml.PrefixedAttribute(pre, key, value, _) if pre == elem.scope.getPrefix("http://www.spiritconsortium.org/XMLSchema/SPIRIT/1685-2009") &&
                key == "dependency" => Nil
              case scala.xml.PrefixedAttribute(pre, key, value, _) if pre == elem.scope.getPrefix("http://www.spiritconsortium.org/XMLSchema/SPIRIT/1685-2009") &&
                key == "choiceRef" => Nil
              case scala.xml.PrefixedAttribute(pre, key, value, _) if pre == elem.scope.getPrefix("http://www.spiritconsortium.org/XMLSchema/SPIRIT/1685-2009") &&
                key == "order" => Nil
              case scala.xml.PrefixedAttribute(pre, key, value, _) if pre == elem.scope.getPrefix("http://www.spiritconsortium.org/XMLSchema/SPIRIT/1685-2009") &&
                key == "configGroups" => Nil
              case scala.xml.PrefixedAttribute(pre, key, value, _) if pre == elem.scope.getPrefix("http://www.spiritconsortium.org/XMLSchema/SPIRIT/1685-2009") &&
                key == "bitStringLength" => Nil
              case scala.xml.PrefixedAttribute(pre, key, value, _) if pre == elem.scope.getPrefix("http://www.spiritconsortium.org/XMLSchema/SPIRIT/1685-2009") &&
                key == "minimum" => Nil
              case scala.xml.PrefixedAttribute(pre, key, value, _) if pre == elem.scope.getPrefix("http://www.spiritconsortium.org/XMLSchema/SPIRIT/1685-2009") &&
                key == "maximum" => Nil
              case scala.xml.PrefixedAttribute(pre, key, value, _) if pre == elem.scope.getPrefix("http://www.spiritconsortium.org/XMLSchema/SPIRIT/1685-2009") &&
                key == "rangeType" => Nil
              case scala.xml.PrefixedAttribute(pre, key, value, _) if pre == elem.scope.getPrefix("http://www.spiritconsortium.org/XMLSchema/SPIRIT/1685-2009") &&
                key == "prompt" => Nil
              case scala.xml.UnprefixedAttribute(key, value, _) =>
                List(("@" + key, IPXACT2009scalaxb.DataRecord(None, Some(key), value.text)))
              case scala.xml.PrefixedAttribute(pre, key, value, _) =>
                val ns = elem.scope.getURI(pre)
                List(("@{" + ns + "}" + key, IPXACT2009scalaxb.DataRecord(Option[String](ns), Some(key), value.text)))
              case _ => Nil
            }
          case _ => Nil
        }): _*)))
      case _ => Left("reads failed: seq must be scala.xml.Node")
    }
    
    override def writesAttribute(__obj: Value3, __scope: scala.xml.NamespaceBinding): scala.xml.MetaData = {
      var attr: scala.xml.MetaData  = scala.xml.Null
      __obj.attributes.toList map {
        case ("@{http://www.spiritconsortium.org/XMLSchema/SPIRIT/1685-2009}format", _) => if (__obj.spiritformat.toString != "long") attr = scala.xml.Attribute(__scope.getPrefix("http://www.spiritconsortium.org/XMLSchema/SPIRIT/1685-2009"), "format", __obj.spiritformat.toString, attr)
        case ("@{http://www.spiritconsortium.org/XMLSchema/SPIRIT/1685-2009}resolve", _) => __obj.spiritresolve foreach { x => attr = scala.xml.Attribute(__scope.getPrefix("http://www.spiritconsortium.org/XMLSchema/SPIRIT/1685-2009"), "resolve", x.toString, attr) }
        case ("@{http://www.spiritconsortium.org/XMLSchema/SPIRIT/1685-2009}id", _) => __obj.spiritid foreach { x => attr = scala.xml.Attribute(__scope.getPrefix("http://www.spiritconsortium.org/XMLSchema/SPIRIT/1685-2009"), "id", x.toString, attr) }
        case ("@{http://www.spiritconsortium.org/XMLSchema/SPIRIT/1685-2009}dependency", _) => __obj.spiritdependency foreach { x => attr = scala.xml.Attribute(__scope.getPrefix("http://www.spiritconsortium.org/XMLSchema/SPIRIT/1685-2009"), "dependency", x.toString, attr) }
        case ("@{http://www.spiritconsortium.org/XMLSchema/SPIRIT/1685-2009}choiceRef", _) => __obj.spiritchoiceRef foreach { x => attr = scala.xml.Attribute(__scope.getPrefix("http://www.spiritconsortium.org/XMLSchema/SPIRIT/1685-2009"), "choiceRef", x.toString, attr) }
        case ("@{http://www.spiritconsortium.org/XMLSchema/SPIRIT/1685-2009}order", _) => __obj.spiritorder foreach { x => attr = scala.xml.Attribute(__scope.getPrefix("http://www.spiritconsortium.org/XMLSchema/SPIRIT/1685-2009"), "order", x.toString, attr) }
        case ("@{http://www.spiritconsortium.org/XMLSchema/SPIRIT/1685-2009}configGroups", _) => __obj.spiritconfigGroups foreach { x => attr = scala.xml.Attribute(__scope.getPrefix("http://www.spiritconsortium.org/XMLSchema/SPIRIT/1685-2009"), "configGroups", x.toString, attr) }
        case ("@{http://www.spiritconsortium.org/XMLSchema/SPIRIT/1685-2009}bitStringLength", _) => __obj.spiritbitStringLength foreach { x => attr = scala.xml.Attribute(__scope.getPrefix("http://www.spiritconsortium.org/XMLSchema/SPIRIT/1685-2009"), "bitStringLength", x.toString, attr) }
        case ("@{http://www.spiritconsortium.org/XMLSchema/SPIRIT/1685-2009}minimum", _) => __obj.spiritminimum foreach { x => attr = scala.xml.Attribute(__scope.getPrefix("http://www.spiritconsortium.org/XMLSchema/SPIRIT/1685-2009"), "minimum", x.toString, attr) }
        case ("@{http://www.spiritconsortium.org/XMLSchema/SPIRIT/1685-2009}maximum", _) => __obj.spiritmaximum foreach { x => attr = scala.xml.Attribute(__scope.getPrefix("http://www.spiritconsortium.org/XMLSchema/SPIRIT/1685-2009"), "maximum", x.toString, attr) }
        case ("@{http://www.spiritconsortium.org/XMLSchema/SPIRIT/1685-2009}rangeType", _) => if (__obj.spiritrangeType.toString != "float") attr = scala.xml.Attribute(__scope.getPrefix("http://www.spiritconsortium.org/XMLSchema/SPIRIT/1685-2009"), "rangeType", __obj.spiritrangeType.toString, attr)
        case ("@{http://www.spiritconsortium.org/XMLSchema/SPIRIT/1685-2009}prompt", _) => __obj.spiritprompt foreach { x => attr = scala.xml.Attribute(__scope.getPrefix("http://www.spiritconsortium.org/XMLSchema/SPIRIT/1685-2009"), "prompt", x.toString, attr) }
        case (key, x) => attr = scala.xml.Attribute((x.namespace map { __scope.getPrefix(_) }).orNull, x.key.orNull, x.value.toString, attr)
      }
      attr
    }

    def writesChildNodes(__obj: Value3, __scope: scala.xml.NamespaceBinding): Seq[scala.xml.Node] =
      Seq(scala.xml.Text(__obj.value.toString))

  }

  trait Default_Mask2Format extends IPXACT2009scalaxb.XMLFormat[Mask2] with IPXACT2009scalaxb.CanWriteChildNodes[Mask2] {
    val targetNamespace: Option[String] = Some("http://www.spiritconsortium.org/XMLSchema/SPIRIT/1685-2009")
    def reads(seq: scala.xml.NodeSeq, stack: List[IPXACT2009scalaxb.ElemName]): Either[String, Mask2] = seq match {
      case node: scala.xml.Node => Right(Mask2(IPXACT2009scalaxb.fromXML[String](node, IPXACT2009scalaxb.ElemName(node) :: stack),
        scala.collection.immutable.ListMap(List(
        (node \ "@{http://www.spiritconsortium.org/XMLSchema/SPIRIT/1685-2009}format").headOption map { x => IPXACT2009scalaxb.DataRecord(x, node, IPXACT2009scalaxb.fromXML[FormatType](x, IPXACT2009scalaxb.ElemName(node) :: stack)) } orElse Some(IPXACT2009scalaxb.DataRecord(None, None, IPXACT2009scalaxb.fromXML[FormatType](scala.xml.Text("long"), IPXACT2009scalaxb.ElemName(node) :: stack))) map { "@{http://www.spiritconsortium.org/XMLSchema/SPIRIT/1685-2009}format" -> _ },
        (node \ "@{http://www.spiritconsortium.org/XMLSchema/SPIRIT/1685-2009}resolve").headOption map { x => IPXACT2009scalaxb.DataRecord(x, node, IPXACT2009scalaxb.fromXML[ResolveType](x, IPXACT2009scalaxb.ElemName(node) :: stack)) } map { "@{http://www.spiritconsortium.org/XMLSchema/SPIRIT/1685-2009}resolve" -> _ },
        (node \ "@{http://www.spiritconsortium.org/XMLSchema/SPIRIT/1685-2009}id").headOption map { x => IPXACT2009scalaxb.DataRecord(x, node, IPXACT2009scalaxb.fromXML[String](x, IPXACT2009scalaxb.ElemName(node) :: stack)) } map { "@{http://www.spiritconsortium.org/XMLSchema/SPIRIT/1685-2009}id" -> _ },
        (node \ "@{http://www.spiritconsortium.org/XMLSchema/SPIRIT/1685-2009}dependency").headOption map { x => IPXACT2009scalaxb.DataRecord(x, node, IPXACT2009scalaxb.fromXML[String](x, IPXACT2009scalaxb.ElemName(node) :: stack)) } map { "@{http://www.spiritconsortium.org/XMLSchema/SPIRIT/1685-2009}dependency" -> _ },
        (node \ "@{http://www.spiritconsortium.org/XMLSchema/SPIRIT/1685-2009}choiceRef").headOption map { x => IPXACT2009scalaxb.DataRecord(x, node, IPXACT2009scalaxb.fromXML[String](x, IPXACT2009scalaxb.ElemName(node) :: stack)) } map { "@{http://www.spiritconsortium.org/XMLSchema/SPIRIT/1685-2009}choiceRef" -> _ },
        (node \ "@{http://www.spiritconsortium.org/XMLSchema/SPIRIT/1685-2009}order").headOption map { x => IPXACT2009scalaxb.DataRecord(x, node, IPXACT2009scalaxb.fromXML[Float](x, IPXACT2009scalaxb.ElemName(node) :: stack)) } map { "@{http://www.spiritconsortium.org/XMLSchema/SPIRIT/1685-2009}order" -> _ },
        (node \ "@{http://www.spiritconsortium.org/XMLSchema/SPIRIT/1685-2009}configGroups").headOption map { x => IPXACT2009scalaxb.DataRecord(x, node, IPXACT2009scalaxb.fromXML[Seq[String]](x, IPXACT2009scalaxb.ElemName(node) :: stack)) } map { "@{http://www.spiritconsortium.org/XMLSchema/SPIRIT/1685-2009}configGroups" -> _ },
        (node \ "@{http://www.spiritconsortium.org/XMLSchema/SPIRIT/1685-2009}bitStringLength").headOption map { x => IPXACT2009scalaxb.DataRecord(x, node, IPXACT2009scalaxb.fromXML[BigInt](x, IPXACT2009scalaxb.ElemName(node) :: stack)) } map { "@{http://www.spiritconsortium.org/XMLSchema/SPIRIT/1685-2009}bitStringLength" -> _ },
        (node \ "@{http://www.spiritconsortium.org/XMLSchema/SPIRIT/1685-2009}minimum").headOption map { x => IPXACT2009scalaxb.DataRecord(x, node, IPXACT2009scalaxb.fromXML[String](x, IPXACT2009scalaxb.ElemName(node) :: stack)) } map { "@{http://www.spiritconsortium.org/XMLSchema/SPIRIT/1685-2009}minimum" -> _ },
        (node \ "@{http://www.spiritconsortium.org/XMLSchema/SPIRIT/1685-2009}maximum").headOption map { x => IPXACT2009scalaxb.DataRecord(x, node, IPXACT2009scalaxb.fromXML[String](x, IPXACT2009scalaxb.ElemName(node) :: stack)) } map { "@{http://www.spiritconsortium.org/XMLSchema/SPIRIT/1685-2009}maximum" -> _ },
        (node \ "@{http://www.spiritconsortium.org/XMLSchema/SPIRIT/1685-2009}rangeType").headOption map { x => IPXACT2009scalaxb.DataRecord(x, node, IPXACT2009scalaxb.fromXML[RangeTypeType](x, IPXACT2009scalaxb.ElemName(node) :: stack)) } orElse Some(IPXACT2009scalaxb.DataRecord(None, None, IPXACT2009scalaxb.fromXML[RangeTypeType](scala.xml.Text("float"), IPXACT2009scalaxb.ElemName(node) :: stack))) map { "@{http://www.spiritconsortium.org/XMLSchema/SPIRIT/1685-2009}rangeType" -> _ },
        (node \ "@{http://www.spiritconsortium.org/XMLSchema/SPIRIT/1685-2009}prompt").headOption map { x => IPXACT2009scalaxb.DataRecord(x, node, IPXACT2009scalaxb.fromXML[String](x, IPXACT2009scalaxb.ElemName(node) :: stack)) } map { "@{http://www.spiritconsortium.org/XMLSchema/SPIRIT/1685-2009}prompt" -> _ }
        ).flatten[(String, IPXACT2009scalaxb.DataRecord[Any])] ::: (node match {
          case elem: scala.xml.Elem =>
            elem.attributes.toList flatMap {
              case scala.xml.PrefixedAttribute(pre, key, value, _) if pre == elem.scope.getPrefix("http://www.spiritconsortium.org/XMLSchema/SPIRIT/1685-2009") &&
                key == "format" => Nil
              case scala.xml.PrefixedAttribute(pre, key, value, _) if pre == elem.scope.getPrefix("http://www.spiritconsortium.org/XMLSchema/SPIRIT/1685-2009") &&
                key == "resolve" => Nil
              case scala.xml.PrefixedAttribute(pre, key, value, _) if pre == elem.scope.getPrefix("http://www.spiritconsortium.org/XMLSchema/SPIRIT/1685-2009") &&
                key == "id" => Nil
              case scala.xml.PrefixedAttribute(pre, key, value, _) if pre == elem.scope.getPrefix("http://www.spiritconsortium.org/XMLSchema/SPIRIT/1685-2009") &&
                key == "dependency" => Nil
              case scala.xml.PrefixedAttribute(pre, key, value, _) if pre == elem.scope.getPrefix("http://www.spiritconsortium.org/XMLSchema/SPIRIT/1685-2009") &&
                key == "choiceRef" => Nil
              case scala.xml.PrefixedAttribute(pre, key, value, _) if pre == elem.scope.getPrefix("http://www.spiritconsortium.org/XMLSchema/SPIRIT/1685-2009") &&
                key == "order" => Nil
              case scala.xml.PrefixedAttribute(pre, key, value, _) if pre == elem.scope.getPrefix("http://www.spiritconsortium.org/XMLSchema/SPIRIT/1685-2009") &&
                key == "configGroups" => Nil
              case scala.xml.PrefixedAttribute(pre, key, value, _) if pre == elem.scope.getPrefix("http://www.spiritconsortium.org/XMLSchema/SPIRIT/1685-2009") &&
                key == "bitStringLength" => Nil
              case scala.xml.PrefixedAttribute(pre, key, value, _) if pre == elem.scope.getPrefix("http://www.spiritconsortium.org/XMLSchema/SPIRIT/1685-2009") &&
                key == "minimum" => Nil
              case scala.xml.PrefixedAttribute(pre, key, value, _) if pre == elem.scope.getPrefix("http://www.spiritconsortium.org/XMLSchema/SPIRIT/1685-2009") &&
                key == "maximum" => Nil
              case scala.xml.PrefixedAttribute(pre, key, value, _) if pre == elem.scope.getPrefix("http://www.spiritconsortium.org/XMLSchema/SPIRIT/1685-2009") &&
                key == "rangeType" => Nil
              case scala.xml.PrefixedAttribute(pre, key, value, _) if pre == elem.scope.getPrefix("http://www.spiritconsortium.org/XMLSchema/SPIRIT/1685-2009") &&
                key == "prompt" => Nil
              case scala.xml.UnprefixedAttribute(key, value, _) =>
                List(("@" + key, IPXACT2009scalaxb.DataRecord(None, Some(key), value.text)))
              case scala.xml.PrefixedAttribute(pre, key, value, _) =>
                val ns = elem.scope.getURI(pre)
                List(("@{" + ns + "}" + key, IPXACT2009scalaxb.DataRecord(Option[String](ns), Some(key), value.text)))
              case _ => Nil
            }
          case _ => Nil
        }): _*)))
      case _ => Left("reads failed: seq must be scala.xml.Node")
    }
    
    override def writesAttribute(__obj: Mask2, __scope: scala.xml.NamespaceBinding): scala.xml.MetaData = {
      var attr: scala.xml.MetaData  = scala.xml.Null
      __obj.attributes.toList map {
        case ("@{http://www.spiritconsortium.org/XMLSchema/SPIRIT/1685-2009}format", _) => if (__obj.spiritformat.toString != "long") attr = scala.xml.Attribute(__scope.getPrefix("http://www.spiritconsortium.org/XMLSchema/SPIRIT/1685-2009"), "format", __obj.spiritformat.toString, attr)
        case ("@{http://www.spiritconsortium.org/XMLSchema/SPIRIT/1685-2009}resolve", _) => __obj.spiritresolve foreach { x => attr = scala.xml.Attribute(__scope.getPrefix("http://www.spiritconsortium.org/XMLSchema/SPIRIT/1685-2009"), "resolve", x.toString, attr) }
        case ("@{http://www.spiritconsortium.org/XMLSchema/SPIRIT/1685-2009}id", _) => __obj.spiritid foreach { x => attr = scala.xml.Attribute(__scope.getPrefix("http://www.spiritconsortium.org/XMLSchema/SPIRIT/1685-2009"), "id", x.toString, attr) }
        case ("@{http://www.spiritconsortium.org/XMLSchema/SPIRIT/1685-2009}dependency", _) => __obj.spiritdependency foreach { x => attr = scala.xml.Attribute(__scope.getPrefix("http://www.spiritconsortium.org/XMLSchema/SPIRIT/1685-2009"), "dependency", x.toString, attr) }
        case ("@{http://www.spiritconsortium.org/XMLSchema/SPIRIT/1685-2009}choiceRef", _) => __obj.spiritchoiceRef foreach { x => attr = scala.xml.Attribute(__scope.getPrefix("http://www.spiritconsortium.org/XMLSchema/SPIRIT/1685-2009"), "choiceRef", x.toString, attr) }
        case ("@{http://www.spiritconsortium.org/XMLSchema/SPIRIT/1685-2009}order", _) => __obj.spiritorder foreach { x => attr = scala.xml.Attribute(__scope.getPrefix("http://www.spiritconsortium.org/XMLSchema/SPIRIT/1685-2009"), "order", x.toString, attr) }
        case ("@{http://www.spiritconsortium.org/XMLSchema/SPIRIT/1685-2009}configGroups", _) => __obj.spiritconfigGroups foreach { x => attr = scala.xml.Attribute(__scope.getPrefix("http://www.spiritconsortium.org/XMLSchema/SPIRIT/1685-2009"), "configGroups", x.toString, attr) }
        case ("@{http://www.spiritconsortium.org/XMLSchema/SPIRIT/1685-2009}bitStringLength", _) => __obj.spiritbitStringLength foreach { x => attr = scala.xml.Attribute(__scope.getPrefix("http://www.spiritconsortium.org/XMLSchema/SPIRIT/1685-2009"), "bitStringLength", x.toString, attr) }
        case ("@{http://www.spiritconsortium.org/XMLSchema/SPIRIT/1685-2009}minimum", _) => __obj.spiritminimum foreach { x => attr = scala.xml.Attribute(__scope.getPrefix("http://www.spiritconsortium.org/XMLSchema/SPIRIT/1685-2009"), "minimum", x.toString, attr) }
        case ("@{http://www.spiritconsortium.org/XMLSchema/SPIRIT/1685-2009}maximum", _) => __obj.spiritmaximum foreach { x => attr = scala.xml.Attribute(__scope.getPrefix("http://www.spiritconsortium.org/XMLSchema/SPIRIT/1685-2009"), "maximum", x.toString, attr) }
        case ("@{http://www.spiritconsortium.org/XMLSchema/SPIRIT/1685-2009}rangeType", _) => if (__obj.spiritrangeType.toString != "float") attr = scala.xml.Attribute(__scope.getPrefix("http://www.spiritconsortium.org/XMLSchema/SPIRIT/1685-2009"), "rangeType", __obj.spiritrangeType.toString, attr)
        case ("@{http://www.spiritconsortium.org/XMLSchema/SPIRIT/1685-2009}prompt", _) => __obj.spiritprompt foreach { x => attr = scala.xml.Attribute(__scope.getPrefix("http://www.spiritconsortium.org/XMLSchema/SPIRIT/1685-2009"), "prompt", x.toString, attr) }
        case (key, x) => attr = scala.xml.Attribute((x.namespace map { __scope.getPrefix(_) }).orNull, x.key.orNull, x.value.toString, attr)
      }
      attr
    }

    def writesChildNodes(__obj: Mask2, __scope: scala.xml.NamespaceBinding): Seq[scala.xml.Node] =
      Seq(scala.xml.Text(__obj.value.toString))

  }

  trait Default_Reset2Format extends IPXACT2009scalaxb.ElemNameParser[Reset2] {
    val targetNamespace: Option[String] = Some("http://www.spiritconsortium.org/XMLSchema/SPIRIT/1685-2009")
    
    def parser(node: scala.xml.Node, stack: List[IPXACT2009scalaxb.ElemName]): Parser[Reset2] =
      phrase((IPXACT2009scalaxb.ElemName(Some("http://www.spiritconsortium.org/XMLSchema/SPIRIT/1685-2009"), "value")) ~
      opt(IPXACT2009scalaxb.ElemName(Some("http://www.spiritconsortium.org/XMLSchema/SPIRIT/1685-2009"), "mask")) ^^
      { case p1 ~ p2 =>
      Reset2(IPXACT2009scalaxb.fromXML[Value3](p1, IPXACT2009scalaxb.ElemName(node) :: stack),
        p2.headOption map { IPXACT2009scalaxb.fromXML[Mask2](_, IPXACT2009scalaxb.ElemName(node) :: stack) }) })
    
    def writesChildNodes(__obj: Reset2, __scope: scala.xml.NamespaceBinding): Seq[scala.xml.Node] =
      Seq.concat(IPXACT2009scalaxb.toXML[Value3](__obj.value, Some("http://www.spiritconsortium.org/XMLSchema/SPIRIT/1685-2009"), Some("value"), __scope, false),
        __obj.mask map { IPXACT2009scalaxb.toXML[Mask2](_, Some("http://www.spiritconsortium.org/XMLSchema/SPIRIT/1685-2009"), Some("mask"), __scope, false) } getOrElse {Nil})

  }


/** Alternate register file defnition specific information
*/
  trait _AlternateRegisterDefinitionGroupGroupFormat extends IPXACT2009scalaxb.AnyElemNameParser {
    def parseAlternateRegisterDefinitionGroupGroup(node: scala.xml.Node, stack: List[IPXACT2009scalaxb.ElemName]): Parser[AlternateRegisterDefinitionGroupSequence] =
      ((opt(IPXACT2009scalaxb.ElemName(Some("http://www.spiritconsortium.org/XMLSchema/SPIRIT/1685-2009"), "typeIdentifier")) ~
      opt(IPXACT2009scalaxb.ElemName(Some("http://www.spiritconsortium.org/XMLSchema/SPIRIT/1685-2009"), "volatile")) ~
      opt(IPXACT2009scalaxb.ElemName(Some("http://www.spiritconsortium.org/XMLSchema/SPIRIT/1685-2009"), "access")) ~
      opt(IPXACT2009scalaxb.ElemName(Some("http://www.spiritconsortium.org/XMLSchema/SPIRIT/1685-2009"), "reset")) ~
      safeRep(IPXACT2009scalaxb.ElemName(Some("http://www.spiritconsortium.org/XMLSchema/SPIRIT/1685-2009"), "field"))) ^^
        { case p1 ~ p2 ~ p3 ~ p4 ~ p5 => AlternateRegisterDefinitionGroupSequence(p1.headOption map { IPXACT2009scalaxb.fromXML[String](_, IPXACT2009scalaxb.ElemName(node) :: stack) },
        p2.headOption map { IPXACT2009scalaxb.fromXML[Boolean](_, IPXACT2009scalaxb.ElemName(node) :: stack) },
        p3.headOption map { IPXACT2009scalaxb.fromXML[AccessType](_, IPXACT2009scalaxb.ElemName(node) :: stack) },
        p4.headOption map { IPXACT2009scalaxb.fromXML[Reset2](_, IPXACT2009scalaxb.ElemName(node) :: stack) },
        p5 map { IPXACT2009scalaxb.fromXML[FieldType](_, IPXACT2009scalaxb.ElemName(node) :: stack) }) })
  
    def parseAlternateRegisterDefinitionGroupGroup(node: scala.xml.Node, stack: List[IPXACT2009scalaxb.ElemName], wrap: Boolean): Parser[IPXACT2009scalaxb.DataRecord[Any]] =
      ((opt(IPXACT2009scalaxb.ElemName(Some("http://www.spiritconsortium.org/XMLSchema/SPIRIT/1685-2009"), "typeIdentifier")) ~
      opt(IPXACT2009scalaxb.ElemName(Some("http://www.spiritconsortium.org/XMLSchema/SPIRIT/1685-2009"), "volatile")) ~
      opt(IPXACT2009scalaxb.ElemName(Some("http://www.spiritconsortium.org/XMLSchema/SPIRIT/1685-2009"), "access")) ~
      opt(IPXACT2009scalaxb.ElemName(Some("http://www.spiritconsortium.org/XMLSchema/SPIRIT/1685-2009"), "reset")) ~
      safeRep(IPXACT2009scalaxb.ElemName(Some("http://www.spiritconsortium.org/XMLSchema/SPIRIT/1685-2009"), "field"))) ^^
        { case p1 ~ p2 ~ p3 ~ p4 ~ p5 => IPXACT2009scalaxb.DataRecord(AlternateRegisterDefinitionGroupSequence(p1.headOption map { IPXACT2009scalaxb.fromXML[String](_, IPXACT2009scalaxb.ElemName(node) :: stack) },
        p2.headOption map { IPXACT2009scalaxb.fromXML[Boolean](_, IPXACT2009scalaxb.ElemName(node) :: stack) },
        p3.headOption map { IPXACT2009scalaxb.fromXML[AccessType](_, IPXACT2009scalaxb.ElemName(node) :: stack) },
        p4.headOption map { IPXACT2009scalaxb.fromXML[Reset2](_, IPXACT2009scalaxb.ElemName(node) :: stack) },
        p5 map { IPXACT2009scalaxb.fromXML[FieldType](_, IPXACT2009scalaxb.ElemName(node) :: stack) })) })
    
    def parsemixedAlternateRegisterDefinitionGroupGroup(node: scala.xml.Node, stack: List[IPXACT2009scalaxb.ElemName]): Parser[Seq[IPXACT2009scalaxb.DataRecord[Any]]] =
      (((opt(IPXACT2009scalaxb.ElemName(Some("http://www.spiritconsortium.org/XMLSchema/SPIRIT/1685-2009"), "typeIdentifier")) ^^
      (_ map { x => IPXACT2009scalaxb.DataRecord(x.namespace, Some(x.name), IPXACT2009scalaxb.fromXML[String](x, IPXACT2009scalaxb.ElemName(node) :: stack)) })) ~
      optTextRecord ~ 
      (opt(IPXACT2009scalaxb.ElemName(Some("http://www.spiritconsortium.org/XMLSchema/SPIRIT/1685-2009"), "volatile")) ^^
      (_ map { x => IPXACT2009scalaxb.DataRecord(x.namespace, Some(x.name), IPXACT2009scalaxb.fromXML[Boolean](x, IPXACT2009scalaxb.ElemName(node) :: stack)) })) ~
      optTextRecord ~ 
      (opt(IPXACT2009scalaxb.ElemName(Some("http://www.spiritconsortium.org/XMLSchema/SPIRIT/1685-2009"), "access")) ^^
      (_ map { x => IPXACT2009scalaxb.DataRecord(x.namespace, Some(x.name), IPXACT2009scalaxb.fromXML[AccessType](x, IPXACT2009scalaxb.ElemName(node) :: stack)) })) ~
      optTextRecord ~ 
      (opt(IPXACT2009scalaxb.ElemName(Some("http://www.spiritconsortium.org/XMLSchema/SPIRIT/1685-2009"), "reset")) ^^
      (_ map { x => IPXACT2009scalaxb.DataRecord(x.namespace, Some(x.name), IPXACT2009scalaxb.fromXML[Reset2](x, IPXACT2009scalaxb.ElemName(node) :: stack)) })) ~
      optTextRecord ~ 
      (safeRep(IPXACT2009scalaxb.ElemName(Some("http://www.spiritconsortium.org/XMLSchema/SPIRIT/1685-2009"), "field")) ^^
      (_.toSeq map { x => IPXACT2009scalaxb.DataRecord(x.namespace, Some(x.name), IPXACT2009scalaxb.fromXML[FieldType](x, IPXACT2009scalaxb.ElemName(node) :: stack)) })) ~
      optTextRecord) ^^ 
        { case p1 ~ p2 ~ p3 ~ p4 ~ p5 ~ p6 ~ p7 ~ p8 ~ p9 ~ p10 => Seq.concat(p1.toList,
        p2.toList,
        p3.toList,
        p4.toList,
        p5.toList,
        p6.toList,
        p7.toList,
        p8.toList,
        p9,
        p10.toList) })
  }

  trait Default_AlternateRegisterDefinitionGroupSequenceFormat extends IPXACT2009scalaxb.XMLFormat[AlternateRegisterDefinitionGroupSequence] {
    def reads(seq: scala.xml.NodeSeq, stack: List[IPXACT2009scalaxb.ElemName]): Either[String, AlternateRegisterDefinitionGroupSequence] = Left("don't call me.")
    
    def writes(__obj: AlternateRegisterDefinitionGroupSequence, __namespace: Option[String], __elementLabel: Option[String], 
        __scope: scala.xml.NamespaceBinding, __typeAttribute: Boolean): scala.xml.NodeSeq =
      Seq.concat(__obj.typeIdentifier map { IPXACT2009scalaxb.toXML[String](_, Some("http://www.spiritconsortium.org/XMLSchema/SPIRIT/1685-2009"), Some("typeIdentifier"), __scope, false) } getOrElse {Nil},
        __obj.volatile map { IPXACT2009scalaxb.toXML[Boolean](_, Some("http://www.spiritconsortium.org/XMLSchema/SPIRIT/1685-2009"), Some("volatile"), __scope, false) } getOrElse {Nil},
        __obj.access map { IPXACT2009scalaxb.toXML[AccessType](_, Some("http://www.spiritconsortium.org/XMLSchema/SPIRIT/1685-2009"), Some("access"), __scope, false) } getOrElse {Nil},
        __obj.reset map { IPXACT2009scalaxb.toXML[Reset2](_, Some("http://www.spiritconsortium.org/XMLSchema/SPIRIT/1685-2009"), Some("reset"), __scope, false) } getOrElse {Nil},
        __obj.field flatMap { IPXACT2009scalaxb.toXML[FieldType](_, Some("http://www.spiritconsortium.org/XMLSchema/SPIRIT/1685-2009"), Some("field"), __scope, false) })


  }


/** Address block definition specific information
*/
  trait _AddressBlockDefinitionGroupGroupFormat extends _BlockSizeGroupFormat with _MemoryBlockDataGroupFormat with _RegisterDataGroupFormat {
    def parseAddressBlockDefinitionGroupGroup(node: scala.xml.Node, stack: List[IPXACT2009scalaxb.ElemName]): Parser[AddressBlockDefinitionGroupSequence] =
      ((opt(IPXACT2009scalaxb.ElemName(Some("http://www.spiritconsortium.org/XMLSchema/SPIRIT/1685-2009"), "typeIdentifier")) ~
      (parseBlockSizeGroup(node, IPXACT2009scalaxb.ElemName(node) :: stack)) ~
      (parseMemoryBlockDataGroup(node, IPXACT2009scalaxb.ElemName(node) :: stack)) ~
      (parseRegisterDataGroup(node, IPXACT2009scalaxb.ElemName(node) :: stack))) ^^
        { case p1 ~ p2 ~ p3 ~ p4 => AddressBlockDefinitionGroupSequence(p1.headOption map { IPXACT2009scalaxb.fromXML[String](_, IPXACT2009scalaxb.ElemName(node) :: stack) },
        p2,
        p3,
        p4) })
  
    def parseAddressBlockDefinitionGroupGroup(node: scala.xml.Node, stack: List[IPXACT2009scalaxb.ElemName], wrap: Boolean): Parser[IPXACT2009scalaxb.DataRecord[Any]] =
      ((opt(IPXACT2009scalaxb.ElemName(Some("http://www.spiritconsortium.org/XMLSchema/SPIRIT/1685-2009"), "typeIdentifier")) ~
      (parseBlockSizeGroup(node, IPXACT2009scalaxb.ElemName(node) :: stack)) ~
      (parseMemoryBlockDataGroup(node, IPXACT2009scalaxb.ElemName(node) :: stack)) ~
      (parseRegisterDataGroup(node, IPXACT2009scalaxb.ElemName(node) :: stack))) ^^
        { case p1 ~ p2 ~ p3 ~ p4 => IPXACT2009scalaxb.DataRecord(AddressBlockDefinitionGroupSequence(p1.headOption map { IPXACT2009scalaxb.fromXML[String](_, IPXACT2009scalaxb.ElemName(node) :: stack) },
        p2,
        p3,
        p4)) })
    
    def parsemixedAddressBlockDefinitionGroupGroup(node: scala.xml.Node, stack: List[IPXACT2009scalaxb.ElemName]): Parser[Seq[IPXACT2009scalaxb.DataRecord[Any]]] =
      (((opt(IPXACT2009scalaxb.ElemName(Some("http://www.spiritconsortium.org/XMLSchema/SPIRIT/1685-2009"), "typeIdentifier")) ^^
      (_ map { x => IPXACT2009scalaxb.DataRecord(x.namespace, Some(x.name), IPXACT2009scalaxb.fromXML[String](x, IPXACT2009scalaxb.ElemName(node) :: stack)) })) ~
      optTextRecord ~ 
      (parsemixedBlockSizeGroup(node, IPXACT2009scalaxb.ElemName(node) :: stack)) ~
      optTextRecord ~ 
      (parsemixedMemoryBlockDataGroup(node, IPXACT2009scalaxb.ElemName(node) :: stack)) ~
      optTextRecord ~ 
      (parsemixedRegisterDataGroup(node, IPXACT2009scalaxb.ElemName(node) :: stack)) ~
      optTextRecord) ^^ 
        { case p1 ~ p2 ~ p3 ~ p4 ~ p5 ~ p6 ~ p7 ~ p8 => Seq.concat(p1.toList,
        p2.toList,
        p3,
        p4.toList,
        p5,
        p6.toList,
        p7,
        p8.toList) })
  }

  trait Default_AddressBlockDefinitionGroupSequenceFormat extends IPXACT2009scalaxb.XMLFormat[AddressBlockDefinitionGroupSequence] {
    def reads(seq: scala.xml.NodeSeq, stack: List[IPXACT2009scalaxb.ElemName]): Either[String, AddressBlockDefinitionGroupSequence] = Left("don't call me.")
    
    def writes(__obj: AddressBlockDefinitionGroupSequence, __namespace: Option[String], __elementLabel: Option[String], 
        __scope: scala.xml.NamespaceBinding, __typeAttribute: Boolean): scala.xml.NodeSeq =
      Seq.concat(__obj.typeIdentifier map { IPXACT2009scalaxb.toXML[String](_, Some("http://www.spiritconsortium.org/XMLSchema/SPIRIT/1685-2009"), Some("typeIdentifier"), __scope, false) } getOrElse {Nil},
        IPXACT2009scalaxb.toXML[BlockSizeSequence](__obj.blockSizeSequence2, None, Some("blockSizeSequence2"), __scope, false),
        IPXACT2009scalaxb.toXML[MemoryBlockDataSequence](__obj.memoryBlockDataSequence3, None, Some("memoryBlockDataSequence3"), __scope, false),
        IPXACT2009scalaxb.toXML[RegisterDataSequence](__obj.registerDataSequence4, None, Some("registerDataSequence4"), __scope, false))


  }


/** Field definition specific information
*/
  trait _FieldDefinitionGroupGroupFormat extends _FieldDataGroupFormat {
    def parseFieldDefinitionGroupGroup(node: scala.xml.Node, stack: List[IPXACT2009scalaxb.ElemName]): Parser[FieldDefinitionGroupSequence] =
      ((opt(IPXACT2009scalaxb.ElemName(Some("http://www.spiritconsortium.org/XMLSchema/SPIRIT/1685-2009"), "typeIdentifier")) ~
      (IPXACT2009scalaxb.ElemName(Some("http://www.spiritconsortium.org/XMLSchema/SPIRIT/1685-2009"), "bitWidth")) ~
      (parseFieldDataGroup(node, IPXACT2009scalaxb.ElemName(node) :: stack))) ^^
        { case p1 ~ p2 ~ p3 => FieldDefinitionGroupSequence(p1.headOption map { IPXACT2009scalaxb.fromXML[String](_, IPXACT2009scalaxb.ElemName(node) :: stack) },
        IPXACT2009scalaxb.fromXML[BitWidth](p2, IPXACT2009scalaxb.ElemName(node) :: stack),
        p3) })
  
    def parseFieldDefinitionGroupGroup(node: scala.xml.Node, stack: List[IPXACT2009scalaxb.ElemName], wrap: Boolean): Parser[IPXACT2009scalaxb.DataRecord[Any]] =
      ((opt(IPXACT2009scalaxb.ElemName(Some("http://www.spiritconsortium.org/XMLSchema/SPIRIT/1685-2009"), "typeIdentifier")) ~
      (IPXACT2009scalaxb.ElemName(Some("http://www.spiritconsortium.org/XMLSchema/SPIRIT/1685-2009"), "bitWidth")) ~
      (parseFieldDataGroup(node, IPXACT2009scalaxb.ElemName(node) :: stack))) ^^
        { case p1 ~ p2 ~ p3 => IPXACT2009scalaxb.DataRecord(FieldDefinitionGroupSequence(p1.headOption map { IPXACT2009scalaxb.fromXML[String](_, IPXACT2009scalaxb.ElemName(node) :: stack) },
        IPXACT2009scalaxb.fromXML[BitWidth](p2, IPXACT2009scalaxb.ElemName(node) :: stack),
        p3)) })
    
    def parsemixedFieldDefinitionGroupGroup(node: scala.xml.Node, stack: List[IPXACT2009scalaxb.ElemName]): Parser[Seq[IPXACT2009scalaxb.DataRecord[Any]]] =
      (((opt(IPXACT2009scalaxb.ElemName(Some("http://www.spiritconsortium.org/XMLSchema/SPIRIT/1685-2009"), "typeIdentifier")) ^^
      (_ map { x => IPXACT2009scalaxb.DataRecord(x.namespace, Some(x.name), IPXACT2009scalaxb.fromXML[String](x, IPXACT2009scalaxb.ElemName(node) :: stack)) })) ~
      optTextRecord ~ 
      ((IPXACT2009scalaxb.ElemName(Some("http://www.spiritconsortium.org/XMLSchema/SPIRIT/1685-2009"), "bitWidth")) ^^
      (x => IPXACT2009scalaxb.DataRecord(x.namespace, Some(x.name), IPXACT2009scalaxb.fromXML[BitWidth](x, IPXACT2009scalaxb.ElemName(node) :: stack)))) ~
      optTextRecord ~ 
      (parsemixedFieldDataGroup(node, IPXACT2009scalaxb.ElemName(node) :: stack)) ~
      optTextRecord) ^^ 
        { case p1 ~ p2 ~ p3 ~ p4 ~ p5 ~ p6 => Seq.concat(p1.toList,
        p2.toList,
        Seq(p3),
        p4.toList,
        p5,
        p6.toList) })
  }

  trait Default_FieldDefinitionGroupSequenceFormat extends IPXACT2009scalaxb.XMLFormat[FieldDefinitionGroupSequence] {
    def reads(seq: scala.xml.NodeSeq, stack: List[IPXACT2009scalaxb.ElemName]): Either[String, FieldDefinitionGroupSequence] = Left("don't call me.")
    
    def writes(__obj: FieldDefinitionGroupSequence, __namespace: Option[String], __elementLabel: Option[String], 
        __scope: scala.xml.NamespaceBinding, __typeAttribute: Boolean): scala.xml.NodeSeq =
      Seq.concat(__obj.typeIdentifier map { IPXACT2009scalaxb.toXML[String](_, Some("http://www.spiritconsortium.org/XMLSchema/SPIRIT/1685-2009"), Some("typeIdentifier"), __scope, false) } getOrElse {Nil},
        IPXACT2009scalaxb.toXML[BitWidth](__obj.bitWidth, Some("http://www.spiritconsortium.org/XMLSchema/SPIRIT/1685-2009"), Some("bitWidth"), __scope, false),
        IPXACT2009scalaxb.toXML[FieldDataSequence](__obj.fieldDataSequence3, None, Some("fieldDataSequence3"), __scope, false))


  }


/** This group of optional elements describes the memory mapped registers of an address block
*/
  trait _RegisterDataGroupFormat extends IPXACT2009scalaxb.AnyElemNameParser {
    def parseRegisterDataGroup(node: scala.xml.Node, stack: List[IPXACT2009scalaxb.ElemName]): Parser[RegisterDataSequence] =
      ((safeRep(IPXACT2009scalaxb.ElemName(Some("http://www.spiritconsortium.org/XMLSchema/SPIRIT/1685-2009"), "register")) ~
      safeRep(IPXACT2009scalaxb.ElemName(Some("http://www.spiritconsortium.org/XMLSchema/SPIRIT/1685-2009"), "registerFile"))) ^^
        { case p1 ~ p2 => RegisterDataSequence(p1 map { IPXACT2009scalaxb.fromXML[Register](_, IPXACT2009scalaxb.ElemName(node) :: stack) },
        p2 map { IPXACT2009scalaxb.fromXML[RegisterFile](_, IPXACT2009scalaxb.ElemName(node) :: stack) }) })
  
    def parseRegisterDataGroup(node: scala.xml.Node, stack: List[IPXACT2009scalaxb.ElemName], wrap: Boolean): Parser[IPXACT2009scalaxb.DataRecord[Any]] =
      ((safeRep(IPXACT2009scalaxb.ElemName(Some("http://www.spiritconsortium.org/XMLSchema/SPIRIT/1685-2009"), "register")) ~
      safeRep(IPXACT2009scalaxb.ElemName(Some("http://www.spiritconsortium.org/XMLSchema/SPIRIT/1685-2009"), "registerFile"))) ^^
        { case p1 ~ p2 => IPXACT2009scalaxb.DataRecord(RegisterDataSequence(p1 map { IPXACT2009scalaxb.fromXML[Register](_, IPXACT2009scalaxb.ElemName(node) :: stack) },
        p2 map { IPXACT2009scalaxb.fromXML[RegisterFile](_, IPXACT2009scalaxb.ElemName(node) :: stack) })) })
    
    def parsemixedRegisterDataGroup(node: scala.xml.Node, stack: List[IPXACT2009scalaxb.ElemName]): Parser[Seq[IPXACT2009scalaxb.DataRecord[Any]]] =
      (((safeRep(IPXACT2009scalaxb.ElemName(Some("http://www.spiritconsortium.org/XMLSchema/SPIRIT/1685-2009"), "register")) ^^
      (_.toSeq map { x => IPXACT2009scalaxb.DataRecord(x.namespace, Some(x.name), IPXACT2009scalaxb.fromXML[Register](x, IPXACT2009scalaxb.ElemName(node) :: stack)) })) ~
      optTextRecord ~ 
      (safeRep(IPXACT2009scalaxb.ElemName(Some("http://www.spiritconsortium.org/XMLSchema/SPIRIT/1685-2009"), "registerFile")) ^^
      (_.toSeq map { x => IPXACT2009scalaxb.DataRecord(x.namespace, Some(x.name), IPXACT2009scalaxb.fromXML[RegisterFile](x, IPXACT2009scalaxb.ElemName(node) :: stack)) })) ~
      optTextRecord) ^^ 
        { case p1 ~ p2 ~ p3 ~ p4 => Seq.concat(p1,
        p2.toList,
        p3,
        p4.toList) })
  }

  trait Default_RegisterDataSequenceFormat extends IPXACT2009scalaxb.XMLFormat[RegisterDataSequence] {
    def reads(seq: scala.xml.NodeSeq, stack: List[IPXACT2009scalaxb.ElemName]): Either[String, RegisterDataSequence] = Left("don't call me.")
    
    def writes(__obj: RegisterDataSequence, __namespace: Option[String], __elementLabel: Option[String], 
        __scope: scala.xml.NamespaceBinding, __typeAttribute: Boolean): scala.xml.NodeSeq =
      Seq.concat(__obj.register flatMap { IPXACT2009scalaxb.toXML[Register](_, Some("http://www.spiritconsortium.org/XMLSchema/SPIRIT/1685-2009"), Some("register"), __scope, false) },
        __obj.registerFile flatMap { IPXACT2009scalaxb.toXML[RegisterFile](_, Some("http://www.spiritconsortium.org/XMLSchema/SPIRIT/1685-2009"), Some("registerFile"), __scope, false) })


  }


/** This group of elements describes the number of addressable units and the width of a row of an address block in a memory map.

Note that this is a group, not an element.  It does not appear in the XML, but its contents may.
*/
  trait _BlockSizeGroupFormat extends IPXACT2009scalaxb.AnyElemNameParser {
    def parseBlockSizeGroup(node: scala.xml.Node, stack: List[IPXACT2009scalaxb.ElemName]): Parser[BlockSizeSequence] =
      (((IPXACT2009scalaxb.ElemName(Some("http://www.spiritconsortium.org/XMLSchema/SPIRIT/1685-2009"), "range")) ~
      (IPXACT2009scalaxb.ElemName(Some("http://www.spiritconsortium.org/XMLSchema/SPIRIT/1685-2009"), "width"))) ^^
        { case p1 ~ p2 => BlockSizeSequence(IPXACT2009scalaxb.fromXML[RangeType3](p1, IPXACT2009scalaxb.ElemName(node) :: stack),
        IPXACT2009scalaxb.fromXML[Width](p2, IPXACT2009scalaxb.ElemName(node) :: stack)) })
  
    def parseBlockSizeGroup(node: scala.xml.Node, stack: List[IPXACT2009scalaxb.ElemName], wrap: Boolean): Parser[IPXACT2009scalaxb.DataRecord[Any]] =
      (((IPXACT2009scalaxb.ElemName(Some("http://www.spiritconsortium.org/XMLSchema/SPIRIT/1685-2009"), "range")) ~
      (IPXACT2009scalaxb.ElemName(Some("http://www.spiritconsortium.org/XMLSchema/SPIRIT/1685-2009"), "width"))) ^^
        { case p1 ~ p2 => IPXACT2009scalaxb.DataRecord(BlockSizeSequence(IPXACT2009scalaxb.fromXML[RangeType3](p1, IPXACT2009scalaxb.ElemName(node) :: stack),
        IPXACT2009scalaxb.fromXML[Width](p2, IPXACT2009scalaxb.ElemName(node) :: stack))) })
    
    def parsemixedBlockSizeGroup(node: scala.xml.Node, stack: List[IPXACT2009scalaxb.ElemName]): Parser[Seq[IPXACT2009scalaxb.DataRecord[Any]]] =
      ((((IPXACT2009scalaxb.ElemName(Some("http://www.spiritconsortium.org/XMLSchema/SPIRIT/1685-2009"), "range")) ^^
      (x => IPXACT2009scalaxb.DataRecord(x.namespace, Some(x.name), IPXACT2009scalaxb.fromXML[RangeType3](x, IPXACT2009scalaxb.ElemName(node) :: stack)))) ~
      optTextRecord ~ 
      ((IPXACT2009scalaxb.ElemName(Some("http://www.spiritconsortium.org/XMLSchema/SPIRIT/1685-2009"), "width")) ^^
      (x => IPXACT2009scalaxb.DataRecord(x.namespace, Some(x.name), IPXACT2009scalaxb.fromXML[Width](x, IPXACT2009scalaxb.ElemName(node) :: stack)))) ~
      optTextRecord) ^^ 
        { case p1 ~ p2 ~ p3 ~ p4 => Seq.concat(Seq(p1),
        p2.toList,
        Seq(p3),
        p4.toList) })
  }

  trait Default_BlockSizeSequenceFormat extends IPXACT2009scalaxb.XMLFormat[BlockSizeSequence] {
    def reads(seq: scala.xml.NodeSeq, stack: List[IPXACT2009scalaxb.ElemName]): Either[String, BlockSizeSequence] = Left("don't call me.")
    
    def writes(__obj: BlockSizeSequence, __namespace: Option[String], __elementLabel: Option[String], 
        __scope: scala.xml.NamespaceBinding, __typeAttribute: Boolean): scala.xml.NodeSeq =
      Seq.concat(IPXACT2009scalaxb.toXML[RangeType3](__obj.range, Some("http://www.spiritconsortium.org/XMLSchema/SPIRIT/1685-2009"), Some("range"), __scope, false),
        IPXACT2009scalaxb.toXML[Width](__obj.width, Some("http://www.spiritconsortium.org/XMLSchema/SPIRIT/1685-2009"), Some("width"), __scope, false))


  }


/** This group of elements describes an absolute or relative address of an address block in a memory map.

Note that this is a group, not an element.  It does not appear in the XML, but its contents may.
*/
  trait _AddressSpecifierGroupFormat extends IPXACT2009scalaxb.AnyElemNameParser {
    def parseAddressSpecifierGroup(node: scala.xml.Node, stack: List[IPXACT2009scalaxb.ElemName]): Parser[AddressSpecifierSequence] =
      (((IPXACT2009scalaxb.ElemName(Some("http://www.spiritconsortium.org/XMLSchema/SPIRIT/1685-2009"), "baseAddress"))) ^^
        { case p1 => AddressSpecifierSequence(IPXACT2009scalaxb.fromXML[BaseAddress2](p1, IPXACT2009scalaxb.ElemName(node) :: stack)) })
  
    def parseAddressSpecifierGroup(node: scala.xml.Node, stack: List[IPXACT2009scalaxb.ElemName], wrap: Boolean): Parser[IPXACT2009scalaxb.DataRecord[Any]] =
      (((IPXACT2009scalaxb.ElemName(Some("http://www.spiritconsortium.org/XMLSchema/SPIRIT/1685-2009"), "baseAddress"))) ^^
        { case p1 => IPXACT2009scalaxb.DataRecord(AddressSpecifierSequence(IPXACT2009scalaxb.fromXML[BaseAddress2](p1, IPXACT2009scalaxb.ElemName(node) :: stack))) })
    
    def parsemixedAddressSpecifierGroup(node: scala.xml.Node, stack: List[IPXACT2009scalaxb.ElemName]): Parser[Seq[IPXACT2009scalaxb.DataRecord[Any]]] =
      ((((IPXACT2009scalaxb.ElemName(Some("http://www.spiritconsortium.org/XMLSchema/SPIRIT/1685-2009"), "baseAddress")) ^^
      (x => IPXACT2009scalaxb.DataRecord(x.namespace, Some(x.name), IPXACT2009scalaxb.fromXML[BaseAddress2](x, IPXACT2009scalaxb.ElemName(node) :: stack)))) ~
      optTextRecord) ^^ 
        { case p1 ~ p2 => Seq.concat(Seq(p1),
        p2.toList) })
  }

  trait Default_AddressSpecifierSequenceFormat extends IPXACT2009scalaxb.XMLFormat[AddressSpecifierSequence] {
    def reads(seq: scala.xml.NodeSeq, stack: List[IPXACT2009scalaxb.ElemName]): Either[String, AddressSpecifierSequence] = Left("don't call me.")
    
    def writes(__obj: AddressSpecifierSequence, __namespace: Option[String], __elementLabel: Option[String], 
        __scope: scala.xml.NamespaceBinding, __typeAttribute: Boolean): scala.xml.NodeSeq =
      IPXACT2009scalaxb.toXML[BaseAddress2](__obj.baseAddress, Some("http://www.spiritconsortium.org/XMLSchema/SPIRIT/1685-2009"), Some("baseAddress"), __scope, false)

  }

/** A group elements for a memoryMap
*/
  trait _MemoryMapGroupFormat extends IPXACT2009scalaxb.AnyElemNameParser {
    def parseMemoryMapGroup(node: scala.xml.Node, stack: List[IPXACT2009scalaxb.ElemName]): Parser[IPXACT2009scalaxb.DataRecord[MemoryMapOption]] =
      (((IPXACT2009scalaxb.ElemName(Some("http://www.spiritconsortium.org/XMLSchema/SPIRIT/1685-2009"), "addressBlock")) ^^
      (x => IPXACT2009scalaxb.DataRecord(x.namespace, Some(x.name), IPXACT2009scalaxb.fromXML[AddressBlockType](x, IPXACT2009scalaxb.ElemName(node) :: stack)))) |
      ((IPXACT2009scalaxb.ElemName(Some("http://www.spiritconsortium.org/XMLSchema/SPIRIT/1685-2009"), "bank")) ^^
      (x => IPXACT2009scalaxb.DataRecord(x.namespace, Some(x.name), IPXACT2009scalaxb.fromXML[AddressBankType](x, IPXACT2009scalaxb.ElemName(node) :: stack)))) |
      ((IPXACT2009scalaxb.ElemName(Some("http://www.spiritconsortium.org/XMLSchema/SPIRIT/1685-2009"), "subspaceMap")) ^^
      (x => IPXACT2009scalaxb.DataRecord(x.namespace, Some(x.name), IPXACT2009scalaxb.fromXML[SubspaceRefType](x, IPXACT2009scalaxb.ElemName(node) :: stack)))))
  
    def parseMemoryMapGroup(node: scala.xml.Node, stack: List[IPXACT2009scalaxb.ElemName], wrap: Boolean): Parser[IPXACT2009scalaxb.DataRecord[MemoryMapOption]] =
      (((IPXACT2009scalaxb.ElemName(Some("http://www.spiritconsortium.org/XMLSchema/SPIRIT/1685-2009"), "addressBlock")) ^^
      (x => IPXACT2009scalaxb.DataRecord(x.namespace, Some(x.name), IPXACT2009scalaxb.fromXML[AddressBlockType](x, IPXACT2009scalaxb.ElemName(node) :: stack)))) |
      ((IPXACT2009scalaxb.ElemName(Some("http://www.spiritconsortium.org/XMLSchema/SPIRIT/1685-2009"), "bank")) ^^
      (x => IPXACT2009scalaxb.DataRecord(x.namespace, Some(x.name), IPXACT2009scalaxb.fromXML[AddressBankType](x, IPXACT2009scalaxb.ElemName(node) :: stack)))) |
      ((IPXACT2009scalaxb.ElemName(Some("http://www.spiritconsortium.org/XMLSchema/SPIRIT/1685-2009"), "subspaceMap")) ^^
      (x => IPXACT2009scalaxb.DataRecord(x.namespace, Some(x.name), IPXACT2009scalaxb.fromXML[SubspaceRefType](x, IPXACT2009scalaxb.ElemName(node) :: stack)))))
    
    def parsemixedMemoryMapGroup(node: scala.xml.Node, stack: List[IPXACT2009scalaxb.ElemName]): Parser[Seq[IPXACT2009scalaxb.DataRecord[Any]]] =
      (((((IPXACT2009scalaxb.ElemName(Some("http://www.spiritconsortium.org/XMLSchema/SPIRIT/1685-2009"), "addressBlock")) ^^
      (x => IPXACT2009scalaxb.DataRecord(x.namespace, Some(x.name), IPXACT2009scalaxb.fromXML[AddressBlockType](x, IPXACT2009scalaxb.ElemName(node) :: stack)))) ~
      optTextRecord) ^^ 
        { case p1 ~ p2 => Seq.concat(Seq(p1),
        p2.toList) }) ||| 
      ((((IPXACT2009scalaxb.ElemName(Some("http://www.spiritconsortium.org/XMLSchema/SPIRIT/1685-2009"), "bank")) ^^
      (x => IPXACT2009scalaxb.DataRecord(x.namespace, Some(x.name), IPXACT2009scalaxb.fromXML[AddressBankType](x, IPXACT2009scalaxb.ElemName(node) :: stack)))) ~
      optTextRecord) ^^ 
        { case p1 ~ p2 => Seq.concat(Seq(p1),
        p2.toList) }) ||| 
      ((((IPXACT2009scalaxb.ElemName(Some("http://www.spiritconsortium.org/XMLSchema/SPIRIT/1685-2009"), "subspaceMap")) ^^
      (x => IPXACT2009scalaxb.DataRecord(x.namespace, Some(x.name), IPXACT2009scalaxb.fromXML[SubspaceRefType](x, IPXACT2009scalaxb.ElemName(node) :: stack)))) ~
      optTextRecord) ^^ 
        { case p1 ~ p2 => Seq.concat(Seq(p1),
        p2.toList) }))
  }


/** This is a group of optional elements commonly added to various types of address blocks in a memory map.
*/
  trait _AddressBlockExtensionsGroupFormat extends _MemoryBlockDataGroupFormat with _RegisterDataGroupFormat {
    def parseAddressBlockExtensionsGroup(node: scala.xml.Node, stack: List[IPXACT2009scalaxb.ElemName]): Parser[AddressBlockExtensionsSequence] =
      (((parseMemoryBlockDataGroup(node, IPXACT2009scalaxb.ElemName(node) :: stack)) ~
      (parseRegisterDataGroup(node, IPXACT2009scalaxb.ElemName(node) :: stack))) ^^
        { case p1 ~ p2 => AddressBlockExtensionsSequence(p1,
        p2) })
  
    def parseAddressBlockExtensionsGroup(node: scala.xml.Node, stack: List[IPXACT2009scalaxb.ElemName], wrap: Boolean): Parser[IPXACT2009scalaxb.DataRecord[Any]] =
      (((parseMemoryBlockDataGroup(node, IPXACT2009scalaxb.ElemName(node) :: stack)) ~
      (parseRegisterDataGroup(node, IPXACT2009scalaxb.ElemName(node) :: stack))) ^^
        { case p1 ~ p2 => IPXACT2009scalaxb.DataRecord(AddressBlockExtensionsSequence(p1,
        p2)) })
    
    def parsemixedAddressBlockExtensionsGroup(node: scala.xml.Node, stack: List[IPXACT2009scalaxb.ElemName]): Parser[Seq[IPXACT2009scalaxb.DataRecord[Any]]] =
      (((parsemixedMemoryBlockDataGroup(node, IPXACT2009scalaxb.ElemName(node) :: stack)) ~
      optTextRecord ~ 
      (parsemixedRegisterDataGroup(node, IPXACT2009scalaxb.ElemName(node) :: stack)) ~
      optTextRecord) ^^ 
        { case p1 ~ p2 ~ p3 ~ p4 => Seq.concat(p1,
        p2.toList,
        p3,
        p4.toList) })
  }

  trait Default_AddressBlockExtensionsSequenceFormat extends IPXACT2009scalaxb.XMLFormat[AddressBlockExtensionsSequence] {
    def reads(seq: scala.xml.NodeSeq, stack: List[IPXACT2009scalaxb.ElemName]): Either[String, AddressBlockExtensionsSequence] = Left("don't call me.")
    
    def writes(__obj: AddressBlockExtensionsSequence, __namespace: Option[String], __elementLabel: Option[String], 
        __scope: scala.xml.NamespaceBinding, __typeAttribute: Boolean): scala.xml.NodeSeq =
      Seq.concat(IPXACT2009scalaxb.toXML[MemoryBlockDataSequence](__obj.memoryBlockDataSequence1, None, Some("memoryBlockDataSequence1"), __scope, false),
        IPXACT2009scalaxb.toXML[RegisterDataSequence](__obj.registerDataSequence2, None, Some("registerDataSequence2"), __scope, false))


  }


/** This group of elements is common to top level banks and banked banks.
*/
  trait _BankBaseGroupFormat extends _MemoryBlockDataGroupFormat {
    def parseBankBaseGroup(node: scala.xml.Node, stack: List[IPXACT2009scalaxb.ElemName]): Parser[BankBaseSequence] =
      ((safeRep(((IPXACT2009scalaxb.ElemName(Some("http://www.spiritconsortium.org/XMLSchema/SPIRIT/1685-2009"), "addressBlock")) ^^
      (x => IPXACT2009scalaxb.DataRecord(x.namespace, Some(x.name), IPXACT2009scalaxb.fromXML[BankedBlockType](x, IPXACT2009scalaxb.ElemName(node) :: stack)))) |
      ((IPXACT2009scalaxb.ElemName(Some("http://www.spiritconsortium.org/XMLSchema/SPIRIT/1685-2009"), "bank")) ^^
      (x => IPXACT2009scalaxb.DataRecord(x.namespace, Some(x.name), IPXACT2009scalaxb.fromXML[BankedBankType](x, IPXACT2009scalaxb.ElemName(node) :: stack)))) |
      ((IPXACT2009scalaxb.ElemName(Some("http://www.spiritconsortium.org/XMLSchema/SPIRIT/1685-2009"), "subspaceMap")) ^^
      (x => IPXACT2009scalaxb.DataRecord(x.namespace, Some(x.name), IPXACT2009scalaxb.fromXML[BankedSubspaceType](x, IPXACT2009scalaxb.ElemName(node) :: stack))))) ~
      (parseMemoryBlockDataGroup(node, IPXACT2009scalaxb.ElemName(node) :: stack)) ~
      opt(IPXACT2009scalaxb.ElemName(Some("http://www.spiritconsortium.org/XMLSchema/SPIRIT/1685-2009"), "vendorExtensions"))) ^^
        { case p1 ~ p2 ~ p3 => BankBaseSequence(p1,
        p2,
        p3.headOption map { IPXACT2009scalaxb.fromXML[VendorExtensions](_, IPXACT2009scalaxb.ElemName(node) :: stack) }) })
  
    def parseBankBaseGroup(node: scala.xml.Node, stack: List[IPXACT2009scalaxb.ElemName], wrap: Boolean): Parser[IPXACT2009scalaxb.DataRecord[Any]] =
      ((safeRep(((IPXACT2009scalaxb.ElemName(Some("http://www.spiritconsortium.org/XMLSchema/SPIRIT/1685-2009"), "addressBlock")) ^^
      (x => IPXACT2009scalaxb.DataRecord(x.namespace, Some(x.name), IPXACT2009scalaxb.fromXML[BankedBlockType](x, IPXACT2009scalaxb.ElemName(node) :: stack)))) |
      ((IPXACT2009scalaxb.ElemName(Some("http://www.spiritconsortium.org/XMLSchema/SPIRIT/1685-2009"), "bank")) ^^
      (x => IPXACT2009scalaxb.DataRecord(x.namespace, Some(x.name), IPXACT2009scalaxb.fromXML[BankedBankType](x, IPXACT2009scalaxb.ElemName(node) :: stack)))) |
      ((IPXACT2009scalaxb.ElemName(Some("http://www.spiritconsortium.org/XMLSchema/SPIRIT/1685-2009"), "subspaceMap")) ^^
      (x => IPXACT2009scalaxb.DataRecord(x.namespace, Some(x.name), IPXACT2009scalaxb.fromXML[BankedSubspaceType](x, IPXACT2009scalaxb.ElemName(node) :: stack))))) ~
      (parseMemoryBlockDataGroup(node, IPXACT2009scalaxb.ElemName(node) :: stack)) ~
      opt(IPXACT2009scalaxb.ElemName(Some("http://www.spiritconsortium.org/XMLSchema/SPIRIT/1685-2009"), "vendorExtensions"))) ^^
        { case p1 ~ p2 ~ p3 => IPXACT2009scalaxb.DataRecord(BankBaseSequence(p1,
        p2,
        p3.headOption map { IPXACT2009scalaxb.fromXML[VendorExtensions](_, IPXACT2009scalaxb.ElemName(node) :: stack) })) })
    
    def parsemixedBankBaseGroup(node: scala.xml.Node, stack: List[IPXACT2009scalaxb.ElemName]): Parser[Seq[IPXACT2009scalaxb.DataRecord[Any]]] =
      ((safeRep(((((IPXACT2009scalaxb.ElemName(Some("http://www.spiritconsortium.org/XMLSchema/SPIRIT/1685-2009"), "addressBlock")) ^^
      (x => IPXACT2009scalaxb.DataRecord(x.namespace, Some(x.name), IPXACT2009scalaxb.fromXML[BankedBlockType](x, IPXACT2009scalaxb.ElemName(node) :: stack)))) ~
      optTextRecord) ^^ 
        { case p1 ~ p2 => Seq.concat(Seq(p1),
        p2.toList) }) ||| 
      ((((IPXACT2009scalaxb.ElemName(Some("http://www.spiritconsortium.org/XMLSchema/SPIRIT/1685-2009"), "bank")) ^^
      (x => IPXACT2009scalaxb.DataRecord(x.namespace, Some(x.name), IPXACT2009scalaxb.fromXML[BankedBankType](x, IPXACT2009scalaxb.ElemName(node) :: stack)))) ~
      optTextRecord) ^^ 
        { case p1 ~ p2 => Seq.concat(Seq(p1),
        p2.toList) }) ||| 
      ((((IPXACT2009scalaxb.ElemName(Some("http://www.spiritconsortium.org/XMLSchema/SPIRIT/1685-2009"), "subspaceMap")) ^^
      (x => IPXACT2009scalaxb.DataRecord(x.namespace, Some(x.name), IPXACT2009scalaxb.fromXML[BankedSubspaceType](x, IPXACT2009scalaxb.ElemName(node) :: stack)))) ~
      optTextRecord) ^^ 
        { case p1 ~ p2 => Seq.concat(Seq(p1),
        p2.toList) })) ~ 
      optTextRecord ~ 
      (parsemixedMemoryBlockDataGroup(node, IPXACT2009scalaxb.ElemName(node) :: stack)) ~
      optTextRecord ~ 
      (opt(IPXACT2009scalaxb.ElemName(Some("http://www.spiritconsortium.org/XMLSchema/SPIRIT/1685-2009"), "vendorExtensions")) ^^
      (_ map { x => IPXACT2009scalaxb.DataRecord(x.namespace, Some(x.name), IPXACT2009scalaxb.fromXML[VendorExtensions](x, IPXACT2009scalaxb.ElemName(node) :: stack)) })) ~
      optTextRecord) ^^ 
        { case p1 ~ p2 ~ p3 ~ p4 ~ p5 ~ p6 => Seq.concat(p1.flatten,
        p2.toList,
        p3,
        p4.toList,
        p5.toList,
        p6.toList) })
  }

  trait Default_BankBaseSequenceFormat extends IPXACT2009scalaxb.XMLFormat[BankBaseSequence] {
    def reads(seq: scala.xml.NodeSeq, stack: List[IPXACT2009scalaxb.ElemName]): Either[String, BankBaseSequence] = Left("don't call me.")
    
    def writes(__obj: BankBaseSequence, __namespace: Option[String], __elementLabel: Option[String], 
        __scope: scala.xml.NamespaceBinding, __typeAttribute: Boolean): scala.xml.NodeSeq =
      Seq.concat(__obj.bankbaseoption1 flatMap { x => IPXACT2009scalaxb.toXML[IPXACT2009scalaxb.DataRecord[BankBaseOption1]](x, x.namespace, x.key, __scope, false) },
        IPXACT2009scalaxb.toXML[MemoryBlockDataSequence](__obj.memoryBlockDataSequence2, None, Some("memoryBlockDataSequence2"), __scope, false),
        __obj.vendorExtensions map { IPXACT2009scalaxb.toXML[VendorExtensions](_, Some("http://www.spiritconsortium.org/XMLSchema/SPIRIT/1685-2009"), Some("vendorExtensions"), __scope, false) } getOrElse {Nil})


  }


/** This group of optional elements can be used to provide additional descriptions to an address block or bank.

Note that this is a group, not an element.  It does not appear in the XML, but its contents may.
*/
  trait _MemoryBlockDataGroupFormat extends IPXACT2009scalaxb.AnyElemNameParser {
    def parseMemoryBlockDataGroup(node: scala.xml.Node, stack: List[IPXACT2009scalaxb.ElemName]): Parser[MemoryBlockDataSequence] =
      ((opt(IPXACT2009scalaxb.ElemName(Some("http://www.spiritconsortium.org/XMLSchema/SPIRIT/1685-2009"), "usage")) ~
      opt(IPXACT2009scalaxb.ElemName(Some("http://www.spiritconsortium.org/XMLSchema/SPIRIT/1685-2009"), "volatile")) ~
      opt(IPXACT2009scalaxb.ElemName(Some("http://www.spiritconsortium.org/XMLSchema/SPIRIT/1685-2009"), "access")) ~
      opt(IPXACT2009scalaxb.ElemName(Some("http://www.spiritconsortium.org/XMLSchema/SPIRIT/1685-2009"), "parameters"))) ^^
        { case p1 ~ p2 ~ p3 ~ p4 => MemoryBlockDataSequence(p1.headOption map { IPXACT2009scalaxb.fromXML[UsageType](_, IPXACT2009scalaxb.ElemName(node) :: stack) },
        p2.headOption map { IPXACT2009scalaxb.fromXML[Boolean](_, IPXACT2009scalaxb.ElemName(node) :: stack) },
        p3.headOption map { IPXACT2009scalaxb.fromXML[AccessType](_, IPXACT2009scalaxb.ElemName(node) :: stack) },
        p4.headOption map { IPXACT2009scalaxb.fromXML[Parameters](_, IPXACT2009scalaxb.ElemName(node) :: stack) }) })
  
    def parseMemoryBlockDataGroup(node: scala.xml.Node, stack: List[IPXACT2009scalaxb.ElemName], wrap: Boolean): Parser[IPXACT2009scalaxb.DataRecord[Any]] =
      ((opt(IPXACT2009scalaxb.ElemName(Some("http://www.spiritconsortium.org/XMLSchema/SPIRIT/1685-2009"), "usage")) ~
      opt(IPXACT2009scalaxb.ElemName(Some("http://www.spiritconsortium.org/XMLSchema/SPIRIT/1685-2009"), "volatile")) ~
      opt(IPXACT2009scalaxb.ElemName(Some("http://www.spiritconsortium.org/XMLSchema/SPIRIT/1685-2009"), "access")) ~
      opt(IPXACT2009scalaxb.ElemName(Some("http://www.spiritconsortium.org/XMLSchema/SPIRIT/1685-2009"), "parameters"))) ^^
        { case p1 ~ p2 ~ p3 ~ p4 => IPXACT2009scalaxb.DataRecord(MemoryBlockDataSequence(p1.headOption map { IPXACT2009scalaxb.fromXML[UsageType](_, IPXACT2009scalaxb.ElemName(node) :: stack) },
        p2.headOption map { IPXACT2009scalaxb.fromXML[Boolean](_, IPXACT2009scalaxb.ElemName(node) :: stack) },
        p3.headOption map { IPXACT2009scalaxb.fromXML[AccessType](_, IPXACT2009scalaxb.ElemName(node) :: stack) },
        p4.headOption map { IPXACT2009scalaxb.fromXML[Parameters](_, IPXACT2009scalaxb.ElemName(node) :: stack) })) })
    
    def parsemixedMemoryBlockDataGroup(node: scala.xml.Node, stack: List[IPXACT2009scalaxb.ElemName]): Parser[Seq[IPXACT2009scalaxb.DataRecord[Any]]] =
      (((opt(IPXACT2009scalaxb.ElemName(Some("http://www.spiritconsortium.org/XMLSchema/SPIRIT/1685-2009"), "usage")) ^^
      (_ map { x => IPXACT2009scalaxb.DataRecord(x.namespace, Some(x.name), IPXACT2009scalaxb.fromXML[String](x, IPXACT2009scalaxb.ElemName(node) :: stack)) })) ~
      optTextRecord ~ 
      (opt(IPXACT2009scalaxb.ElemName(Some("http://www.spiritconsortium.org/XMLSchema/SPIRIT/1685-2009"), "volatile")) ^^
      (_ map { x => IPXACT2009scalaxb.DataRecord(x.namespace, Some(x.name), IPXACT2009scalaxb.fromXML[Boolean](x, IPXACT2009scalaxb.ElemName(node) :: stack)) })) ~
      optTextRecord ~ 
      (opt(IPXACT2009scalaxb.ElemName(Some("http://www.spiritconsortium.org/XMLSchema/SPIRIT/1685-2009"), "access")) ^^
      (_ map { x => IPXACT2009scalaxb.DataRecord(x.namespace, Some(x.name), IPXACT2009scalaxb.fromXML[AccessType](x, IPXACT2009scalaxb.ElemName(node) :: stack)) })) ~
      optTextRecord ~ 
      (opt(IPXACT2009scalaxb.ElemName(Some("http://www.spiritconsortium.org/XMLSchema/SPIRIT/1685-2009"), "parameters")) ^^
      (_ map { x => IPXACT2009scalaxb.DataRecord(x.namespace, Some(x.name), IPXACT2009scalaxb.fromXML[Parameters](x, IPXACT2009scalaxb.ElemName(node) :: stack)) })) ~
      optTextRecord) ^^ 
        { case p1 ~ p2 ~ p3 ~ p4 ~ p5 ~ p6 ~ p7 ~ p8 => Seq.concat(p1.toList,
        p2.toList,
        p3.toList,
        p4.toList,
        p5.toList,
        p6.toList,
        p7.toList,
        p8.toList) })
  }

  trait Default_MemoryBlockDataSequenceFormat extends IPXACT2009scalaxb.XMLFormat[MemoryBlockDataSequence] {
    def reads(seq: scala.xml.NodeSeq, stack: List[IPXACT2009scalaxb.ElemName]): Either[String, MemoryBlockDataSequence] = Left("don't call me.")
    
    def writes(__obj: MemoryBlockDataSequence, __namespace: Option[String], __elementLabel: Option[String], 
        __scope: scala.xml.NamespaceBinding, __typeAttribute: Boolean): scala.xml.NodeSeq =
      Seq.concat(__obj.usage map { IPXACT2009scalaxb.toXML[UsageType](_, Some("http://www.spiritconsortium.org/XMLSchema/SPIRIT/1685-2009"), Some("usage"), __scope, false) } getOrElse {Nil},
        __obj.volatile map { IPXACT2009scalaxb.toXML[Boolean](_, Some("http://www.spiritconsortium.org/XMLSchema/SPIRIT/1685-2009"), Some("volatile"), __scope, false) } getOrElse {Nil},
        __obj.access map { IPXACT2009scalaxb.toXML[AccessType](_, Some("http://www.spiritconsortium.org/XMLSchema/SPIRIT/1685-2009"), Some("access"), __scope, false) } getOrElse {Nil},
        __obj.parameters map { IPXACT2009scalaxb.toXML[Parameters](_, Some("http://www.spiritconsortium.org/XMLSchema/SPIRIT/1685-2009"), Some("parameters"), __scope, false) } getOrElse {Nil})


  }


/** Additional field data
*/
  trait _FieldDataGroupFormat extends IPXACT2009scalaxb.AnyElemNameParser {
    def parseFieldDataGroup(node: scala.xml.Node, stack: List[IPXACT2009scalaxb.ElemName]): Parser[FieldDataSequence] =
      ((opt(IPXACT2009scalaxb.ElemName(Some("http://www.spiritconsortium.org/XMLSchema/SPIRIT/1685-2009"), "volatile")) ~
      opt(IPXACT2009scalaxb.ElemName(Some("http://www.spiritconsortium.org/XMLSchema/SPIRIT/1685-2009"), "access")) ~
      opt(IPXACT2009scalaxb.ElemName(Some("http://www.spiritconsortium.org/XMLSchema/SPIRIT/1685-2009"), "enumeratedValues")) ~
      opt(IPXACT2009scalaxb.ElemName(Some("http://www.spiritconsortium.org/XMLSchema/SPIRIT/1685-2009"), "modifiedWriteValue")) ~
      opt(IPXACT2009scalaxb.ElemName(Some("http://www.spiritconsortium.org/XMLSchema/SPIRIT/1685-2009"), "writeValueConstraint")) ~
      opt(IPXACT2009scalaxb.ElemName(Some("http://www.spiritconsortium.org/XMLSchema/SPIRIT/1685-2009"), "readAction")) ~
      opt(IPXACT2009scalaxb.ElemName(Some("http://www.spiritconsortium.org/XMLSchema/SPIRIT/1685-2009"), "testable"))) ^^
        { case p1 ~ p2 ~ p3 ~ p4 ~ p5 ~ p6 ~ p7 => FieldDataSequence(p1.headOption map { IPXACT2009scalaxb.fromXML[Boolean](_, IPXACT2009scalaxb.ElemName(node) :: stack) },
        p2.headOption map { IPXACT2009scalaxb.fromXML[AccessType](_, IPXACT2009scalaxb.ElemName(node) :: stack) },
        p3.headOption map { IPXACT2009scalaxb.fromXML[EnumeratedValues](_, IPXACT2009scalaxb.ElemName(node) :: stack) },
        p4.headOption map { IPXACT2009scalaxb.fromXML[ModifiedWriteValue](_, IPXACT2009scalaxb.ElemName(node) :: stack) },
        p5.headOption map { IPXACT2009scalaxb.fromXML[WriteValueConstraintType](_, IPXACT2009scalaxb.ElemName(node) :: stack) },
        p6.headOption map { IPXACT2009scalaxb.fromXML[ReadAction](_, IPXACT2009scalaxb.ElemName(node) :: stack) },
        p7.headOption map { IPXACT2009scalaxb.fromXML[Testable](_, IPXACT2009scalaxb.ElemName(node) :: stack) }) })
  
    def parseFieldDataGroup(node: scala.xml.Node, stack: List[IPXACT2009scalaxb.ElemName], wrap: Boolean): Parser[IPXACT2009scalaxb.DataRecord[Any]] =
      ((opt(IPXACT2009scalaxb.ElemName(Some("http://www.spiritconsortium.org/XMLSchema/SPIRIT/1685-2009"), "volatile")) ~
      opt(IPXACT2009scalaxb.ElemName(Some("http://www.spiritconsortium.org/XMLSchema/SPIRIT/1685-2009"), "access")) ~
      opt(IPXACT2009scalaxb.ElemName(Some("http://www.spiritconsortium.org/XMLSchema/SPIRIT/1685-2009"), "enumeratedValues")) ~
      opt(IPXACT2009scalaxb.ElemName(Some("http://www.spiritconsortium.org/XMLSchema/SPIRIT/1685-2009"), "modifiedWriteValue")) ~
      opt(IPXACT2009scalaxb.ElemName(Some("http://www.spiritconsortium.org/XMLSchema/SPIRIT/1685-2009"), "writeValueConstraint")) ~
      opt(IPXACT2009scalaxb.ElemName(Some("http://www.spiritconsortium.org/XMLSchema/SPIRIT/1685-2009"), "readAction")) ~
      opt(IPXACT2009scalaxb.ElemName(Some("http://www.spiritconsortium.org/XMLSchema/SPIRIT/1685-2009"), "testable"))) ^^
        { case p1 ~ p2 ~ p3 ~ p4 ~ p5 ~ p6 ~ p7 => IPXACT2009scalaxb.DataRecord(FieldDataSequence(p1.headOption map { IPXACT2009scalaxb.fromXML[Boolean](_, IPXACT2009scalaxb.ElemName(node) :: stack) },
        p2.headOption map { IPXACT2009scalaxb.fromXML[AccessType](_, IPXACT2009scalaxb.ElemName(node) :: stack) },
        p3.headOption map { IPXACT2009scalaxb.fromXML[EnumeratedValues](_, IPXACT2009scalaxb.ElemName(node) :: stack) },
        p4.headOption map { IPXACT2009scalaxb.fromXML[ModifiedWriteValue](_, IPXACT2009scalaxb.ElemName(node) :: stack) },
        p5.headOption map { IPXACT2009scalaxb.fromXML[WriteValueConstraintType](_, IPXACT2009scalaxb.ElemName(node) :: stack) },
        p6.headOption map { IPXACT2009scalaxb.fromXML[ReadAction](_, IPXACT2009scalaxb.ElemName(node) :: stack) },
        p7.headOption map { IPXACT2009scalaxb.fromXML[Testable](_, IPXACT2009scalaxb.ElemName(node) :: stack) })) })
    
    def parsemixedFieldDataGroup(node: scala.xml.Node, stack: List[IPXACT2009scalaxb.ElemName]): Parser[Seq[IPXACT2009scalaxb.DataRecord[Any]]] =
      (((opt(IPXACT2009scalaxb.ElemName(Some("http://www.spiritconsortium.org/XMLSchema/SPIRIT/1685-2009"), "volatile")) ^^
      (_ map { x => IPXACT2009scalaxb.DataRecord(x.namespace, Some(x.name), IPXACT2009scalaxb.fromXML[Boolean](x, IPXACT2009scalaxb.ElemName(node) :: stack)) })) ~
      optTextRecord ~ 
      (opt(IPXACT2009scalaxb.ElemName(Some("http://www.spiritconsortium.org/XMLSchema/SPIRIT/1685-2009"), "access")) ^^
      (_ map { x => IPXACT2009scalaxb.DataRecord(x.namespace, Some(x.name), IPXACT2009scalaxb.fromXML[AccessType](x, IPXACT2009scalaxb.ElemName(node) :: stack)) })) ~
      optTextRecord ~ 
      (opt(IPXACT2009scalaxb.ElemName(Some("http://www.spiritconsortium.org/XMLSchema/SPIRIT/1685-2009"), "enumeratedValues")) ^^
      (_ map { x => IPXACT2009scalaxb.DataRecord(x.namespace, Some(x.name), IPXACT2009scalaxb.fromXML[EnumeratedValues](x, IPXACT2009scalaxb.ElemName(node) :: stack)) })) ~
      optTextRecord ~ 
      (opt(IPXACT2009scalaxb.ElemName(Some("http://www.spiritconsortium.org/XMLSchema/SPIRIT/1685-2009"), "modifiedWriteValue")) ^^
      (_ map { x => IPXACT2009scalaxb.DataRecord(x.namespace, Some(x.name), IPXACT2009scalaxb.fromXML[String](x, IPXACT2009scalaxb.ElemName(node) :: stack)) })) ~
      optTextRecord ~ 
      (opt(IPXACT2009scalaxb.ElemName(Some("http://www.spiritconsortium.org/XMLSchema/SPIRIT/1685-2009"), "writeValueConstraint")) ^^
      (_ map { x => IPXACT2009scalaxb.DataRecord(x.namespace, Some(x.name), IPXACT2009scalaxb.fromXML[WriteValueConstraintType](x, IPXACT2009scalaxb.ElemName(node) :: stack)) })) ~
      optTextRecord ~ 
      (opt(IPXACT2009scalaxb.ElemName(Some("http://www.spiritconsortium.org/XMLSchema/SPIRIT/1685-2009"), "readAction")) ^^
      (_ map { x => IPXACT2009scalaxb.DataRecord(x.namespace, Some(x.name), IPXACT2009scalaxb.fromXML[String](x, IPXACT2009scalaxb.ElemName(node) :: stack)) })) ~
      optTextRecord ~ 
      (opt(IPXACT2009scalaxb.ElemName(Some("http://www.spiritconsortium.org/XMLSchema/SPIRIT/1685-2009"), "testable")) ^^
      (_ map { x => IPXACT2009scalaxb.DataRecord(x.namespace, Some(x.name), IPXACT2009scalaxb.fromXML[Testable](x, IPXACT2009scalaxb.ElemName(node) :: stack)) })) ~
      optTextRecord) ^^ 
        { case p1 ~ p2 ~ p3 ~ p4 ~ p5 ~ p6 ~ p7 ~ p8 ~ p9 ~ p10 ~ p11 ~ p12 ~ p13 ~ p14 => Seq.concat(p1.toList,
        p2.toList,
        p3.toList,
        p4.toList,
        p5.toList,
        p6.toList,
        p7.toList,
        p8.toList,
        p9.toList,
        p10.toList,
        p11.toList,
        p12.toList,
        p13.toList,
        p14.toList) })
  }

  trait Default_FieldDataSequenceFormat extends IPXACT2009scalaxb.XMLFormat[FieldDataSequence] {
    def reads(seq: scala.xml.NodeSeq, stack: List[IPXACT2009scalaxb.ElemName]): Either[String, FieldDataSequence] = Left("don't call me.")
    
    def writes(__obj: FieldDataSequence, __namespace: Option[String], __elementLabel: Option[String], 
        __scope: scala.xml.NamespaceBinding, __typeAttribute: Boolean): scala.xml.NodeSeq =
      Seq.concat(__obj.volatile map { IPXACT2009scalaxb.toXML[Boolean](_, Some("http://www.spiritconsortium.org/XMLSchema/SPIRIT/1685-2009"), Some("volatile"), __scope, false) } getOrElse {Nil},
        __obj.access map { IPXACT2009scalaxb.toXML[AccessType](_, Some("http://www.spiritconsortium.org/XMLSchema/SPIRIT/1685-2009"), Some("access"), __scope, false) } getOrElse {Nil},
        __obj.enumeratedValues map { IPXACT2009scalaxb.toXML[EnumeratedValues](_, Some("http://www.spiritconsortium.org/XMLSchema/SPIRIT/1685-2009"), Some("enumeratedValues"), __scope, false) } getOrElse {Nil},
        __obj.modifiedWriteValue map { IPXACT2009scalaxb.toXML[ModifiedWriteValue](_, Some("http://www.spiritconsortium.org/XMLSchema/SPIRIT/1685-2009"), Some("modifiedWriteValue"), __scope, false) } getOrElse {Nil},
        __obj.writeValueConstraint map { IPXACT2009scalaxb.toXML[WriteValueConstraintType](_, Some("http://www.spiritconsortium.org/XMLSchema/SPIRIT/1685-2009"), Some("writeValueConstraint"), __scope, false) } getOrElse {Nil},
        __obj.readAction map { IPXACT2009scalaxb.toXML[ReadAction](_, Some("http://www.spiritconsortium.org/XMLSchema/SPIRIT/1685-2009"), Some("readAction"), __scope, false) } getOrElse {Nil},
        __obj.testable map { IPXACT2009scalaxb.toXML[Testable](_, Some("http://www.spiritconsortium.org/XMLSchema/SPIRIT/1685-2009"), Some("testable"), __scope, false) } getOrElse {Nil})


  }


/** Register file defnition specific information
*/
  trait _RegisterFileDefinitionGroupGroupFormat extends _RegisterDataGroupFormat {
    def parseRegisterFileDefinitionGroupGroup(node: scala.xml.Node, stack: List[IPXACT2009scalaxb.ElemName]): Parser[RegisterFileDefinitionGroupSequence] =
      ((opt(IPXACT2009scalaxb.ElemName(Some("http://www.spiritconsortium.org/XMLSchema/SPIRIT/1685-2009"), "typeIdentifier")) ~
      (IPXACT2009scalaxb.ElemName(Some("http://www.spiritconsortium.org/XMLSchema/SPIRIT/1685-2009"), "range")) ~
      (parseRegisterDataGroup(node, IPXACT2009scalaxb.ElemName(node) :: stack))) ^^
        { case p1 ~ p2 ~ p3 => RegisterFileDefinitionGroupSequence(p1.headOption map { IPXACT2009scalaxb.fromXML[String](_, IPXACT2009scalaxb.ElemName(node) :: stack) },
        IPXACT2009scalaxb.fromXML[RangeType4](p2, IPXACT2009scalaxb.ElemName(node) :: stack),
        p3) })
  
    def parseRegisterFileDefinitionGroupGroup(node: scala.xml.Node, stack: List[IPXACT2009scalaxb.ElemName], wrap: Boolean): Parser[IPXACT2009scalaxb.DataRecord[Any]] =
      ((opt(IPXACT2009scalaxb.ElemName(Some("http://www.spiritconsortium.org/XMLSchema/SPIRIT/1685-2009"), "typeIdentifier")) ~
      (IPXACT2009scalaxb.ElemName(Some("http://www.spiritconsortium.org/XMLSchema/SPIRIT/1685-2009"), "range")) ~
      (parseRegisterDataGroup(node, IPXACT2009scalaxb.ElemName(node) :: stack))) ^^
        { case p1 ~ p2 ~ p3 => IPXACT2009scalaxb.DataRecord(RegisterFileDefinitionGroupSequence(p1.headOption map { IPXACT2009scalaxb.fromXML[String](_, IPXACT2009scalaxb.ElemName(node) :: stack) },
        IPXACT2009scalaxb.fromXML[RangeType4](p2, IPXACT2009scalaxb.ElemName(node) :: stack),
        p3)) })
    
    def parsemixedRegisterFileDefinitionGroupGroup(node: scala.xml.Node, stack: List[IPXACT2009scalaxb.ElemName]): Parser[Seq[IPXACT2009scalaxb.DataRecord[Any]]] =
      (((opt(IPXACT2009scalaxb.ElemName(Some("http://www.spiritconsortium.org/XMLSchema/SPIRIT/1685-2009"), "typeIdentifier")) ^^
      (_ map { x => IPXACT2009scalaxb.DataRecord(x.namespace, Some(x.name), IPXACT2009scalaxb.fromXML[String](x, IPXACT2009scalaxb.ElemName(node) :: stack)) })) ~
      optTextRecord ~ 
      ((IPXACT2009scalaxb.ElemName(Some("http://www.spiritconsortium.org/XMLSchema/SPIRIT/1685-2009"), "range")) ^^
      (x => IPXACT2009scalaxb.DataRecord(x.namespace, Some(x.name), IPXACT2009scalaxb.fromXML[RangeType4](x, IPXACT2009scalaxb.ElemName(node) :: stack)))) ~
      optTextRecord ~ 
      (parsemixedRegisterDataGroup(node, IPXACT2009scalaxb.ElemName(node) :: stack)) ~
      optTextRecord) ^^ 
        { case p1 ~ p2 ~ p3 ~ p4 ~ p5 ~ p6 => Seq.concat(p1.toList,
        p2.toList,
        Seq(p3),
        p4.toList,
        p5,
        p6.toList) })
  }

  trait Default_RegisterFileDefinitionGroupSequenceFormat extends IPXACT2009scalaxb.XMLFormat[RegisterFileDefinitionGroupSequence] {
    def reads(seq: scala.xml.NodeSeq, stack: List[IPXACT2009scalaxb.ElemName]): Either[String, RegisterFileDefinitionGroupSequence] = Left("don't call me.")
    
    def writes(__obj: RegisterFileDefinitionGroupSequence, __namespace: Option[String], __elementLabel: Option[String], 
        __scope: scala.xml.NamespaceBinding, __typeAttribute: Boolean): scala.xml.NodeSeq =
      Seq.concat(__obj.typeIdentifier map { IPXACT2009scalaxb.toXML[String](_, Some("http://www.spiritconsortium.org/XMLSchema/SPIRIT/1685-2009"), Some("typeIdentifier"), __scope, false) } getOrElse {Nil},
        IPXACT2009scalaxb.toXML[RangeType4](__obj.range, Some("http://www.spiritconsortium.org/XMLSchema/SPIRIT/1685-2009"), Some("range"), __scope, false),
        IPXACT2009scalaxb.toXML[RegisterDataSequence](__obj.registerDataSequence3, None, Some("registerDataSequence3"), __scope, false))


  }


/** Register definition specific information
*/
  trait _RegisterDefinitionGroupGroupFormat extends IPXACT2009scalaxb.AnyElemNameParser {
    def parseRegisterDefinitionGroupGroup(node: scala.xml.Node, stack: List[IPXACT2009scalaxb.ElemName]): Parser[RegisterDefinitionGroupSequence] =
      ((opt(IPXACT2009scalaxb.ElemName(Some("http://www.spiritconsortium.org/XMLSchema/SPIRIT/1685-2009"), "typeIdentifier")) ~
      (IPXACT2009scalaxb.ElemName(Some("http://www.spiritconsortium.org/XMLSchema/SPIRIT/1685-2009"), "size")) ~
      opt(IPXACT2009scalaxb.ElemName(Some("http://www.spiritconsortium.org/XMLSchema/SPIRIT/1685-2009"), "volatile")) ~
      opt(IPXACT2009scalaxb.ElemName(Some("http://www.spiritconsortium.org/XMLSchema/SPIRIT/1685-2009"), "access")) ~
      opt(IPXACT2009scalaxb.ElemName(Some("http://www.spiritconsortium.org/XMLSchema/SPIRIT/1685-2009"), "reset")) ~
      safeRep(IPXACT2009scalaxb.ElemName(Some("http://www.spiritconsortium.org/XMLSchema/SPIRIT/1685-2009"), "field"))) ^^
        { case p1 ~ p2 ~ p3 ~ p4 ~ p5 ~ p6 => RegisterDefinitionGroupSequence(p1.headOption map { IPXACT2009scalaxb.fromXML[String](_, IPXACT2009scalaxb.ElemName(node) :: stack) },
        IPXACT2009scalaxb.fromXML[Size](p2, IPXACT2009scalaxb.ElemName(node) :: stack),
        p3.headOption map { IPXACT2009scalaxb.fromXML[Boolean](_, IPXACT2009scalaxb.ElemName(node) :: stack) },
        p4.headOption map { IPXACT2009scalaxb.fromXML[AccessType](_, IPXACT2009scalaxb.ElemName(node) :: stack) },
        p5.headOption map { IPXACT2009scalaxb.fromXML[Reset](_, IPXACT2009scalaxb.ElemName(node) :: stack) },
        p6 map { IPXACT2009scalaxb.fromXML[FieldType](_, IPXACT2009scalaxb.ElemName(node) :: stack) }) })
  
    def parseRegisterDefinitionGroupGroup(node: scala.xml.Node, stack: List[IPXACT2009scalaxb.ElemName], wrap: Boolean): Parser[IPXACT2009scalaxb.DataRecord[Any]] =
      ((opt(IPXACT2009scalaxb.ElemName(Some("http://www.spiritconsortium.org/XMLSchema/SPIRIT/1685-2009"), "typeIdentifier")) ~
      (IPXACT2009scalaxb.ElemName(Some("http://www.spiritconsortium.org/XMLSchema/SPIRIT/1685-2009"), "size")) ~
      opt(IPXACT2009scalaxb.ElemName(Some("http://www.spiritconsortium.org/XMLSchema/SPIRIT/1685-2009"), "volatile")) ~
      opt(IPXACT2009scalaxb.ElemName(Some("http://www.spiritconsortium.org/XMLSchema/SPIRIT/1685-2009"), "access")) ~
      opt(IPXACT2009scalaxb.ElemName(Some("http://www.spiritconsortium.org/XMLSchema/SPIRIT/1685-2009"), "reset")) ~
      safeRep(IPXACT2009scalaxb.ElemName(Some("http://www.spiritconsortium.org/XMLSchema/SPIRIT/1685-2009"), "field"))) ^^
        { case p1 ~ p2 ~ p3 ~ p4 ~ p5 ~ p6 => IPXACT2009scalaxb.DataRecord(RegisterDefinitionGroupSequence(p1.headOption map { IPXACT2009scalaxb.fromXML[String](_, IPXACT2009scalaxb.ElemName(node) :: stack) },
        IPXACT2009scalaxb.fromXML[Size](p2, IPXACT2009scalaxb.ElemName(node) :: stack),
        p3.headOption map { IPXACT2009scalaxb.fromXML[Boolean](_, IPXACT2009scalaxb.ElemName(node) :: stack) },
        p4.headOption map { IPXACT2009scalaxb.fromXML[AccessType](_, IPXACT2009scalaxb.ElemName(node) :: stack) },
        p5.headOption map { IPXACT2009scalaxb.fromXML[Reset](_, IPXACT2009scalaxb.ElemName(node) :: stack) },
        p6 map { IPXACT2009scalaxb.fromXML[FieldType](_, IPXACT2009scalaxb.ElemName(node) :: stack) })) })
    
    def parsemixedRegisterDefinitionGroupGroup(node: scala.xml.Node, stack: List[IPXACT2009scalaxb.ElemName]): Parser[Seq[IPXACT2009scalaxb.DataRecord[Any]]] =
      (((opt(IPXACT2009scalaxb.ElemName(Some("http://www.spiritconsortium.org/XMLSchema/SPIRIT/1685-2009"), "typeIdentifier")) ^^
      (_ map { x => IPXACT2009scalaxb.DataRecord(x.namespace, Some(x.name), IPXACT2009scalaxb.fromXML[String](x, IPXACT2009scalaxb.ElemName(node) :: stack)) })) ~
      optTextRecord ~ 
      ((IPXACT2009scalaxb.ElemName(Some("http://www.spiritconsortium.org/XMLSchema/SPIRIT/1685-2009"), "size")) ^^
      (x => IPXACT2009scalaxb.DataRecord(x.namespace, Some(x.name), IPXACT2009scalaxb.fromXML[Size](x, IPXACT2009scalaxb.ElemName(node) :: stack)))) ~
      optTextRecord ~ 
      (opt(IPXACT2009scalaxb.ElemName(Some("http://www.spiritconsortium.org/XMLSchema/SPIRIT/1685-2009"), "volatile")) ^^
      (_ map { x => IPXACT2009scalaxb.DataRecord(x.namespace, Some(x.name), IPXACT2009scalaxb.fromXML[Boolean](x, IPXACT2009scalaxb.ElemName(node) :: stack)) })) ~
      optTextRecord ~ 
      (opt(IPXACT2009scalaxb.ElemName(Some("http://www.spiritconsortium.org/XMLSchema/SPIRIT/1685-2009"), "access")) ^^
      (_ map { x => IPXACT2009scalaxb.DataRecord(x.namespace, Some(x.name), IPXACT2009scalaxb.fromXML[AccessType](x, IPXACT2009scalaxb.ElemName(node) :: stack)) })) ~
      optTextRecord ~ 
      (opt(IPXACT2009scalaxb.ElemName(Some("http://www.spiritconsortium.org/XMLSchema/SPIRIT/1685-2009"), "reset")) ^^
      (_ map { x => IPXACT2009scalaxb.DataRecord(x.namespace, Some(x.name), IPXACT2009scalaxb.fromXML[Reset](x, IPXACT2009scalaxb.ElemName(node) :: stack)) })) ~
      optTextRecord ~ 
      (safeRep(IPXACT2009scalaxb.ElemName(Some("http://www.spiritconsortium.org/XMLSchema/SPIRIT/1685-2009"), "field")) ^^
      (_.toSeq map { x => IPXACT2009scalaxb.DataRecord(x.namespace, Some(x.name), IPXACT2009scalaxb.fromXML[FieldType](x, IPXACT2009scalaxb.ElemName(node) :: stack)) })) ~
      optTextRecord) ^^ 
        { case p1 ~ p2 ~ p3 ~ p4 ~ p5 ~ p6 ~ p7 ~ p8 ~ p9 ~ p10 ~ p11 ~ p12 => Seq.concat(p1.toList,
        p2.toList,
        Seq(p3),
        p4.toList,
        p5.toList,
        p6.toList,
        p7.toList,
        p8.toList,
        p9.toList,
        p10.toList,
        p11,
        p12.toList) })
  }

  trait Default_RegisterDefinitionGroupSequenceFormat extends IPXACT2009scalaxb.XMLFormat[RegisterDefinitionGroupSequence] {
    def reads(seq: scala.xml.NodeSeq, stack: List[IPXACT2009scalaxb.ElemName]): Either[String, RegisterDefinitionGroupSequence] = Left("don't call me.")
    
    def writes(__obj: RegisterDefinitionGroupSequence, __namespace: Option[String], __elementLabel: Option[String], 
        __scope: scala.xml.NamespaceBinding, __typeAttribute: Boolean): scala.xml.NodeSeq =
      Seq.concat(__obj.typeIdentifier map { IPXACT2009scalaxb.toXML[String](_, Some("http://www.spiritconsortium.org/XMLSchema/SPIRIT/1685-2009"), Some("typeIdentifier"), __scope, false) } getOrElse {Nil},
        IPXACT2009scalaxb.toXML[Size](__obj.size, Some("http://www.spiritconsortium.org/XMLSchema/SPIRIT/1685-2009"), Some("size"), __scope, false),
        __obj.volatile map { IPXACT2009scalaxb.toXML[Boolean](_, Some("http://www.spiritconsortium.org/XMLSchema/SPIRIT/1685-2009"), Some("volatile"), __scope, false) } getOrElse {Nil},
        __obj.access map { IPXACT2009scalaxb.toXML[AccessType](_, Some("http://www.spiritconsortium.org/XMLSchema/SPIRIT/1685-2009"), Some("access"), __scope, false) } getOrElse {Nil},
        __obj.reset map { IPXACT2009scalaxb.toXML[Reset](_, Some("http://www.spiritconsortium.org/XMLSchema/SPIRIT/1685-2009"), Some("reset"), __scope, false) } getOrElse {Nil},
        __obj.field flatMap { IPXACT2009scalaxb.toXML[FieldType](_, Some("http://www.spiritconsortium.org/XMLSchema/SPIRIT/1685-2009"), Some("field"), __scope, false) })


  }

  trait Default_LanguageFormat extends IPXACT2009scalaxb.XMLFormat[Language] with IPXACT2009scalaxb.CanWriteChildNodes[Language] {
    val targetNamespace: Option[String] = Some("http://www.spiritconsortium.org/XMLSchema/SPIRIT/1685-2009")
    def reads(seq: scala.xml.NodeSeq, stack: List[IPXACT2009scalaxb.ElemName]): Either[String, Language] = seq match {
      case node: scala.xml.Node => Right(Language(IPXACT2009scalaxb.fromXML[String](node, IPXACT2009scalaxb.ElemName(node) :: stack),
        scala.collection.immutable.ListMap(List(
        (node \ "@{http://www.spiritconsortium.org/XMLSchema/SPIRIT/1685-2009}strict").headOption map { x => IPXACT2009scalaxb.DataRecord(x, node, IPXACT2009scalaxb.fromXML[Boolean](x, IPXACT2009scalaxb.ElemName(node) :: stack)) } orElse Some(IPXACT2009scalaxb.DataRecord(None, None, IPXACT2009scalaxb.fromXML[Boolean](scala.xml.Text("false"), IPXACT2009scalaxb.ElemName(node) :: stack))) map { "@strict" -> _ }
        ).flatten[(String, IPXACT2009scalaxb.DataRecord[Any])]: _*)))
      case _ => Left("reads failed: seq must be scala.xml.Node")
    }
    
    override def writesAttribute(__obj: Language, __scope: scala.xml.NamespaceBinding): scala.xml.MetaData = {
      var attr: scala.xml.MetaData  = scala.xml.Null
      __obj.attributes.toList map {
        case ("@strict", _) => if (__obj.strict.toString != "false") attr = scala.xml.Attribute(__scope.getPrefix("http://www.spiritconsortium.org/XMLSchema/SPIRIT/1685-2009"), "strict", __obj.strict.toString, attr)
        case (key, x) => attr = scala.xml.Attribute((x.namespace map { __scope.getPrefix(_) }).orNull, x.key.orNull, x.value.toString, attr)
      }
      attr
    }

    def writesChildNodes(__obj: Language, __scope: scala.xml.NamespaceBinding): Seq[scala.xml.Node] =
      Seq(scala.xml.Text(__obj.value.toString))

  }

  trait Default_WhiteboxElementRefsFormat extends IPXACT2009scalaxb.ElemNameParser[WhiteboxElementRefs] {
    val targetNamespace: Option[String] = Some("http://www.spiritconsortium.org/XMLSchema/SPIRIT/1685-2009")
    
    def parser(node: scala.xml.Node, stack: List[IPXACT2009scalaxb.ElemName]): Parser[WhiteboxElementRefs] =
      phrase(safeRep(IPXACT2009scalaxb.ElemName(Some("http://www.spiritconsortium.org/XMLSchema/SPIRIT/1685-2009"), "whiteboxElementRef")) ^^
      { case p1 =>
      WhiteboxElementRefs(p1 map { IPXACT2009scalaxb.fromXML[WhiteboxElementRefType](_, IPXACT2009scalaxb.ElemName(node) :: stack) }) })
    
    def writesChildNodes(__obj: WhiteboxElementRefs, __scope: scala.xml.NamespaceBinding): Seq[scala.xml.Node] =
      (__obj.whiteboxElementRef flatMap { IPXACT2009scalaxb.toXML[WhiteboxElementRefType](_, Some("http://www.spiritconsortium.org/XMLSchema/SPIRIT/1685-2009"), Some("whiteboxElementRef"), __scope, false) })
  }
  trait Default_ViewTypeFormat extends IPXACT2009scalaxb.ElemNameParser[ViewType] with _NameGroupNMTOKENGroupFormat {
    val targetNamespace: Option[String] = Some("http://www.spiritconsortium.org/XMLSchema/SPIRIT/1685-2009")
    
    override def typeName: Option[String] = Some("viewType")

    def parser(node: scala.xml.Node, stack: List[IPXACT2009scalaxb.ElemName]): Parser[ViewType] =
      phrase((parseNameGroupNMTOKENGroup(node, IPXACT2009scalaxb.ElemName(node) :: stack)) ~
      safeRep(IPXACT2009scalaxb.ElemName(Some("http://www.spiritconsortium.org/XMLSchema/SPIRIT/1685-2009"), "envIdentifier")) ~
      (((IPXACT2009scalaxb.ElemName(Some("http://www.spiritconsortium.org/XMLSchema/SPIRIT/1685-2009"), "hierarchyRef")) ^^
      (x => IPXACT2009scalaxb.DataRecord(x.namespace, Some(x.name), IPXACT2009scalaxb.fromXML[LibraryRefType](x, IPXACT2009scalaxb.ElemName(node) :: stack)))) |||
      ((opt(IPXACT2009scalaxb.ElemName(Some("http://www.spiritconsortium.org/XMLSchema/SPIRIT/1685-2009"), "language")) ~
      opt(IPXACT2009scalaxb.ElemName(Some("http://www.spiritconsortium.org/XMLSchema/SPIRIT/1685-2009"), "modelName")) ~
      safeRep(IPXACT2009scalaxb.ElemName(Some("http://www.spiritconsortium.org/XMLSchema/SPIRIT/1685-2009"), "defaultFileBuilder")) ~
      safeRep(IPXACT2009scalaxb.ElemName(Some("http://www.spiritconsortium.org/XMLSchema/SPIRIT/1685-2009"), "fileSetRef")) ~
      safeRep(IPXACT2009scalaxb.ElemName(Some("http://www.spiritconsortium.org/XMLSchema/SPIRIT/1685-2009"), "constraintSetRef")) ~
      opt(IPXACT2009scalaxb.ElemName(Some("http://www.spiritconsortium.org/XMLSchema/SPIRIT/1685-2009"), "whiteboxElementRefs")) ~
      opt(IPXACT2009scalaxb.ElemName(Some("http://www.spiritconsortium.org/XMLSchema/SPIRIT/1685-2009"), "parameters"))) ^^
        { case p1 ~ p2 ~ p3 ~ p4 ~ p5 ~ p6 ~ p7 => IPXACT2009scalaxb.DataRecord(ViewTypeSequence1(p1.headOption map { IPXACT2009scalaxb.fromXML[Language](_, IPXACT2009scalaxb.ElemName(node) :: stack) },
        p2.headOption map { IPXACT2009scalaxb.fromXML[String](_, IPXACT2009scalaxb.ElemName(node) :: stack) },
        p3 map { IPXACT2009scalaxb.fromXML[FileBuilderType](_, IPXACT2009scalaxb.ElemName(node) :: stack) },
        p4 map { IPXACT2009scalaxb.fromXML[FileSetRef](_, IPXACT2009scalaxb.ElemName(node) :: stack) },
        p5 map { IPXACT2009scalaxb.fromXML[String](_, IPXACT2009scalaxb.ElemName(node) :: stack) },
        p6.headOption map { IPXACT2009scalaxb.fromXML[WhiteboxElementRefs](_, IPXACT2009scalaxb.ElemName(node) :: stack) },
        p7.headOption map { IPXACT2009scalaxb.fromXML[Parameters](_, IPXACT2009scalaxb.ElemName(node) :: stack) })) })) ~
      opt(IPXACT2009scalaxb.ElemName(Some("http://www.spiritconsortium.org/XMLSchema/SPIRIT/1685-2009"), "vendorExtensions")) ^^
      { case p1 ~ p2 ~ p3 ~ p4 =>
      ViewType(p1,
        p2 map { IPXACT2009scalaxb.fromXML[String](_, IPXACT2009scalaxb.ElemName(node) :: stack) },
        p3,
        p4.headOption map { IPXACT2009scalaxb.fromXML[VendorExtensions](_, IPXACT2009scalaxb.ElemName(node) :: stack) }) })
    
    def writesChildNodes(__obj: ViewType, __scope: scala.xml.NamespaceBinding): Seq[scala.xml.Node] =
      Seq.concat(IPXACT2009scalaxb.toXML[NameGroupNMTOKENSequence](__obj.nameGroupNMTOKENSequence1, None, Some("nameGroupNMTOKENSequence1"), __scope, false),
        __obj.envIdentifier flatMap { IPXACT2009scalaxb.toXML[String](_, Some("http://www.spiritconsortium.org/XMLSchema/SPIRIT/1685-2009"), Some("envIdentifier"), __scope, false) },
        (Some(__obj.viewtypeoption) map {x => IPXACT2009scalaxb.toXML[IPXACT2009scalaxb.DataRecord[ViewTypeOption]](x, x.namespace, x.key, __scope, false)}).get,
        __obj.vendorExtensions map { IPXACT2009scalaxb.toXML[VendorExtensions](_, Some("http://www.spiritconsortium.org/XMLSchema/SPIRIT/1685-2009"), Some("vendorExtensions"), __scope, false) } getOrElse {Nil})

  }

  trait Default_ViewTypeSequence1Format extends IPXACT2009scalaxb.XMLFormat[ViewTypeSequence1] {
    def reads(seq: scala.xml.NodeSeq, stack: List[IPXACT2009scalaxb.ElemName]): Either[String, ViewTypeSequence1] = Left("don't call me.")
    
    def writes(__obj: ViewTypeSequence1, __namespace: Option[String], __elementLabel: Option[String], 
        __scope: scala.xml.NamespaceBinding, __typeAttribute: Boolean): scala.xml.NodeSeq =
      Seq.concat(__obj.language map { IPXACT2009scalaxb.toXML[Language](_, Some("http://www.spiritconsortium.org/XMLSchema/SPIRIT/1685-2009"), Some("language"), __scope, false) } getOrElse {Nil},
        __obj.modelName map { IPXACT2009scalaxb.toXML[String](_, Some("http://www.spiritconsortium.org/XMLSchema/SPIRIT/1685-2009"), Some("modelName"), __scope, false) } getOrElse {Nil},
        __obj.defaultFileBuilder flatMap { IPXACT2009scalaxb.toXML[FileBuilderType](_, Some("http://www.spiritconsortium.org/XMLSchema/SPIRIT/1685-2009"), Some("defaultFileBuilder"), __scope, false) },
        __obj.fileSetRef flatMap { IPXACT2009scalaxb.toXML[FileSetRef](_, Some("http://www.spiritconsortium.org/XMLSchema/SPIRIT/1685-2009"), Some("fileSetRef"), __scope, false) },
        __obj.constraintSetRef flatMap { IPXACT2009scalaxb.toXML[String](_, Some("http://www.spiritconsortium.org/XMLSchema/SPIRIT/1685-2009"), Some("constraintSetRef"), __scope, false) },
        __obj.whiteboxElementRefs map { IPXACT2009scalaxb.toXML[WhiteboxElementRefs](_, Some("http://www.spiritconsortium.org/XMLSchema/SPIRIT/1685-2009"), Some("whiteboxElementRefs"), __scope, false) } getOrElse {Nil},
        __obj.parameters map { IPXACT2009scalaxb.toXML[Parameters](_, Some("http://www.spiritconsortium.org/XMLSchema/SPIRIT/1685-2009"), Some("parameters"), __scope, false) } getOrElse {Nil})


  }

  trait Default_Language2Format extends IPXACT2009scalaxb.XMLFormat[Language2] with IPXACT2009scalaxb.CanWriteChildNodes[Language2] {
    val targetNamespace: Option[String] = Some("http://www.spiritconsortium.org/XMLSchema/SPIRIT/1685-2009")
    def reads(seq: scala.xml.NodeSeq, stack: List[IPXACT2009scalaxb.ElemName]): Either[String, Language2] = seq match {
      case node: scala.xml.Node => Right(Language2(IPXACT2009scalaxb.fromXML[String](node, IPXACT2009scalaxb.ElemName(node) :: stack),
        scala.collection.immutable.ListMap(List(
        (node \ "@{http://www.spiritconsortium.org/XMLSchema/SPIRIT/1685-2009}strict").headOption map { x => IPXACT2009scalaxb.DataRecord(x, node, IPXACT2009scalaxb.fromXML[Boolean](x, IPXACT2009scalaxb.ElemName(node) :: stack)) } map { "@strict" -> _ }
        ).flatten[(String, IPXACT2009scalaxb.DataRecord[Any])]: _*)))
      case _ => Left("reads failed: seq must be scala.xml.Node")
    }
    
    override def writesAttribute(__obj: Language2, __scope: scala.xml.NamespaceBinding): scala.xml.MetaData = {
      var attr: scala.xml.MetaData  = scala.xml.Null
      __obj.attributes.toList map {
        case ("@strict", _) => __obj.strict foreach { x => attr = scala.xml.Attribute(__scope.getPrefix("http://www.spiritconsortium.org/XMLSchema/SPIRIT/1685-2009"), "strict", x.toString, attr) }
        case (key, x) => attr = scala.xml.Attribute((x.namespace map { __scope.getPrefix(_) }).orNull, x.key.orNull, x.value.toString, attr)
      }
      attr
    }

    def writesChildNodes(__obj: Language2, __scope: scala.xml.NamespaceBinding): Seq[scala.xml.Node] =
      Seq(scala.xml.Text(__obj.value.toString))

  }

  trait Default_AbstractorViewTypeFormat extends IPXACT2009scalaxb.ElemNameParser[AbstractorViewType] with _NameGroupNMTOKENGroupFormat {
    val targetNamespace: Option[String] = Some("http://www.spiritconsortium.org/XMLSchema/SPIRIT/1685-2009")
    
    override def typeName: Option[String] = Some("abstractorViewType")

    def parser(node: scala.xml.Node, stack: List[IPXACT2009scalaxb.ElemName]): Parser[AbstractorViewType] =
      phrase((parseNameGroupNMTOKENGroup(node, IPXACT2009scalaxb.ElemName(node) :: stack)) ~
      safeRep(IPXACT2009scalaxb.ElemName(Some("http://www.spiritconsortium.org/XMLSchema/SPIRIT/1685-2009"), "envIdentifier")) ~
      opt(IPXACT2009scalaxb.ElemName(Some("http://www.spiritconsortium.org/XMLSchema/SPIRIT/1685-2009"), "language")) ~
      opt(IPXACT2009scalaxb.ElemName(Some("http://www.spiritconsortium.org/XMLSchema/SPIRIT/1685-2009"), "modelName")) ~
      safeRep(IPXACT2009scalaxb.ElemName(Some("http://www.spiritconsortium.org/XMLSchema/SPIRIT/1685-2009"), "defaultFileBuilder")) ~
      safeRep(IPXACT2009scalaxb.ElemName(Some("http://www.spiritconsortium.org/XMLSchema/SPIRIT/1685-2009"), "fileSetRef")) ~
      opt(IPXACT2009scalaxb.ElemName(Some("http://www.spiritconsortium.org/XMLSchema/SPIRIT/1685-2009"), "parameters")) ~
      opt(IPXACT2009scalaxb.ElemName(Some("http://www.spiritconsortium.org/XMLSchema/SPIRIT/1685-2009"), "vendorExtensions")) ^^
      { case p1 ~ p2 ~ p3 ~ p4 ~ p5 ~ p6 ~ p7 ~ p8 =>
      AbstractorViewType(p1,
        p2 map { IPXACT2009scalaxb.fromXML[String](_, IPXACT2009scalaxb.ElemName(node) :: stack) },
        p3.headOption map { IPXACT2009scalaxb.fromXML[Language2](_, IPXACT2009scalaxb.ElemName(node) :: stack) },
        p4.headOption map { IPXACT2009scalaxb.fromXML[String](_, IPXACT2009scalaxb.ElemName(node) :: stack) },
        p5 map { IPXACT2009scalaxb.fromXML[FileBuilderType](_, IPXACT2009scalaxb.ElemName(node) :: stack) },
        p6 map { IPXACT2009scalaxb.fromXML[FileSetRef](_, IPXACT2009scalaxb.ElemName(node) :: stack) },
        p7.headOption map { IPXACT2009scalaxb.fromXML[Parameters](_, IPXACT2009scalaxb.ElemName(node) :: stack) },
        p8.headOption map { IPXACT2009scalaxb.fromXML[VendorExtensions](_, IPXACT2009scalaxb.ElemName(node) :: stack) }) })
    
    def writesChildNodes(__obj: AbstractorViewType, __scope: scala.xml.NamespaceBinding): Seq[scala.xml.Node] =
      Seq.concat(IPXACT2009scalaxb.toXML[NameGroupNMTOKENSequence](__obj.nameGroupNMTOKENSequence1, None, Some("nameGroupNMTOKENSequence1"), __scope, false),
        __obj.envIdentifier flatMap { IPXACT2009scalaxb.toXML[String](_, Some("http://www.spiritconsortium.org/XMLSchema/SPIRIT/1685-2009"), Some("envIdentifier"), __scope, false) },
        __obj.language map { IPXACT2009scalaxb.toXML[Language2](_, Some("http://www.spiritconsortium.org/XMLSchema/SPIRIT/1685-2009"), Some("language"), __scope, false) } getOrElse {Nil},
        __obj.modelName map { IPXACT2009scalaxb.toXML[String](_, Some("http://www.spiritconsortium.org/XMLSchema/SPIRIT/1685-2009"), Some("modelName"), __scope, false) } getOrElse {Nil},
        __obj.defaultFileBuilder flatMap { IPXACT2009scalaxb.toXML[FileBuilderType](_, Some("http://www.spiritconsortium.org/XMLSchema/SPIRIT/1685-2009"), Some("defaultFileBuilder"), __scope, false) },
        __obj.fileSetRef flatMap { IPXACT2009scalaxb.toXML[FileSetRef](_, Some("http://www.spiritconsortium.org/XMLSchema/SPIRIT/1685-2009"), Some("fileSetRef"), __scope, false) },
        __obj.parameters map { IPXACT2009scalaxb.toXML[Parameters](_, Some("http://www.spiritconsortium.org/XMLSchema/SPIRIT/1685-2009"), Some("parameters"), __scope, false) } getOrElse {Nil},
        __obj.vendorExtensions map { IPXACT2009scalaxb.toXML[VendorExtensions](_, Some("http://www.spiritconsortium.org/XMLSchema/SPIRIT/1685-2009"), Some("vendorExtensions"), __scope, false) } getOrElse {Nil})

  }

  trait Default_ViewsFormat extends IPXACT2009scalaxb.ElemNameParser[Views] {
    val targetNamespace: Option[String] = Some("http://www.spiritconsortium.org/XMLSchema/SPIRIT/1685-2009")
    
    def parser(node: scala.xml.Node, stack: List[IPXACT2009scalaxb.ElemName]): Parser[Views] =
      phrase(safeRep(IPXACT2009scalaxb.ElemName(Some("http://www.spiritconsortium.org/XMLSchema/SPIRIT/1685-2009"), "view")) ^^
      { case p1 =>
      Views(p1 map { IPXACT2009scalaxb.fromXML[ViewType](_, IPXACT2009scalaxb.ElemName(node) :: stack) }) })
    
    def writesChildNodes(__obj: Views, __scope: scala.xml.NamespaceBinding): Seq[scala.xml.Node] =
      (__obj.view flatMap { IPXACT2009scalaxb.toXML[ViewType](_, Some("http://www.spiritconsortium.org/XMLSchema/SPIRIT/1685-2009"), Some("view"), __scope, false) })
  }
  trait Default_PortsFormat extends IPXACT2009scalaxb.ElemNameParser[Ports] {
    val targetNamespace: Option[String] = Some("http://www.spiritconsortium.org/XMLSchema/SPIRIT/1685-2009")
    
    def parser(node: scala.xml.Node, stack: List[IPXACT2009scalaxb.ElemName]): Parser[Ports] =
      phrase(safeRep(IPXACT2009scalaxb.ElemName(Some("http://www.spiritconsortium.org/XMLSchema/SPIRIT/1685-2009"), "port")) ^^
      { case p1 =>
      Ports(p1 map { IPXACT2009scalaxb.fromXML[PortTypable](_, IPXACT2009scalaxb.ElemName(node) :: stack) }) })
    
    def writesChildNodes(__obj: Ports, __scope: scala.xml.NamespaceBinding): Seq[scala.xml.Node] =
      (__obj.port flatMap { IPXACT2009scalaxb.toXML[PortTypable](_, Some("http://www.spiritconsortium.org/XMLSchema/SPIRIT/1685-2009"), Some("port"), __scope, false) })
  }
  trait Default_ModelParametersFormat extends IPXACT2009scalaxb.ElemNameParser[ModelParameters] {
    val targetNamespace: Option[String] = Some("http://www.spiritconsortium.org/XMLSchema/SPIRIT/1685-2009")
    
    def parser(node: scala.xml.Node, stack: List[IPXACT2009scalaxb.ElemName]): Parser[ModelParameters] =
      phrase(safeRep(IPXACT2009scalaxb.ElemName(Some("http://www.spiritconsortium.org/XMLSchema/SPIRIT/1685-2009"), "modelParameter")) ^^
      { case p1 =>
      ModelParameters(p1 map { IPXACT2009scalaxb.fromXML[NameValueTypeType](_, IPXACT2009scalaxb.ElemName(node) :: stack) }) })
    
    def writesChildNodes(__obj: ModelParameters, __scope: scala.xml.NamespaceBinding): Seq[scala.xml.Node] =
      (__obj.modelParameter flatMap { IPXACT2009scalaxb.toXML[NameValueTypeType](_, Some("http://www.spiritconsortium.org/XMLSchema/SPIRIT/1685-2009"), Some("modelParameter"), __scope, false) })
  }
  trait Default_ModelTypeFormat extends IPXACT2009scalaxb.ElemNameParser[ModelType] {
    val targetNamespace: Option[String] = Some("http://www.spiritconsortium.org/XMLSchema/SPIRIT/1685-2009")
    
    override def typeName: Option[String] = Some("modelType")

    def parser(node: scala.xml.Node, stack: List[IPXACT2009scalaxb.ElemName]): Parser[ModelType] =
      phrase(opt(IPXACT2009scalaxb.ElemName(Some("http://www.spiritconsortium.org/XMLSchema/SPIRIT/1685-2009"), "views")) ~
      opt(IPXACT2009scalaxb.ElemName(Some("http://www.spiritconsortium.org/XMLSchema/SPIRIT/1685-2009"), "ports")) ~
      opt(IPXACT2009scalaxb.ElemName(Some("http://www.spiritconsortium.org/XMLSchema/SPIRIT/1685-2009"), "modelParameters")) ^^
      { case p1 ~ p2 ~ p3 =>
      ModelType(p1.headOption map { IPXACT2009scalaxb.fromXML[Views](_, IPXACT2009scalaxb.ElemName(node) :: stack) },
        p2.headOption map { IPXACT2009scalaxb.fromXML[Ports](_, IPXACT2009scalaxb.ElemName(node) :: stack) },
        p3.headOption map { IPXACT2009scalaxb.fromXML[ModelParameters](_, IPXACT2009scalaxb.ElemName(node) :: stack) }) })
    
    def writesChildNodes(__obj: ModelType, __scope: scala.xml.NamespaceBinding): Seq[scala.xml.Node] =
      Seq.concat(__obj.views map { IPXACT2009scalaxb.toXML[Views](_, Some("http://www.spiritconsortium.org/XMLSchema/SPIRIT/1685-2009"), Some("views"), __scope, false) } getOrElse {Nil},
        __obj.ports map { IPXACT2009scalaxb.toXML[Ports](_, Some("http://www.spiritconsortium.org/XMLSchema/SPIRIT/1685-2009"), Some("ports"), __scope, false) } getOrElse {Nil},
        __obj.modelParameters map { IPXACT2009scalaxb.toXML[ModelParameters](_, Some("http://www.spiritconsortium.org/XMLSchema/SPIRIT/1685-2009"), Some("modelParameters"), __scope, false) } getOrElse {Nil})

  }

  trait Default_Views2Format extends IPXACT2009scalaxb.ElemNameParser[Views2] {
    val targetNamespace: Option[String] = Some("http://www.spiritconsortium.org/XMLSchema/SPIRIT/1685-2009")
    
    def parser(node: scala.xml.Node, stack: List[IPXACT2009scalaxb.ElemName]): Parser[Views2] =
      phrase(safeRep(IPXACT2009scalaxb.ElemName(Some("http://www.spiritconsortium.org/XMLSchema/SPIRIT/1685-2009"), "view")) ^^
      { case p1 =>
      Views2(p1 map { IPXACT2009scalaxb.fromXML[AbstractorViewType](_, IPXACT2009scalaxb.ElemName(node) :: stack) }) })
    
    def writesChildNodes(__obj: Views2, __scope: scala.xml.NamespaceBinding): Seq[scala.xml.Node] =
      (__obj.view flatMap { IPXACT2009scalaxb.toXML[AbstractorViewType](_, Some("http://www.spiritconsortium.org/XMLSchema/SPIRIT/1685-2009"), Some("view"), __scope, false) })
  }
  trait Default_Ports2Format extends IPXACT2009scalaxb.ElemNameParser[Ports2] {
    val targetNamespace: Option[String] = Some("http://www.spiritconsortium.org/XMLSchema/SPIRIT/1685-2009")
    
    def parser(node: scala.xml.Node, stack: List[IPXACT2009scalaxb.ElemName]): Parser[Ports2] =
      phrase(safeRep(IPXACT2009scalaxb.ElemName(Some("http://www.spiritconsortium.org/XMLSchema/SPIRIT/1685-2009"), "port")) ^^
      { case p1 =>
      Ports2(p1 map { IPXACT2009scalaxb.fromXML[AbstractorPortType](_, IPXACT2009scalaxb.ElemName(node) :: stack) }) })
    
    def writesChildNodes(__obj: Ports2, __scope: scala.xml.NamespaceBinding): Seq[scala.xml.Node] =
      (__obj.port flatMap { IPXACT2009scalaxb.toXML[AbstractorPortType](_, Some("http://www.spiritconsortium.org/XMLSchema/SPIRIT/1685-2009"), Some("port"), __scope, false) })
  }
  trait Default_ModelParameters2Format extends IPXACT2009scalaxb.ElemNameParser[ModelParameters2] {
    val targetNamespace: Option[String] = Some("http://www.spiritconsortium.org/XMLSchema/SPIRIT/1685-2009")
    
    def parser(node: scala.xml.Node, stack: List[IPXACT2009scalaxb.ElemName]): Parser[ModelParameters2] =
      phrase(safeRep(IPXACT2009scalaxb.ElemName(Some("http://www.spiritconsortium.org/XMLSchema/SPIRIT/1685-2009"), "modelParameter")) ^^
      { case p1 =>
      ModelParameters2(p1 map { IPXACT2009scalaxb.fromXML[NameValueTypeType](_, IPXACT2009scalaxb.ElemName(node) :: stack) }) })
    
    def writesChildNodes(__obj: ModelParameters2, __scope: scala.xml.NamespaceBinding): Seq[scala.xml.Node] =
      (__obj.modelParameter flatMap { IPXACT2009scalaxb.toXML[NameValueTypeType](_, Some("http://www.spiritconsortium.org/XMLSchema/SPIRIT/1685-2009"), Some("modelParameter"), __scope, false) })
  }
  trait Default_AbstractorModelTypeFormat extends IPXACT2009scalaxb.ElemNameParser[AbstractorModelType] {
    val targetNamespace: Option[String] = Some("http://www.spiritconsortium.org/XMLSchema/SPIRIT/1685-2009")
    
    override def typeName: Option[String] = Some("abstractorModelType")

    def parser(node: scala.xml.Node, stack: List[IPXACT2009scalaxb.ElemName]): Parser[AbstractorModelType] =
      phrase(opt(IPXACT2009scalaxb.ElemName(Some("http://www.spiritconsortium.org/XMLSchema/SPIRIT/1685-2009"), "views")) ~
      opt(IPXACT2009scalaxb.ElemName(Some("http://www.spiritconsortium.org/XMLSchema/SPIRIT/1685-2009"), "ports")) ~
      opt(IPXACT2009scalaxb.ElemName(Some("http://www.spiritconsortium.org/XMLSchema/SPIRIT/1685-2009"), "modelParameters")) ^^
      { case p1 ~ p2 ~ p3 =>
      AbstractorModelType(p1.headOption map { IPXACT2009scalaxb.fromXML[Views2](_, IPXACT2009scalaxb.ElemName(node) :: stack) },
        p2.headOption map { IPXACT2009scalaxb.fromXML[Ports2](_, IPXACT2009scalaxb.ElemName(node) :: stack) },
        p3.headOption map { IPXACT2009scalaxb.fromXML[ModelParameters2](_, IPXACT2009scalaxb.ElemName(node) :: stack) }) })
    
    def writesChildNodes(__obj: AbstractorModelType, __scope: scala.xml.NamespaceBinding): Seq[scala.xml.Node] =
      Seq.concat(__obj.views map { IPXACT2009scalaxb.toXML[Views2](_, Some("http://www.spiritconsortium.org/XMLSchema/SPIRIT/1685-2009"), Some("views"), __scope, false) } getOrElse {Nil},
        __obj.ports map { IPXACT2009scalaxb.toXML[Ports2](_, Some("http://www.spiritconsortium.org/XMLSchema/SPIRIT/1685-2009"), Some("ports"), __scope, false) } getOrElse {Nil},
        __obj.modelParameters map { IPXACT2009scalaxb.toXML[ModelParameters2](_, Some("http://www.spiritconsortium.org/XMLSchema/SPIRIT/1685-2009"), Some("modelParameters"), __scope, false) } getOrElse {Nil})

  }

  trait Default_WhiteboxPathFormat extends IPXACT2009scalaxb.ElemNameParser[WhiteboxPath] {
    val targetNamespace: Option[String] = Some("http://www.spiritconsortium.org/XMLSchema/SPIRIT/1685-2009")
    
    def parser(node: scala.xml.Node, stack: List[IPXACT2009scalaxb.ElemName]): Parser[WhiteboxPath] =
      phrase((IPXACT2009scalaxb.ElemName(Some("http://www.spiritconsortium.org/XMLSchema/SPIRIT/1685-2009"), "pathName")) ~
      opt(((IPXACT2009scalaxb.ElemName(Some("http://www.spiritconsortium.org/XMLSchema/SPIRIT/1685-2009"), "left")) ~
      (IPXACT2009scalaxb.ElemName(Some("http://www.spiritconsortium.org/XMLSchema/SPIRIT/1685-2009"), "right"))) ^^
        { case p1 ~ p2 => WhiteboxPathSequence1(IPXACT2009scalaxb.fromXML[BigInt](p1, IPXACT2009scalaxb.ElemName(node) :: stack),
        IPXACT2009scalaxb.fromXML[BigInt](p2, IPXACT2009scalaxb.ElemName(node) :: stack)) }) ^^
      { case p1 ~ p2 =>
      WhiteboxPath(IPXACT2009scalaxb.fromXML[String](p1, IPXACT2009scalaxb.ElemName(node) :: stack),
        p2) })
    
    def writesChildNodes(__obj: WhiteboxPath, __scope: scala.xml.NamespaceBinding): Seq[scala.xml.Node] =
      Seq.concat(IPXACT2009scalaxb.toXML[String](__obj.pathName, Some("http://www.spiritconsortium.org/XMLSchema/SPIRIT/1685-2009"), Some("pathName"), __scope, false),
        __obj.whiteboxpathsequence1 map { IPXACT2009scalaxb.toXML[WhiteboxPathSequence1](_, None, Some("whiteboxpathsequence1"), __scope, false) } getOrElse {Nil})

  }

  trait Default_WhiteboxPathSequence1Format extends IPXACT2009scalaxb.XMLFormat[WhiteboxPathSequence1] {
    def reads(seq: scala.xml.NodeSeq, stack: List[IPXACT2009scalaxb.ElemName]): Either[String, WhiteboxPathSequence1] = Left("don't call me.")
    
    def writes(__obj: WhiteboxPathSequence1, __namespace: Option[String], __elementLabel: Option[String], 
        __scope: scala.xml.NamespaceBinding, __typeAttribute: Boolean): scala.xml.NodeSeq =
      Seq.concat(IPXACT2009scalaxb.toXML[BigInt](__obj.left, Some("http://www.spiritconsortium.org/XMLSchema/SPIRIT/1685-2009"), Some("left"), __scope, false),
        IPXACT2009scalaxb.toXML[BigInt](__obj.right, Some("http://www.spiritconsortium.org/XMLSchema/SPIRIT/1685-2009"), Some("right"), __scope, false))


  }

  trait Default_WhiteboxElementRefTypeFormat extends IPXACT2009scalaxb.ElemNameParser[WhiteboxElementRefType] {
    val targetNamespace: Option[String] = Some("http://www.spiritconsortium.org/XMLSchema/SPIRIT/1685-2009")
    
    override def typeName: Option[String] = Some("whiteboxElementRefType")

    def parser(node: scala.xml.Node, stack: List[IPXACT2009scalaxb.ElemName]): Parser[WhiteboxElementRefType] =
      phrase(safeRep(IPXACT2009scalaxb.ElemName(Some("http://www.spiritconsortium.org/XMLSchema/SPIRIT/1685-2009"), "whiteboxPath")) ^^
      { case p1 =>
      WhiteboxElementRefType(p1 map { IPXACT2009scalaxb.fromXML[WhiteboxPath](_, IPXACT2009scalaxb.ElemName(node) :: stack) },
        scala.collection.immutable.ListMap(List(
        (node \ "@{http://www.spiritconsortium.org/XMLSchema/SPIRIT/1685-2009}name").headOption map { x => IPXACT2009scalaxb.DataRecord(x, node, IPXACT2009scalaxb.fromXML[String](x, IPXACT2009scalaxb.ElemName(node) :: stack)) } map { "@name" -> _ }
        ).flatten[(String, IPXACT2009scalaxb.DataRecord[Any])]: _*)) })
    
    override def writesAttribute(__obj: WhiteboxElementRefType, __scope: scala.xml.NamespaceBinding): scala.xml.MetaData = {
      var attr: scala.xml.MetaData  = scala.xml.Null
      __obj.attributes.toList map {
        case ("@name", _) => attr = scala.xml.Attribute(__scope.getPrefix("http://www.spiritconsortium.org/XMLSchema/SPIRIT/1685-2009"), "name", __obj.name.toString, attr)
        case (key, x) => attr = scala.xml.Attribute((x.namespace map { __scope.getPrefix(_) }).orNull, x.key.orNull, x.value.toString, attr)
      }
      attr
    }

    def writesChildNodes(__obj: WhiteboxElementRefType, __scope: scala.xml.NamespaceBinding): Seq[scala.xml.Node] =
      (__obj.whiteboxPath flatMap { IPXACT2009scalaxb.toXML[WhiteboxPath](_, Some("http://www.spiritconsortium.org/XMLSchema/SPIRIT/1685-2009"), Some("whiteboxPath"), __scope, false) })
  }

  def build_ComponentPortDirectionTypeFormat = new Default_ComponentPortDirectionTypeFormat {}
  trait Default_ComponentPortDirectionTypeFormat extends IPXACT2009scalaxb.XMLFormat[ComponentPortDirectionType] {
    val targetNamespace: Option[String] = Some("http://www.spiritconsortium.org/XMLSchema/SPIRIT/1685-2009")
    
    def fromString(value: String, scope: scala.xml.NamespaceBinding): ComponentPortDirectionType =
        (fromString0(value, scope)).apply(IPXACT2009scalaxb.fromXML[String](scala.xml.Text(value)))

    private def fromString0(value: String, scope: scala.xml.NamespaceBinding): PartialFunction[Any, ComponentPortDirectionType] = {
      case x: String if x == IPXACT2009scalaxb.fromXML[String](scala.xml.Text("in")) => In
      case x: String if x == IPXACT2009scalaxb.fromXML[String](scala.xml.Text("out")) => Out
      case x: String if x == IPXACT2009scalaxb.fromXML[String](scala.xml.Text("inout")) => Inout
      case x: String if x == IPXACT2009scalaxb.fromXML[String](scala.xml.Text("phantom")) => Phantom

    }



    def reads(seq: scala.xml.NodeSeq, stack: List[IPXACT2009scalaxb.ElemName]): Either[String, ComponentPortDirectionType] = seq match {
      case elem: scala.xml.Elem => Right(fromString(elem.text, elem.scope))
      case _ => Right(fromString(seq.text, scala.xml.TopScope))
    }
    
    def writes(__obj: ComponentPortDirectionType, __namespace: Option[String], __elementLabel: Option[String],
        __scope: scala.xml.NamespaceBinding, __typeAttribute: Boolean): scala.xml.NodeSeq =
      scala.xml.Elem(IPXACT2009scalaxb.Helper.getPrefix(__namespace, __scope).orNull,
        __elementLabel getOrElse { sys.error("missing element label.") },
        scala.xml.Null, __scope, true, scala.xml.Text(__obj.toString))
  }
  trait Default_LeftType4Format extends IPXACT2009scalaxb.XMLFormat[LeftType4] with IPXACT2009scalaxb.CanWriteChildNodes[LeftType4] {
    val targetNamespace: Option[String] = Some("http://www.spiritconsortium.org/XMLSchema/SPIRIT/1685-2009")
    def reads(seq: scala.xml.NodeSeq, stack: List[IPXACT2009scalaxb.ElemName]): Either[String, LeftType4] = seq match {
      case node: scala.xml.Node => Right(LeftType4(IPXACT2009scalaxb.fromXML[BigInt](node, IPXACT2009scalaxb.ElemName(node) :: stack),
        scala.collection.immutable.ListMap(List(
        (node \ "@{http://www.spiritconsortium.org/XMLSchema/SPIRIT/1685-2009}format").headOption map { x => IPXACT2009scalaxb.DataRecord(x, node, IPXACT2009scalaxb.fromXML[FormatType](x, IPXACT2009scalaxb.ElemName(node) :: stack)) } orElse Some(IPXACT2009scalaxb.DataRecord(None, None, IPXACT2009scalaxb.fromXML[FormatType](scala.xml.Text("long"), IPXACT2009scalaxb.ElemName(node) :: stack))) map { "@{http://www.spiritconsortium.org/XMLSchema/SPIRIT/1685-2009}format" -> _ },
        (node \ "@{http://www.spiritconsortium.org/XMLSchema/SPIRIT/1685-2009}resolve").headOption map { x => IPXACT2009scalaxb.DataRecord(x, node, IPXACT2009scalaxb.fromXML[ResolveType](x, IPXACT2009scalaxb.ElemName(node) :: stack)) } map { "@{http://www.spiritconsortium.org/XMLSchema/SPIRIT/1685-2009}resolve" -> _ },
        (node \ "@{http://www.spiritconsortium.org/XMLSchema/SPIRIT/1685-2009}id").headOption map { x => IPXACT2009scalaxb.DataRecord(x, node, IPXACT2009scalaxb.fromXML[String](x, IPXACT2009scalaxb.ElemName(node) :: stack)) } map { "@{http://www.spiritconsortium.org/XMLSchema/SPIRIT/1685-2009}id" -> _ },
        (node \ "@{http://www.spiritconsortium.org/XMLSchema/SPIRIT/1685-2009}dependency").headOption map { x => IPXACT2009scalaxb.DataRecord(x, node, IPXACT2009scalaxb.fromXML[String](x, IPXACT2009scalaxb.ElemName(node) :: stack)) } map { "@{http://www.spiritconsortium.org/XMLSchema/SPIRIT/1685-2009}dependency" -> _ },
        (node \ "@{http://www.spiritconsortium.org/XMLSchema/SPIRIT/1685-2009}choiceRef").headOption map { x => IPXACT2009scalaxb.DataRecord(x, node, IPXACT2009scalaxb.fromXML[String](x, IPXACT2009scalaxb.ElemName(node) :: stack)) } map { "@{http://www.spiritconsortium.org/XMLSchema/SPIRIT/1685-2009}choiceRef" -> _ },
        (node \ "@{http://www.spiritconsortium.org/XMLSchema/SPIRIT/1685-2009}order").headOption map { x => IPXACT2009scalaxb.DataRecord(x, node, IPXACT2009scalaxb.fromXML[Float](x, IPXACT2009scalaxb.ElemName(node) :: stack)) } map { "@{http://www.spiritconsortium.org/XMLSchema/SPIRIT/1685-2009}order" -> _ },
        (node \ "@{http://www.spiritconsortium.org/XMLSchema/SPIRIT/1685-2009}configGroups").headOption map { x => IPXACT2009scalaxb.DataRecord(x, node, IPXACT2009scalaxb.fromXML[Seq[String]](x, IPXACT2009scalaxb.ElemName(node) :: stack)) } map { "@{http://www.spiritconsortium.org/XMLSchema/SPIRIT/1685-2009}configGroups" -> _ },
        (node \ "@{http://www.spiritconsortium.org/XMLSchema/SPIRIT/1685-2009}bitStringLength").headOption map { x => IPXACT2009scalaxb.DataRecord(x, node, IPXACT2009scalaxb.fromXML[BigInt](x, IPXACT2009scalaxb.ElemName(node) :: stack)) } map { "@{http://www.spiritconsortium.org/XMLSchema/SPIRIT/1685-2009}bitStringLength" -> _ },
        (node \ "@{http://www.spiritconsortium.org/XMLSchema/SPIRIT/1685-2009}minimum").headOption map { x => IPXACT2009scalaxb.DataRecord(x, node, IPXACT2009scalaxb.fromXML[String](x, IPXACT2009scalaxb.ElemName(node) :: stack)) } map { "@{http://www.spiritconsortium.org/XMLSchema/SPIRIT/1685-2009}minimum" -> _ },
        (node \ "@{http://www.spiritconsortium.org/XMLSchema/SPIRIT/1685-2009}maximum").headOption map { x => IPXACT2009scalaxb.DataRecord(x, node, IPXACT2009scalaxb.fromXML[String](x, IPXACT2009scalaxb.ElemName(node) :: stack)) } map { "@{http://www.spiritconsortium.org/XMLSchema/SPIRIT/1685-2009}maximum" -> _ },
        (node \ "@{http://www.spiritconsortium.org/XMLSchema/SPIRIT/1685-2009}rangeType").headOption map { x => IPXACT2009scalaxb.DataRecord(x, node, IPXACT2009scalaxb.fromXML[RangeTypeType](x, IPXACT2009scalaxb.ElemName(node) :: stack)) } orElse Some(IPXACT2009scalaxb.DataRecord(None, None, IPXACT2009scalaxb.fromXML[RangeTypeType](scala.xml.Text("float"), IPXACT2009scalaxb.ElemName(node) :: stack))) map { "@{http://www.spiritconsortium.org/XMLSchema/SPIRIT/1685-2009}rangeType" -> _ },
        (node \ "@{http://www.spiritconsortium.org/XMLSchema/SPIRIT/1685-2009}prompt").headOption map { x => IPXACT2009scalaxb.DataRecord(x, node, IPXACT2009scalaxb.fromXML[String](x, IPXACT2009scalaxb.ElemName(node) :: stack)) } map { "@{http://www.spiritconsortium.org/XMLSchema/SPIRIT/1685-2009}prompt" -> _ }
        ).flatten[(String, IPXACT2009scalaxb.DataRecord[Any])] ::: (node match {
          case elem: scala.xml.Elem =>
            elem.attributes.toList flatMap {
              case scala.xml.PrefixedAttribute(pre, key, value, _) if pre == elem.scope.getPrefix("http://www.spiritconsortium.org/XMLSchema/SPIRIT/1685-2009") &&
                key == "format" => Nil
              case scala.xml.PrefixedAttribute(pre, key, value, _) if pre == elem.scope.getPrefix("http://www.spiritconsortium.org/XMLSchema/SPIRIT/1685-2009") &&
                key == "resolve" => Nil
              case scala.xml.PrefixedAttribute(pre, key, value, _) if pre == elem.scope.getPrefix("http://www.spiritconsortium.org/XMLSchema/SPIRIT/1685-2009") &&
                key == "id" => Nil
              case scala.xml.PrefixedAttribute(pre, key, value, _) if pre == elem.scope.getPrefix("http://www.spiritconsortium.org/XMLSchema/SPIRIT/1685-2009") &&
                key == "dependency" => Nil
              case scala.xml.PrefixedAttribute(pre, key, value, _) if pre == elem.scope.getPrefix("http://www.spiritconsortium.org/XMLSchema/SPIRIT/1685-2009") &&
                key == "choiceRef" => Nil
              case scala.xml.PrefixedAttribute(pre, key, value, _) if pre == elem.scope.getPrefix("http://www.spiritconsortium.org/XMLSchema/SPIRIT/1685-2009") &&
                key == "order" => Nil
              case scala.xml.PrefixedAttribute(pre, key, value, _) if pre == elem.scope.getPrefix("http://www.spiritconsortium.org/XMLSchema/SPIRIT/1685-2009") &&
                key == "configGroups" => Nil
              case scala.xml.PrefixedAttribute(pre, key, value, _) if pre == elem.scope.getPrefix("http://www.spiritconsortium.org/XMLSchema/SPIRIT/1685-2009") &&
                key == "bitStringLength" => Nil
              case scala.xml.PrefixedAttribute(pre, key, value, _) if pre == elem.scope.getPrefix("http://www.spiritconsortium.org/XMLSchema/SPIRIT/1685-2009") &&
                key == "minimum" => Nil
              case scala.xml.PrefixedAttribute(pre, key, value, _) if pre == elem.scope.getPrefix("http://www.spiritconsortium.org/XMLSchema/SPIRIT/1685-2009") &&
                key == "maximum" => Nil
              case scala.xml.PrefixedAttribute(pre, key, value, _) if pre == elem.scope.getPrefix("http://www.spiritconsortium.org/XMLSchema/SPIRIT/1685-2009") &&
                key == "rangeType" => Nil
              case scala.xml.PrefixedAttribute(pre, key, value, _) if pre == elem.scope.getPrefix("http://www.spiritconsortium.org/XMLSchema/SPIRIT/1685-2009") &&
                key == "prompt" => Nil
              case scala.xml.UnprefixedAttribute(key, value, _) =>
                List(("@" + key, IPXACT2009scalaxb.DataRecord(None, Some(key), value.text)))
              case scala.xml.PrefixedAttribute(pre, key, value, _) =>
                val ns = elem.scope.getURI(pre)
                List(("@{" + ns + "}" + key, IPXACT2009scalaxb.DataRecord(Option[String](ns), Some(key), value.text)))
              case _ => Nil
            }
          case _ => Nil
        }): _*)))
      case _ => Left("reads failed: seq must be scala.xml.Node")
    }
    
    override def writesAttribute(__obj: LeftType4, __scope: scala.xml.NamespaceBinding): scala.xml.MetaData = {
      var attr: scala.xml.MetaData  = scala.xml.Null
      __obj.attributes.toList map {
        case ("@{http://www.spiritconsortium.org/XMLSchema/SPIRIT/1685-2009}format", _) => if (__obj.spiritformat.toString != "long") attr = scala.xml.Attribute(__scope.getPrefix("http://www.spiritconsortium.org/XMLSchema/SPIRIT/1685-2009"), "format", __obj.spiritformat.toString, attr)
        case ("@{http://www.spiritconsortium.org/XMLSchema/SPIRIT/1685-2009}resolve", _) => __obj.spiritresolve foreach { x => attr = scala.xml.Attribute(__scope.getPrefix("http://www.spiritconsortium.org/XMLSchema/SPIRIT/1685-2009"), "resolve", x.toString, attr) }
        case ("@{http://www.spiritconsortium.org/XMLSchema/SPIRIT/1685-2009}id", _) => __obj.spiritid foreach { x => attr = scala.xml.Attribute(__scope.getPrefix("http://www.spiritconsortium.org/XMLSchema/SPIRIT/1685-2009"), "id", x.toString, attr) }
        case ("@{http://www.spiritconsortium.org/XMLSchema/SPIRIT/1685-2009}dependency", _) => __obj.spiritdependency foreach { x => attr = scala.xml.Attribute(__scope.getPrefix("http://www.spiritconsortium.org/XMLSchema/SPIRIT/1685-2009"), "dependency", x.toString, attr) }
        case ("@{http://www.spiritconsortium.org/XMLSchema/SPIRIT/1685-2009}choiceRef", _) => __obj.spiritchoiceRef foreach { x => attr = scala.xml.Attribute(__scope.getPrefix("http://www.spiritconsortium.org/XMLSchema/SPIRIT/1685-2009"), "choiceRef", x.toString, attr) }
        case ("@{http://www.spiritconsortium.org/XMLSchema/SPIRIT/1685-2009}order", _) => __obj.spiritorder foreach { x => attr = scala.xml.Attribute(__scope.getPrefix("http://www.spiritconsortium.org/XMLSchema/SPIRIT/1685-2009"), "order", x.toString, attr) }
        case ("@{http://www.spiritconsortium.org/XMLSchema/SPIRIT/1685-2009}configGroups", _) => __obj.spiritconfigGroups foreach { x => attr = scala.xml.Attribute(__scope.getPrefix("http://www.spiritconsortium.org/XMLSchema/SPIRIT/1685-2009"), "configGroups", x.toString, attr) }
        case ("@{http://www.spiritconsortium.org/XMLSchema/SPIRIT/1685-2009}bitStringLength", _) => __obj.spiritbitStringLength foreach { x => attr = scala.xml.Attribute(__scope.getPrefix("http://www.spiritconsortium.org/XMLSchema/SPIRIT/1685-2009"), "bitStringLength", x.toString, attr) }
        case ("@{http://www.spiritconsortium.org/XMLSchema/SPIRIT/1685-2009}minimum", _) => __obj.spiritminimum foreach { x => attr = scala.xml.Attribute(__scope.getPrefix("http://www.spiritconsortium.org/XMLSchema/SPIRIT/1685-2009"), "minimum", x.toString, attr) }
        case ("@{http://www.spiritconsortium.org/XMLSchema/SPIRIT/1685-2009}maximum", _) => __obj.spiritmaximum foreach { x => attr = scala.xml.Attribute(__scope.getPrefix("http://www.spiritconsortium.org/XMLSchema/SPIRIT/1685-2009"), "maximum", x.toString, attr) }
        case ("@{http://www.spiritconsortium.org/XMLSchema/SPIRIT/1685-2009}rangeType", _) => if (__obj.spiritrangeType.toString != "float") attr = scala.xml.Attribute(__scope.getPrefix("http://www.spiritconsortium.org/XMLSchema/SPIRIT/1685-2009"), "rangeType", __obj.spiritrangeType.toString, attr)
        case ("@{http://www.spiritconsortium.org/XMLSchema/SPIRIT/1685-2009}prompt", _) => __obj.spiritprompt foreach { x => attr = scala.xml.Attribute(__scope.getPrefix("http://www.spiritconsortium.org/XMLSchema/SPIRIT/1685-2009"), "prompt", x.toString, attr) }
        case (key, x) => attr = scala.xml.Attribute((x.namespace map { __scope.getPrefix(_) }).orNull, x.key.orNull, x.value.toString, attr)
      }
      attr
    }

    def writesChildNodes(__obj: LeftType4, __scope: scala.xml.NamespaceBinding): Seq[scala.xml.Node] =
      Seq(scala.xml.Text(__obj.value.toString))

  }

  trait Default_RightType4Format extends IPXACT2009scalaxb.XMLFormat[RightType4] with IPXACT2009scalaxb.CanWriteChildNodes[RightType4] {
    val targetNamespace: Option[String] = Some("http://www.spiritconsortium.org/XMLSchema/SPIRIT/1685-2009")
    def reads(seq: scala.xml.NodeSeq, stack: List[IPXACT2009scalaxb.ElemName]): Either[String, RightType4] = seq match {
      case node: scala.xml.Node => Right(RightType4(IPXACT2009scalaxb.fromXML[BigInt](node, IPXACT2009scalaxb.ElemName(node) :: stack),
        scala.collection.immutable.ListMap(List(
        (node \ "@{http://www.spiritconsortium.org/XMLSchema/SPIRIT/1685-2009}format").headOption map { x => IPXACT2009scalaxb.DataRecord(x, node, IPXACT2009scalaxb.fromXML[FormatType](x, IPXACT2009scalaxb.ElemName(node) :: stack)) } orElse Some(IPXACT2009scalaxb.DataRecord(None, None, IPXACT2009scalaxb.fromXML[FormatType](scala.xml.Text("long"), IPXACT2009scalaxb.ElemName(node) :: stack))) map { "@{http://www.spiritconsortium.org/XMLSchema/SPIRIT/1685-2009}format" -> _ },
        (node \ "@{http://www.spiritconsortium.org/XMLSchema/SPIRIT/1685-2009}resolve").headOption map { x => IPXACT2009scalaxb.DataRecord(x, node, IPXACT2009scalaxb.fromXML[ResolveType](x, IPXACT2009scalaxb.ElemName(node) :: stack)) } map { "@{http://www.spiritconsortium.org/XMLSchema/SPIRIT/1685-2009}resolve" -> _ },
        (node \ "@{http://www.spiritconsortium.org/XMLSchema/SPIRIT/1685-2009}id").headOption map { x => IPXACT2009scalaxb.DataRecord(x, node, IPXACT2009scalaxb.fromXML[String](x, IPXACT2009scalaxb.ElemName(node) :: stack)) } map { "@{http://www.spiritconsortium.org/XMLSchema/SPIRIT/1685-2009}id" -> _ },
        (node \ "@{http://www.spiritconsortium.org/XMLSchema/SPIRIT/1685-2009}dependency").headOption map { x => IPXACT2009scalaxb.DataRecord(x, node, IPXACT2009scalaxb.fromXML[String](x, IPXACT2009scalaxb.ElemName(node) :: stack)) } map { "@{http://www.spiritconsortium.org/XMLSchema/SPIRIT/1685-2009}dependency" -> _ },
        (node \ "@{http://www.spiritconsortium.org/XMLSchema/SPIRIT/1685-2009}choiceRef").headOption map { x => IPXACT2009scalaxb.DataRecord(x, node, IPXACT2009scalaxb.fromXML[String](x, IPXACT2009scalaxb.ElemName(node) :: stack)) } map { "@{http://www.spiritconsortium.org/XMLSchema/SPIRIT/1685-2009}choiceRef" -> _ },
        (node \ "@{http://www.spiritconsortium.org/XMLSchema/SPIRIT/1685-2009}order").headOption map { x => IPXACT2009scalaxb.DataRecord(x, node, IPXACT2009scalaxb.fromXML[Float](x, IPXACT2009scalaxb.ElemName(node) :: stack)) } map { "@{http://www.spiritconsortium.org/XMLSchema/SPIRIT/1685-2009}order" -> _ },
        (node \ "@{http://www.spiritconsortium.org/XMLSchema/SPIRIT/1685-2009}configGroups").headOption map { x => IPXACT2009scalaxb.DataRecord(x, node, IPXACT2009scalaxb.fromXML[Seq[String]](x, IPXACT2009scalaxb.ElemName(node) :: stack)) } map { "@{http://www.spiritconsortium.org/XMLSchema/SPIRIT/1685-2009}configGroups" -> _ },
        (node \ "@{http://www.spiritconsortium.org/XMLSchema/SPIRIT/1685-2009}bitStringLength").headOption map { x => IPXACT2009scalaxb.DataRecord(x, node, IPXACT2009scalaxb.fromXML[BigInt](x, IPXACT2009scalaxb.ElemName(node) :: stack)) } map { "@{http://www.spiritconsortium.org/XMLSchema/SPIRIT/1685-2009}bitStringLength" -> _ },
        (node \ "@{http://www.spiritconsortium.org/XMLSchema/SPIRIT/1685-2009}minimum").headOption map { x => IPXACT2009scalaxb.DataRecord(x, node, IPXACT2009scalaxb.fromXML[String](x, IPXACT2009scalaxb.ElemName(node) :: stack)) } map { "@{http://www.spiritconsortium.org/XMLSchema/SPIRIT/1685-2009}minimum" -> _ },
        (node \ "@{http://www.spiritconsortium.org/XMLSchema/SPIRIT/1685-2009}maximum").headOption map { x => IPXACT2009scalaxb.DataRecord(x, node, IPXACT2009scalaxb.fromXML[String](x, IPXACT2009scalaxb.ElemName(node) :: stack)) } map { "@{http://www.spiritconsortium.org/XMLSchema/SPIRIT/1685-2009}maximum" -> _ },
        (node \ "@{http://www.spiritconsortium.org/XMLSchema/SPIRIT/1685-2009}rangeType").headOption map { x => IPXACT2009scalaxb.DataRecord(x, node, IPXACT2009scalaxb.fromXML[RangeTypeType](x, IPXACT2009scalaxb.ElemName(node) :: stack)) } orElse Some(IPXACT2009scalaxb.DataRecord(None, None, IPXACT2009scalaxb.fromXML[RangeTypeType](scala.xml.Text("float"), IPXACT2009scalaxb.ElemName(node) :: stack))) map { "@{http://www.spiritconsortium.org/XMLSchema/SPIRIT/1685-2009}rangeType" -> _ },
        (node \ "@{http://www.spiritconsortium.org/XMLSchema/SPIRIT/1685-2009}prompt").headOption map { x => IPXACT2009scalaxb.DataRecord(x, node, IPXACT2009scalaxb.fromXML[String](x, IPXACT2009scalaxb.ElemName(node) :: stack)) } map { "@{http://www.spiritconsortium.org/XMLSchema/SPIRIT/1685-2009}prompt" -> _ }
        ).flatten[(String, IPXACT2009scalaxb.DataRecord[Any])] ::: (node match {
          case elem: scala.xml.Elem =>
            elem.attributes.toList flatMap {
              case scala.xml.PrefixedAttribute(pre, key, value, _) if pre == elem.scope.getPrefix("http://www.spiritconsortium.org/XMLSchema/SPIRIT/1685-2009") &&
                key == "format" => Nil
              case scala.xml.PrefixedAttribute(pre, key, value, _) if pre == elem.scope.getPrefix("http://www.spiritconsortium.org/XMLSchema/SPIRIT/1685-2009") &&
                key == "resolve" => Nil
              case scala.xml.PrefixedAttribute(pre, key, value, _) if pre == elem.scope.getPrefix("http://www.spiritconsortium.org/XMLSchema/SPIRIT/1685-2009") &&
                key == "id" => Nil
              case scala.xml.PrefixedAttribute(pre, key, value, _) if pre == elem.scope.getPrefix("http://www.spiritconsortium.org/XMLSchema/SPIRIT/1685-2009") &&
                key == "dependency" => Nil
              case scala.xml.PrefixedAttribute(pre, key, value, _) if pre == elem.scope.getPrefix("http://www.spiritconsortium.org/XMLSchema/SPIRIT/1685-2009") &&
                key == "choiceRef" => Nil
              case scala.xml.PrefixedAttribute(pre, key, value, _) if pre == elem.scope.getPrefix("http://www.spiritconsortium.org/XMLSchema/SPIRIT/1685-2009") &&
                key == "order" => Nil
              case scala.xml.PrefixedAttribute(pre, key, value, _) if pre == elem.scope.getPrefix("http://www.spiritconsortium.org/XMLSchema/SPIRIT/1685-2009") &&
                key == "configGroups" => Nil
              case scala.xml.PrefixedAttribute(pre, key, value, _) if pre == elem.scope.getPrefix("http://www.spiritconsortium.org/XMLSchema/SPIRIT/1685-2009") &&
                key == "bitStringLength" => Nil
              case scala.xml.PrefixedAttribute(pre, key, value, _) if pre == elem.scope.getPrefix("http://www.spiritconsortium.org/XMLSchema/SPIRIT/1685-2009") &&
                key == "minimum" => Nil
              case scala.xml.PrefixedAttribute(pre, key, value, _) if pre == elem.scope.getPrefix("http://www.spiritconsortium.org/XMLSchema/SPIRIT/1685-2009") &&
                key == "maximum" => Nil
              case scala.xml.PrefixedAttribute(pre, key, value, _) if pre == elem.scope.getPrefix("http://www.spiritconsortium.org/XMLSchema/SPIRIT/1685-2009") &&
                key == "rangeType" => Nil
              case scala.xml.PrefixedAttribute(pre, key, value, _) if pre == elem.scope.getPrefix("http://www.spiritconsortium.org/XMLSchema/SPIRIT/1685-2009") &&
                key == "prompt" => Nil
              case scala.xml.UnprefixedAttribute(key, value, _) =>
                List(("@" + key, IPXACT2009scalaxb.DataRecord(None, Some(key), value.text)))
              case scala.xml.PrefixedAttribute(pre, key, value, _) =>
                val ns = elem.scope.getURI(pre)
                List(("@{" + ns + "}" + key, IPXACT2009scalaxb.DataRecord(Option[String](ns), Some(key), value.text)))
              case _ => Nil
            }
          case _ => Nil
        }): _*)))
      case _ => Left("reads failed: seq must be scala.xml.Node")
    }
    
    override def writesAttribute(__obj: RightType4, __scope: scala.xml.NamespaceBinding): scala.xml.MetaData = {
      var attr: scala.xml.MetaData  = scala.xml.Null
      __obj.attributes.toList map {
        case ("@{http://www.spiritconsortium.org/XMLSchema/SPIRIT/1685-2009}format", _) => if (__obj.spiritformat.toString != "long") attr = scala.xml.Attribute(__scope.getPrefix("http://www.spiritconsortium.org/XMLSchema/SPIRIT/1685-2009"), "format", __obj.spiritformat.toString, attr)
        case ("@{http://www.spiritconsortium.org/XMLSchema/SPIRIT/1685-2009}resolve", _) => __obj.spiritresolve foreach { x => attr = scala.xml.Attribute(__scope.getPrefix("http://www.spiritconsortium.org/XMLSchema/SPIRIT/1685-2009"), "resolve", x.toString, attr) }
        case ("@{http://www.spiritconsortium.org/XMLSchema/SPIRIT/1685-2009}id", _) => __obj.spiritid foreach { x => attr = scala.xml.Attribute(__scope.getPrefix("http://www.spiritconsortium.org/XMLSchema/SPIRIT/1685-2009"), "id", x.toString, attr) }
        case ("@{http://www.spiritconsortium.org/XMLSchema/SPIRIT/1685-2009}dependency", _) => __obj.spiritdependency foreach { x => attr = scala.xml.Attribute(__scope.getPrefix("http://www.spiritconsortium.org/XMLSchema/SPIRIT/1685-2009"), "dependency", x.toString, attr) }
        case ("@{http://www.spiritconsortium.org/XMLSchema/SPIRIT/1685-2009}choiceRef", _) => __obj.spiritchoiceRef foreach { x => attr = scala.xml.Attribute(__scope.getPrefix("http://www.spiritconsortium.org/XMLSchema/SPIRIT/1685-2009"), "choiceRef", x.toString, attr) }
        case ("@{http://www.spiritconsortium.org/XMLSchema/SPIRIT/1685-2009}order", _) => __obj.spiritorder foreach { x => attr = scala.xml.Attribute(__scope.getPrefix("http://www.spiritconsortium.org/XMLSchema/SPIRIT/1685-2009"), "order", x.toString, attr) }
        case ("@{http://www.spiritconsortium.org/XMLSchema/SPIRIT/1685-2009}configGroups", _) => __obj.spiritconfigGroups foreach { x => attr = scala.xml.Attribute(__scope.getPrefix("http://www.spiritconsortium.org/XMLSchema/SPIRIT/1685-2009"), "configGroups", x.toString, attr) }
        case ("@{http://www.spiritconsortium.org/XMLSchema/SPIRIT/1685-2009}bitStringLength", _) => __obj.spiritbitStringLength foreach { x => attr = scala.xml.Attribute(__scope.getPrefix("http://www.spiritconsortium.org/XMLSchema/SPIRIT/1685-2009"), "bitStringLength", x.toString, attr) }
        case ("@{http://www.spiritconsortium.org/XMLSchema/SPIRIT/1685-2009}minimum", _) => __obj.spiritminimum foreach { x => attr = scala.xml.Attribute(__scope.getPrefix("http://www.spiritconsortium.org/XMLSchema/SPIRIT/1685-2009"), "minimum", x.toString, attr) }
        case ("@{http://www.spiritconsortium.org/XMLSchema/SPIRIT/1685-2009}maximum", _) => __obj.spiritmaximum foreach { x => attr = scala.xml.Attribute(__scope.getPrefix("http://www.spiritconsortium.org/XMLSchema/SPIRIT/1685-2009"), "maximum", x.toString, attr) }
        case ("@{http://www.spiritconsortium.org/XMLSchema/SPIRIT/1685-2009}rangeType", _) => if (__obj.spiritrangeType.toString != "float") attr = scala.xml.Attribute(__scope.getPrefix("http://www.spiritconsortium.org/XMLSchema/SPIRIT/1685-2009"), "rangeType", __obj.spiritrangeType.toString, attr)
        case ("@{http://www.spiritconsortium.org/XMLSchema/SPIRIT/1685-2009}prompt", _) => __obj.spiritprompt foreach { x => attr = scala.xml.Attribute(__scope.getPrefix("http://www.spiritconsortium.org/XMLSchema/SPIRIT/1685-2009"), "prompt", x.toString, attr) }
        case (key, x) => attr = scala.xml.Attribute((x.namespace map { __scope.getPrefix(_) }).orNull, x.key.orNull, x.value.toString, attr)
      }
      attr
    }

    def writesChildNodes(__obj: RightType4, __scope: scala.xml.NamespaceBinding): Seq[scala.xml.Node] =
      Seq(scala.xml.Text(__obj.value.toString))

  }

  trait Default_Vector4Format extends IPXACT2009scalaxb.ElemNameParser[Vector4] {
    val targetNamespace: Option[String] = Some("http://www.spiritconsortium.org/XMLSchema/SPIRIT/1685-2009")
    
    def parser(node: scala.xml.Node, stack: List[IPXACT2009scalaxb.ElemName]): Parser[Vector4] =
      phrase((IPXACT2009scalaxb.ElemName(Some("http://www.spiritconsortium.org/XMLSchema/SPIRIT/1685-2009"), "left")) ~
      (IPXACT2009scalaxb.ElemName(Some("http://www.spiritconsortium.org/XMLSchema/SPIRIT/1685-2009"), "right")) ^^
      { case p1 ~ p2 =>
      Vector4(IPXACT2009scalaxb.fromXML[LeftType4](p1, IPXACT2009scalaxb.ElemName(node) :: stack),
        IPXACT2009scalaxb.fromXML[RightType4](p2, IPXACT2009scalaxb.ElemName(node) :: stack)) })
    
    def writesChildNodes(__obj: Vector4, __scope: scala.xml.NamespaceBinding): Seq[scala.xml.Node] =
      Seq.concat(IPXACT2009scalaxb.toXML[LeftType4](__obj.left, Some("http://www.spiritconsortium.org/XMLSchema/SPIRIT/1685-2009"), Some("left"), __scope, false),
        IPXACT2009scalaxb.toXML[RightType4](__obj.right, Some("http://www.spiritconsortium.org/XMLSchema/SPIRIT/1685-2009"), Some("right"), __scope, false))

  }

  trait Default_PortDeclarationTypableFormat extends IPXACT2009scalaxb.XMLFormat[PortDeclarationTypable] {
    def reads(seq: scala.xml.NodeSeq, stack: List[IPXACT2009scalaxb.ElemName]): Either[String, PortDeclarationTypable] = seq match {
      case node: scala.xml.Node =>     
        IPXACT2009scalaxb.Helper.instanceType(node) match {
          case (Some("http://www.spiritconsortium.org/XMLSchema/SPIRIT/1685-2009"), Some("portType")) => Right(IPXACT2009scalaxb.fromXML[PortTypable](node, stack))
          case (Some("http://www.spiritconsortium.org/XMLSchema/SPIRIT/1685-2009"), Some("abstractorPortType")) => Right(IPXACT2009scalaxb.fromXML[AbstractorPortType](node, stack))
          case _ => Right(IPXACT2009scalaxb.fromXML[PortDeclarationType](node, stack))
        }
      case _ => Left("reads failed: seq must be scala.xml.Node")  
    }
    
    def writes(__obj: PortDeclarationTypable, __namespace: Option[String], __elementLabel: Option[String],
        __scope: scala.xml.NamespaceBinding, __typeAttribute: Boolean): scala.xml.NodeSeq = __obj match {
      case x: PortTypable => IPXACT2009scalaxb.toXML[PortTypable](x, __namespace, __elementLabel, __scope, true)
      case x: PortDeclarationType => IPXACT2009scalaxb.toXML[PortDeclarationType](x, __namespace, __elementLabel, __scope, __typeAttribute)
    }
  }

  trait Default_PortDeclarationTypeFormat extends IPXACT2009scalaxb.ElemNameParser[PortDeclarationType] with _NameGroupPortGroupFormat {
    val targetNamespace: Option[String] = Some("http://www.spiritconsortium.org/XMLSchema/SPIRIT/1685-2009")
    
    override def typeName: Option[String] = Some("portDeclarationType")

    def parser(node: scala.xml.Node, stack: List[IPXACT2009scalaxb.ElemName]): Parser[PortDeclarationType] =
      phrase((parseNameGroupPortGroup(node, IPXACT2009scalaxb.ElemName(node) :: stack)) ~
      (((IPXACT2009scalaxb.ElemName(Some("http://www.spiritconsortium.org/XMLSchema/SPIRIT/1685-2009"), "wire")) ^^
      (x => IPXACT2009scalaxb.DataRecord(x.namespace, Some(x.name), IPXACT2009scalaxb.fromXML[PortWireTypable](x, IPXACT2009scalaxb.ElemName(node) :: stack)))) |
      ((IPXACT2009scalaxb.ElemName(Some("http://www.spiritconsortium.org/XMLSchema/SPIRIT/1685-2009"), "transactional")) ^^
      (x => IPXACT2009scalaxb.DataRecord(x.namespace, Some(x.name), IPXACT2009scalaxb.fromXML[PortTransactionalType](x, IPXACT2009scalaxb.ElemName(node) :: stack))))) ~
      ((opt(IPXACT2009scalaxb.ElemName(Some("http://www.spiritconsortium.org/XMLSchema/SPIRIT/1685-2009"), "access"))) ^^
        { case p1 => PortDeclarationTypableSequence1(p1.headOption map { IPXACT2009scalaxb.fromXML[PortAccessType](_, IPXACT2009scalaxb.ElemName(node) :: stack) }) }) ^^
      { case p1 ~ p2 ~ p3 =>
      PortDeclarationType(p1,
        p2,
        p3) })
    
    def writesChildNodes(__obj: PortDeclarationType, __scope: scala.xml.NamespaceBinding): Seq[scala.xml.Node] =
      Seq.concat(IPXACT2009scalaxb.toXML[NameGroupPortSequence](__obj.nameGroupPortSequence1, None, Some("nameGroupPortSequence1"), __scope, false),
        (Some(__obj.portdeclarationtypableoption) map {x => IPXACT2009scalaxb.toXML[IPXACT2009scalaxb.DataRecord[PortDeclarationTypableOption]](x, x.namespace, x.key, __scope, false)}).get,
        IPXACT2009scalaxb.toXML[PortDeclarationTypableSequence1](__obj.portdeclarationtypablesequence1, None, Some("portdeclarationtypablesequence1"), __scope, false))

  }

  trait Default_PortDeclarationTypableSequence1Format extends IPXACT2009scalaxb.XMLFormat[PortDeclarationTypableSequence1] {
    def reads(seq: scala.xml.NodeSeq, stack: List[IPXACT2009scalaxb.ElemName]): Either[String, PortDeclarationTypableSequence1] = Left("don't call me.")
    
    def writes(__obj: PortDeclarationTypableSequence1, __namespace: Option[String], __elementLabel: Option[String], 
        __scope: scala.xml.NamespaceBinding, __typeAttribute: Boolean): scala.xml.NodeSeq =
      __obj.access map { IPXACT2009scalaxb.toXML[PortAccessType](_, Some("http://www.spiritconsortium.org/XMLSchema/SPIRIT/1685-2009"), Some("access"), __scope, false) } getOrElse {Nil}

  }
  trait Default_PortTypableFormat extends IPXACT2009scalaxb.XMLFormat[PortTypable] {
    def reads(seq: scala.xml.NodeSeq, stack: List[IPXACT2009scalaxb.ElemName]): Either[String, PortTypable] = seq match {
      case node: scala.xml.Node =>     
        IPXACT2009scalaxb.Helper.instanceType(node) match {
          case (Some("http://www.spiritconsortium.org/XMLSchema/SPIRIT/1685-2009"), Some("abstractorPortType")) => Right(IPXACT2009scalaxb.fromXML[AbstractorPortType](node, stack))
          case _ => Right(IPXACT2009scalaxb.fromXML[PortType](node, stack))
        }
      case _ => Left("reads failed: seq must be scala.xml.Node")  
    }
    
    def writes(__obj: PortTypable, __namespace: Option[String], __elementLabel: Option[String],
        __scope: scala.xml.NamespaceBinding, __typeAttribute: Boolean): scala.xml.NodeSeq = __obj match {
      case x: AbstractorPortType => IPXACT2009scalaxb.toXML[AbstractorPortType](x, __namespace, __elementLabel, __scope, true)
      case x: PortType => IPXACT2009scalaxb.toXML[PortType](x, __namespace, __elementLabel, __scope, __typeAttribute)
    }
  }
  trait Default_PortTypeFormat extends IPXACT2009scalaxb.ElemNameParser[PortType] with _NameGroupPortGroupFormat {
    val targetNamespace: Option[String] = Some("http://www.spiritconsortium.org/XMLSchema/SPIRIT/1685-2009")
    
    override def typeName: Option[String] = Some("portType")

    def parser(node: scala.xml.Node, stack: List[IPXACT2009scalaxb.ElemName]): Parser[PortType] =
      phrase((parseNameGroupPortGroup(node, IPXACT2009scalaxb.ElemName(node) :: stack)) ~
      (((IPXACT2009scalaxb.ElemName(Some("http://www.spiritconsortium.org/XMLSchema/SPIRIT/1685-2009"), "wire")) ^^
      (x => IPXACT2009scalaxb.DataRecord(x.namespace, Some(x.name), IPXACT2009scalaxb.fromXML[PortWireTypable](x, IPXACT2009scalaxb.ElemName(node) :: stack)))) |
      ((IPXACT2009scalaxb.ElemName(Some("http://www.spiritconsortium.org/XMLSchema/SPIRIT/1685-2009"), "transactional")) ^^
      (x => IPXACT2009scalaxb.DataRecord(x.namespace, Some(x.name), IPXACT2009scalaxb.fromXML[PortTransactionalType](x, IPXACT2009scalaxb.ElemName(node) :: stack))))) ~
      ((opt(IPXACT2009scalaxb.ElemName(Some("http://www.spiritconsortium.org/XMLSchema/SPIRIT/1685-2009"), "access"))) ^^
        { case p1 => PortDeclarationTypableSequence1(p1.headOption map { IPXACT2009scalaxb.fromXML[PortAccessType](_, IPXACT2009scalaxb.ElemName(node) :: stack) }) }) ~
      opt(IPXACT2009scalaxb.ElemName(Some("http://www.spiritconsortium.org/XMLSchema/SPIRIT/1685-2009"), "vendorExtensions")) ^^
      { case p1 ~ p2 ~ p3 ~ p4 =>
      PortType(p1,
        p2,
        p3,
        p4.headOption map { IPXACT2009scalaxb.fromXML[VendorExtensions](_, IPXACT2009scalaxb.ElemName(node) :: stack) }) })
    
    def writesChildNodes(__obj: PortType, __scope: scala.xml.NamespaceBinding): Seq[scala.xml.Node] =
      Seq.concat(IPXACT2009scalaxb.toXML[NameGroupPortSequence](__obj.nameGroupPortSequence1, None, Some("nameGroupPortSequence1"), __scope, false),
        (Some(__obj.portdeclarationtypableoption) map {x => IPXACT2009scalaxb.toXML[IPXACT2009scalaxb.DataRecord[PortDeclarationTypableOption]](x, x.namespace, x.key, __scope, false)}).get,
        IPXACT2009scalaxb.toXML[PortDeclarationTypableSequence1](__obj.portdeclarationtypablesequence1, None, Some("portdeclarationtypablesequence1"), __scope, false),
        __obj.vendorExtensions map { IPXACT2009scalaxb.toXML[VendorExtensions](_, Some("http://www.spiritconsortium.org/XMLSchema/SPIRIT/1685-2009"), Some("vendorExtensions"), __scope, false) } getOrElse {Nil})

  }

  trait Default_AbstractorPortTypeFormat extends IPXACT2009scalaxb.ElemNameParser[AbstractorPortType] with _NameGroupPortGroupFormat {
    val targetNamespace: Option[String] = Some("http://www.spiritconsortium.org/XMLSchema/SPIRIT/1685-2009")
    
    override def typeName: Option[String] = Some("abstractorPortType")

    def parser(node: scala.xml.Node, stack: List[IPXACT2009scalaxb.ElemName]): Parser[AbstractorPortType] =
      phrase((parseNameGroupPortGroup(node, IPXACT2009scalaxb.ElemName(node) :: stack)) ~
      (((IPXACT2009scalaxb.ElemName(Some("http://www.spiritconsortium.org/XMLSchema/SPIRIT/1685-2009"), "wire")) ^^
      (x => IPXACT2009scalaxb.DataRecord(x.namespace, Some(x.name), IPXACT2009scalaxb.fromXML[PortWireTypable](x, IPXACT2009scalaxb.ElemName(node) :: stack)))) |
      ((IPXACT2009scalaxb.ElemName(Some("http://www.spiritconsortium.org/XMLSchema/SPIRIT/1685-2009"), "transactional")) ^^
      (x => IPXACT2009scalaxb.DataRecord(x.namespace, Some(x.name), IPXACT2009scalaxb.fromXML[PortTransactionalType](x, IPXACT2009scalaxb.ElemName(node) :: stack))))) ~
      ((opt(IPXACT2009scalaxb.ElemName(Some("http://www.spiritconsortium.org/XMLSchema/SPIRIT/1685-2009"), "access"))) ^^
        { case p1 => PortDeclarationTypableSequence1(p1.headOption map { IPXACT2009scalaxb.fromXML[PortAccessType](_, IPXACT2009scalaxb.ElemName(node) :: stack) }) }) ~
      opt(IPXACT2009scalaxb.ElemName(Some("http://www.spiritconsortium.org/XMLSchema/SPIRIT/1685-2009"), "vendorExtensions")) ^^
      { case p1 ~ p2 ~ p3 ~ p4 =>
      AbstractorPortType(p1,
        p2,
        p3,
        p4.headOption map { IPXACT2009scalaxb.fromXML[VendorExtensions](_, IPXACT2009scalaxb.ElemName(node) :: stack) }) })
    
    def writesChildNodes(__obj: AbstractorPortType, __scope: scala.xml.NamespaceBinding): Seq[scala.xml.Node] =
      Seq.concat(IPXACT2009scalaxb.toXML[NameGroupPortSequence](__obj.nameGroupPortSequence1, None, Some("nameGroupPortSequence1"), __scope, false),
        (Some(__obj.portdeclarationtypableoption) map {x => IPXACT2009scalaxb.toXML[IPXACT2009scalaxb.DataRecord[PortDeclarationTypableOption]](x, x.namespace, x.key, __scope, false)}).get,
        IPXACT2009scalaxb.toXML[PortDeclarationTypableSequence1](__obj.portdeclarationtypablesequence1, None, Some("portdeclarationtypablesequence1"), __scope, false),
        __obj.vendorExtensions map { IPXACT2009scalaxb.toXML[VendorExtensions](_, Some("http://www.spiritconsortium.org/XMLSchema/SPIRIT/1685-2009"), Some("vendorExtensions"), __scope, false) } getOrElse {Nil})

  }

  trait Default_AbstractorPortTypeSequence3Format extends IPXACT2009scalaxb.XMLFormat[AbstractorPortTypeSequence3] {
    def reads(seq: scala.xml.NodeSeq, stack: List[IPXACT2009scalaxb.ElemName]): Either[String, AbstractorPortTypeSequence3] = Left("don't call me.")
    
    def writes(__obj: AbstractorPortTypeSequence3, __namespace: Option[String], __elementLabel: Option[String], 
        __scope: scala.xml.NamespaceBinding, __typeAttribute: Boolean): scala.xml.NodeSeq =
      __obj.vendorExtensions map { IPXACT2009scalaxb.toXML[VendorExtensions](_, Some("http://www.spiritconsortium.org/XMLSchema/SPIRIT/1685-2009"), Some("vendorExtensions"), __scope, false) } getOrElse {Nil}

  }
  trait Default_AbstractorPortTypeSequence1Format extends IPXACT2009scalaxb.XMLFormat[AbstractorPortTypeSequence1] {
    def reads(seq: scala.xml.NodeSeq, stack: List[IPXACT2009scalaxb.ElemName]): Either[String, AbstractorPortTypeSequence1] = Left("don't call me.")
    
    def writes(__obj: AbstractorPortTypeSequence1, __namespace: Option[String], __elementLabel: Option[String], 
        __scope: scala.xml.NamespaceBinding, __typeAttribute: Boolean): scala.xml.NodeSeq =
      Seq.concat(IPXACT2009scalaxb.toXML[NameGroupPortSequence](__obj.nameGroupPortSequence1, None, Some("nameGroupPortSequence1"), __scope, false),
        (Some(__obj.abstractorporttypeoption) map {x => IPXACT2009scalaxb.toXML[IPXACT2009scalaxb.DataRecord[AbstractorPortTypeOption]](x, x.namespace, x.key, __scope, false)}).get,
        IPXACT2009scalaxb.toXML[AbstractorPortTypeSequence2](__obj.abstractorporttypesequence2, None, Some("abstractorporttypesequence2"), __scope, false))


  }

  trait Default_AbstractorPortTypeSequence2Format extends IPXACT2009scalaxb.XMLFormat[AbstractorPortTypeSequence2] {
    def reads(seq: scala.xml.NodeSeq, stack: List[IPXACT2009scalaxb.ElemName]): Either[String, AbstractorPortTypeSequence2] = Left("don't call me.")
    
    def writes(__obj: AbstractorPortTypeSequence2, __namespace: Option[String], __elementLabel: Option[String], 
        __scope: scala.xml.NamespaceBinding, __typeAttribute: Boolean): scala.xml.NodeSeq =
      __obj.access map { IPXACT2009scalaxb.toXML[PortAccessType](_, Some("http://www.spiritconsortium.org/XMLSchema/SPIRIT/1685-2009"), Some("access"), __scope, false) } getOrElse {Nil}

  }
  def build_InitiativeTypeFormat = new Default_InitiativeTypeFormat {}
  trait Default_InitiativeTypeFormat extends IPXACT2009scalaxb.XMLFormat[InitiativeType] {
    val targetNamespace: Option[String] = Some("http://www.spiritconsortium.org/XMLSchema/SPIRIT/1685-2009")
    
    def fromString(value: String, scope: scala.xml.NamespaceBinding): InitiativeType =
        (fromString0(value, scope)).apply(IPXACT2009scalaxb.fromXML[String](scala.xml.Text(value)))

    private def fromString0(value: String, scope: scala.xml.NamespaceBinding): PartialFunction[Any, InitiativeType] = {
      case x: String if x == IPXACT2009scalaxb.fromXML[String](scala.xml.Text("requires")) => RequiresValue
      case x: String if x == IPXACT2009scalaxb.fromXML[String](scala.xml.Text("provides")) => ProvidesValue
      case x: String if x == IPXACT2009scalaxb.fromXML[String](scala.xml.Text("both")) => BothValue
      case x: String if x == IPXACT2009scalaxb.fromXML[String](scala.xml.Text("phantom")) => PhantomValue

    }



    def reads(seq: scala.xml.NodeSeq, stack: List[IPXACT2009scalaxb.ElemName]): Either[String, InitiativeType] = seq match {
      case elem: scala.xml.Elem => Right(fromString(elem.text, elem.scope))
      case _ => Right(fromString(seq.text, scala.xml.TopScope))
    }
    
    def writes(__obj: InitiativeType, __namespace: Option[String], __elementLabel: Option[String],
        __scope: scala.xml.NamespaceBinding, __typeAttribute: Boolean): scala.xml.NodeSeq =
      scala.xml.Elem(IPXACT2009scalaxb.Helper.getPrefix(__namespace, __scope).orNull,
        __elementLabel getOrElse { sys.error("missing element label.") },
        scala.xml.Null, __scope, true, scala.xml.Text(__obj.toString))
  }
  def build_PortAccessTypeTypeFormat = new Default_PortAccessTypeTypeFormat {}
  trait Default_PortAccessTypeTypeFormat extends IPXACT2009scalaxb.XMLFormat[PortAccessTypeType] {
    val targetNamespace: Option[String] = Some("http://www.spiritconsortium.org/XMLSchema/SPIRIT/1685-2009")
    
    def fromString(value: String, scope: scala.xml.NamespaceBinding): PortAccessTypeType =
        (fromString0(value, scope)).apply(IPXACT2009scalaxb.fromXML[String](scala.xml.Text(value)))

    private def fromString0(value: String, scope: scala.xml.NamespaceBinding): PartialFunction[Any, PortAccessTypeType] = {
      case x: String if x == IPXACT2009scalaxb.fromXML[String](scala.xml.Text("ref")) => Ref
      case x: String if x == IPXACT2009scalaxb.fromXML[String](scala.xml.Text("ptr")) => Ptr

    }



    def reads(seq: scala.xml.NodeSeq, stack: List[IPXACT2009scalaxb.ElemName]): Either[String, PortAccessTypeType] = seq match {
      case elem: scala.xml.Elem => Right(fromString(elem.text, elem.scope))
      case _ => Right(fromString(seq.text, scala.xml.TopScope))
    }
    
    def writes(__obj: PortAccessTypeType, __namespace: Option[String], __elementLabel: Option[String],
        __scope: scala.xml.NamespaceBinding, __typeAttribute: Boolean): scala.xml.NodeSeq =
      scala.xml.Elem(IPXACT2009scalaxb.Helper.getPrefix(__namespace, __scope).orNull,
        __elementLabel getOrElse { sys.error("missing element label.") },
        scala.xml.Null, __scope, true, scala.xml.Text(__obj.toString))
  }
  trait Default_TypeName2Format extends IPXACT2009scalaxb.XMLFormat[TypeName2] with IPXACT2009scalaxb.CanWriteChildNodes[TypeName2] {
    val targetNamespace: Option[String] = Some("http://www.spiritconsortium.org/XMLSchema/SPIRIT/1685-2009")
    def reads(seq: scala.xml.NodeSeq, stack: List[IPXACT2009scalaxb.ElemName]): Either[String, TypeName2] = seq match {
      case node: scala.xml.Node => Right(TypeName2(IPXACT2009scalaxb.fromXML[String](node, IPXACT2009scalaxb.ElemName(node) :: stack),
        scala.collection.immutable.ListMap(List(
        (node \ "@{http://www.spiritconsortium.org/XMLSchema/SPIRIT/1685-2009}constrained").headOption map { x => IPXACT2009scalaxb.DataRecord(x, node, IPXACT2009scalaxb.fromXML[Boolean](x, IPXACT2009scalaxb.ElemName(node) :: stack)) } orElse Some(IPXACT2009scalaxb.DataRecord(None, None, IPXACT2009scalaxb.fromXML[Boolean](scala.xml.Text("false"), IPXACT2009scalaxb.ElemName(node) :: stack))) map { "@constrained" -> _ }
        ).flatten[(String, IPXACT2009scalaxb.DataRecord[Any])]: _*)))
      case _ => Left("reads failed: seq must be scala.xml.Node")
    }
    
    override def writesAttribute(__obj: TypeName2, __scope: scala.xml.NamespaceBinding): scala.xml.MetaData = {
      var attr: scala.xml.MetaData  = scala.xml.Null
      __obj.attributes.toList map {
        case ("@constrained", _) => if (__obj.constrained.toString != "false") attr = scala.xml.Attribute(__scope.getPrefix("http://www.spiritconsortium.org/XMLSchema/SPIRIT/1685-2009"), "constrained", __obj.constrained.toString, attr)
        case (key, x) => attr = scala.xml.Attribute((x.namespace map { __scope.getPrefix(_) }).orNull, x.key.orNull, x.value.toString, attr)
      }
      attr
    }

    def writesChildNodes(__obj: TypeName2, __scope: scala.xml.NamespaceBinding): Seq[scala.xml.Node] =
      Seq(scala.xml.Text(__obj.value.toString))

  }

  trait Default_TransTypeDefFormat extends IPXACT2009scalaxb.ElemNameParser[TransTypeDef] {
    val targetNamespace: Option[String] = Some("http://www.spiritconsortium.org/XMLSchema/SPIRIT/1685-2009")
    
    def parser(node: scala.xml.Node, stack: List[IPXACT2009scalaxb.ElemName]): Parser[TransTypeDef] =
      phrase((IPXACT2009scalaxb.ElemName(Some("http://www.spiritconsortium.org/XMLSchema/SPIRIT/1685-2009"), "typeName")) ~
      safeRep(IPXACT2009scalaxb.ElemName(Some("http://www.spiritconsortium.org/XMLSchema/SPIRIT/1685-2009"), "typeDefinition")) ^^
      { case p1 ~ p2 =>
      TransTypeDef(IPXACT2009scalaxb.fromXML[TypeName2](p1, IPXACT2009scalaxb.ElemName(node) :: stack),
        p2 map { IPXACT2009scalaxb.fromXML[String](_, IPXACT2009scalaxb.ElemName(node) :: stack) }) })
    
    def writesChildNodes(__obj: TransTypeDef, __scope: scala.xml.NamespaceBinding): Seq[scala.xml.Node] =
      Seq.concat(IPXACT2009scalaxb.toXML[TypeName2](__obj.typeName, Some("http://www.spiritconsortium.org/XMLSchema/SPIRIT/1685-2009"), Some("typeName"), __scope, false),
        __obj.typeDefinition flatMap { IPXACT2009scalaxb.toXML[String](_, Some("http://www.spiritconsortium.org/XMLSchema/SPIRIT/1685-2009"), Some("typeDefinition"), __scope, false) })

  }

  trait Default_TypeName3Format extends IPXACT2009scalaxb.XMLFormat[TypeName3] with IPXACT2009scalaxb.CanWriteChildNodes[TypeName3] {
    val targetNamespace: Option[String] = Some("http://www.spiritconsortium.org/XMLSchema/SPIRIT/1685-2009")
    def reads(seq: scala.xml.NodeSeq, stack: List[IPXACT2009scalaxb.ElemName]): Either[String, TypeName3] = seq match {
      case node: scala.xml.Node => Right(TypeName3(IPXACT2009scalaxb.fromXML[String](node, IPXACT2009scalaxb.ElemName(node) :: stack),
        scala.collection.immutable.ListMap(List(
        (node \ "@{http://www.spiritconsortium.org/XMLSchema/SPIRIT/1685-2009}constrained").headOption map { x => IPXACT2009scalaxb.DataRecord(x, node, IPXACT2009scalaxb.fromXML[Boolean](x, IPXACT2009scalaxb.ElemName(node) :: stack)) } orElse Some(IPXACT2009scalaxb.DataRecord(None, None, IPXACT2009scalaxb.fromXML[Boolean](scala.xml.Text("false"), IPXACT2009scalaxb.ElemName(node) :: stack))) map { "@constrained" -> _ },
        (node \ "@{http://www.spiritconsortium.org/XMLSchema/SPIRIT/1685-2009}implicit").headOption map { x => IPXACT2009scalaxb.DataRecord(x, node, IPXACT2009scalaxb.fromXML[Boolean](x, IPXACT2009scalaxb.ElemName(node) :: stack)) } orElse Some(IPXACT2009scalaxb.DataRecord(None, None, IPXACT2009scalaxb.fromXML[Boolean](scala.xml.Text("false"), IPXACT2009scalaxb.ElemName(node) :: stack))) map { "@implicit" -> _ }
        ).flatten[(String, IPXACT2009scalaxb.DataRecord[Any])]: _*)))
      case _ => Left("reads failed: seq must be scala.xml.Node")
    }
    
    override def writesAttribute(__obj: TypeName3, __scope: scala.xml.NamespaceBinding): scala.xml.MetaData = {
      var attr: scala.xml.MetaData  = scala.xml.Null
      __obj.attributes.toList map {
        case ("@constrained", _) => if (__obj.constrained.toString != "false") attr = scala.xml.Attribute(__scope.getPrefix("http://www.spiritconsortium.org/XMLSchema/SPIRIT/1685-2009"), "constrained", __obj.constrained.toString, attr)
        case ("@implicit", _) => if (__obj.implicitValue.toString != "false") attr = scala.xml.Attribute(__scope.getPrefix("http://www.spiritconsortium.org/XMLSchema/SPIRIT/1685-2009"), "implicit", __obj.implicitValue.toString, attr)
        case (key, x) => attr = scala.xml.Attribute((x.namespace map { __scope.getPrefix(_) }).orNull, x.key.orNull, x.value.toString, attr)
      }
      attr
    }

    def writesChildNodes(__obj: TypeName3, __scope: scala.xml.NamespaceBinding): Seq[scala.xml.Node] =
      Seq(scala.xml.Text(__obj.value.toString))

  }

  trait Default_Parameters2Format extends IPXACT2009scalaxb.ElemNameParser[Parameters2] {
    val targetNamespace: Option[String] = Some("http://www.spiritconsortium.org/XMLSchema/SPIRIT/1685-2009")
    
    def parser(node: scala.xml.Node, stack: List[IPXACT2009scalaxb.ElemName]): Parser[Parameters2] =
      phrase(safeRep(IPXACT2009scalaxb.ElemName(Some("http://www.spiritconsortium.org/XMLSchema/SPIRIT/1685-2009"), "parameter")) ^^
      { case p1 =>
      Parameters2(p1 map { IPXACT2009scalaxb.fromXML[NameValuePairTypable](_, IPXACT2009scalaxb.ElemName(node) :: stack) }) })
    
    def writesChildNodes(__obj: Parameters2, __scope: scala.xml.NamespaceBinding): Seq[scala.xml.Node] =
      (__obj.parameter flatMap { IPXACT2009scalaxb.toXML[NameValuePairTypable](_, Some("http://www.spiritconsortium.org/XMLSchema/SPIRIT/1685-2009"), Some("parameter"), __scope, false) })
  }
  trait Default_ServiceTypeDefFormat extends IPXACT2009scalaxb.ElemNameParser[ServiceTypeDef] {
    val targetNamespace: Option[String] = Some("http://www.spiritconsortium.org/XMLSchema/SPIRIT/1685-2009")
    
    def parser(node: scala.xml.Node, stack: List[IPXACT2009scalaxb.ElemName]): Parser[ServiceTypeDef] =
      phrase((IPXACT2009scalaxb.ElemName(Some("http://www.spiritconsortium.org/XMLSchema/SPIRIT/1685-2009"), "typeName")) ~
      safeRep(IPXACT2009scalaxb.ElemName(Some("http://www.spiritconsortium.org/XMLSchema/SPIRIT/1685-2009"), "typeDefinition")) ~
      opt(IPXACT2009scalaxb.ElemName(Some("http://www.spiritconsortium.org/XMLSchema/SPIRIT/1685-2009"), "parameters")) ^^
      { case p1 ~ p2 ~ p3 =>
      ServiceTypeDef(IPXACT2009scalaxb.fromXML[TypeName3](p1, IPXACT2009scalaxb.ElemName(node) :: stack),
        p2 map { IPXACT2009scalaxb.fromXML[String](_, IPXACT2009scalaxb.ElemName(node) :: stack) },
        p3.headOption map { IPXACT2009scalaxb.fromXML[Parameters2](_, IPXACT2009scalaxb.ElemName(node) :: stack) }) })
    
    def writesChildNodes(__obj: ServiceTypeDef, __scope: scala.xml.NamespaceBinding): Seq[scala.xml.Node] =
      Seq.concat(IPXACT2009scalaxb.toXML[TypeName3](__obj.typeName, Some("http://www.spiritconsortium.org/XMLSchema/SPIRIT/1685-2009"), Some("typeName"), __scope, false),
        __obj.typeDefinition flatMap { IPXACT2009scalaxb.toXML[String](_, Some("http://www.spiritconsortium.org/XMLSchema/SPIRIT/1685-2009"), Some("typeDefinition"), __scope, false) },
        __obj.parameters map { IPXACT2009scalaxb.toXML[Parameters2](_, Some("http://www.spiritconsortium.org/XMLSchema/SPIRIT/1685-2009"), Some("parameters"), __scope, false) } getOrElse {Nil})

  }

  trait Default_TypeName4Format extends IPXACT2009scalaxb.XMLFormat[TypeName4] with IPXACT2009scalaxb.CanWriteChildNodes[TypeName4] {
    val targetNamespace: Option[String] = Some("http://www.spiritconsortium.org/XMLSchema/SPIRIT/1685-2009")
    def reads(seq: scala.xml.NodeSeq, stack: List[IPXACT2009scalaxb.ElemName]): Either[String, TypeName4] = seq match {
      case node: scala.xml.Node => Right(TypeName4(IPXACT2009scalaxb.fromXML[String](node, IPXACT2009scalaxb.ElemName(node) :: stack),
        scala.collection.immutable.ListMap(List(
        (node \ "@{http://www.spiritconsortium.org/XMLSchema/SPIRIT/1685-2009}constrained").headOption map { x => IPXACT2009scalaxb.DataRecord(x, node, IPXACT2009scalaxb.fromXML[Boolean](x, IPXACT2009scalaxb.ElemName(node) :: stack)) } orElse Some(IPXACT2009scalaxb.DataRecord(None, None, IPXACT2009scalaxb.fromXML[Boolean](scala.xml.Text("false"), IPXACT2009scalaxb.ElemName(node) :: stack))) map { "@constrained" -> _ }
        ).flatten[(String, IPXACT2009scalaxb.DataRecord[Any])]: _*)))
      case _ => Left("reads failed: seq must be scala.xml.Node")
    }
    
    override def writesAttribute(__obj: TypeName4, __scope: scala.xml.NamespaceBinding): scala.xml.MetaData = {
      var attr: scala.xml.MetaData  = scala.xml.Null
      __obj.attributes.toList map {
        case ("@constrained", _) => if (__obj.constrained.toString != "false") attr = scala.xml.Attribute(__scope.getPrefix("http://www.spiritconsortium.org/XMLSchema/SPIRIT/1685-2009"), "constrained", __obj.constrained.toString, attr)
        case (key, x) => attr = scala.xml.Attribute((x.namespace map { __scope.getPrefix(_) }).orNull, x.key.orNull, x.value.toString, attr)
      }
      attr
    }

    def writesChildNodes(__obj: TypeName4, __scope: scala.xml.NamespaceBinding): Seq[scala.xml.Node] =
      Seq(scala.xml.Text(__obj.value.toString))

  }

  trait Default_WireTypeDefFormat extends IPXACT2009scalaxb.ElemNameParser[WireTypeDef] {
    val targetNamespace: Option[String] = Some("http://www.spiritconsortium.org/XMLSchema/SPIRIT/1685-2009")
    
    def parser(node: scala.xml.Node, stack: List[IPXACT2009scalaxb.ElemName]): Parser[WireTypeDef] =
      phrase((IPXACT2009scalaxb.ElemName(Some("http://www.spiritconsortium.org/XMLSchema/SPIRIT/1685-2009"), "typeName")) ~
      safeRep(IPXACT2009scalaxb.ElemName(Some("http://www.spiritconsortium.org/XMLSchema/SPIRIT/1685-2009"), "typeDefinition")) ~
      safeRep(IPXACT2009scalaxb.ElemName(Some("http://www.spiritconsortium.org/XMLSchema/SPIRIT/1685-2009"), "viewNameRef")) ^^
      { case p1 ~ p2 ~ p3 =>
      WireTypeDef(IPXACT2009scalaxb.fromXML[TypeName4](p1, IPXACT2009scalaxb.ElemName(node) :: stack),
        p2 map { IPXACT2009scalaxb.fromXML[String](_, IPXACT2009scalaxb.ElemName(node) :: stack) },
        p3 map { IPXACT2009scalaxb.fromXML[String](_, IPXACT2009scalaxb.ElemName(node) :: stack) }) })
    
    def writesChildNodes(__obj: WireTypeDef, __scope: scala.xml.NamespaceBinding): Seq[scala.xml.Node] =
      Seq.concat(IPXACT2009scalaxb.toXML[TypeName4](__obj.typeName, Some("http://www.spiritconsortium.org/XMLSchema/SPIRIT/1685-2009"), Some("typeName"), __scope, false),
        __obj.typeDefinition flatMap { IPXACT2009scalaxb.toXML[String](_, Some("http://www.spiritconsortium.org/XMLSchema/SPIRIT/1685-2009"), Some("typeDefinition"), __scope, false) },
        __obj.viewNameRef flatMap { IPXACT2009scalaxb.toXML[String](_, Some("http://www.spiritconsortium.org/XMLSchema/SPIRIT/1685-2009"), Some("viewNameRef"), __scope, false) })

  }

  trait Default_ServiceTypeDefsFormat extends IPXACT2009scalaxb.ElemNameParser[ServiceTypeDefs] {
    val targetNamespace: Option[String] = Some("http://www.spiritconsortium.org/XMLSchema/SPIRIT/1685-2009")
    
    def parser(node: scala.xml.Node, stack: List[IPXACT2009scalaxb.ElemName]): Parser[ServiceTypeDefs] =
      phrase(safeRep(IPXACT2009scalaxb.ElemName(Some("http://www.spiritconsortium.org/XMLSchema/SPIRIT/1685-2009"), "serviceTypeDef")) ^^
      { case p1 =>
      ServiceTypeDefs(p1 map { IPXACT2009scalaxb.fromXML[ServiceTypeDef](_, IPXACT2009scalaxb.ElemName(node) :: stack) }) })
    
    def writesChildNodes(__obj: ServiceTypeDefs, __scope: scala.xml.NamespaceBinding): Seq[scala.xml.Node] =
      (__obj.serviceTypeDef flatMap { IPXACT2009scalaxb.toXML[ServiceTypeDef](_, Some("http://www.spiritconsortium.org/XMLSchema/SPIRIT/1685-2009"), Some("serviceTypeDef"), __scope, false) })
  }
  trait Default_WireTypeDefsFormat extends IPXACT2009scalaxb.ElemNameParser[WireTypeDefs] {
    val targetNamespace: Option[String] = Some("http://www.spiritconsortium.org/XMLSchema/SPIRIT/1685-2009")
    
    def parser(node: scala.xml.Node, stack: List[IPXACT2009scalaxb.ElemName]): Parser[WireTypeDefs] =
      phrase(safeRep(IPXACT2009scalaxb.ElemName(Some("http://www.spiritconsortium.org/XMLSchema/SPIRIT/1685-2009"), "wireTypeDef")) ^^
      { case p1 =>
      WireTypeDefs(p1 map { IPXACT2009scalaxb.fromXML[WireTypeDef](_, IPXACT2009scalaxb.ElemName(node) :: stack) }) })
    
    def writesChildNodes(__obj: WireTypeDefs, __scope: scala.xml.NamespaceBinding): Seq[scala.xml.Node] =
      (__obj.wireTypeDef flatMap { IPXACT2009scalaxb.toXML[WireTypeDef](_, Some("http://www.spiritconsortium.org/XMLSchema/SPIRIT/1685-2009"), Some("wireTypeDef"), __scope, false) })
  }
  trait Default_PortWireTypableFormat extends IPXACT2009scalaxb.XMLFormat[PortWireTypable] {
    def reads(seq: scala.xml.NodeSeq, stack: List[IPXACT2009scalaxb.ElemName]): Either[String, PortWireTypable] = seq match {
      case node: scala.xml.Node =>     
        IPXACT2009scalaxb.Helper.instanceType(node) match {
          case (Some("http://www.spiritconsortium.org/XMLSchema/SPIRIT/1685-2009"), Some("abstractorPortWireType")) => Right(IPXACT2009scalaxb.fromXML[AbstractorPortWireType](node, stack))
          case _ => Right(IPXACT2009scalaxb.fromXML[PortWireType](node, stack))
        }
      case _ => Left("reads failed: seq must be scala.xml.Node")  
    }
    
    def writes(__obj: PortWireTypable, __namespace: Option[String], __elementLabel: Option[String],
        __scope: scala.xml.NamespaceBinding, __typeAttribute: Boolean): scala.xml.NodeSeq = __obj match {
      case x: AbstractorPortWireType => IPXACT2009scalaxb.toXML[AbstractorPortWireType](x, __namespace, __elementLabel, __scope, true)
      case x: PortWireType => IPXACT2009scalaxb.toXML[PortWireType](x, __namespace, __elementLabel, __scope, __typeAttribute)
    }
  }
  trait Default_PortWireTypeFormat extends IPXACT2009scalaxb.ElemNameParser[PortWireType] {
    val targetNamespace: Option[String] = Some("http://www.spiritconsortium.org/XMLSchema/SPIRIT/1685-2009")
    
    override def typeName: Option[String] = Some("portWireType")

    def parser(node: scala.xml.Node, stack: List[IPXACT2009scalaxb.ElemName]): Parser[PortWireType] =
      phrase((IPXACT2009scalaxb.ElemName(Some("http://www.spiritconsortium.org/XMLSchema/SPIRIT/1685-2009"), "direction")) ~
      opt(IPXACT2009scalaxb.ElemName(Some("http://www.spiritconsortium.org/XMLSchema/SPIRIT/1685-2009"), "vector")) ~
      opt(IPXACT2009scalaxb.ElemName(Some("http://www.spiritconsortium.org/XMLSchema/SPIRIT/1685-2009"), "wireTypeDefs")) ~
      opt(IPXACT2009scalaxb.ElemName(Some("http://www.spiritconsortium.org/XMLSchema/SPIRIT/1685-2009"), "driver")) ~
      opt(IPXACT2009scalaxb.ElemName(Some("http://www.spiritconsortium.org/XMLSchema/SPIRIT/1685-2009"), "constraintSets")) ^^
      { case p1 ~ p2 ~ p3 ~ p4 ~ p5 =>
      PortWireType(IPXACT2009scalaxb.fromXML[ComponentPortDirectionType](p1, IPXACT2009scalaxb.ElemName(node) :: stack),
        p2.headOption map { IPXACT2009scalaxb.fromXML[Vector4](_, IPXACT2009scalaxb.ElemName(node) :: stack) },
        p3.headOption map { IPXACT2009scalaxb.fromXML[WireTypeDefs](_, IPXACT2009scalaxb.ElemName(node) :: stack) },
        p4.headOption map { IPXACT2009scalaxb.fromXML[DriverType](_, IPXACT2009scalaxb.ElemName(node) :: stack) },
        p5.headOption map { IPXACT2009scalaxb.fromXML[ConstraintSets](_, IPXACT2009scalaxb.ElemName(node) :: stack) },
        scala.collection.immutable.ListMap(List(
        (node \ "@{http://www.spiritconsortium.org/XMLSchema/SPIRIT/1685-2009}allLogicalDirectionsAllowed").headOption map { x => IPXACT2009scalaxb.DataRecord(x, node, IPXACT2009scalaxb.fromXML[Boolean](x, IPXACT2009scalaxb.ElemName(node) :: stack)) } orElse Some(IPXACT2009scalaxb.DataRecord(None, None, IPXACT2009scalaxb.fromXML[Boolean](scala.xml.Text("false"), IPXACT2009scalaxb.ElemName(node) :: stack))) map { "@allLogicalDirectionsAllowed" -> _ }
        ).flatten[(String, IPXACT2009scalaxb.DataRecord[Any])]: _*)) })
    
    override def writesAttribute(__obj: PortWireType, __scope: scala.xml.NamespaceBinding): scala.xml.MetaData = {
      var attr: scala.xml.MetaData  = scala.xml.Null
      __obj.attributes.toList map {
        case ("@allLogicalDirectionsAllowed", _) => if (__obj.allLogicalDirectionsAllowed.toString != "false") attr = scala.xml.Attribute(__scope.getPrefix("http://www.spiritconsortium.org/XMLSchema/SPIRIT/1685-2009"), "allLogicalDirectionsAllowed", __obj.allLogicalDirectionsAllowed.toString, attr)
        case (key, x) => attr = scala.xml.Attribute((x.namespace map { __scope.getPrefix(_) }).orNull, x.key.orNull, x.value.toString, attr)
      }
      attr
    }

    def writesChildNodes(__obj: PortWireType, __scope: scala.xml.NamespaceBinding): Seq[scala.xml.Node] =
      Seq.concat(IPXACT2009scalaxb.toXML[ComponentPortDirectionType](__obj.direction, Some("http://www.spiritconsortium.org/XMLSchema/SPIRIT/1685-2009"), Some("direction"), __scope, false),
        __obj.vector map { IPXACT2009scalaxb.toXML[Vector4](_, Some("http://www.spiritconsortium.org/XMLSchema/SPIRIT/1685-2009"), Some("vector"), __scope, false) } getOrElse {Nil},
        __obj.wireTypeDefs map { IPXACT2009scalaxb.toXML[WireTypeDefs](_, Some("http://www.spiritconsortium.org/XMLSchema/SPIRIT/1685-2009"), Some("wireTypeDefs"), __scope, false) } getOrElse {Nil},
        __obj.driver map { IPXACT2009scalaxb.toXML[DriverType](_, Some("http://www.spiritconsortium.org/XMLSchema/SPIRIT/1685-2009"), Some("driver"), __scope, false) } getOrElse {Nil},
        __obj.constraintSets map { IPXACT2009scalaxb.toXML[ConstraintSets](_, Some("http://www.spiritconsortium.org/XMLSchema/SPIRIT/1685-2009"), Some("constraintSets"), __scope, false) } getOrElse {Nil})

  }

  trait Default_ServiceFormat extends IPXACT2009scalaxb.ElemNameParser[Service] {
    val targetNamespace: Option[String] = Some("http://www.spiritconsortium.org/XMLSchema/SPIRIT/1685-2009")
    
    def parser(node: scala.xml.Node, stack: List[IPXACT2009scalaxb.ElemName]): Parser[Service] =
      phrase((IPXACT2009scalaxb.ElemName(Some("http://www.spiritconsortium.org/XMLSchema/SPIRIT/1685-2009"), "initiative")) ~
      opt(IPXACT2009scalaxb.ElemName(Some("http://www.spiritconsortium.org/XMLSchema/SPIRIT/1685-2009"), "serviceTypeDefs")) ~
      opt(IPXACT2009scalaxb.ElemName(Some("http://www.spiritconsortium.org/XMLSchema/SPIRIT/1685-2009"), "vendorExtensions")) ^^
      { case p1 ~ p2 ~ p3 =>
      Service(IPXACT2009scalaxb.fromXML[InitiativeType](p1, IPXACT2009scalaxb.ElemName(node) :: stack),
        p2.headOption map { IPXACT2009scalaxb.fromXML[ServiceTypeDefs](_, IPXACT2009scalaxb.ElemName(node) :: stack) },
        p3.headOption map { IPXACT2009scalaxb.fromXML[VendorExtensions](_, IPXACT2009scalaxb.ElemName(node) :: stack) }) })
    
    def writesChildNodes(__obj: Service, __scope: scala.xml.NamespaceBinding): Seq[scala.xml.Node] =
      Seq.concat(IPXACT2009scalaxb.toXML[InitiativeType](__obj.initiative, Some("http://www.spiritconsortium.org/XMLSchema/SPIRIT/1685-2009"), Some("initiative"), __scope, false),
        __obj.serviceTypeDefs map { IPXACT2009scalaxb.toXML[ServiceTypeDefs](_, Some("http://www.spiritconsortium.org/XMLSchema/SPIRIT/1685-2009"), Some("serviceTypeDefs"), __scope, false) } getOrElse {Nil},
        __obj.vendorExtensions map { IPXACT2009scalaxb.toXML[VendorExtensions](_, Some("http://www.spiritconsortium.org/XMLSchema/SPIRIT/1685-2009"), Some("vendorExtensions"), __scope, false) } getOrElse {Nil})

  }

  trait Default_ConnectionFormat extends IPXACT2009scalaxb.ElemNameParser[Connection] {
    val targetNamespace: Option[String] = Some("http://www.spiritconsortium.org/XMLSchema/SPIRIT/1685-2009")
    
    def parser(node: scala.xml.Node, stack: List[IPXACT2009scalaxb.ElemName]): Parser[Connection] =
      phrase(opt(IPXACT2009scalaxb.ElemName(Some("http://www.spiritconsortium.org/XMLSchema/SPIRIT/1685-2009"), "maxConnections")) ~
      opt(IPXACT2009scalaxb.ElemName(Some("http://www.spiritconsortium.org/XMLSchema/SPIRIT/1685-2009"), "minConnections")) ^^
      { case p1 ~ p2 =>
      Connection(p1.headOption map { IPXACT2009scalaxb.fromXML[BigInt](_, IPXACT2009scalaxb.ElemName(node) :: stack) },
        p2.headOption map { IPXACT2009scalaxb.fromXML[BigInt](_, IPXACT2009scalaxb.ElemName(node) :: stack) }) })
    
    def writesChildNodes(__obj: Connection, __scope: scala.xml.NamespaceBinding): Seq[scala.xml.Node] =
      Seq.concat(__obj.maxConnections map { IPXACT2009scalaxb.toXML[BigInt](_, Some("http://www.spiritconsortium.org/XMLSchema/SPIRIT/1685-2009"), Some("maxConnections"), __scope, false) } getOrElse {Nil},
        __obj.minConnections map { IPXACT2009scalaxb.toXML[BigInt](_, Some("http://www.spiritconsortium.org/XMLSchema/SPIRIT/1685-2009"), Some("minConnections"), __scope, false) } getOrElse {Nil})

  }

  trait Default_PortTransactionalTypeFormat extends IPXACT2009scalaxb.ElemNameParser[PortTransactionalType] {
    val targetNamespace: Option[String] = Some("http://www.spiritconsortium.org/XMLSchema/SPIRIT/1685-2009")
    
    override def typeName: Option[String] = Some("portTransactionalType")

    def parser(node: scala.xml.Node, stack: List[IPXACT2009scalaxb.ElemName]): Parser[PortTransactionalType] =
      phrase(opt(IPXACT2009scalaxb.ElemName(Some("http://www.spiritconsortium.org/XMLSchema/SPIRIT/1685-2009"), "transTypeDef")) ~
      (IPXACT2009scalaxb.ElemName(Some("http://www.spiritconsortium.org/XMLSchema/SPIRIT/1685-2009"), "service")) ~
      opt(IPXACT2009scalaxb.ElemName(Some("http://www.spiritconsortium.org/XMLSchema/SPIRIT/1685-2009"), "connection")) ^^
      { case p1 ~ p2 ~ p3 =>
      PortTransactionalType(p1.headOption map { IPXACT2009scalaxb.fromXML[TransTypeDef](_, IPXACT2009scalaxb.ElemName(node) :: stack) },
        IPXACT2009scalaxb.fromXML[Service](p2, IPXACT2009scalaxb.ElemName(node) :: stack),
        p3.headOption map { IPXACT2009scalaxb.fromXML[Connection](_, IPXACT2009scalaxb.ElemName(node) :: stack) },
        scala.collection.immutable.ListMap(List(
        (node \ "@{http://www.spiritconsortium.org/XMLSchema/SPIRIT/1685-2009}allLogicalInitiativesAllowed").headOption map { x => IPXACT2009scalaxb.DataRecord(x, node, IPXACT2009scalaxb.fromXML[Boolean](x, IPXACT2009scalaxb.ElemName(node) :: stack)) } orElse Some(IPXACT2009scalaxb.DataRecord(None, None, IPXACT2009scalaxb.fromXML[Boolean](scala.xml.Text("false"), IPXACT2009scalaxb.ElemName(node) :: stack))) map { "@allLogicalInitiativesAllowed" -> _ }
        ).flatten[(String, IPXACT2009scalaxb.DataRecord[Any])]: _*)) })
    
    override def writesAttribute(__obj: PortTransactionalType, __scope: scala.xml.NamespaceBinding): scala.xml.MetaData = {
      var attr: scala.xml.MetaData  = scala.xml.Null
      __obj.attributes.toList map {
        case ("@allLogicalInitiativesAllowed", _) => if (__obj.allLogicalInitiativesAllowed.toString != "false") attr = scala.xml.Attribute(__scope.getPrefix("http://www.spiritconsortium.org/XMLSchema/SPIRIT/1685-2009"), "allLogicalInitiativesAllowed", __obj.allLogicalInitiativesAllowed.toString, attr)
        case (key, x) => attr = scala.xml.Attribute((x.namespace map { __scope.getPrefix(_) }).orNull, x.key.orNull, x.value.toString, attr)
      }
      attr
    }

    def writesChildNodes(__obj: PortTransactionalType, __scope: scala.xml.NamespaceBinding): Seq[scala.xml.Node] =
      Seq.concat(__obj.transTypeDef map { IPXACT2009scalaxb.toXML[TransTypeDef](_, Some("http://www.spiritconsortium.org/XMLSchema/SPIRIT/1685-2009"), Some("transTypeDef"), __scope, false) } getOrElse {Nil},
        IPXACT2009scalaxb.toXML[Service](__obj.service, Some("http://www.spiritconsortium.org/XMLSchema/SPIRIT/1685-2009"), Some("service"), __scope, false),
        __obj.connection map { IPXACT2009scalaxb.toXML[Connection](_, Some("http://www.spiritconsortium.org/XMLSchema/SPIRIT/1685-2009"), Some("connection"), __scope, false) } getOrElse {Nil})

  }

  trait Default_AbstractorPortWireTypeFormat extends IPXACT2009scalaxb.ElemNameParser[AbstractorPortWireType] {
    val targetNamespace: Option[String] = Some("http://www.spiritconsortium.org/XMLSchema/SPIRIT/1685-2009")
    
    override def typeName: Option[String] = Some("abstractorPortWireType")

    def parser(node: scala.xml.Node, stack: List[IPXACT2009scalaxb.ElemName]): Parser[AbstractorPortWireType] =
      phrase((IPXACT2009scalaxb.ElemName(Some("http://www.spiritconsortium.org/XMLSchema/SPIRIT/1685-2009"), "direction")) ~
      opt(IPXACT2009scalaxb.ElemName(Some("http://www.spiritconsortium.org/XMLSchema/SPIRIT/1685-2009"), "vector")) ~
      opt(IPXACT2009scalaxb.ElemName(Some("http://www.spiritconsortium.org/XMLSchema/SPIRIT/1685-2009"), "wireTypeDefs")) ~
      opt(IPXACT2009scalaxb.ElemName(Some("http://www.spiritconsortium.org/XMLSchema/SPIRIT/1685-2009"), "driver")) ~
      opt(IPXACT2009scalaxb.ElemName(Some("http://www.spiritconsortium.org/XMLSchema/SPIRIT/1685-2009"), "constraintSets")) ^^
      { case p1 ~ p2 ~ p3 ~ p4 ~ p5 =>
      AbstractorPortWireType(IPXACT2009scalaxb.fromXML[ComponentPortDirectionType](p1, IPXACT2009scalaxb.ElemName(node) :: stack),
        p2.headOption map { IPXACT2009scalaxb.fromXML[Vector4](_, IPXACT2009scalaxb.ElemName(node) :: stack) },
        p3.headOption map { IPXACT2009scalaxb.fromXML[WireTypeDefs](_, IPXACT2009scalaxb.ElemName(node) :: stack) },
        p4.headOption map { IPXACT2009scalaxb.fromXML[DriverType](_, IPXACT2009scalaxb.ElemName(node) :: stack) },
        p5.headOption map { IPXACT2009scalaxb.fromXML[ConstraintSets](_, IPXACT2009scalaxb.ElemName(node) :: stack) },
        scala.collection.immutable.ListMap(List(
        (node \ "@{http://www.spiritconsortium.org/XMLSchema/SPIRIT/1685-2009}allLogicalDirectionsAllowed").headOption map { x => IPXACT2009scalaxb.DataRecord(x, node, IPXACT2009scalaxb.fromXML[Boolean](x, IPXACT2009scalaxb.ElemName(node) :: stack)) } orElse Some(IPXACT2009scalaxb.DataRecord(None, None, IPXACT2009scalaxb.fromXML[Boolean](scala.xml.Text("false"), IPXACT2009scalaxb.ElemName(node) :: stack))) map { "@allLogicalDirectionsAllowed" -> _ }
        ).flatten[(String, IPXACT2009scalaxb.DataRecord[Any])]: _*)) })
    
    override def writesAttribute(__obj: AbstractorPortWireType, __scope: scala.xml.NamespaceBinding): scala.xml.MetaData = {
      var attr: scala.xml.MetaData  = scala.xml.Null
      __obj.attributes.toList map {
        case ("@allLogicalDirectionsAllowed", _) => if (__obj.allLogicalDirectionsAllowed.toString != "false") attr = scala.xml.Attribute(__scope.getPrefix("http://www.spiritconsortium.org/XMLSchema/SPIRIT/1685-2009"), "allLogicalDirectionsAllowed", __obj.allLogicalDirectionsAllowed.toString, attr)
        case (key, x) => attr = scala.xml.Attribute((x.namespace map { __scope.getPrefix(_) }).orNull, x.key.orNull, x.value.toString, attr)
      }
      attr
    }

    def writesChildNodes(__obj: AbstractorPortWireType, __scope: scala.xml.NamespaceBinding): Seq[scala.xml.Node] =
      Seq.concat(IPXACT2009scalaxb.toXML[ComponentPortDirectionType](__obj.direction, Some("http://www.spiritconsortium.org/XMLSchema/SPIRIT/1685-2009"), Some("direction"), __scope, false),
        __obj.vector map { IPXACT2009scalaxb.toXML[Vector4](_, Some("http://www.spiritconsortium.org/XMLSchema/SPIRIT/1685-2009"), Some("vector"), __scope, false) } getOrElse {Nil},
        __obj.wireTypeDefs map { IPXACT2009scalaxb.toXML[WireTypeDefs](_, Some("http://www.spiritconsortium.org/XMLSchema/SPIRIT/1685-2009"), Some("wireTypeDefs"), __scope, false) } getOrElse {Nil},
        __obj.driver map { IPXACT2009scalaxb.toXML[DriverType](_, Some("http://www.spiritconsortium.org/XMLSchema/SPIRIT/1685-2009"), Some("driver"), __scope, false) } getOrElse {Nil},
        __obj.constraintSets map { IPXACT2009scalaxb.toXML[ConstraintSets](_, Some("http://www.spiritconsortium.org/XMLSchema/SPIRIT/1685-2009"), Some("constraintSets"), __scope, false) } getOrElse {Nil})

  }

  trait Default_PortAccessTypeFormat extends IPXACT2009scalaxb.ElemNameParser[PortAccessType] {
    val targetNamespace: Option[String] = Some("http://www.spiritconsortium.org/XMLSchema/SPIRIT/1685-2009")
    
    override def typeName: Option[String] = Some("portAccessType")

    def parser(node: scala.xml.Node, stack: List[IPXACT2009scalaxb.ElemName]): Parser[PortAccessType] =
      phrase(opt(IPXACT2009scalaxb.ElemName(Some("http://www.spiritconsortium.org/XMLSchema/SPIRIT/1685-2009"), "portAccessType")) ~
      opt(IPXACT2009scalaxb.ElemName(Some("http://www.spiritconsortium.org/XMLSchema/SPIRIT/1685-2009"), "portAccessHandle")) ^^
      { case p1 ~ p2 =>
      PortAccessType(p1.headOption map { IPXACT2009scalaxb.fromXML[PortAccessTypeType](_, IPXACT2009scalaxb.ElemName(node) :: stack) },
        p2.headOption map { IPXACT2009scalaxb.fromXML[String](_, IPXACT2009scalaxb.ElemName(node) :: stack) }) })
    
    def writesChildNodes(__obj: PortAccessType, __scope: scala.xml.NamespaceBinding): Seq[scala.xml.Node] =
      Seq.concat(__obj.portAccessType map { IPXACT2009scalaxb.toXML[PortAccessTypeType](_, Some("http://www.spiritconsortium.org/XMLSchema/SPIRIT/1685-2009"), Some("portAccessType"), __scope, false) } getOrElse {Nil},
        __obj.portAccessHandle map { IPXACT2009scalaxb.toXML[String](_, Some("http://www.spiritconsortium.org/XMLSchema/SPIRIT/1685-2009"), Some("portAccessHandle"), __scope, false) } getOrElse {Nil})

  }

  trait Default_DefaultValueFormat extends IPXACT2009scalaxb.XMLFormat[DefaultValue] with IPXACT2009scalaxb.CanWriteChildNodes[DefaultValue] {
    val targetNamespace: Option[String] = Some("http://www.spiritconsortium.org/XMLSchema/SPIRIT/1685-2009")
    def reads(seq: scala.xml.NodeSeq, stack: List[IPXACT2009scalaxb.ElemName]): Either[String, DefaultValue] = seq match {
      case node: scala.xml.Node => Right(DefaultValue(IPXACT2009scalaxb.fromXML[String](node, IPXACT2009scalaxb.ElemName(node) :: stack),
        scala.collection.immutable.ListMap(List(
        (node \ "@{http://www.spiritconsortium.org/XMLSchema/SPIRIT/1685-2009}format").headOption map { x => IPXACT2009scalaxb.DataRecord(x, node, IPXACT2009scalaxb.fromXML[FormatType](x, IPXACT2009scalaxb.ElemName(node) :: stack)) } orElse Some(IPXACT2009scalaxb.DataRecord(None, None, IPXACT2009scalaxb.fromXML[FormatType](scala.xml.Text("long"), IPXACT2009scalaxb.ElemName(node) :: stack))) map { "@{http://www.spiritconsortium.org/XMLSchema/SPIRIT/1685-2009}format" -> _ },
        (node \ "@{http://www.spiritconsortium.org/XMLSchema/SPIRIT/1685-2009}resolve").headOption map { x => IPXACT2009scalaxb.DataRecord(x, node, IPXACT2009scalaxb.fromXML[ResolveType](x, IPXACT2009scalaxb.ElemName(node) :: stack)) } map { "@{http://www.spiritconsortium.org/XMLSchema/SPIRIT/1685-2009}resolve" -> _ },
        (node \ "@{http://www.spiritconsortium.org/XMLSchema/SPIRIT/1685-2009}id").headOption map { x => IPXACT2009scalaxb.DataRecord(x, node, IPXACT2009scalaxb.fromXML[String](x, IPXACT2009scalaxb.ElemName(node) :: stack)) } map { "@{http://www.spiritconsortium.org/XMLSchema/SPIRIT/1685-2009}id" -> _ },
        (node \ "@{http://www.spiritconsortium.org/XMLSchema/SPIRIT/1685-2009}dependency").headOption map { x => IPXACT2009scalaxb.DataRecord(x, node, IPXACT2009scalaxb.fromXML[String](x, IPXACT2009scalaxb.ElemName(node) :: stack)) } map { "@{http://www.spiritconsortium.org/XMLSchema/SPIRIT/1685-2009}dependency" -> _ },
        (node \ "@{http://www.spiritconsortium.org/XMLSchema/SPIRIT/1685-2009}choiceRef").headOption map { x => IPXACT2009scalaxb.DataRecord(x, node, IPXACT2009scalaxb.fromXML[String](x, IPXACT2009scalaxb.ElemName(node) :: stack)) } map { "@{http://www.spiritconsortium.org/XMLSchema/SPIRIT/1685-2009}choiceRef" -> _ },
        (node \ "@{http://www.spiritconsortium.org/XMLSchema/SPIRIT/1685-2009}order").headOption map { x => IPXACT2009scalaxb.DataRecord(x, node, IPXACT2009scalaxb.fromXML[Float](x, IPXACT2009scalaxb.ElemName(node) :: stack)) } map { "@{http://www.spiritconsortium.org/XMLSchema/SPIRIT/1685-2009}order" -> _ },
        (node \ "@{http://www.spiritconsortium.org/XMLSchema/SPIRIT/1685-2009}configGroups").headOption map { x => IPXACT2009scalaxb.DataRecord(x, node, IPXACT2009scalaxb.fromXML[Seq[String]](x, IPXACT2009scalaxb.ElemName(node) :: stack)) } map { "@{http://www.spiritconsortium.org/XMLSchema/SPIRIT/1685-2009}configGroups" -> _ },
        (node \ "@{http://www.spiritconsortium.org/XMLSchema/SPIRIT/1685-2009}bitStringLength").headOption map { x => IPXACT2009scalaxb.DataRecord(x, node, IPXACT2009scalaxb.fromXML[BigInt](x, IPXACT2009scalaxb.ElemName(node) :: stack)) } map { "@{http://www.spiritconsortium.org/XMLSchema/SPIRIT/1685-2009}bitStringLength" -> _ },
        (node \ "@{http://www.spiritconsortium.org/XMLSchema/SPIRIT/1685-2009}minimum").headOption map { x => IPXACT2009scalaxb.DataRecord(x, node, IPXACT2009scalaxb.fromXML[String](x, IPXACT2009scalaxb.ElemName(node) :: stack)) } map { "@{http://www.spiritconsortium.org/XMLSchema/SPIRIT/1685-2009}minimum" -> _ },
        (node \ "@{http://www.spiritconsortium.org/XMLSchema/SPIRIT/1685-2009}maximum").headOption map { x => IPXACT2009scalaxb.DataRecord(x, node, IPXACT2009scalaxb.fromXML[String](x, IPXACT2009scalaxb.ElemName(node) :: stack)) } map { "@{http://www.spiritconsortium.org/XMLSchema/SPIRIT/1685-2009}maximum" -> _ },
        (node \ "@{http://www.spiritconsortium.org/XMLSchema/SPIRIT/1685-2009}rangeType").headOption map { x => IPXACT2009scalaxb.DataRecord(x, node, IPXACT2009scalaxb.fromXML[RangeTypeType](x, IPXACT2009scalaxb.ElemName(node) :: stack)) } orElse Some(IPXACT2009scalaxb.DataRecord(None, None, IPXACT2009scalaxb.fromXML[RangeTypeType](scala.xml.Text("float"), IPXACT2009scalaxb.ElemName(node) :: stack))) map { "@{http://www.spiritconsortium.org/XMLSchema/SPIRIT/1685-2009}rangeType" -> _ },
        (node \ "@{http://www.spiritconsortium.org/XMLSchema/SPIRIT/1685-2009}prompt").headOption map { x => IPXACT2009scalaxb.DataRecord(x, node, IPXACT2009scalaxb.fromXML[String](x, IPXACT2009scalaxb.ElemName(node) :: stack)) } map { "@{http://www.spiritconsortium.org/XMLSchema/SPIRIT/1685-2009}prompt" -> _ }
        ).flatten[(String, IPXACT2009scalaxb.DataRecord[Any])] ::: (node match {
          case elem: scala.xml.Elem =>
            elem.attributes.toList flatMap {
              case scala.xml.PrefixedAttribute(pre, key, value, _) if pre == elem.scope.getPrefix("http://www.spiritconsortium.org/XMLSchema/SPIRIT/1685-2009") &&
                key == "format" => Nil
              case scala.xml.PrefixedAttribute(pre, key, value, _) if pre == elem.scope.getPrefix("http://www.spiritconsortium.org/XMLSchema/SPIRIT/1685-2009") &&
                key == "resolve" => Nil
              case scala.xml.PrefixedAttribute(pre, key, value, _) if pre == elem.scope.getPrefix("http://www.spiritconsortium.org/XMLSchema/SPIRIT/1685-2009") &&
                key == "id" => Nil
              case scala.xml.PrefixedAttribute(pre, key, value, _) if pre == elem.scope.getPrefix("http://www.spiritconsortium.org/XMLSchema/SPIRIT/1685-2009") &&
                key == "dependency" => Nil
              case scala.xml.PrefixedAttribute(pre, key, value, _) if pre == elem.scope.getPrefix("http://www.spiritconsortium.org/XMLSchema/SPIRIT/1685-2009") &&
                key == "choiceRef" => Nil
              case scala.xml.PrefixedAttribute(pre, key, value, _) if pre == elem.scope.getPrefix("http://www.spiritconsortium.org/XMLSchema/SPIRIT/1685-2009") &&
                key == "order" => Nil
              case scala.xml.PrefixedAttribute(pre, key, value, _) if pre == elem.scope.getPrefix("http://www.spiritconsortium.org/XMLSchema/SPIRIT/1685-2009") &&
                key == "configGroups" => Nil
              case scala.xml.PrefixedAttribute(pre, key, value, _) if pre == elem.scope.getPrefix("http://www.spiritconsortium.org/XMLSchema/SPIRIT/1685-2009") &&
                key == "bitStringLength" => Nil
              case scala.xml.PrefixedAttribute(pre, key, value, _) if pre == elem.scope.getPrefix("http://www.spiritconsortium.org/XMLSchema/SPIRIT/1685-2009") &&
                key == "minimum" => Nil
              case scala.xml.PrefixedAttribute(pre, key, value, _) if pre == elem.scope.getPrefix("http://www.spiritconsortium.org/XMLSchema/SPIRIT/1685-2009") &&
                key == "maximum" => Nil
              case scala.xml.PrefixedAttribute(pre, key, value, _) if pre == elem.scope.getPrefix("http://www.spiritconsortium.org/XMLSchema/SPIRIT/1685-2009") &&
                key == "rangeType" => Nil
              case scala.xml.PrefixedAttribute(pre, key, value, _) if pre == elem.scope.getPrefix("http://www.spiritconsortium.org/XMLSchema/SPIRIT/1685-2009") &&
                key == "prompt" => Nil
              case scala.xml.UnprefixedAttribute(key, value, _) =>
                List(("@" + key, IPXACT2009scalaxb.DataRecord(None, Some(key), value.text)))
              case scala.xml.PrefixedAttribute(pre, key, value, _) =>
                val ns = elem.scope.getURI(pre)
                List(("@{" + ns + "}" + key, IPXACT2009scalaxb.DataRecord(Option[String](ns), Some(key), value.text)))
              case _ => Nil
            }
          case _ => Nil
        }): _*)))
      case _ => Left("reads failed: seq must be scala.xml.Node")
    }
    
    override def writesAttribute(__obj: DefaultValue, __scope: scala.xml.NamespaceBinding): scala.xml.MetaData = {
      var attr: scala.xml.MetaData  = scala.xml.Null
      __obj.attributes.toList map {
        case ("@{http://www.spiritconsortium.org/XMLSchema/SPIRIT/1685-2009}format", _) => if (__obj.spiritformat.toString != "long") attr = scala.xml.Attribute(__scope.getPrefix("http://www.spiritconsortium.org/XMLSchema/SPIRIT/1685-2009"), "format", __obj.spiritformat.toString, attr)
        case ("@{http://www.spiritconsortium.org/XMLSchema/SPIRIT/1685-2009}resolve", _) => __obj.spiritresolve foreach { x => attr = scala.xml.Attribute(__scope.getPrefix("http://www.spiritconsortium.org/XMLSchema/SPIRIT/1685-2009"), "resolve", x.toString, attr) }
        case ("@{http://www.spiritconsortium.org/XMLSchema/SPIRIT/1685-2009}id", _) => __obj.spiritid foreach { x => attr = scala.xml.Attribute(__scope.getPrefix("http://www.spiritconsortium.org/XMLSchema/SPIRIT/1685-2009"), "id", x.toString, attr) }
        case ("@{http://www.spiritconsortium.org/XMLSchema/SPIRIT/1685-2009}dependency", _) => __obj.spiritdependency foreach { x => attr = scala.xml.Attribute(__scope.getPrefix("http://www.spiritconsortium.org/XMLSchema/SPIRIT/1685-2009"), "dependency", x.toString, attr) }
        case ("@{http://www.spiritconsortium.org/XMLSchema/SPIRIT/1685-2009}choiceRef", _) => __obj.spiritchoiceRef foreach { x => attr = scala.xml.Attribute(__scope.getPrefix("http://www.spiritconsortium.org/XMLSchema/SPIRIT/1685-2009"), "choiceRef", x.toString, attr) }
        case ("@{http://www.spiritconsortium.org/XMLSchema/SPIRIT/1685-2009}order", _) => __obj.spiritorder foreach { x => attr = scala.xml.Attribute(__scope.getPrefix("http://www.spiritconsortium.org/XMLSchema/SPIRIT/1685-2009"), "order", x.toString, attr) }
        case ("@{http://www.spiritconsortium.org/XMLSchema/SPIRIT/1685-2009}configGroups", _) => __obj.spiritconfigGroups foreach { x => attr = scala.xml.Attribute(__scope.getPrefix("http://www.spiritconsortium.org/XMLSchema/SPIRIT/1685-2009"), "configGroups", x.toString, attr) }
        case ("@{http://www.spiritconsortium.org/XMLSchema/SPIRIT/1685-2009}bitStringLength", _) => __obj.spiritbitStringLength foreach { x => attr = scala.xml.Attribute(__scope.getPrefix("http://www.spiritconsortium.org/XMLSchema/SPIRIT/1685-2009"), "bitStringLength", x.toString, attr) }
        case ("@{http://www.spiritconsortium.org/XMLSchema/SPIRIT/1685-2009}minimum", _) => __obj.spiritminimum foreach { x => attr = scala.xml.Attribute(__scope.getPrefix("http://www.spiritconsortium.org/XMLSchema/SPIRIT/1685-2009"), "minimum", x.toString, attr) }
        case ("@{http://www.spiritconsortium.org/XMLSchema/SPIRIT/1685-2009}maximum", _) => __obj.spiritmaximum foreach { x => attr = scala.xml.Attribute(__scope.getPrefix("http://www.spiritconsortium.org/XMLSchema/SPIRIT/1685-2009"), "maximum", x.toString, attr) }
        case ("@{http://www.spiritconsortium.org/XMLSchema/SPIRIT/1685-2009}rangeType", _) => if (__obj.spiritrangeType.toString != "float") attr = scala.xml.Attribute(__scope.getPrefix("http://www.spiritconsortium.org/XMLSchema/SPIRIT/1685-2009"), "rangeType", __obj.spiritrangeType.toString, attr)
        case ("@{http://www.spiritconsortium.org/XMLSchema/SPIRIT/1685-2009}prompt", _) => __obj.spiritprompt foreach { x => attr = scala.xml.Attribute(__scope.getPrefix("http://www.spiritconsortium.org/XMLSchema/SPIRIT/1685-2009"), "prompt", x.toString, attr) }
        case (key, x) => attr = scala.xml.Attribute((x.namespace map { __scope.getPrefix(_) }).orNull, x.key.orNull, x.value.toString, attr)
      }
      attr
    }

    def writesChildNodes(__obj: DefaultValue, __scope: scala.xml.NamespaceBinding): Seq[scala.xml.Node] =
      Seq(scala.xml.Text(__obj.value.toString))

  }

  trait Default_ClockDriverFormat extends IPXACT2009scalaxb.ElemNameParser[ClockDriver] {
    val targetNamespace: Option[String] = Some("http://www.spiritconsortium.org/XMLSchema/SPIRIT/1685-2009")
    
    def parser(node: scala.xml.Node, stack: List[IPXACT2009scalaxb.ElemName]): Parser[ClockDriver] =
      phrase((IPXACT2009scalaxb.ElemName(Some("http://www.spiritconsortium.org/XMLSchema/SPIRIT/1685-2009"), "clockPeriod")) ~
      (IPXACT2009scalaxb.ElemName(Some("http://www.spiritconsortium.org/XMLSchema/SPIRIT/1685-2009"), "clockPulseOffset")) ~
      (IPXACT2009scalaxb.ElemName(Some("http://www.spiritconsortium.org/XMLSchema/SPIRIT/1685-2009"), "clockPulseValue")) ~
      (IPXACT2009scalaxb.ElemName(Some("http://www.spiritconsortium.org/XMLSchema/SPIRIT/1685-2009"), "clockPulseDuration")) ^^
      { case p1 ~ p2 ~ p3 ~ p4 =>
      ClockDriver(IPXACT2009scalaxb.fromXML[ClockPeriod](p1, IPXACT2009scalaxb.ElemName(node) :: stack),
        IPXACT2009scalaxb.fromXML[ClockPulseOffset](p2, IPXACT2009scalaxb.ElemName(node) :: stack),
        IPXACT2009scalaxb.fromXML[ClockPulseValue](p3, IPXACT2009scalaxb.ElemName(node) :: stack),
        IPXACT2009scalaxb.fromXML[ClockPulseDuration](p4, IPXACT2009scalaxb.ElemName(node) :: stack),
        scala.collection.immutable.ListMap(List(
        (node \ "@{http://www.spiritconsortium.org/XMLSchema/SPIRIT/1685-2009}clockName").headOption map { x => IPXACT2009scalaxb.DataRecord(x, node, IPXACT2009scalaxb.fromXML[String](x, IPXACT2009scalaxb.ElemName(node) :: stack)) } map { "@clockName" -> _ }
        ).flatten[(String, IPXACT2009scalaxb.DataRecord[Any])]: _*)) })
    
    override def writesAttribute(__obj: ClockDriver, __scope: scala.xml.NamespaceBinding): scala.xml.MetaData = {
      var attr: scala.xml.MetaData  = scala.xml.Null
      __obj.attributes.toList map {
        case ("@clockName", _) => __obj.clockName foreach { x => attr = scala.xml.Attribute(__scope.getPrefix("http://www.spiritconsortium.org/XMLSchema/SPIRIT/1685-2009"), "clockName", x.toString, attr) }
        case (key, x) => attr = scala.xml.Attribute((x.namespace map { __scope.getPrefix(_) }).orNull, x.key.orNull, x.value.toString, attr)
      }
      attr
    }

    def writesChildNodes(__obj: ClockDriver, __scope: scala.xml.NamespaceBinding): Seq[scala.xml.Node] =
      Seq.concat(IPXACT2009scalaxb.toXML[ClockPeriod](__obj.clockPeriod, Some("http://www.spiritconsortium.org/XMLSchema/SPIRIT/1685-2009"), Some("clockPeriod"), __scope, false),
        IPXACT2009scalaxb.toXML[ClockPulseOffset](__obj.clockPulseOffset, Some("http://www.spiritconsortium.org/XMLSchema/SPIRIT/1685-2009"), Some("clockPulseOffset"), __scope, false),
        IPXACT2009scalaxb.toXML[ClockPulseValue](__obj.clockPulseValue, Some("http://www.spiritconsortium.org/XMLSchema/SPIRIT/1685-2009"), Some("clockPulseValue"), __scope, false),
        IPXACT2009scalaxb.toXML[ClockPulseDuration](__obj.clockPulseDuration, Some("http://www.spiritconsortium.org/XMLSchema/SPIRIT/1685-2009"), Some("clockPulseDuration"), __scope, false))

  }

  trait Default_SingleShotOffsetFormat extends IPXACT2009scalaxb.XMLFormat[SingleShotOffset] with IPXACT2009scalaxb.CanWriteChildNodes[SingleShotOffset] {
    val targetNamespace: Option[String] = Some("http://www.spiritconsortium.org/XMLSchema/SPIRIT/1685-2009")
    def reads(seq: scala.xml.NodeSeq, stack: List[IPXACT2009scalaxb.ElemName]): Either[String, SingleShotOffset] = seq match {
      case node: scala.xml.Node => Right(SingleShotOffset(IPXACT2009scalaxb.fromXML[Seq[Double]](node, IPXACT2009scalaxb.ElemName(node) :: stack),
        scala.collection.immutable.ListMap(List(
        (node \ "@{http://www.spiritconsortium.org/XMLSchema/SPIRIT/1685-2009}format").headOption map { x => IPXACT2009scalaxb.DataRecord(x, node, IPXACT2009scalaxb.fromXML[FormatType](x, IPXACT2009scalaxb.ElemName(node) :: stack)) } orElse Some(IPXACT2009scalaxb.DataRecord(None, None, IPXACT2009scalaxb.fromXML[FormatType](scala.xml.Text("float"), IPXACT2009scalaxb.ElemName(node) :: stack))) map { "@{http://www.spiritconsortium.org/XMLSchema/SPIRIT/1685-2009}format" -> _ },
        (node \ "@{http://www.spiritconsortium.org/XMLSchema/SPIRIT/1685-2009}resolve").headOption map { x => IPXACT2009scalaxb.DataRecord(x, node, IPXACT2009scalaxb.fromXML[ResolveType](x, IPXACT2009scalaxb.ElemName(node) :: stack)) } map { "@{http://www.spiritconsortium.org/XMLSchema/SPIRIT/1685-2009}resolve" -> _ },
        (node \ "@{http://www.spiritconsortium.org/XMLSchema/SPIRIT/1685-2009}id").headOption map { x => IPXACT2009scalaxb.DataRecord(x, node, IPXACT2009scalaxb.fromXML[String](x, IPXACT2009scalaxb.ElemName(node) :: stack)) } map { "@{http://www.spiritconsortium.org/XMLSchema/SPIRIT/1685-2009}id" -> _ },
        (node \ "@{http://www.spiritconsortium.org/XMLSchema/SPIRIT/1685-2009}dependency").headOption map { x => IPXACT2009scalaxb.DataRecord(x, node, IPXACT2009scalaxb.fromXML[String](x, IPXACT2009scalaxb.ElemName(node) :: stack)) } map { "@{http://www.spiritconsortium.org/XMLSchema/SPIRIT/1685-2009}dependency" -> _ },
        (node \ "@{http://www.spiritconsortium.org/XMLSchema/SPIRIT/1685-2009}choiceRef").headOption map { x => IPXACT2009scalaxb.DataRecord(x, node, IPXACT2009scalaxb.fromXML[String](x, IPXACT2009scalaxb.ElemName(node) :: stack)) } map { "@{http://www.spiritconsortium.org/XMLSchema/SPIRIT/1685-2009}choiceRef" -> _ },
        (node \ "@{http://www.spiritconsortium.org/XMLSchema/SPIRIT/1685-2009}order").headOption map { x => IPXACT2009scalaxb.DataRecord(x, node, IPXACT2009scalaxb.fromXML[Float](x, IPXACT2009scalaxb.ElemName(node) :: stack)) } map { "@{http://www.spiritconsortium.org/XMLSchema/SPIRIT/1685-2009}order" -> _ },
        (node \ "@{http://www.spiritconsortium.org/XMLSchema/SPIRIT/1685-2009}configGroups").headOption map { x => IPXACT2009scalaxb.DataRecord(x, node, IPXACT2009scalaxb.fromXML[Seq[String]](x, IPXACT2009scalaxb.ElemName(node) :: stack)) } map { "@{http://www.spiritconsortium.org/XMLSchema/SPIRIT/1685-2009}configGroups" -> _ },
        (node \ "@{http://www.spiritconsortium.org/XMLSchema/SPIRIT/1685-2009}bitStringLength").headOption map { x => IPXACT2009scalaxb.DataRecord(x, node, IPXACT2009scalaxb.fromXML[BigInt](x, IPXACT2009scalaxb.ElemName(node) :: stack)) } map { "@{http://www.spiritconsortium.org/XMLSchema/SPIRIT/1685-2009}bitStringLength" -> _ },
        (node \ "@{http://www.spiritconsortium.org/XMLSchema/SPIRIT/1685-2009}minimum").headOption map { x => IPXACT2009scalaxb.DataRecord(x, node, IPXACT2009scalaxb.fromXML[String](x, IPXACT2009scalaxb.ElemName(node) :: stack)) } map { "@{http://www.spiritconsortium.org/XMLSchema/SPIRIT/1685-2009}minimum" -> _ },
        (node \ "@{http://www.spiritconsortium.org/XMLSchema/SPIRIT/1685-2009}maximum").headOption map { x => IPXACT2009scalaxb.DataRecord(x, node, IPXACT2009scalaxb.fromXML[String](x, IPXACT2009scalaxb.ElemName(node) :: stack)) } map { "@{http://www.spiritconsortium.org/XMLSchema/SPIRIT/1685-2009}maximum" -> _ },
        (node \ "@{http://www.spiritconsortium.org/XMLSchema/SPIRIT/1685-2009}rangeType").headOption map { x => IPXACT2009scalaxb.DataRecord(x, node, IPXACT2009scalaxb.fromXML[RangeTypeType](x, IPXACT2009scalaxb.ElemName(node) :: stack)) } orElse Some(IPXACT2009scalaxb.DataRecord(None, None, IPXACT2009scalaxb.fromXML[RangeTypeType](scala.xml.Text("float"), IPXACT2009scalaxb.ElemName(node) :: stack))) map { "@{http://www.spiritconsortium.org/XMLSchema/SPIRIT/1685-2009}rangeType" -> _ },
        (node \ "@{http://www.spiritconsortium.org/XMLSchema/SPIRIT/1685-2009}prompt").headOption map { x => IPXACT2009scalaxb.DataRecord(x, node, IPXACT2009scalaxb.fromXML[String](x, IPXACT2009scalaxb.ElemName(node) :: stack)) } map { "@{http://www.spiritconsortium.org/XMLSchema/SPIRIT/1685-2009}prompt" -> _ }
        ).flatten[(String, IPXACT2009scalaxb.DataRecord[Any])] ::: (node match {
          case elem: scala.xml.Elem =>
            elem.attributes.toList flatMap {
              case scala.xml.PrefixedAttribute(pre, key, value, _) if pre == elem.scope.getPrefix("http://www.spiritconsortium.org/XMLSchema/SPIRIT/1685-2009") &&
                key == "format" => Nil
              case scala.xml.PrefixedAttribute(pre, key, value, _) if pre == elem.scope.getPrefix("http://www.spiritconsortium.org/XMLSchema/SPIRIT/1685-2009") &&
                key == "resolve" => Nil
              case scala.xml.PrefixedAttribute(pre, key, value, _) if pre == elem.scope.getPrefix("http://www.spiritconsortium.org/XMLSchema/SPIRIT/1685-2009") &&
                key == "id" => Nil
              case scala.xml.PrefixedAttribute(pre, key, value, _) if pre == elem.scope.getPrefix("http://www.spiritconsortium.org/XMLSchema/SPIRIT/1685-2009") &&
                key == "dependency" => Nil
              case scala.xml.PrefixedAttribute(pre, key, value, _) if pre == elem.scope.getPrefix("http://www.spiritconsortium.org/XMLSchema/SPIRIT/1685-2009") &&
                key == "choiceRef" => Nil
              case scala.xml.PrefixedAttribute(pre, key, value, _) if pre == elem.scope.getPrefix("http://www.spiritconsortium.org/XMLSchema/SPIRIT/1685-2009") &&
                key == "order" => Nil
              case scala.xml.PrefixedAttribute(pre, key, value, _) if pre == elem.scope.getPrefix("http://www.spiritconsortium.org/XMLSchema/SPIRIT/1685-2009") &&
                key == "configGroups" => Nil
              case scala.xml.PrefixedAttribute(pre, key, value, _) if pre == elem.scope.getPrefix("http://www.spiritconsortium.org/XMLSchema/SPIRIT/1685-2009") &&
                key == "bitStringLength" => Nil
              case scala.xml.PrefixedAttribute(pre, key, value, _) if pre == elem.scope.getPrefix("http://www.spiritconsortium.org/XMLSchema/SPIRIT/1685-2009") &&
                key == "minimum" => Nil
              case scala.xml.PrefixedAttribute(pre, key, value, _) if pre == elem.scope.getPrefix("http://www.spiritconsortium.org/XMLSchema/SPIRIT/1685-2009") &&
                key == "maximum" => Nil
              case scala.xml.PrefixedAttribute(pre, key, value, _) if pre == elem.scope.getPrefix("http://www.spiritconsortium.org/XMLSchema/SPIRIT/1685-2009") &&
                key == "rangeType" => Nil
              case scala.xml.PrefixedAttribute(pre, key, value, _) if pre == elem.scope.getPrefix("http://www.spiritconsortium.org/XMLSchema/SPIRIT/1685-2009") &&
                key == "prompt" => Nil
              case scala.xml.UnprefixedAttribute(key, value, _) =>
                List(("@" + key, IPXACT2009scalaxb.DataRecord(None, Some(key), value.text)))
              case scala.xml.PrefixedAttribute(pre, key, value, _) =>
                val ns = elem.scope.getURI(pre)
                List(("@{" + ns + "}" + key, IPXACT2009scalaxb.DataRecord(Option[String](ns), Some(key), value.text)))
              case _ => Nil
            }
          case _ => Nil
        }): _*)))
      case _ => Left("reads failed: seq must be scala.xml.Node")
    }
    
    override def writesAttribute(__obj: SingleShotOffset, __scope: scala.xml.NamespaceBinding): scala.xml.MetaData = {
      var attr: scala.xml.MetaData  = scala.xml.Null
      __obj.attributes.toList map {
        case ("@{http://www.spiritconsortium.org/XMLSchema/SPIRIT/1685-2009}format", _) => if (__obj.spiritformat.toString != "float") attr = scala.xml.Attribute(__scope.getPrefix("http://www.spiritconsortium.org/XMLSchema/SPIRIT/1685-2009"), "format", __obj.spiritformat.toString, attr)
        case ("@{http://www.spiritconsortium.org/XMLSchema/SPIRIT/1685-2009}resolve", _) => __obj.spiritresolve foreach { x => attr = scala.xml.Attribute(__scope.getPrefix("http://www.spiritconsortium.org/XMLSchema/SPIRIT/1685-2009"), "resolve", x.toString, attr) }
        case ("@{http://www.spiritconsortium.org/XMLSchema/SPIRIT/1685-2009}id", _) => __obj.spiritid foreach { x => attr = scala.xml.Attribute(__scope.getPrefix("http://www.spiritconsortium.org/XMLSchema/SPIRIT/1685-2009"), "id", x.toString, attr) }
        case ("@{http://www.spiritconsortium.org/XMLSchema/SPIRIT/1685-2009}dependency", _) => __obj.spiritdependency foreach { x => attr = scala.xml.Attribute(__scope.getPrefix("http://www.spiritconsortium.org/XMLSchema/SPIRIT/1685-2009"), "dependency", x.toString, attr) }
        case ("@{http://www.spiritconsortium.org/XMLSchema/SPIRIT/1685-2009}choiceRef", _) => __obj.spiritchoiceRef foreach { x => attr = scala.xml.Attribute(__scope.getPrefix("http://www.spiritconsortium.org/XMLSchema/SPIRIT/1685-2009"), "choiceRef", x.toString, attr) }
        case ("@{http://www.spiritconsortium.org/XMLSchema/SPIRIT/1685-2009}order", _) => __obj.spiritorder foreach { x => attr = scala.xml.Attribute(__scope.getPrefix("http://www.spiritconsortium.org/XMLSchema/SPIRIT/1685-2009"), "order", x.toString, attr) }
        case ("@{http://www.spiritconsortium.org/XMLSchema/SPIRIT/1685-2009}configGroups", _) => __obj.spiritconfigGroups foreach { x => attr = scala.xml.Attribute(__scope.getPrefix("http://www.spiritconsortium.org/XMLSchema/SPIRIT/1685-2009"), "configGroups", x.toString, attr) }
        case ("@{http://www.spiritconsortium.org/XMLSchema/SPIRIT/1685-2009}bitStringLength", _) => __obj.spiritbitStringLength foreach { x => attr = scala.xml.Attribute(__scope.getPrefix("http://www.spiritconsortium.org/XMLSchema/SPIRIT/1685-2009"), "bitStringLength", x.toString, attr) }
        case ("@{http://www.spiritconsortium.org/XMLSchema/SPIRIT/1685-2009}minimum", _) => __obj.spiritminimum foreach { x => attr = scala.xml.Attribute(__scope.getPrefix("http://www.spiritconsortium.org/XMLSchema/SPIRIT/1685-2009"), "minimum", x.toString, attr) }
        case ("@{http://www.spiritconsortium.org/XMLSchema/SPIRIT/1685-2009}maximum", _) => __obj.spiritmaximum foreach { x => attr = scala.xml.Attribute(__scope.getPrefix("http://www.spiritconsortium.org/XMLSchema/SPIRIT/1685-2009"), "maximum", x.toString, attr) }
        case ("@{http://www.spiritconsortium.org/XMLSchema/SPIRIT/1685-2009}rangeType", _) => if (__obj.spiritrangeType.toString != "float") attr = scala.xml.Attribute(__scope.getPrefix("http://www.spiritconsortium.org/XMLSchema/SPIRIT/1685-2009"), "rangeType", __obj.spiritrangeType.toString, attr)
        case ("@{http://www.spiritconsortium.org/XMLSchema/SPIRIT/1685-2009}prompt", _) => __obj.spiritprompt foreach { x => attr = scala.xml.Attribute(__scope.getPrefix("http://www.spiritconsortium.org/XMLSchema/SPIRIT/1685-2009"), "prompt", x.toString, attr) }
        case (key, x) => attr = scala.xml.Attribute((x.namespace map { __scope.getPrefix(_) }).orNull, x.key.orNull, x.value.toString, attr)
      }
      attr
    }

    def writesChildNodes(__obj: SingleShotOffset, __scope: scala.xml.NamespaceBinding): Seq[scala.xml.Node] =
      Seq(scala.xml.Text(__obj.value.toString))

  }

  trait Default_SingleShotValueFormat extends IPXACT2009scalaxb.XMLFormat[SingleShotValue] with IPXACT2009scalaxb.CanWriteChildNodes[SingleShotValue] {
    val targetNamespace: Option[String] = Some("http://www.spiritconsortium.org/XMLSchema/SPIRIT/1685-2009")
    def reads(seq: scala.xml.NodeSeq, stack: List[IPXACT2009scalaxb.ElemName]): Either[String, SingleShotValue] = seq match {
      case node: scala.xml.Node => Right(SingleShotValue(IPXACT2009scalaxb.fromXML[String](node, IPXACT2009scalaxb.ElemName(node) :: stack),
        scala.collection.immutable.ListMap(List(
        (node \ "@{http://www.spiritconsortium.org/XMLSchema/SPIRIT/1685-2009}format").headOption map { x => IPXACT2009scalaxb.DataRecord(x, node, IPXACT2009scalaxb.fromXML[FormatType](x, IPXACT2009scalaxb.ElemName(node) :: stack)) } orElse Some(IPXACT2009scalaxb.DataRecord(None, None, IPXACT2009scalaxb.fromXML[FormatType](scala.xml.Text("long"), IPXACT2009scalaxb.ElemName(node) :: stack))) map { "@{http://www.spiritconsortium.org/XMLSchema/SPIRIT/1685-2009}format" -> _ },
        (node \ "@{http://www.spiritconsortium.org/XMLSchema/SPIRIT/1685-2009}resolve").headOption map { x => IPXACT2009scalaxb.DataRecord(x, node, IPXACT2009scalaxb.fromXML[ResolveType](x, IPXACT2009scalaxb.ElemName(node) :: stack)) } map { "@{http://www.spiritconsortium.org/XMLSchema/SPIRIT/1685-2009}resolve" -> _ },
        (node \ "@{http://www.spiritconsortium.org/XMLSchema/SPIRIT/1685-2009}id").headOption map { x => IPXACT2009scalaxb.DataRecord(x, node, IPXACT2009scalaxb.fromXML[String](x, IPXACT2009scalaxb.ElemName(node) :: stack)) } map { "@{http://www.spiritconsortium.org/XMLSchema/SPIRIT/1685-2009}id" -> _ },
        (node \ "@{http://www.spiritconsortium.org/XMLSchema/SPIRIT/1685-2009}dependency").headOption map { x => IPXACT2009scalaxb.DataRecord(x, node, IPXACT2009scalaxb.fromXML[String](x, IPXACT2009scalaxb.ElemName(node) :: stack)) } map { "@{http://www.spiritconsortium.org/XMLSchema/SPIRIT/1685-2009}dependency" -> _ },
        (node \ "@{http://www.spiritconsortium.org/XMLSchema/SPIRIT/1685-2009}choiceRef").headOption map { x => IPXACT2009scalaxb.DataRecord(x, node, IPXACT2009scalaxb.fromXML[String](x, IPXACT2009scalaxb.ElemName(node) :: stack)) } map { "@{http://www.spiritconsortium.org/XMLSchema/SPIRIT/1685-2009}choiceRef" -> _ },
        (node \ "@{http://www.spiritconsortium.org/XMLSchema/SPIRIT/1685-2009}order").headOption map { x => IPXACT2009scalaxb.DataRecord(x, node, IPXACT2009scalaxb.fromXML[Float](x, IPXACT2009scalaxb.ElemName(node) :: stack)) } map { "@{http://www.spiritconsortium.org/XMLSchema/SPIRIT/1685-2009}order" -> _ },
        (node \ "@{http://www.spiritconsortium.org/XMLSchema/SPIRIT/1685-2009}configGroups").headOption map { x => IPXACT2009scalaxb.DataRecord(x, node, IPXACT2009scalaxb.fromXML[Seq[String]](x, IPXACT2009scalaxb.ElemName(node) :: stack)) } map { "@{http://www.spiritconsortium.org/XMLSchema/SPIRIT/1685-2009}configGroups" -> _ },
        (node \ "@{http://www.spiritconsortium.org/XMLSchema/SPIRIT/1685-2009}bitStringLength").headOption map { x => IPXACT2009scalaxb.DataRecord(x, node, IPXACT2009scalaxb.fromXML[BigInt](x, IPXACT2009scalaxb.ElemName(node) :: stack)) } map { "@{http://www.spiritconsortium.org/XMLSchema/SPIRIT/1685-2009}bitStringLength" -> _ },
        (node \ "@{http://www.spiritconsortium.org/XMLSchema/SPIRIT/1685-2009}minimum").headOption map { x => IPXACT2009scalaxb.DataRecord(x, node, IPXACT2009scalaxb.fromXML[String](x, IPXACT2009scalaxb.ElemName(node) :: stack)) } map { "@{http://www.spiritconsortium.org/XMLSchema/SPIRIT/1685-2009}minimum" -> _ },
        (node \ "@{http://www.spiritconsortium.org/XMLSchema/SPIRIT/1685-2009}maximum").headOption map { x => IPXACT2009scalaxb.DataRecord(x, node, IPXACT2009scalaxb.fromXML[String](x, IPXACT2009scalaxb.ElemName(node) :: stack)) } map { "@{http://www.spiritconsortium.org/XMLSchema/SPIRIT/1685-2009}maximum" -> _ },
        (node \ "@{http://www.spiritconsortium.org/XMLSchema/SPIRIT/1685-2009}rangeType").headOption map { x => IPXACT2009scalaxb.DataRecord(x, node, IPXACT2009scalaxb.fromXML[RangeTypeType](x, IPXACT2009scalaxb.ElemName(node) :: stack)) } orElse Some(IPXACT2009scalaxb.DataRecord(None, None, IPXACT2009scalaxb.fromXML[RangeTypeType](scala.xml.Text("float"), IPXACT2009scalaxb.ElemName(node) :: stack))) map { "@{http://www.spiritconsortium.org/XMLSchema/SPIRIT/1685-2009}rangeType" -> _ },
        (node \ "@{http://www.spiritconsortium.org/XMLSchema/SPIRIT/1685-2009}prompt").headOption map { x => IPXACT2009scalaxb.DataRecord(x, node, IPXACT2009scalaxb.fromXML[String](x, IPXACT2009scalaxb.ElemName(node) :: stack)) } map { "@{http://www.spiritconsortium.org/XMLSchema/SPIRIT/1685-2009}prompt" -> _ }
        ).flatten[(String, IPXACT2009scalaxb.DataRecord[Any])] ::: (node match {
          case elem: scala.xml.Elem =>
            elem.attributes.toList flatMap {
              case scala.xml.PrefixedAttribute(pre, key, value, _) if pre == elem.scope.getPrefix("http://www.spiritconsortium.org/XMLSchema/SPIRIT/1685-2009") &&
                key == "format" => Nil
              case scala.xml.PrefixedAttribute(pre, key, value, _) if pre == elem.scope.getPrefix("http://www.spiritconsortium.org/XMLSchema/SPIRIT/1685-2009") &&
                key == "resolve" => Nil
              case scala.xml.PrefixedAttribute(pre, key, value, _) if pre == elem.scope.getPrefix("http://www.spiritconsortium.org/XMLSchema/SPIRIT/1685-2009") &&
                key == "id" => Nil
              case scala.xml.PrefixedAttribute(pre, key, value, _) if pre == elem.scope.getPrefix("http://www.spiritconsortium.org/XMLSchema/SPIRIT/1685-2009") &&
                key == "dependency" => Nil
              case scala.xml.PrefixedAttribute(pre, key, value, _) if pre == elem.scope.getPrefix("http://www.spiritconsortium.org/XMLSchema/SPIRIT/1685-2009") &&
                key == "choiceRef" => Nil
              case scala.xml.PrefixedAttribute(pre, key, value, _) if pre == elem.scope.getPrefix("http://www.spiritconsortium.org/XMLSchema/SPIRIT/1685-2009") &&
                key == "order" => Nil
              case scala.xml.PrefixedAttribute(pre, key, value, _) if pre == elem.scope.getPrefix("http://www.spiritconsortium.org/XMLSchema/SPIRIT/1685-2009") &&
                key == "configGroups" => Nil
              case scala.xml.PrefixedAttribute(pre, key, value, _) if pre == elem.scope.getPrefix("http://www.spiritconsortium.org/XMLSchema/SPIRIT/1685-2009") &&
                key == "bitStringLength" => Nil
              case scala.xml.PrefixedAttribute(pre, key, value, _) if pre == elem.scope.getPrefix("http://www.spiritconsortium.org/XMLSchema/SPIRIT/1685-2009") &&
                key == "minimum" => Nil
              case scala.xml.PrefixedAttribute(pre, key, value, _) if pre == elem.scope.getPrefix("http://www.spiritconsortium.org/XMLSchema/SPIRIT/1685-2009") &&
                key == "maximum" => Nil
              case scala.xml.PrefixedAttribute(pre, key, value, _) if pre == elem.scope.getPrefix("http://www.spiritconsortium.org/XMLSchema/SPIRIT/1685-2009") &&
                key == "rangeType" => Nil
              case scala.xml.PrefixedAttribute(pre, key, value, _) if pre == elem.scope.getPrefix("http://www.spiritconsortium.org/XMLSchema/SPIRIT/1685-2009") &&
                key == "prompt" => Nil
              case scala.xml.UnprefixedAttribute(key, value, _) =>
                List(("@" + key, IPXACT2009scalaxb.DataRecord(None, Some(key), value.text)))
              case scala.xml.PrefixedAttribute(pre, key, value, _) =>
                val ns = elem.scope.getURI(pre)
                List(("@{" + ns + "}" + key, IPXACT2009scalaxb.DataRecord(Option[String](ns), Some(key), value.text)))
              case _ => Nil
            }
          case _ => Nil
        }): _*)))
      case _ => Left("reads failed: seq must be scala.xml.Node")
    }
    
    override def writesAttribute(__obj: SingleShotValue, __scope: scala.xml.NamespaceBinding): scala.xml.MetaData = {
      var attr: scala.xml.MetaData  = scala.xml.Null
      __obj.attributes.toList map {
        case ("@{http://www.spiritconsortium.org/XMLSchema/SPIRIT/1685-2009}format", _) => if (__obj.spiritformat.toString != "long") attr = scala.xml.Attribute(__scope.getPrefix("http://www.spiritconsortium.org/XMLSchema/SPIRIT/1685-2009"), "format", __obj.spiritformat.toString, attr)
        case ("@{http://www.spiritconsortium.org/XMLSchema/SPIRIT/1685-2009}resolve", _) => __obj.spiritresolve foreach { x => attr = scala.xml.Attribute(__scope.getPrefix("http://www.spiritconsortium.org/XMLSchema/SPIRIT/1685-2009"), "resolve", x.toString, attr) }
        case ("@{http://www.spiritconsortium.org/XMLSchema/SPIRIT/1685-2009}id", _) => __obj.spiritid foreach { x => attr = scala.xml.Attribute(__scope.getPrefix("http://www.spiritconsortium.org/XMLSchema/SPIRIT/1685-2009"), "id", x.toString, attr) }
        case ("@{http://www.spiritconsortium.org/XMLSchema/SPIRIT/1685-2009}dependency", _) => __obj.spiritdependency foreach { x => attr = scala.xml.Attribute(__scope.getPrefix("http://www.spiritconsortium.org/XMLSchema/SPIRIT/1685-2009"), "dependency", x.toString, attr) }
        case ("@{http://www.spiritconsortium.org/XMLSchema/SPIRIT/1685-2009}choiceRef", _) => __obj.spiritchoiceRef foreach { x => attr = scala.xml.Attribute(__scope.getPrefix("http://www.spiritconsortium.org/XMLSchema/SPIRIT/1685-2009"), "choiceRef", x.toString, attr) }
        case ("@{http://www.spiritconsortium.org/XMLSchema/SPIRIT/1685-2009}order", _) => __obj.spiritorder foreach { x => attr = scala.xml.Attribute(__scope.getPrefix("http://www.spiritconsortium.org/XMLSchema/SPIRIT/1685-2009"), "order", x.toString, attr) }
        case ("@{http://www.spiritconsortium.org/XMLSchema/SPIRIT/1685-2009}configGroups", _) => __obj.spiritconfigGroups foreach { x => attr = scala.xml.Attribute(__scope.getPrefix("http://www.spiritconsortium.org/XMLSchema/SPIRIT/1685-2009"), "configGroups", x.toString, attr) }
        case ("@{http://www.spiritconsortium.org/XMLSchema/SPIRIT/1685-2009}bitStringLength", _) => __obj.spiritbitStringLength foreach { x => attr = scala.xml.Attribute(__scope.getPrefix("http://www.spiritconsortium.org/XMLSchema/SPIRIT/1685-2009"), "bitStringLength", x.toString, attr) }
        case ("@{http://www.spiritconsortium.org/XMLSchema/SPIRIT/1685-2009}minimum", _) => __obj.spiritminimum foreach { x => attr = scala.xml.Attribute(__scope.getPrefix("http://www.spiritconsortium.org/XMLSchema/SPIRIT/1685-2009"), "minimum", x.toString, attr) }
        case ("@{http://www.spiritconsortium.org/XMLSchema/SPIRIT/1685-2009}maximum", _) => __obj.spiritmaximum foreach { x => attr = scala.xml.Attribute(__scope.getPrefix("http://www.spiritconsortium.org/XMLSchema/SPIRIT/1685-2009"), "maximum", x.toString, attr) }
        case ("@{http://www.spiritconsortium.org/XMLSchema/SPIRIT/1685-2009}rangeType", _) => if (__obj.spiritrangeType.toString != "float") attr = scala.xml.Attribute(__scope.getPrefix("http://www.spiritconsortium.org/XMLSchema/SPIRIT/1685-2009"), "rangeType", __obj.spiritrangeType.toString, attr)
        case ("@{http://www.spiritconsortium.org/XMLSchema/SPIRIT/1685-2009}prompt", _) => __obj.spiritprompt foreach { x => attr = scala.xml.Attribute(__scope.getPrefix("http://www.spiritconsortium.org/XMLSchema/SPIRIT/1685-2009"), "prompt", x.toString, attr) }
        case (key, x) => attr = scala.xml.Attribute((x.namespace map { __scope.getPrefix(_) }).orNull, x.key.orNull, x.value.toString, attr)
      }
      attr
    }

    def writesChildNodes(__obj: SingleShotValue, __scope: scala.xml.NamespaceBinding): Seq[scala.xml.Node] =
      Seq(scala.xml.Text(__obj.value.toString))

  }

  trait Default_SingleShotDurationFormat extends IPXACT2009scalaxb.XMLFormat[SingleShotDuration] with IPXACT2009scalaxb.CanWriteChildNodes[SingleShotDuration] {
    val targetNamespace: Option[String] = Some("http://www.spiritconsortium.org/XMLSchema/SPIRIT/1685-2009")
    def reads(seq: scala.xml.NodeSeq, stack: List[IPXACT2009scalaxb.ElemName]): Either[String, SingleShotDuration] = seq match {
      case node: scala.xml.Node => Right(SingleShotDuration(IPXACT2009scalaxb.fromXML[Seq[Double]](node, IPXACT2009scalaxb.ElemName(node) :: stack),
        scala.collection.immutable.ListMap(List(
        (node \ "@{http://www.spiritconsortium.org/XMLSchema/SPIRIT/1685-2009}format").headOption map { x => IPXACT2009scalaxb.DataRecord(x, node, IPXACT2009scalaxb.fromXML[FormatType](x, IPXACT2009scalaxb.ElemName(node) :: stack)) } orElse Some(IPXACT2009scalaxb.DataRecord(None, None, IPXACT2009scalaxb.fromXML[FormatType](scala.xml.Text("float"), IPXACT2009scalaxb.ElemName(node) :: stack))) map { "@{http://www.spiritconsortium.org/XMLSchema/SPIRIT/1685-2009}format" -> _ },
        (node \ "@{http://www.spiritconsortium.org/XMLSchema/SPIRIT/1685-2009}resolve").headOption map { x => IPXACT2009scalaxb.DataRecord(x, node, IPXACT2009scalaxb.fromXML[ResolveType](x, IPXACT2009scalaxb.ElemName(node) :: stack)) } map { "@{http://www.spiritconsortium.org/XMLSchema/SPIRIT/1685-2009}resolve" -> _ },
        (node \ "@{http://www.spiritconsortium.org/XMLSchema/SPIRIT/1685-2009}id").headOption map { x => IPXACT2009scalaxb.DataRecord(x, node, IPXACT2009scalaxb.fromXML[String](x, IPXACT2009scalaxb.ElemName(node) :: stack)) } map { "@{http://www.spiritconsortium.org/XMLSchema/SPIRIT/1685-2009}id" -> _ },
        (node \ "@{http://www.spiritconsortium.org/XMLSchema/SPIRIT/1685-2009}dependency").headOption map { x => IPXACT2009scalaxb.DataRecord(x, node, IPXACT2009scalaxb.fromXML[String](x, IPXACT2009scalaxb.ElemName(node) :: stack)) } map { "@{http://www.spiritconsortium.org/XMLSchema/SPIRIT/1685-2009}dependency" -> _ },
        (node \ "@{http://www.spiritconsortium.org/XMLSchema/SPIRIT/1685-2009}choiceRef").headOption map { x => IPXACT2009scalaxb.DataRecord(x, node, IPXACT2009scalaxb.fromXML[String](x, IPXACT2009scalaxb.ElemName(node) :: stack)) } map { "@{http://www.spiritconsortium.org/XMLSchema/SPIRIT/1685-2009}choiceRef" -> _ },
        (node \ "@{http://www.spiritconsortium.org/XMLSchema/SPIRIT/1685-2009}order").headOption map { x => IPXACT2009scalaxb.DataRecord(x, node, IPXACT2009scalaxb.fromXML[Float](x, IPXACT2009scalaxb.ElemName(node) :: stack)) } map { "@{http://www.spiritconsortium.org/XMLSchema/SPIRIT/1685-2009}order" -> _ },
        (node \ "@{http://www.spiritconsortium.org/XMLSchema/SPIRIT/1685-2009}configGroups").headOption map { x => IPXACT2009scalaxb.DataRecord(x, node, IPXACT2009scalaxb.fromXML[Seq[String]](x, IPXACT2009scalaxb.ElemName(node) :: stack)) } map { "@{http://www.spiritconsortium.org/XMLSchema/SPIRIT/1685-2009}configGroups" -> _ },
        (node \ "@{http://www.spiritconsortium.org/XMLSchema/SPIRIT/1685-2009}bitStringLength").headOption map { x => IPXACT2009scalaxb.DataRecord(x, node, IPXACT2009scalaxb.fromXML[BigInt](x, IPXACT2009scalaxb.ElemName(node) :: stack)) } map { "@{http://www.spiritconsortium.org/XMLSchema/SPIRIT/1685-2009}bitStringLength" -> _ },
        (node \ "@{http://www.spiritconsortium.org/XMLSchema/SPIRIT/1685-2009}minimum").headOption map { x => IPXACT2009scalaxb.DataRecord(x, node, IPXACT2009scalaxb.fromXML[String](x, IPXACT2009scalaxb.ElemName(node) :: stack)) } map { "@{http://www.spiritconsortium.org/XMLSchema/SPIRIT/1685-2009}minimum" -> _ },
        (node \ "@{http://www.spiritconsortium.org/XMLSchema/SPIRIT/1685-2009}maximum").headOption map { x => IPXACT2009scalaxb.DataRecord(x, node, IPXACT2009scalaxb.fromXML[String](x, IPXACT2009scalaxb.ElemName(node) :: stack)) } map { "@{http://www.spiritconsortium.org/XMLSchema/SPIRIT/1685-2009}maximum" -> _ },
        (node \ "@{http://www.spiritconsortium.org/XMLSchema/SPIRIT/1685-2009}rangeType").headOption map { x => IPXACT2009scalaxb.DataRecord(x, node, IPXACT2009scalaxb.fromXML[RangeTypeType](x, IPXACT2009scalaxb.ElemName(node) :: stack)) } orElse Some(IPXACT2009scalaxb.DataRecord(None, None, IPXACT2009scalaxb.fromXML[RangeTypeType](scala.xml.Text("float"), IPXACT2009scalaxb.ElemName(node) :: stack))) map { "@{http://www.spiritconsortium.org/XMLSchema/SPIRIT/1685-2009}rangeType" -> _ },
        (node \ "@{http://www.spiritconsortium.org/XMLSchema/SPIRIT/1685-2009}prompt").headOption map { x => IPXACT2009scalaxb.DataRecord(x, node, IPXACT2009scalaxb.fromXML[String](x, IPXACT2009scalaxb.ElemName(node) :: stack)) } map { "@{http://www.spiritconsortium.org/XMLSchema/SPIRIT/1685-2009}prompt" -> _ }
        ).flatten[(String, IPXACT2009scalaxb.DataRecord[Any])] ::: (node match {
          case elem: scala.xml.Elem =>
            elem.attributes.toList flatMap {
              case scala.xml.PrefixedAttribute(pre, key, value, _) if pre == elem.scope.getPrefix("http://www.spiritconsortium.org/XMLSchema/SPIRIT/1685-2009") &&
                key == "format" => Nil
              case scala.xml.PrefixedAttribute(pre, key, value, _) if pre == elem.scope.getPrefix("http://www.spiritconsortium.org/XMLSchema/SPIRIT/1685-2009") &&
                key == "resolve" => Nil
              case scala.xml.PrefixedAttribute(pre, key, value, _) if pre == elem.scope.getPrefix("http://www.spiritconsortium.org/XMLSchema/SPIRIT/1685-2009") &&
                key == "id" => Nil
              case scala.xml.PrefixedAttribute(pre, key, value, _) if pre == elem.scope.getPrefix("http://www.spiritconsortium.org/XMLSchema/SPIRIT/1685-2009") &&
                key == "dependency" => Nil
              case scala.xml.PrefixedAttribute(pre, key, value, _) if pre == elem.scope.getPrefix("http://www.spiritconsortium.org/XMLSchema/SPIRIT/1685-2009") &&
                key == "choiceRef" => Nil
              case scala.xml.PrefixedAttribute(pre, key, value, _) if pre == elem.scope.getPrefix("http://www.spiritconsortium.org/XMLSchema/SPIRIT/1685-2009") &&
                key == "order" => Nil
              case scala.xml.PrefixedAttribute(pre, key, value, _) if pre == elem.scope.getPrefix("http://www.spiritconsortium.org/XMLSchema/SPIRIT/1685-2009") &&
                key == "configGroups" => Nil
              case scala.xml.PrefixedAttribute(pre, key, value, _) if pre == elem.scope.getPrefix("http://www.spiritconsortium.org/XMLSchema/SPIRIT/1685-2009") &&
                key == "bitStringLength" => Nil
              case scala.xml.PrefixedAttribute(pre, key, value, _) if pre == elem.scope.getPrefix("http://www.spiritconsortium.org/XMLSchema/SPIRIT/1685-2009") &&
                key == "minimum" => Nil
              case scala.xml.PrefixedAttribute(pre, key, value, _) if pre == elem.scope.getPrefix("http://www.spiritconsortium.org/XMLSchema/SPIRIT/1685-2009") &&
                key == "maximum" => Nil
              case scala.xml.PrefixedAttribute(pre, key, value, _) if pre == elem.scope.getPrefix("http://www.spiritconsortium.org/XMLSchema/SPIRIT/1685-2009") &&
                key == "rangeType" => Nil
              case scala.xml.PrefixedAttribute(pre, key, value, _) if pre == elem.scope.getPrefix("http://www.spiritconsortium.org/XMLSchema/SPIRIT/1685-2009") &&
                key == "prompt" => Nil
              case scala.xml.UnprefixedAttribute(key, value, _) =>
                List(("@" + key, IPXACT2009scalaxb.DataRecord(None, Some(key), value.text)))
              case scala.xml.PrefixedAttribute(pre, key, value, _) =>
                val ns = elem.scope.getURI(pre)
                List(("@{" + ns + "}" + key, IPXACT2009scalaxb.DataRecord(Option[String](ns), Some(key), value.text)))
              case _ => Nil
            }
          case _ => Nil
        }): _*)))
      case _ => Left("reads failed: seq must be scala.xml.Node")
    }
    
    override def writesAttribute(__obj: SingleShotDuration, __scope: scala.xml.NamespaceBinding): scala.xml.MetaData = {
      var attr: scala.xml.MetaData  = scala.xml.Null
      __obj.attributes.toList map {
        case ("@{http://www.spiritconsortium.org/XMLSchema/SPIRIT/1685-2009}format", _) => if (__obj.spiritformat.toString != "float") attr = scala.xml.Attribute(__scope.getPrefix("http://www.spiritconsortium.org/XMLSchema/SPIRIT/1685-2009"), "format", __obj.spiritformat.toString, attr)
        case ("@{http://www.spiritconsortium.org/XMLSchema/SPIRIT/1685-2009}resolve", _) => __obj.spiritresolve foreach { x => attr = scala.xml.Attribute(__scope.getPrefix("http://www.spiritconsortium.org/XMLSchema/SPIRIT/1685-2009"), "resolve", x.toString, attr) }
        case ("@{http://www.spiritconsortium.org/XMLSchema/SPIRIT/1685-2009}id", _) => __obj.spiritid foreach { x => attr = scala.xml.Attribute(__scope.getPrefix("http://www.spiritconsortium.org/XMLSchema/SPIRIT/1685-2009"), "id", x.toString, attr) }
        case ("@{http://www.spiritconsortium.org/XMLSchema/SPIRIT/1685-2009}dependency", _) => __obj.spiritdependency foreach { x => attr = scala.xml.Attribute(__scope.getPrefix("http://www.spiritconsortium.org/XMLSchema/SPIRIT/1685-2009"), "dependency", x.toString, attr) }
        case ("@{http://www.spiritconsortium.org/XMLSchema/SPIRIT/1685-2009}choiceRef", _) => __obj.spiritchoiceRef foreach { x => attr = scala.xml.Attribute(__scope.getPrefix("http://www.spiritconsortium.org/XMLSchema/SPIRIT/1685-2009"), "choiceRef", x.toString, attr) }
        case ("@{http://www.spiritconsortium.org/XMLSchema/SPIRIT/1685-2009}order", _) => __obj.spiritorder foreach { x => attr = scala.xml.Attribute(__scope.getPrefix("http://www.spiritconsortium.org/XMLSchema/SPIRIT/1685-2009"), "order", x.toString, attr) }
        case ("@{http://www.spiritconsortium.org/XMLSchema/SPIRIT/1685-2009}configGroups", _) => __obj.spiritconfigGroups foreach { x => attr = scala.xml.Attribute(__scope.getPrefix("http://www.spiritconsortium.org/XMLSchema/SPIRIT/1685-2009"), "configGroups", x.toString, attr) }
        case ("@{http://www.spiritconsortium.org/XMLSchema/SPIRIT/1685-2009}bitStringLength", _) => __obj.spiritbitStringLength foreach { x => attr = scala.xml.Attribute(__scope.getPrefix("http://www.spiritconsortium.org/XMLSchema/SPIRIT/1685-2009"), "bitStringLength", x.toString, attr) }
        case ("@{http://www.spiritconsortium.org/XMLSchema/SPIRIT/1685-2009}minimum", _) => __obj.spiritminimum foreach { x => attr = scala.xml.Attribute(__scope.getPrefix("http://www.spiritconsortium.org/XMLSchema/SPIRIT/1685-2009"), "minimum", x.toString, attr) }
        case ("@{http://www.spiritconsortium.org/XMLSchema/SPIRIT/1685-2009}maximum", _) => __obj.spiritmaximum foreach { x => attr = scala.xml.Attribute(__scope.getPrefix("http://www.spiritconsortium.org/XMLSchema/SPIRIT/1685-2009"), "maximum", x.toString, attr) }
        case ("@{http://www.spiritconsortium.org/XMLSchema/SPIRIT/1685-2009}rangeType", _) => if (__obj.spiritrangeType.toString != "float") attr = scala.xml.Attribute(__scope.getPrefix("http://www.spiritconsortium.org/XMLSchema/SPIRIT/1685-2009"), "rangeType", __obj.spiritrangeType.toString, attr)
        case ("@{http://www.spiritconsortium.org/XMLSchema/SPIRIT/1685-2009}prompt", _) => __obj.spiritprompt foreach { x => attr = scala.xml.Attribute(__scope.getPrefix("http://www.spiritconsortium.org/XMLSchema/SPIRIT/1685-2009"), "prompt", x.toString, attr) }
        case (key, x) => attr = scala.xml.Attribute((x.namespace map { __scope.getPrefix(_) }).orNull, x.key.orNull, x.value.toString, attr)
      }
      attr
    }

    def writesChildNodes(__obj: SingleShotDuration, __scope: scala.xml.NamespaceBinding): Seq[scala.xml.Node] =
      Seq(scala.xml.Text(__obj.value.toString))

  }

  trait Default_SingleShotDriverFormat extends IPXACT2009scalaxb.ElemNameParser[SingleShotDriver] {
    val targetNamespace: Option[String] = Some("http://www.spiritconsortium.org/XMLSchema/SPIRIT/1685-2009")
    
    def parser(node: scala.xml.Node, stack: List[IPXACT2009scalaxb.ElemName]): Parser[SingleShotDriver] =
      phrase((IPXACT2009scalaxb.ElemName(Some("http://www.spiritconsortium.org/XMLSchema/SPIRIT/1685-2009"), "singleShotOffset")) ~
      (IPXACT2009scalaxb.ElemName(Some("http://www.spiritconsortium.org/XMLSchema/SPIRIT/1685-2009"), "singleShotValue")) ~
      (IPXACT2009scalaxb.ElemName(Some("http://www.spiritconsortium.org/XMLSchema/SPIRIT/1685-2009"), "singleShotDuration")) ^^
      { case p1 ~ p2 ~ p3 =>
      SingleShotDriver(IPXACT2009scalaxb.fromXML[SingleShotOffset](p1, IPXACT2009scalaxb.ElemName(node) :: stack),
        IPXACT2009scalaxb.fromXML[SingleShotValue](p2, IPXACT2009scalaxb.ElemName(node) :: stack),
        IPXACT2009scalaxb.fromXML[SingleShotDuration](p3, IPXACT2009scalaxb.ElemName(node) :: stack)) })
    
    def writesChildNodes(__obj: SingleShotDriver, __scope: scala.xml.NamespaceBinding): Seq[scala.xml.Node] =
      Seq.concat(IPXACT2009scalaxb.toXML[SingleShotOffset](__obj.singleShotOffset, Some("http://www.spiritconsortium.org/XMLSchema/SPIRIT/1685-2009"), Some("singleShotOffset"), __scope, false),
        IPXACT2009scalaxb.toXML[SingleShotValue](__obj.singleShotValue, Some("http://www.spiritconsortium.org/XMLSchema/SPIRIT/1685-2009"), Some("singleShotValue"), __scope, false),
        IPXACT2009scalaxb.toXML[SingleShotDuration](__obj.singleShotDuration, Some("http://www.spiritconsortium.org/XMLSchema/SPIRIT/1685-2009"), Some("singleShotDuration"), __scope, false))

  }

  def build_DriverTypeTypeFormat = new Default_DriverTypeTypeFormat {}
  trait Default_DriverTypeTypeFormat extends IPXACT2009scalaxb.XMLFormat[DriverTypeType] {
    val targetNamespace: Option[String] = Some("http://www.spiritconsortium.org/XMLSchema/SPIRIT/1685-2009")
    
    def fromString(value: String, scope: scala.xml.NamespaceBinding): DriverTypeType =
        (fromString0(value, scope)).apply(IPXACT2009scalaxb.fromXML[String](scala.xml.Text(value)))

    private def fromString0(value: String, scope: scala.xml.NamespaceBinding): PartialFunction[Any, DriverTypeType] = {
      case x: String if x == IPXACT2009scalaxb.fromXML[String](scala.xml.Text("clock")) => Clock
      case x: String if x == IPXACT2009scalaxb.fromXML[String](scala.xml.Text("singleShot")) => SingleShot
      case x: String if x == IPXACT2009scalaxb.fromXML[String](scala.xml.Text("any")) => AnyType

    }



    def reads(seq: scala.xml.NodeSeq, stack: List[IPXACT2009scalaxb.ElemName]): Either[String, DriverTypeType] = seq match {
      case elem: scala.xml.Elem => Right(fromString(elem.text, elem.scope))
      case _ => Right(fromString(seq.text, scala.xml.TopScope))
    }
    
    def writes(__obj: DriverTypeType, __namespace: Option[String], __elementLabel: Option[String],
        __scope: scala.xml.NamespaceBinding, __typeAttribute: Boolean): scala.xml.NodeSeq =
      scala.xml.Elem(IPXACT2009scalaxb.Helper.getPrefix(__namespace, __scope).orNull,
        __elementLabel getOrElse { sys.error("missing element label.") },
        scala.xml.Null, __scope, true, scala.xml.Text(__obj.toString))
  }
  trait Default_RequiresDriverFormat extends IPXACT2009scalaxb.XMLFormat[RequiresDriver] with IPXACT2009scalaxb.CanWriteChildNodes[RequiresDriver] {
    val targetNamespace: Option[String] = Some("http://www.spiritconsortium.org/XMLSchema/SPIRIT/1685-2009")
    def reads(seq: scala.xml.NodeSeq, stack: List[IPXACT2009scalaxb.ElemName]): Either[String, RequiresDriver] = seq match {
      case node: scala.xml.Node => Right(RequiresDriver(IPXACT2009scalaxb.fromXML[Boolean](node, IPXACT2009scalaxb.ElemName(node) :: stack),
        scala.collection.immutable.ListMap(List(
        (node \ "@{http://www.spiritconsortium.org/XMLSchema/SPIRIT/1685-2009}driverType").headOption map { x => IPXACT2009scalaxb.DataRecord(x, node, IPXACT2009scalaxb.fromXML[DriverTypeType](x, IPXACT2009scalaxb.ElemName(node) :: stack)) } orElse Some(IPXACT2009scalaxb.DataRecord(None, None, IPXACT2009scalaxb.fromXML[DriverTypeType](scala.xml.Text("any"), IPXACT2009scalaxb.ElemName(node) :: stack))) map { "@driverType" -> _ }
        ).flatten[(String, IPXACT2009scalaxb.DataRecord[Any])]: _*)))
      case _ => Left("reads failed: seq must be scala.xml.Node")
    }
    
    override def writesAttribute(__obj: RequiresDriver, __scope: scala.xml.NamespaceBinding): scala.xml.MetaData = {
      var attr: scala.xml.MetaData  = scala.xml.Null
      __obj.attributes.toList map {
        case ("@driverType", _) => if (__obj.driverType.toString != "any") attr = scala.xml.Attribute(__scope.getPrefix("http://www.spiritconsortium.org/XMLSchema/SPIRIT/1685-2009"), "driverType", __obj.driverType.toString, attr)
        case (key, x) => attr = scala.xml.Attribute((x.namespace map { __scope.getPrefix(_) }).orNull, x.key.orNull, x.value.toString, attr)
      }
      attr
    }

    def writesChildNodes(__obj: RequiresDriver, __scope: scala.xml.NamespaceBinding): Seq[scala.xml.Node] =
      Seq(scala.xml.Text(__obj.value.toString))

  }

  trait Default_DriverTypeFormat extends IPXACT2009scalaxb.ElemNameParser[DriverType] {
    val targetNamespace: Option[String] = Some("http://www.spiritconsortium.org/XMLSchema/SPIRIT/1685-2009")
    
    override def typeName: Option[String] = Some("driverType")

    def parser(node: scala.xml.Node, stack: List[IPXACT2009scalaxb.ElemName]): Parser[DriverType] =
      phrase(opt(((IPXACT2009scalaxb.ElemName(Some("http://www.spiritconsortium.org/XMLSchema/SPIRIT/1685-2009"), "defaultValue")) ^^
      (x => IPXACT2009scalaxb.DataRecord(x.namespace, Some(x.name), IPXACT2009scalaxb.fromXML[DefaultValue](x, IPXACT2009scalaxb.ElemName(node) :: stack)))) |
      ((IPXACT2009scalaxb.ElemName(Some("http://www.spiritconsortium.org/XMLSchema/SPIRIT/1685-2009"), "clockDriver")) ^^
      (x => IPXACT2009scalaxb.DataRecord(x.namespace, Some(x.name), IPXACT2009scalaxb.fromXML[ClockDriver](x, IPXACT2009scalaxb.ElemName(node) :: stack)))) |
      ((IPXACT2009scalaxb.ElemName(Some("http://www.spiritconsortium.org/XMLSchema/SPIRIT/1685-2009"), "singleShotDriver")) ^^
      (x => IPXACT2009scalaxb.DataRecord(x.namespace, Some(x.name), IPXACT2009scalaxb.fromXML[SingleShotDriver](x, IPXACT2009scalaxb.ElemName(node) :: stack))))) ^^
      { case p1 =>
      DriverType(p1) })
    
    def writesChildNodes(__obj: DriverType, __scope: scala.xml.NamespaceBinding): Seq[scala.xml.Node] =
      (__obj.drivertypeoption map { x => IPXACT2009scalaxb.toXML[IPXACT2009scalaxb.DataRecord[DriverTypeOption]](x, x.namespace, x.key, __scope, false) } getOrElse {Nil})
  }

  trait Default_ClockPeriodFormat extends IPXACT2009scalaxb.XMLFormat[ClockPeriod] with IPXACT2009scalaxb.CanWriteChildNodes[ClockPeriod] {
    val targetNamespace: Option[String] = Some("http://www.spiritconsortium.org/XMLSchema/SPIRIT/1685-2009")
    def reads(seq: scala.xml.NodeSeq, stack: List[IPXACT2009scalaxb.ElemName]): Either[String, ClockPeriod] = seq match {
      case node: scala.xml.Node => Right(ClockPeriod(IPXACT2009scalaxb.fromXML[Seq[Double]](node, IPXACT2009scalaxb.ElemName(node) :: stack),
        scala.collection.immutable.ListMap(List(
        (node \ "@{http://www.spiritconsortium.org/XMLSchema/SPIRIT/1685-2009}units").headOption map { x => IPXACT2009scalaxb.DataRecord(x, node, IPXACT2009scalaxb.fromXML[DelayValueUnitType](x, IPXACT2009scalaxb.ElemName(node) :: stack)) } orElse Some(IPXACT2009scalaxb.DataRecord(None, None, IPXACT2009scalaxb.fromXML[DelayValueUnitType](scala.xml.Text("ns"), IPXACT2009scalaxb.ElemName(node) :: stack))) map { "@units" -> _ },
        (node \ "@{http://www.spiritconsortium.org/XMLSchema/SPIRIT/1685-2009}format").headOption map { x => IPXACT2009scalaxb.DataRecord(x, node, IPXACT2009scalaxb.fromXML[FormatType](x, IPXACT2009scalaxb.ElemName(node) :: stack)) } orElse Some(IPXACT2009scalaxb.DataRecord(None, None, IPXACT2009scalaxb.fromXML[FormatType](scala.xml.Text("float"), IPXACT2009scalaxb.ElemName(node) :: stack))) map { "@{http://www.spiritconsortium.org/XMLSchema/SPIRIT/1685-2009}format" -> _ },
        (node \ "@{http://www.spiritconsortium.org/XMLSchema/SPIRIT/1685-2009}resolve").headOption map { x => IPXACT2009scalaxb.DataRecord(x, node, IPXACT2009scalaxb.fromXML[ResolveType](x, IPXACT2009scalaxb.ElemName(node) :: stack)) } map { "@{http://www.spiritconsortium.org/XMLSchema/SPIRIT/1685-2009}resolve" -> _ },
        (node \ "@{http://www.spiritconsortium.org/XMLSchema/SPIRIT/1685-2009}id").headOption map { x => IPXACT2009scalaxb.DataRecord(x, node, IPXACT2009scalaxb.fromXML[String](x, IPXACT2009scalaxb.ElemName(node) :: stack)) } map { "@{http://www.spiritconsortium.org/XMLSchema/SPIRIT/1685-2009}id" -> _ },
        (node \ "@{http://www.spiritconsortium.org/XMLSchema/SPIRIT/1685-2009}dependency").headOption map { x => IPXACT2009scalaxb.DataRecord(x, node, IPXACT2009scalaxb.fromXML[String](x, IPXACT2009scalaxb.ElemName(node) :: stack)) } map { "@{http://www.spiritconsortium.org/XMLSchema/SPIRIT/1685-2009}dependency" -> _ },
        (node \ "@{http://www.spiritconsortium.org/XMLSchema/SPIRIT/1685-2009}choiceRef").headOption map { x => IPXACT2009scalaxb.DataRecord(x, node, IPXACT2009scalaxb.fromXML[String](x, IPXACT2009scalaxb.ElemName(node) :: stack)) } map { "@{http://www.spiritconsortium.org/XMLSchema/SPIRIT/1685-2009}choiceRef" -> _ },
        (node \ "@{http://www.spiritconsortium.org/XMLSchema/SPIRIT/1685-2009}order").headOption map { x => IPXACT2009scalaxb.DataRecord(x, node, IPXACT2009scalaxb.fromXML[Float](x, IPXACT2009scalaxb.ElemName(node) :: stack)) } map { "@{http://www.spiritconsortium.org/XMLSchema/SPIRIT/1685-2009}order" -> _ },
        (node \ "@{http://www.spiritconsortium.org/XMLSchema/SPIRIT/1685-2009}configGroups").headOption map { x => IPXACT2009scalaxb.DataRecord(x, node, IPXACT2009scalaxb.fromXML[Seq[String]](x, IPXACT2009scalaxb.ElemName(node) :: stack)) } map { "@{http://www.spiritconsortium.org/XMLSchema/SPIRIT/1685-2009}configGroups" -> _ },
        (node \ "@{http://www.spiritconsortium.org/XMLSchema/SPIRIT/1685-2009}bitStringLength").headOption map { x => IPXACT2009scalaxb.DataRecord(x, node, IPXACT2009scalaxb.fromXML[BigInt](x, IPXACT2009scalaxb.ElemName(node) :: stack)) } map { "@{http://www.spiritconsortium.org/XMLSchema/SPIRIT/1685-2009}bitStringLength" -> _ },
        (node \ "@{http://www.spiritconsortium.org/XMLSchema/SPIRIT/1685-2009}minimum").headOption map { x => IPXACT2009scalaxb.DataRecord(x, node, IPXACT2009scalaxb.fromXML[String](x, IPXACT2009scalaxb.ElemName(node) :: stack)) } map { "@{http://www.spiritconsortium.org/XMLSchema/SPIRIT/1685-2009}minimum" -> _ },
        (node \ "@{http://www.spiritconsortium.org/XMLSchema/SPIRIT/1685-2009}maximum").headOption map { x => IPXACT2009scalaxb.DataRecord(x, node, IPXACT2009scalaxb.fromXML[String](x, IPXACT2009scalaxb.ElemName(node) :: stack)) } map { "@{http://www.spiritconsortium.org/XMLSchema/SPIRIT/1685-2009}maximum" -> _ },
        (node \ "@{http://www.spiritconsortium.org/XMLSchema/SPIRIT/1685-2009}rangeType").headOption map { x => IPXACT2009scalaxb.DataRecord(x, node, IPXACT2009scalaxb.fromXML[RangeTypeType](x, IPXACT2009scalaxb.ElemName(node) :: stack)) } orElse Some(IPXACT2009scalaxb.DataRecord(None, None, IPXACT2009scalaxb.fromXML[RangeTypeType](scala.xml.Text("float"), IPXACT2009scalaxb.ElemName(node) :: stack))) map { "@{http://www.spiritconsortium.org/XMLSchema/SPIRIT/1685-2009}rangeType" -> _ },
        (node \ "@{http://www.spiritconsortium.org/XMLSchema/SPIRIT/1685-2009}prompt").headOption map { x => IPXACT2009scalaxb.DataRecord(x, node, IPXACT2009scalaxb.fromXML[String](x, IPXACT2009scalaxb.ElemName(node) :: stack)) } map { "@{http://www.spiritconsortium.org/XMLSchema/SPIRIT/1685-2009}prompt" -> _ }
        ).flatten[(String, IPXACT2009scalaxb.DataRecord[Any])] ::: (node match {
          case elem: scala.xml.Elem =>
            elem.attributes.toList flatMap {
              case scala.xml.PrefixedAttribute(pre, key, value, _) if pre == elem.scope.getPrefix("http://www.spiritconsortium.org/XMLSchema/SPIRIT/1685-2009") &&
                key == "units" => Nil
              case scala.xml.PrefixedAttribute(pre, key, value, _) if pre == elem.scope.getPrefix("http://www.spiritconsortium.org/XMLSchema/SPIRIT/1685-2009") &&
                key == "format" => Nil
              case scala.xml.PrefixedAttribute(pre, key, value, _) if pre == elem.scope.getPrefix("http://www.spiritconsortium.org/XMLSchema/SPIRIT/1685-2009") &&
                key == "resolve" => Nil
              case scala.xml.PrefixedAttribute(pre, key, value, _) if pre == elem.scope.getPrefix("http://www.spiritconsortium.org/XMLSchema/SPIRIT/1685-2009") &&
                key == "id" => Nil
              case scala.xml.PrefixedAttribute(pre, key, value, _) if pre == elem.scope.getPrefix("http://www.spiritconsortium.org/XMLSchema/SPIRIT/1685-2009") &&
                key == "dependency" => Nil
              case scala.xml.PrefixedAttribute(pre, key, value, _) if pre == elem.scope.getPrefix("http://www.spiritconsortium.org/XMLSchema/SPIRIT/1685-2009") &&
                key == "choiceRef" => Nil
              case scala.xml.PrefixedAttribute(pre, key, value, _) if pre == elem.scope.getPrefix("http://www.spiritconsortium.org/XMLSchema/SPIRIT/1685-2009") &&
                key == "order" => Nil
              case scala.xml.PrefixedAttribute(pre, key, value, _) if pre == elem.scope.getPrefix("http://www.spiritconsortium.org/XMLSchema/SPIRIT/1685-2009") &&
                key == "configGroups" => Nil
              case scala.xml.PrefixedAttribute(pre, key, value, _) if pre == elem.scope.getPrefix("http://www.spiritconsortium.org/XMLSchema/SPIRIT/1685-2009") &&
                key == "bitStringLength" => Nil
              case scala.xml.PrefixedAttribute(pre, key, value, _) if pre == elem.scope.getPrefix("http://www.spiritconsortium.org/XMLSchema/SPIRIT/1685-2009") &&
                key == "minimum" => Nil
              case scala.xml.PrefixedAttribute(pre, key, value, _) if pre == elem.scope.getPrefix("http://www.spiritconsortium.org/XMLSchema/SPIRIT/1685-2009") &&
                key == "maximum" => Nil
              case scala.xml.PrefixedAttribute(pre, key, value, _) if pre == elem.scope.getPrefix("http://www.spiritconsortium.org/XMLSchema/SPIRIT/1685-2009") &&
                key == "rangeType" => Nil
              case scala.xml.PrefixedAttribute(pre, key, value, _) if pre == elem.scope.getPrefix("http://www.spiritconsortium.org/XMLSchema/SPIRIT/1685-2009") &&
                key == "prompt" => Nil
              case scala.xml.UnprefixedAttribute(key, value, _) =>
                List(("@" + key, IPXACT2009scalaxb.DataRecord(None, Some(key), value.text)))
              case scala.xml.PrefixedAttribute(pre, key, value, _) =>
                val ns = elem.scope.getURI(pre)
                List(("@{" + ns + "}" + key, IPXACT2009scalaxb.DataRecord(Option[String](ns), Some(key), value.text)))
              case _ => Nil
            }
          case _ => Nil
        }): _*)))
      case _ => Left("reads failed: seq must be scala.xml.Node")
    }
    
    override def writesAttribute(__obj: ClockPeriod, __scope: scala.xml.NamespaceBinding): scala.xml.MetaData = {
      var attr: scala.xml.MetaData  = scala.xml.Null
      __obj.attributes.toList map {
        case ("@units", _) => if (__obj.units.toString != "ns") attr = scala.xml.Attribute(__scope.getPrefix("http://www.spiritconsortium.org/XMLSchema/SPIRIT/1685-2009"), "units", __obj.units.toString, attr)
        case ("@{http://www.spiritconsortium.org/XMLSchema/SPIRIT/1685-2009}format", _) => if (__obj.spiritformat.toString != "float") attr = scala.xml.Attribute(__scope.getPrefix("http://www.spiritconsortium.org/XMLSchema/SPIRIT/1685-2009"), "format", __obj.spiritformat.toString, attr)
        case ("@{http://www.spiritconsortium.org/XMLSchema/SPIRIT/1685-2009}resolve", _) => __obj.spiritresolve foreach { x => attr = scala.xml.Attribute(__scope.getPrefix("http://www.spiritconsortium.org/XMLSchema/SPIRIT/1685-2009"), "resolve", x.toString, attr) }
        case ("@{http://www.spiritconsortium.org/XMLSchema/SPIRIT/1685-2009}id", _) => __obj.spiritid foreach { x => attr = scala.xml.Attribute(__scope.getPrefix("http://www.spiritconsortium.org/XMLSchema/SPIRIT/1685-2009"), "id", x.toString, attr) }
        case ("@{http://www.spiritconsortium.org/XMLSchema/SPIRIT/1685-2009}dependency", _) => __obj.spiritdependency foreach { x => attr = scala.xml.Attribute(__scope.getPrefix("http://www.spiritconsortium.org/XMLSchema/SPIRIT/1685-2009"), "dependency", x.toString, attr) }
        case ("@{http://www.spiritconsortium.org/XMLSchema/SPIRIT/1685-2009}choiceRef", _) => __obj.spiritchoiceRef foreach { x => attr = scala.xml.Attribute(__scope.getPrefix("http://www.spiritconsortium.org/XMLSchema/SPIRIT/1685-2009"), "choiceRef", x.toString, attr) }
        case ("@{http://www.spiritconsortium.org/XMLSchema/SPIRIT/1685-2009}order", _) => __obj.spiritorder foreach { x => attr = scala.xml.Attribute(__scope.getPrefix("http://www.spiritconsortium.org/XMLSchema/SPIRIT/1685-2009"), "order", x.toString, attr) }
        case ("@{http://www.spiritconsortium.org/XMLSchema/SPIRIT/1685-2009}configGroups", _) => __obj.spiritconfigGroups foreach { x => attr = scala.xml.Attribute(__scope.getPrefix("http://www.spiritconsortium.org/XMLSchema/SPIRIT/1685-2009"), "configGroups", x.toString, attr) }
        case ("@{http://www.spiritconsortium.org/XMLSchema/SPIRIT/1685-2009}bitStringLength", _) => __obj.spiritbitStringLength foreach { x => attr = scala.xml.Attribute(__scope.getPrefix("http://www.spiritconsortium.org/XMLSchema/SPIRIT/1685-2009"), "bitStringLength", x.toString, attr) }
        case ("@{http://www.spiritconsortium.org/XMLSchema/SPIRIT/1685-2009}minimum", _) => __obj.spiritminimum foreach { x => attr = scala.xml.Attribute(__scope.getPrefix("http://www.spiritconsortium.org/XMLSchema/SPIRIT/1685-2009"), "minimum", x.toString, attr) }
        case ("@{http://www.spiritconsortium.org/XMLSchema/SPIRIT/1685-2009}maximum", _) => __obj.spiritmaximum foreach { x => attr = scala.xml.Attribute(__scope.getPrefix("http://www.spiritconsortium.org/XMLSchema/SPIRIT/1685-2009"), "maximum", x.toString, attr) }
        case ("@{http://www.spiritconsortium.org/XMLSchema/SPIRIT/1685-2009}rangeType", _) => if (__obj.spiritrangeType.toString != "float") attr = scala.xml.Attribute(__scope.getPrefix("http://www.spiritconsortium.org/XMLSchema/SPIRIT/1685-2009"), "rangeType", __obj.spiritrangeType.toString, attr)
        case ("@{http://www.spiritconsortium.org/XMLSchema/SPIRIT/1685-2009}prompt", _) => __obj.spiritprompt foreach { x => attr = scala.xml.Attribute(__scope.getPrefix("http://www.spiritconsortium.org/XMLSchema/SPIRIT/1685-2009"), "prompt", x.toString, attr) }
        case (key, x) => attr = scala.xml.Attribute((x.namespace map { __scope.getPrefix(_) }).orNull, x.key.orNull, x.value.toString, attr)
      }
      attr
    }

    def writesChildNodes(__obj: ClockPeriod, __scope: scala.xml.NamespaceBinding): Seq[scala.xml.Node] =
      Seq(scala.xml.Text(__obj.value.toString))

  }

  trait Default_ClockPulseOffsetFormat extends IPXACT2009scalaxb.XMLFormat[ClockPulseOffset] with IPXACT2009scalaxb.CanWriteChildNodes[ClockPulseOffset] {
    val targetNamespace: Option[String] = Some("http://www.spiritconsortium.org/XMLSchema/SPIRIT/1685-2009")
    def reads(seq: scala.xml.NodeSeq, stack: List[IPXACT2009scalaxb.ElemName]): Either[String, ClockPulseOffset] = seq match {
      case node: scala.xml.Node => Right(ClockPulseOffset(IPXACT2009scalaxb.fromXML[Seq[Double]](node, IPXACT2009scalaxb.ElemName(node) :: stack),
        scala.collection.immutable.ListMap(List(
        (node \ "@{http://www.spiritconsortium.org/XMLSchema/SPIRIT/1685-2009}units").headOption map { x => IPXACT2009scalaxb.DataRecord(x, node, IPXACT2009scalaxb.fromXML[DelayValueUnitType](x, IPXACT2009scalaxb.ElemName(node) :: stack)) } orElse Some(IPXACT2009scalaxb.DataRecord(None, None, IPXACT2009scalaxb.fromXML[DelayValueUnitType](scala.xml.Text("ns"), IPXACT2009scalaxb.ElemName(node) :: stack))) map { "@units" -> _ },
        (node \ "@{http://www.spiritconsortium.org/XMLSchema/SPIRIT/1685-2009}format").headOption map { x => IPXACT2009scalaxb.DataRecord(x, node, IPXACT2009scalaxb.fromXML[FormatType](x, IPXACT2009scalaxb.ElemName(node) :: stack)) } orElse Some(IPXACT2009scalaxb.DataRecord(None, None, IPXACT2009scalaxb.fromXML[FormatType](scala.xml.Text("float"), IPXACT2009scalaxb.ElemName(node) :: stack))) map { "@{http://www.spiritconsortium.org/XMLSchema/SPIRIT/1685-2009}format" -> _ },
        (node \ "@{http://www.spiritconsortium.org/XMLSchema/SPIRIT/1685-2009}resolve").headOption map { x => IPXACT2009scalaxb.DataRecord(x, node, IPXACT2009scalaxb.fromXML[ResolveType](x, IPXACT2009scalaxb.ElemName(node) :: stack)) } map { "@{http://www.spiritconsortium.org/XMLSchema/SPIRIT/1685-2009}resolve" -> _ },
        (node \ "@{http://www.spiritconsortium.org/XMLSchema/SPIRIT/1685-2009}id").headOption map { x => IPXACT2009scalaxb.DataRecord(x, node, IPXACT2009scalaxb.fromXML[String](x, IPXACT2009scalaxb.ElemName(node) :: stack)) } map { "@{http://www.spiritconsortium.org/XMLSchema/SPIRIT/1685-2009}id" -> _ },
        (node \ "@{http://www.spiritconsortium.org/XMLSchema/SPIRIT/1685-2009}dependency").headOption map { x => IPXACT2009scalaxb.DataRecord(x, node, IPXACT2009scalaxb.fromXML[String](x, IPXACT2009scalaxb.ElemName(node) :: stack)) } map { "@{http://www.spiritconsortium.org/XMLSchema/SPIRIT/1685-2009}dependency" -> _ },
        (node \ "@{http://www.spiritconsortium.org/XMLSchema/SPIRIT/1685-2009}choiceRef").headOption map { x => IPXACT2009scalaxb.DataRecord(x, node, IPXACT2009scalaxb.fromXML[String](x, IPXACT2009scalaxb.ElemName(node) :: stack)) } map { "@{http://www.spiritconsortium.org/XMLSchema/SPIRIT/1685-2009}choiceRef" -> _ },
        (node \ "@{http://www.spiritconsortium.org/XMLSchema/SPIRIT/1685-2009}order").headOption map { x => IPXACT2009scalaxb.DataRecord(x, node, IPXACT2009scalaxb.fromXML[Float](x, IPXACT2009scalaxb.ElemName(node) :: stack)) } map { "@{http://www.spiritconsortium.org/XMLSchema/SPIRIT/1685-2009}order" -> _ },
        (node \ "@{http://www.spiritconsortium.org/XMLSchema/SPIRIT/1685-2009}configGroups").headOption map { x => IPXACT2009scalaxb.DataRecord(x, node, IPXACT2009scalaxb.fromXML[Seq[String]](x, IPXACT2009scalaxb.ElemName(node) :: stack)) } map { "@{http://www.spiritconsortium.org/XMLSchema/SPIRIT/1685-2009}configGroups" -> _ },
        (node \ "@{http://www.spiritconsortium.org/XMLSchema/SPIRIT/1685-2009}bitStringLength").headOption map { x => IPXACT2009scalaxb.DataRecord(x, node, IPXACT2009scalaxb.fromXML[BigInt](x, IPXACT2009scalaxb.ElemName(node) :: stack)) } map { "@{http://www.spiritconsortium.org/XMLSchema/SPIRIT/1685-2009}bitStringLength" -> _ },
        (node \ "@{http://www.spiritconsortium.org/XMLSchema/SPIRIT/1685-2009}minimum").headOption map { x => IPXACT2009scalaxb.DataRecord(x, node, IPXACT2009scalaxb.fromXML[String](x, IPXACT2009scalaxb.ElemName(node) :: stack)) } map { "@{http://www.spiritconsortium.org/XMLSchema/SPIRIT/1685-2009}minimum" -> _ },
        (node \ "@{http://www.spiritconsortium.org/XMLSchema/SPIRIT/1685-2009}maximum").headOption map { x => IPXACT2009scalaxb.DataRecord(x, node, IPXACT2009scalaxb.fromXML[String](x, IPXACT2009scalaxb.ElemName(node) :: stack)) } map { "@{http://www.spiritconsortium.org/XMLSchema/SPIRIT/1685-2009}maximum" -> _ },
        (node \ "@{http://www.spiritconsortium.org/XMLSchema/SPIRIT/1685-2009}rangeType").headOption map { x => IPXACT2009scalaxb.DataRecord(x, node, IPXACT2009scalaxb.fromXML[RangeTypeType](x, IPXACT2009scalaxb.ElemName(node) :: stack)) } orElse Some(IPXACT2009scalaxb.DataRecord(None, None, IPXACT2009scalaxb.fromXML[RangeTypeType](scala.xml.Text("float"), IPXACT2009scalaxb.ElemName(node) :: stack))) map { "@{http://www.spiritconsortium.org/XMLSchema/SPIRIT/1685-2009}rangeType" -> _ },
        (node \ "@{http://www.spiritconsortium.org/XMLSchema/SPIRIT/1685-2009}prompt").headOption map { x => IPXACT2009scalaxb.DataRecord(x, node, IPXACT2009scalaxb.fromXML[String](x, IPXACT2009scalaxb.ElemName(node) :: stack)) } map { "@{http://www.spiritconsortium.org/XMLSchema/SPIRIT/1685-2009}prompt" -> _ }
        ).flatten[(String, IPXACT2009scalaxb.DataRecord[Any])] ::: (node match {
          case elem: scala.xml.Elem =>
            elem.attributes.toList flatMap {
              case scala.xml.PrefixedAttribute(pre, key, value, _) if pre == elem.scope.getPrefix("http://www.spiritconsortium.org/XMLSchema/SPIRIT/1685-2009") &&
                key == "units" => Nil
              case scala.xml.PrefixedAttribute(pre, key, value, _) if pre == elem.scope.getPrefix("http://www.spiritconsortium.org/XMLSchema/SPIRIT/1685-2009") &&
                key == "format" => Nil
              case scala.xml.PrefixedAttribute(pre, key, value, _) if pre == elem.scope.getPrefix("http://www.spiritconsortium.org/XMLSchema/SPIRIT/1685-2009") &&
                key == "resolve" => Nil
              case scala.xml.PrefixedAttribute(pre, key, value, _) if pre == elem.scope.getPrefix("http://www.spiritconsortium.org/XMLSchema/SPIRIT/1685-2009") &&
                key == "id" => Nil
              case scala.xml.PrefixedAttribute(pre, key, value, _) if pre == elem.scope.getPrefix("http://www.spiritconsortium.org/XMLSchema/SPIRIT/1685-2009") &&
                key == "dependency" => Nil
              case scala.xml.PrefixedAttribute(pre, key, value, _) if pre == elem.scope.getPrefix("http://www.spiritconsortium.org/XMLSchema/SPIRIT/1685-2009") &&
                key == "choiceRef" => Nil
              case scala.xml.PrefixedAttribute(pre, key, value, _) if pre == elem.scope.getPrefix("http://www.spiritconsortium.org/XMLSchema/SPIRIT/1685-2009") &&
                key == "order" => Nil
              case scala.xml.PrefixedAttribute(pre, key, value, _) if pre == elem.scope.getPrefix("http://www.spiritconsortium.org/XMLSchema/SPIRIT/1685-2009") &&
                key == "configGroups" => Nil
              case scala.xml.PrefixedAttribute(pre, key, value, _) if pre == elem.scope.getPrefix("http://www.spiritconsortium.org/XMLSchema/SPIRIT/1685-2009") &&
                key == "bitStringLength" => Nil
              case scala.xml.PrefixedAttribute(pre, key, value, _) if pre == elem.scope.getPrefix("http://www.spiritconsortium.org/XMLSchema/SPIRIT/1685-2009") &&
                key == "minimum" => Nil
              case scala.xml.PrefixedAttribute(pre, key, value, _) if pre == elem.scope.getPrefix("http://www.spiritconsortium.org/XMLSchema/SPIRIT/1685-2009") &&
                key == "maximum" => Nil
              case scala.xml.PrefixedAttribute(pre, key, value, _) if pre == elem.scope.getPrefix("http://www.spiritconsortium.org/XMLSchema/SPIRIT/1685-2009") &&
                key == "rangeType" => Nil
              case scala.xml.PrefixedAttribute(pre, key, value, _) if pre == elem.scope.getPrefix("http://www.spiritconsortium.org/XMLSchema/SPIRIT/1685-2009") &&
                key == "prompt" => Nil
              case scala.xml.UnprefixedAttribute(key, value, _) =>
                List(("@" + key, IPXACT2009scalaxb.DataRecord(None, Some(key), value.text)))
              case scala.xml.PrefixedAttribute(pre, key, value, _) =>
                val ns = elem.scope.getURI(pre)
                List(("@{" + ns + "}" + key, IPXACT2009scalaxb.DataRecord(Option[String](ns), Some(key), value.text)))
              case _ => Nil
            }
          case _ => Nil
        }): _*)))
      case _ => Left("reads failed: seq must be scala.xml.Node")
    }
    
    override def writesAttribute(__obj: ClockPulseOffset, __scope: scala.xml.NamespaceBinding): scala.xml.MetaData = {
      var attr: scala.xml.MetaData  = scala.xml.Null
      __obj.attributes.toList map {
        case ("@units", _) => if (__obj.units.toString != "ns") attr = scala.xml.Attribute(__scope.getPrefix("http://www.spiritconsortium.org/XMLSchema/SPIRIT/1685-2009"), "units", __obj.units.toString, attr)
        case ("@{http://www.spiritconsortium.org/XMLSchema/SPIRIT/1685-2009}format", _) => if (__obj.spiritformat.toString != "float") attr = scala.xml.Attribute(__scope.getPrefix("http://www.spiritconsortium.org/XMLSchema/SPIRIT/1685-2009"), "format", __obj.spiritformat.toString, attr)
        case ("@{http://www.spiritconsortium.org/XMLSchema/SPIRIT/1685-2009}resolve", _) => __obj.spiritresolve foreach { x => attr = scala.xml.Attribute(__scope.getPrefix("http://www.spiritconsortium.org/XMLSchema/SPIRIT/1685-2009"), "resolve", x.toString, attr) }
        case ("@{http://www.spiritconsortium.org/XMLSchema/SPIRIT/1685-2009}id", _) => __obj.spiritid foreach { x => attr = scala.xml.Attribute(__scope.getPrefix("http://www.spiritconsortium.org/XMLSchema/SPIRIT/1685-2009"), "id", x.toString, attr) }
        case ("@{http://www.spiritconsortium.org/XMLSchema/SPIRIT/1685-2009}dependency", _) => __obj.spiritdependency foreach { x => attr = scala.xml.Attribute(__scope.getPrefix("http://www.spiritconsortium.org/XMLSchema/SPIRIT/1685-2009"), "dependency", x.toString, attr) }
        case ("@{http://www.spiritconsortium.org/XMLSchema/SPIRIT/1685-2009}choiceRef", _) => __obj.spiritchoiceRef foreach { x => attr = scala.xml.Attribute(__scope.getPrefix("http://www.spiritconsortium.org/XMLSchema/SPIRIT/1685-2009"), "choiceRef", x.toString, attr) }
        case ("@{http://www.spiritconsortium.org/XMLSchema/SPIRIT/1685-2009}order", _) => __obj.spiritorder foreach { x => attr = scala.xml.Attribute(__scope.getPrefix("http://www.spiritconsortium.org/XMLSchema/SPIRIT/1685-2009"), "order", x.toString, attr) }
        case ("@{http://www.spiritconsortium.org/XMLSchema/SPIRIT/1685-2009}configGroups", _) => __obj.spiritconfigGroups foreach { x => attr = scala.xml.Attribute(__scope.getPrefix("http://www.spiritconsortium.org/XMLSchema/SPIRIT/1685-2009"), "configGroups", x.toString, attr) }
        case ("@{http://www.spiritconsortium.org/XMLSchema/SPIRIT/1685-2009}bitStringLength", _) => __obj.spiritbitStringLength foreach { x => attr = scala.xml.Attribute(__scope.getPrefix("http://www.spiritconsortium.org/XMLSchema/SPIRIT/1685-2009"), "bitStringLength", x.toString, attr) }
        case ("@{http://www.spiritconsortium.org/XMLSchema/SPIRIT/1685-2009}minimum", _) => __obj.spiritminimum foreach { x => attr = scala.xml.Attribute(__scope.getPrefix("http://www.spiritconsortium.org/XMLSchema/SPIRIT/1685-2009"), "minimum", x.toString, attr) }
        case ("@{http://www.spiritconsortium.org/XMLSchema/SPIRIT/1685-2009}maximum", _) => __obj.spiritmaximum foreach { x => attr = scala.xml.Attribute(__scope.getPrefix("http://www.spiritconsortium.org/XMLSchema/SPIRIT/1685-2009"), "maximum", x.toString, attr) }
        case ("@{http://www.spiritconsortium.org/XMLSchema/SPIRIT/1685-2009}rangeType", _) => if (__obj.spiritrangeType.toString != "float") attr = scala.xml.Attribute(__scope.getPrefix("http://www.spiritconsortium.org/XMLSchema/SPIRIT/1685-2009"), "rangeType", __obj.spiritrangeType.toString, attr)
        case ("@{http://www.spiritconsortium.org/XMLSchema/SPIRIT/1685-2009}prompt", _) => __obj.spiritprompt foreach { x => attr = scala.xml.Attribute(__scope.getPrefix("http://www.spiritconsortium.org/XMLSchema/SPIRIT/1685-2009"), "prompt", x.toString, attr) }
        case (key, x) => attr = scala.xml.Attribute((x.namespace map { __scope.getPrefix(_) }).orNull, x.key.orNull, x.value.toString, attr)
      }
      attr
    }

    def writesChildNodes(__obj: ClockPulseOffset, __scope: scala.xml.NamespaceBinding): Seq[scala.xml.Node] =
      Seq(scala.xml.Text(__obj.value.toString))

  }

  trait Default_ClockPulseValueFormat extends IPXACT2009scalaxb.XMLFormat[ClockPulseValue] with IPXACT2009scalaxb.CanWriteChildNodes[ClockPulseValue] {
    val targetNamespace: Option[String] = Some("http://www.spiritconsortium.org/XMLSchema/SPIRIT/1685-2009")
    def reads(seq: scala.xml.NodeSeq, stack: List[IPXACT2009scalaxb.ElemName]): Either[String, ClockPulseValue] = seq match {
      case node: scala.xml.Node => Right(ClockPulseValue(IPXACT2009scalaxb.fromXML[String](node, IPXACT2009scalaxb.ElemName(node) :: stack),
        scala.collection.immutable.ListMap(List(
        (node \ "@{http://www.spiritconsortium.org/XMLSchema/SPIRIT/1685-2009}format").headOption map { x => IPXACT2009scalaxb.DataRecord(x, node, IPXACT2009scalaxb.fromXML[FormatType](x, IPXACT2009scalaxb.ElemName(node) :: stack)) } orElse Some(IPXACT2009scalaxb.DataRecord(None, None, IPXACT2009scalaxb.fromXML[FormatType](scala.xml.Text("long"), IPXACT2009scalaxb.ElemName(node) :: stack))) map { "@{http://www.spiritconsortium.org/XMLSchema/SPIRIT/1685-2009}format" -> _ },
        (node \ "@{http://www.spiritconsortium.org/XMLSchema/SPIRIT/1685-2009}resolve").headOption map { x => IPXACT2009scalaxb.DataRecord(x, node, IPXACT2009scalaxb.fromXML[ResolveType](x, IPXACT2009scalaxb.ElemName(node) :: stack)) } map { "@{http://www.spiritconsortium.org/XMLSchema/SPIRIT/1685-2009}resolve" -> _ },
        (node \ "@{http://www.spiritconsortium.org/XMLSchema/SPIRIT/1685-2009}id").headOption map { x => IPXACT2009scalaxb.DataRecord(x, node, IPXACT2009scalaxb.fromXML[String](x, IPXACT2009scalaxb.ElemName(node) :: stack)) } map { "@{http://www.spiritconsortium.org/XMLSchema/SPIRIT/1685-2009}id" -> _ },
        (node \ "@{http://www.spiritconsortium.org/XMLSchema/SPIRIT/1685-2009}dependency").headOption map { x => IPXACT2009scalaxb.DataRecord(x, node, IPXACT2009scalaxb.fromXML[String](x, IPXACT2009scalaxb.ElemName(node) :: stack)) } map { "@{http://www.spiritconsortium.org/XMLSchema/SPIRIT/1685-2009}dependency" -> _ },
        (node \ "@{http://www.spiritconsortium.org/XMLSchema/SPIRIT/1685-2009}choiceRef").headOption map { x => IPXACT2009scalaxb.DataRecord(x, node, IPXACT2009scalaxb.fromXML[String](x, IPXACT2009scalaxb.ElemName(node) :: stack)) } map { "@{http://www.spiritconsortium.org/XMLSchema/SPIRIT/1685-2009}choiceRef" -> _ },
        (node \ "@{http://www.spiritconsortium.org/XMLSchema/SPIRIT/1685-2009}order").headOption map { x => IPXACT2009scalaxb.DataRecord(x, node, IPXACT2009scalaxb.fromXML[Float](x, IPXACT2009scalaxb.ElemName(node) :: stack)) } map { "@{http://www.spiritconsortium.org/XMLSchema/SPIRIT/1685-2009}order" -> _ },
        (node \ "@{http://www.spiritconsortium.org/XMLSchema/SPIRIT/1685-2009}configGroups").headOption map { x => IPXACT2009scalaxb.DataRecord(x, node, IPXACT2009scalaxb.fromXML[Seq[String]](x, IPXACT2009scalaxb.ElemName(node) :: stack)) } map { "@{http://www.spiritconsortium.org/XMLSchema/SPIRIT/1685-2009}configGroups" -> _ },
        (node \ "@{http://www.spiritconsortium.org/XMLSchema/SPIRIT/1685-2009}bitStringLength").headOption map { x => IPXACT2009scalaxb.DataRecord(x, node, IPXACT2009scalaxb.fromXML[BigInt](x, IPXACT2009scalaxb.ElemName(node) :: stack)) } map { "@{http://www.spiritconsortium.org/XMLSchema/SPIRIT/1685-2009}bitStringLength" -> _ },
        (node \ "@{http://www.spiritconsortium.org/XMLSchema/SPIRIT/1685-2009}minimum").headOption map { x => IPXACT2009scalaxb.DataRecord(x, node, IPXACT2009scalaxb.fromXML[String](x, IPXACT2009scalaxb.ElemName(node) :: stack)) } map { "@{http://www.spiritconsortium.org/XMLSchema/SPIRIT/1685-2009}minimum" -> _ },
        (node \ "@{http://www.spiritconsortium.org/XMLSchema/SPIRIT/1685-2009}maximum").headOption map { x => IPXACT2009scalaxb.DataRecord(x, node, IPXACT2009scalaxb.fromXML[String](x, IPXACT2009scalaxb.ElemName(node) :: stack)) } map { "@{http://www.spiritconsortium.org/XMLSchema/SPIRIT/1685-2009}maximum" -> _ },
        (node \ "@{http://www.spiritconsortium.org/XMLSchema/SPIRIT/1685-2009}rangeType").headOption map { x => IPXACT2009scalaxb.DataRecord(x, node, IPXACT2009scalaxb.fromXML[RangeTypeType](x, IPXACT2009scalaxb.ElemName(node) :: stack)) } orElse Some(IPXACT2009scalaxb.DataRecord(None, None, IPXACT2009scalaxb.fromXML[RangeTypeType](scala.xml.Text("float"), IPXACT2009scalaxb.ElemName(node) :: stack))) map { "@{http://www.spiritconsortium.org/XMLSchema/SPIRIT/1685-2009}rangeType" -> _ },
        (node \ "@{http://www.spiritconsortium.org/XMLSchema/SPIRIT/1685-2009}prompt").headOption map { x => IPXACT2009scalaxb.DataRecord(x, node, IPXACT2009scalaxb.fromXML[String](x, IPXACT2009scalaxb.ElemName(node) :: stack)) } map { "@{http://www.spiritconsortium.org/XMLSchema/SPIRIT/1685-2009}prompt" -> _ }
        ).flatten[(String, IPXACT2009scalaxb.DataRecord[Any])] ::: (node match {
          case elem: scala.xml.Elem =>
            elem.attributes.toList flatMap {
              case scala.xml.PrefixedAttribute(pre, key, value, _) if pre == elem.scope.getPrefix("http://www.spiritconsortium.org/XMLSchema/SPIRIT/1685-2009") &&
                key == "format" => Nil
              case scala.xml.PrefixedAttribute(pre, key, value, _) if pre == elem.scope.getPrefix("http://www.spiritconsortium.org/XMLSchema/SPIRIT/1685-2009") &&
                key == "resolve" => Nil
              case scala.xml.PrefixedAttribute(pre, key, value, _) if pre == elem.scope.getPrefix("http://www.spiritconsortium.org/XMLSchema/SPIRIT/1685-2009") &&
                key == "id" => Nil
              case scala.xml.PrefixedAttribute(pre, key, value, _) if pre == elem.scope.getPrefix("http://www.spiritconsortium.org/XMLSchema/SPIRIT/1685-2009") &&
                key == "dependency" => Nil
              case scala.xml.PrefixedAttribute(pre, key, value, _) if pre == elem.scope.getPrefix("http://www.spiritconsortium.org/XMLSchema/SPIRIT/1685-2009") &&
                key == "choiceRef" => Nil
              case scala.xml.PrefixedAttribute(pre, key, value, _) if pre == elem.scope.getPrefix("http://www.spiritconsortium.org/XMLSchema/SPIRIT/1685-2009") &&
                key == "order" => Nil
              case scala.xml.PrefixedAttribute(pre, key, value, _) if pre == elem.scope.getPrefix("http://www.spiritconsortium.org/XMLSchema/SPIRIT/1685-2009") &&
                key == "configGroups" => Nil
              case scala.xml.PrefixedAttribute(pre, key, value, _) if pre == elem.scope.getPrefix("http://www.spiritconsortium.org/XMLSchema/SPIRIT/1685-2009") &&
                key == "bitStringLength" => Nil
              case scala.xml.PrefixedAttribute(pre, key, value, _) if pre == elem.scope.getPrefix("http://www.spiritconsortium.org/XMLSchema/SPIRIT/1685-2009") &&
                key == "minimum" => Nil
              case scala.xml.PrefixedAttribute(pre, key, value, _) if pre == elem.scope.getPrefix("http://www.spiritconsortium.org/XMLSchema/SPIRIT/1685-2009") &&
                key == "maximum" => Nil
              case scala.xml.PrefixedAttribute(pre, key, value, _) if pre == elem.scope.getPrefix("http://www.spiritconsortium.org/XMLSchema/SPIRIT/1685-2009") &&
                key == "rangeType" => Nil
              case scala.xml.PrefixedAttribute(pre, key, value, _) if pre == elem.scope.getPrefix("http://www.spiritconsortium.org/XMLSchema/SPIRIT/1685-2009") &&
                key == "prompt" => Nil
              case scala.xml.UnprefixedAttribute(key, value, _) =>
                List(("@" + key, IPXACT2009scalaxb.DataRecord(None, Some(key), value.text)))
              case scala.xml.PrefixedAttribute(pre, key, value, _) =>
                val ns = elem.scope.getURI(pre)
                List(("@{" + ns + "}" + key, IPXACT2009scalaxb.DataRecord(Option[String](ns), Some(key), value.text)))
              case _ => Nil
            }
          case _ => Nil
        }): _*)))
      case _ => Left("reads failed: seq must be scala.xml.Node")
    }
    
    override def writesAttribute(__obj: ClockPulseValue, __scope: scala.xml.NamespaceBinding): scala.xml.MetaData = {
      var attr: scala.xml.MetaData  = scala.xml.Null
      __obj.attributes.toList map {
        case ("@{http://www.spiritconsortium.org/XMLSchema/SPIRIT/1685-2009}format", _) => if (__obj.spiritformat.toString != "long") attr = scala.xml.Attribute(__scope.getPrefix("http://www.spiritconsortium.org/XMLSchema/SPIRIT/1685-2009"), "format", __obj.spiritformat.toString, attr)
        case ("@{http://www.spiritconsortium.org/XMLSchema/SPIRIT/1685-2009}resolve", _) => __obj.spiritresolve foreach { x => attr = scala.xml.Attribute(__scope.getPrefix("http://www.spiritconsortium.org/XMLSchema/SPIRIT/1685-2009"), "resolve", x.toString, attr) }
        case ("@{http://www.spiritconsortium.org/XMLSchema/SPIRIT/1685-2009}id", _) => __obj.spiritid foreach { x => attr = scala.xml.Attribute(__scope.getPrefix("http://www.spiritconsortium.org/XMLSchema/SPIRIT/1685-2009"), "id", x.toString, attr) }
        case ("@{http://www.spiritconsortium.org/XMLSchema/SPIRIT/1685-2009}dependency", _) => __obj.spiritdependency foreach { x => attr = scala.xml.Attribute(__scope.getPrefix("http://www.spiritconsortium.org/XMLSchema/SPIRIT/1685-2009"), "dependency", x.toString, attr) }
        case ("@{http://www.spiritconsortium.org/XMLSchema/SPIRIT/1685-2009}choiceRef", _) => __obj.spiritchoiceRef foreach { x => attr = scala.xml.Attribute(__scope.getPrefix("http://www.spiritconsortium.org/XMLSchema/SPIRIT/1685-2009"), "choiceRef", x.toString, attr) }
        case ("@{http://www.spiritconsortium.org/XMLSchema/SPIRIT/1685-2009}order", _) => __obj.spiritorder foreach { x => attr = scala.xml.Attribute(__scope.getPrefix("http://www.spiritconsortium.org/XMLSchema/SPIRIT/1685-2009"), "order", x.toString, attr) }
        case ("@{http://www.spiritconsortium.org/XMLSchema/SPIRIT/1685-2009}configGroups", _) => __obj.spiritconfigGroups foreach { x => attr = scala.xml.Attribute(__scope.getPrefix("http://www.spiritconsortium.org/XMLSchema/SPIRIT/1685-2009"), "configGroups", x.toString, attr) }
        case ("@{http://www.spiritconsortium.org/XMLSchema/SPIRIT/1685-2009}bitStringLength", _) => __obj.spiritbitStringLength foreach { x => attr = scala.xml.Attribute(__scope.getPrefix("http://www.spiritconsortium.org/XMLSchema/SPIRIT/1685-2009"), "bitStringLength", x.toString, attr) }
        case ("@{http://www.spiritconsortium.org/XMLSchema/SPIRIT/1685-2009}minimum", _) => __obj.spiritminimum foreach { x => attr = scala.xml.Attribute(__scope.getPrefix("http://www.spiritconsortium.org/XMLSchema/SPIRIT/1685-2009"), "minimum", x.toString, attr) }
        case ("@{http://www.spiritconsortium.org/XMLSchema/SPIRIT/1685-2009}maximum", _) => __obj.spiritmaximum foreach { x => attr = scala.xml.Attribute(__scope.getPrefix("http://www.spiritconsortium.org/XMLSchema/SPIRIT/1685-2009"), "maximum", x.toString, attr) }
        case ("@{http://www.spiritconsortium.org/XMLSchema/SPIRIT/1685-2009}rangeType", _) => if (__obj.spiritrangeType.toString != "float") attr = scala.xml.Attribute(__scope.getPrefix("http://www.spiritconsortium.org/XMLSchema/SPIRIT/1685-2009"), "rangeType", __obj.spiritrangeType.toString, attr)
        case ("@{http://www.spiritconsortium.org/XMLSchema/SPIRIT/1685-2009}prompt", _) => __obj.spiritprompt foreach { x => attr = scala.xml.Attribute(__scope.getPrefix("http://www.spiritconsortium.org/XMLSchema/SPIRIT/1685-2009"), "prompt", x.toString, attr) }
        case (key, x) => attr = scala.xml.Attribute((x.namespace map { __scope.getPrefix(_) }).orNull, x.key.orNull, x.value.toString, attr)
      }
      attr
    }

    def writesChildNodes(__obj: ClockPulseValue, __scope: scala.xml.NamespaceBinding): Seq[scala.xml.Node] =
      Seq(scala.xml.Text(__obj.value.toString))

  }

  trait Default_ClockPulseDurationFormat extends IPXACT2009scalaxb.XMLFormat[ClockPulseDuration] with IPXACT2009scalaxb.CanWriteChildNodes[ClockPulseDuration] {
    val targetNamespace: Option[String] = Some("http://www.spiritconsortium.org/XMLSchema/SPIRIT/1685-2009")
    def reads(seq: scala.xml.NodeSeq, stack: List[IPXACT2009scalaxb.ElemName]): Either[String, ClockPulseDuration] = seq match {
      case node: scala.xml.Node => Right(ClockPulseDuration(IPXACT2009scalaxb.fromXML[Seq[Double]](node, IPXACT2009scalaxb.ElemName(node) :: stack),
        scala.collection.immutable.ListMap(List(
        (node \ "@{http://www.spiritconsortium.org/XMLSchema/SPIRIT/1685-2009}units").headOption map { x => IPXACT2009scalaxb.DataRecord(x, node, IPXACT2009scalaxb.fromXML[DelayValueUnitType](x, IPXACT2009scalaxb.ElemName(node) :: stack)) } orElse Some(IPXACT2009scalaxb.DataRecord(None, None, IPXACT2009scalaxb.fromXML[DelayValueUnitType](scala.xml.Text("ns"), IPXACT2009scalaxb.ElemName(node) :: stack))) map { "@units" -> _ },
        (node \ "@{http://www.spiritconsortium.org/XMLSchema/SPIRIT/1685-2009}format").headOption map { x => IPXACT2009scalaxb.DataRecord(x, node, IPXACT2009scalaxb.fromXML[FormatType](x, IPXACT2009scalaxb.ElemName(node) :: stack)) } orElse Some(IPXACT2009scalaxb.DataRecord(None, None, IPXACT2009scalaxb.fromXML[FormatType](scala.xml.Text("float"), IPXACT2009scalaxb.ElemName(node) :: stack))) map { "@{http://www.spiritconsortium.org/XMLSchema/SPIRIT/1685-2009}format" -> _ },
        (node \ "@{http://www.spiritconsortium.org/XMLSchema/SPIRIT/1685-2009}resolve").headOption map { x => IPXACT2009scalaxb.DataRecord(x, node, IPXACT2009scalaxb.fromXML[ResolveType](x, IPXACT2009scalaxb.ElemName(node) :: stack)) } map { "@{http://www.spiritconsortium.org/XMLSchema/SPIRIT/1685-2009}resolve" -> _ },
        (node \ "@{http://www.spiritconsortium.org/XMLSchema/SPIRIT/1685-2009}id").headOption map { x => IPXACT2009scalaxb.DataRecord(x, node, IPXACT2009scalaxb.fromXML[String](x, IPXACT2009scalaxb.ElemName(node) :: stack)) } map { "@{http://www.spiritconsortium.org/XMLSchema/SPIRIT/1685-2009}id" -> _ },
        (node \ "@{http://www.spiritconsortium.org/XMLSchema/SPIRIT/1685-2009}dependency").headOption map { x => IPXACT2009scalaxb.DataRecord(x, node, IPXACT2009scalaxb.fromXML[String](x, IPXACT2009scalaxb.ElemName(node) :: stack)) } map { "@{http://www.spiritconsortium.org/XMLSchema/SPIRIT/1685-2009}dependency" -> _ },
        (node \ "@{http://www.spiritconsortium.org/XMLSchema/SPIRIT/1685-2009}choiceRef").headOption map { x => IPXACT2009scalaxb.DataRecord(x, node, IPXACT2009scalaxb.fromXML[String](x, IPXACT2009scalaxb.ElemName(node) :: stack)) } map { "@{http://www.spiritconsortium.org/XMLSchema/SPIRIT/1685-2009}choiceRef" -> _ },
        (node \ "@{http://www.spiritconsortium.org/XMLSchema/SPIRIT/1685-2009}order").headOption map { x => IPXACT2009scalaxb.DataRecord(x, node, IPXACT2009scalaxb.fromXML[Float](x, IPXACT2009scalaxb.ElemName(node) :: stack)) } map { "@{http://www.spiritconsortium.org/XMLSchema/SPIRIT/1685-2009}order" -> _ },
        (node \ "@{http://www.spiritconsortium.org/XMLSchema/SPIRIT/1685-2009}configGroups").headOption map { x => IPXACT2009scalaxb.DataRecord(x, node, IPXACT2009scalaxb.fromXML[Seq[String]](x, IPXACT2009scalaxb.ElemName(node) :: stack)) } map { "@{http://www.spiritconsortium.org/XMLSchema/SPIRIT/1685-2009}configGroups" -> _ },
        (node \ "@{http://www.spiritconsortium.org/XMLSchema/SPIRIT/1685-2009}bitStringLength").headOption map { x => IPXACT2009scalaxb.DataRecord(x, node, IPXACT2009scalaxb.fromXML[BigInt](x, IPXACT2009scalaxb.ElemName(node) :: stack)) } map { "@{http://www.spiritconsortium.org/XMLSchema/SPIRIT/1685-2009}bitStringLength" -> _ },
        (node \ "@{http://www.spiritconsortium.org/XMLSchema/SPIRIT/1685-2009}minimum").headOption map { x => IPXACT2009scalaxb.DataRecord(x, node, IPXACT2009scalaxb.fromXML[String](x, IPXACT2009scalaxb.ElemName(node) :: stack)) } map { "@{http://www.spiritconsortium.org/XMLSchema/SPIRIT/1685-2009}minimum" -> _ },
        (node \ "@{http://www.spiritconsortium.org/XMLSchema/SPIRIT/1685-2009}maximum").headOption map { x => IPXACT2009scalaxb.DataRecord(x, node, IPXACT2009scalaxb.fromXML[String](x, IPXACT2009scalaxb.ElemName(node) :: stack)) } map { "@{http://www.spiritconsortium.org/XMLSchema/SPIRIT/1685-2009}maximum" -> _ },
        (node \ "@{http://www.spiritconsortium.org/XMLSchema/SPIRIT/1685-2009}rangeType").headOption map { x => IPXACT2009scalaxb.DataRecord(x, node, IPXACT2009scalaxb.fromXML[RangeTypeType](x, IPXACT2009scalaxb.ElemName(node) :: stack)) } orElse Some(IPXACT2009scalaxb.DataRecord(None, None, IPXACT2009scalaxb.fromXML[RangeTypeType](scala.xml.Text("float"), IPXACT2009scalaxb.ElemName(node) :: stack))) map { "@{http://www.spiritconsortium.org/XMLSchema/SPIRIT/1685-2009}rangeType" -> _ },
        (node \ "@{http://www.spiritconsortium.org/XMLSchema/SPIRIT/1685-2009}prompt").headOption map { x => IPXACT2009scalaxb.DataRecord(x, node, IPXACT2009scalaxb.fromXML[String](x, IPXACT2009scalaxb.ElemName(node) :: stack)) } map { "@{http://www.spiritconsortium.org/XMLSchema/SPIRIT/1685-2009}prompt" -> _ }
        ).flatten[(String, IPXACT2009scalaxb.DataRecord[Any])] ::: (node match {
          case elem: scala.xml.Elem =>
            elem.attributes.toList flatMap {
              case scala.xml.PrefixedAttribute(pre, key, value, _) if pre == elem.scope.getPrefix("http://www.spiritconsortium.org/XMLSchema/SPIRIT/1685-2009") &&
                key == "units" => Nil
              case scala.xml.PrefixedAttribute(pre, key, value, _) if pre == elem.scope.getPrefix("http://www.spiritconsortium.org/XMLSchema/SPIRIT/1685-2009") &&
                key == "format" => Nil
              case scala.xml.PrefixedAttribute(pre, key, value, _) if pre == elem.scope.getPrefix("http://www.spiritconsortium.org/XMLSchema/SPIRIT/1685-2009") &&
                key == "resolve" => Nil
              case scala.xml.PrefixedAttribute(pre, key, value, _) if pre == elem.scope.getPrefix("http://www.spiritconsortium.org/XMLSchema/SPIRIT/1685-2009") &&
                key == "id" => Nil
              case scala.xml.PrefixedAttribute(pre, key, value, _) if pre == elem.scope.getPrefix("http://www.spiritconsortium.org/XMLSchema/SPIRIT/1685-2009") &&
                key == "dependency" => Nil
              case scala.xml.PrefixedAttribute(pre, key, value, _) if pre == elem.scope.getPrefix("http://www.spiritconsortium.org/XMLSchema/SPIRIT/1685-2009") &&
                key == "choiceRef" => Nil
              case scala.xml.PrefixedAttribute(pre, key, value, _) if pre == elem.scope.getPrefix("http://www.spiritconsortium.org/XMLSchema/SPIRIT/1685-2009") &&
                key == "order" => Nil
              case scala.xml.PrefixedAttribute(pre, key, value, _) if pre == elem.scope.getPrefix("http://www.spiritconsortium.org/XMLSchema/SPIRIT/1685-2009") &&
                key == "configGroups" => Nil
              case scala.xml.PrefixedAttribute(pre, key, value, _) if pre == elem.scope.getPrefix("http://www.spiritconsortium.org/XMLSchema/SPIRIT/1685-2009") &&
                key == "bitStringLength" => Nil
              case scala.xml.PrefixedAttribute(pre, key, value, _) if pre == elem.scope.getPrefix("http://www.spiritconsortium.org/XMLSchema/SPIRIT/1685-2009") &&
                key == "minimum" => Nil
              case scala.xml.PrefixedAttribute(pre, key, value, _) if pre == elem.scope.getPrefix("http://www.spiritconsortium.org/XMLSchema/SPIRIT/1685-2009") &&
                key == "maximum" => Nil
              case scala.xml.PrefixedAttribute(pre, key, value, _) if pre == elem.scope.getPrefix("http://www.spiritconsortium.org/XMLSchema/SPIRIT/1685-2009") &&
                key == "rangeType" => Nil
              case scala.xml.PrefixedAttribute(pre, key, value, _) if pre == elem.scope.getPrefix("http://www.spiritconsortium.org/XMLSchema/SPIRIT/1685-2009") &&
                key == "prompt" => Nil
              case scala.xml.UnprefixedAttribute(key, value, _) =>
                List(("@" + key, IPXACT2009scalaxb.DataRecord(None, Some(key), value.text)))
              case scala.xml.PrefixedAttribute(pre, key, value, _) =>
                val ns = elem.scope.getURI(pre)
                List(("@{" + ns + "}" + key, IPXACT2009scalaxb.DataRecord(Option[String](ns), Some(key), value.text)))
              case _ => Nil
            }
          case _ => Nil
        }): _*)))
      case _ => Left("reads failed: seq must be scala.xml.Node")
    }
    
    override def writesAttribute(__obj: ClockPulseDuration, __scope: scala.xml.NamespaceBinding): scala.xml.MetaData = {
      var attr: scala.xml.MetaData  = scala.xml.Null
      __obj.attributes.toList map {
        case ("@units", _) => if (__obj.units.toString != "ns") attr = scala.xml.Attribute(__scope.getPrefix("http://www.spiritconsortium.org/XMLSchema/SPIRIT/1685-2009"), "units", __obj.units.toString, attr)
        case ("@{http://www.spiritconsortium.org/XMLSchema/SPIRIT/1685-2009}format", _) => if (__obj.spiritformat.toString != "float") attr = scala.xml.Attribute(__scope.getPrefix("http://www.spiritconsortium.org/XMLSchema/SPIRIT/1685-2009"), "format", __obj.spiritformat.toString, attr)
        case ("@{http://www.spiritconsortium.org/XMLSchema/SPIRIT/1685-2009}resolve", _) => __obj.spiritresolve foreach { x => attr = scala.xml.Attribute(__scope.getPrefix("http://www.spiritconsortium.org/XMLSchema/SPIRIT/1685-2009"), "resolve", x.toString, attr) }
        case ("@{http://www.spiritconsortium.org/XMLSchema/SPIRIT/1685-2009}id", _) => __obj.spiritid foreach { x => attr = scala.xml.Attribute(__scope.getPrefix("http://www.spiritconsortium.org/XMLSchema/SPIRIT/1685-2009"), "id", x.toString, attr) }
        case ("@{http://www.spiritconsortium.org/XMLSchema/SPIRIT/1685-2009}dependency", _) => __obj.spiritdependency foreach { x => attr = scala.xml.Attribute(__scope.getPrefix("http://www.spiritconsortium.org/XMLSchema/SPIRIT/1685-2009"), "dependency", x.toString, attr) }
        case ("@{http://www.spiritconsortium.org/XMLSchema/SPIRIT/1685-2009}choiceRef", _) => __obj.spiritchoiceRef foreach { x => attr = scala.xml.Attribute(__scope.getPrefix("http://www.spiritconsortium.org/XMLSchema/SPIRIT/1685-2009"), "choiceRef", x.toString, attr) }
        case ("@{http://www.spiritconsortium.org/XMLSchema/SPIRIT/1685-2009}order", _) => __obj.spiritorder foreach { x => attr = scala.xml.Attribute(__scope.getPrefix("http://www.spiritconsortium.org/XMLSchema/SPIRIT/1685-2009"), "order", x.toString, attr) }
        case ("@{http://www.spiritconsortium.org/XMLSchema/SPIRIT/1685-2009}configGroups", _) => __obj.spiritconfigGroups foreach { x => attr = scala.xml.Attribute(__scope.getPrefix("http://www.spiritconsortium.org/XMLSchema/SPIRIT/1685-2009"), "configGroups", x.toString, attr) }
        case ("@{http://www.spiritconsortium.org/XMLSchema/SPIRIT/1685-2009}bitStringLength", _) => __obj.spiritbitStringLength foreach { x => attr = scala.xml.Attribute(__scope.getPrefix("http://www.spiritconsortium.org/XMLSchema/SPIRIT/1685-2009"), "bitStringLength", x.toString, attr) }
        case ("@{http://www.spiritconsortium.org/XMLSchema/SPIRIT/1685-2009}minimum", _) => __obj.spiritminimum foreach { x => attr = scala.xml.Attribute(__scope.getPrefix("http://www.spiritconsortium.org/XMLSchema/SPIRIT/1685-2009"), "minimum", x.toString, attr) }
        case ("@{http://www.spiritconsortium.org/XMLSchema/SPIRIT/1685-2009}maximum", _) => __obj.spiritmaximum foreach { x => attr = scala.xml.Attribute(__scope.getPrefix("http://www.spiritconsortium.org/XMLSchema/SPIRIT/1685-2009"), "maximum", x.toString, attr) }
        case ("@{http://www.spiritconsortium.org/XMLSchema/SPIRIT/1685-2009}rangeType", _) => if (__obj.spiritrangeType.toString != "float") attr = scala.xml.Attribute(__scope.getPrefix("http://www.spiritconsortium.org/XMLSchema/SPIRIT/1685-2009"), "rangeType", __obj.spiritrangeType.toString, attr)
        case ("@{http://www.spiritconsortium.org/XMLSchema/SPIRIT/1685-2009}prompt", _) => __obj.spiritprompt foreach { x => attr = scala.xml.Attribute(__scope.getPrefix("http://www.spiritconsortium.org/XMLSchema/SPIRIT/1685-2009"), "prompt", x.toString, attr) }
        case (key, x) => attr = scala.xml.Attribute((x.namespace map { __scope.getPrefix(_) }).orNull, x.key.orNull, x.value.toString, attr)
      }
      attr
    }

    def writesChildNodes(__obj: ClockPulseDuration, __scope: scala.xml.NamespaceBinding): Seq[scala.xml.Node] =
      Seq(scala.xml.Text(__obj.value.toString))

  }

  trait Default_ClockDriverTypableFormat extends IPXACT2009scalaxb.XMLFormat[ClockDriverTypable] {
    def reads(seq: scala.xml.NodeSeq, stack: List[IPXACT2009scalaxb.ElemName]): Either[String, ClockDriverTypable] = seq match {
      case node: scala.xml.Node =>     
        IPXACT2009scalaxb.Helper.instanceType(node) match {
          
          case _ => Right(IPXACT2009scalaxb.fromXML[ClockDriverType](node, stack))
        }
      case _ => Left("reads failed: seq must be scala.xml.Node")  
    }
    
    def writes(__obj: ClockDriverTypable, __namespace: Option[String], __elementLabel: Option[String],
        __scope: scala.xml.NamespaceBinding, __typeAttribute: Boolean): scala.xml.NodeSeq = __obj match {
      case x: OtherClockDriver => IPXACT2009scalaxb.toXML[OtherClockDriver](x, __namespace, __elementLabel, __scope, true)
      case x: ClockDriver => IPXACT2009scalaxb.toXML[ClockDriver](x, __namespace, __elementLabel, __scope, true)
      case x: ClockDriverType => IPXACT2009scalaxb.toXML[ClockDriverType](x, __namespace, __elementLabel, __scope, __typeAttribute)
    }
  }

  trait Default_ClockDriverTypeFormat extends IPXACT2009scalaxb.ElemNameParser[ClockDriverType] {
    val targetNamespace: Option[String] = Some("http://www.spiritconsortium.org/XMLSchema/SPIRIT/1685-2009")
    
    override def typeName: Option[String] = Some("clockDriverType")

    def parser(node: scala.xml.Node, stack: List[IPXACT2009scalaxb.ElemName]): Parser[ClockDriverType] =
      phrase((IPXACT2009scalaxb.ElemName(Some("http://www.spiritconsortium.org/XMLSchema/SPIRIT/1685-2009"), "clockPeriod")) ~
      (IPXACT2009scalaxb.ElemName(Some("http://www.spiritconsortium.org/XMLSchema/SPIRIT/1685-2009"), "clockPulseOffset")) ~
      (IPXACT2009scalaxb.ElemName(Some("http://www.spiritconsortium.org/XMLSchema/SPIRIT/1685-2009"), "clockPulseValue")) ~
      (IPXACT2009scalaxb.ElemName(Some("http://www.spiritconsortium.org/XMLSchema/SPIRIT/1685-2009"), "clockPulseDuration")) ^^
      { case p1 ~ p2 ~ p3 ~ p4 =>
      ClockDriverType(IPXACT2009scalaxb.fromXML[ClockPeriod](p1, IPXACT2009scalaxb.ElemName(node) :: stack),
        IPXACT2009scalaxb.fromXML[ClockPulseOffset](p2, IPXACT2009scalaxb.ElemName(node) :: stack),
        IPXACT2009scalaxb.fromXML[ClockPulseValue](p3, IPXACT2009scalaxb.ElemName(node) :: stack),
        IPXACT2009scalaxb.fromXML[ClockPulseDuration](p4, IPXACT2009scalaxb.ElemName(node) :: stack)) })
    
    def writesChildNodes(__obj: ClockDriverType, __scope: scala.xml.NamespaceBinding): Seq[scala.xml.Node] =
      Seq.concat(IPXACT2009scalaxb.toXML[ClockPeriod](__obj.clockPeriod, Some("http://www.spiritconsortium.org/XMLSchema/SPIRIT/1685-2009"), Some("clockPeriod"), __scope, false),
        IPXACT2009scalaxb.toXML[ClockPulseOffset](__obj.clockPulseOffset, Some("http://www.spiritconsortium.org/XMLSchema/SPIRIT/1685-2009"), Some("clockPulseOffset"), __scope, false),
        IPXACT2009scalaxb.toXML[ClockPulseValue](__obj.clockPulseValue, Some("http://www.spiritconsortium.org/XMLSchema/SPIRIT/1685-2009"), Some("clockPulseValue"), __scope, false),
        IPXACT2009scalaxb.toXML[ClockPulseDuration](__obj.clockPulseDuration, Some("http://www.spiritconsortium.org/XMLSchema/SPIRIT/1685-2009"), Some("clockPulseDuration"), __scope, false))

  }

  trait Default_OtherClockDriverFormat extends IPXACT2009scalaxb.ElemNameParser[OtherClockDriver] {
    val targetNamespace: Option[String] = Some("http://www.spiritconsortium.org/XMLSchema/SPIRIT/1685-2009")
    
    def parser(node: scala.xml.Node, stack: List[IPXACT2009scalaxb.ElemName]): Parser[OtherClockDriver] =
      phrase((IPXACT2009scalaxb.ElemName(Some("http://www.spiritconsortium.org/XMLSchema/SPIRIT/1685-2009"), "clockPeriod")) ~
      (IPXACT2009scalaxb.ElemName(Some("http://www.spiritconsortium.org/XMLSchema/SPIRIT/1685-2009"), "clockPulseOffset")) ~
      (IPXACT2009scalaxb.ElemName(Some("http://www.spiritconsortium.org/XMLSchema/SPIRIT/1685-2009"), "clockPulseValue")) ~
      (IPXACT2009scalaxb.ElemName(Some("http://www.spiritconsortium.org/XMLSchema/SPIRIT/1685-2009"), "clockPulseDuration")) ^^
      { case p1 ~ p2 ~ p3 ~ p4 =>
      OtherClockDriver(IPXACT2009scalaxb.fromXML[ClockPeriod](p1, IPXACT2009scalaxb.ElemName(node) :: stack),
        IPXACT2009scalaxb.fromXML[ClockPulseOffset](p2, IPXACT2009scalaxb.ElemName(node) :: stack),
        IPXACT2009scalaxb.fromXML[ClockPulseValue](p3, IPXACT2009scalaxb.ElemName(node) :: stack),
        IPXACT2009scalaxb.fromXML[ClockPulseDuration](p4, IPXACT2009scalaxb.ElemName(node) :: stack),
        scala.collection.immutable.ListMap(List(
        (node \ "@{http://www.spiritconsortium.org/XMLSchema/SPIRIT/1685-2009}clockName").headOption map { x => IPXACT2009scalaxb.DataRecord(x, node, IPXACT2009scalaxb.fromXML[String](x, IPXACT2009scalaxb.ElemName(node) :: stack)) } map { "@clockName" -> _ },
        (node \ "@{http://www.spiritconsortium.org/XMLSchema/SPIRIT/1685-2009}clockSource").headOption map { x => IPXACT2009scalaxb.DataRecord(x, node, IPXACT2009scalaxb.fromXML[String](x, IPXACT2009scalaxb.ElemName(node) :: stack)) } map { "@clockSource" -> _ }
        ).flatten[(String, IPXACT2009scalaxb.DataRecord[Any])]: _*)) })
    
    override def writesAttribute(__obj: OtherClockDriver, __scope: scala.xml.NamespaceBinding): scala.xml.MetaData = {
      var attr: scala.xml.MetaData  = scala.xml.Null
      __obj.attributes.toList map {
        case ("@clockName", _) => attr = scala.xml.Attribute(__scope.getPrefix("http://www.spiritconsortium.org/XMLSchema/SPIRIT/1685-2009"), "clockName", __obj.clockName.toString, attr)
        case ("@clockSource", _) => __obj.clockSource foreach { x => attr = scala.xml.Attribute(__scope.getPrefix("http://www.spiritconsortium.org/XMLSchema/SPIRIT/1685-2009"), "clockSource", x.toString, attr) }
        case (key, x) => attr = scala.xml.Attribute((x.namespace map { __scope.getPrefix(_) }).orNull, x.key.orNull, x.value.toString, attr)
      }
      attr
    }

    def writesChildNodes(__obj: OtherClockDriver, __scope: scala.xml.NamespaceBinding): Seq[scala.xml.Node] =
      Seq.concat(IPXACT2009scalaxb.toXML[ClockPeriod](__obj.clockPeriod, Some("http://www.spiritconsortium.org/XMLSchema/SPIRIT/1685-2009"), Some("clockPeriod"), __scope, false),
        IPXACT2009scalaxb.toXML[ClockPulseOffset](__obj.clockPulseOffset, Some("http://www.spiritconsortium.org/XMLSchema/SPIRIT/1685-2009"), Some("clockPulseOffset"), __scope, false),
        IPXACT2009scalaxb.toXML[ClockPulseValue](__obj.clockPulseValue, Some("http://www.spiritconsortium.org/XMLSchema/SPIRIT/1685-2009"), Some("clockPulseValue"), __scope, false),
        IPXACT2009scalaxb.toXML[ClockPulseDuration](__obj.clockPulseDuration, Some("http://www.spiritconsortium.org/XMLSchema/SPIRIT/1685-2009"), Some("clockPulseDuration"), __scope, false))

  }

  trait Default_ConfigurableElementValuesFormat extends IPXACT2009scalaxb.ElemNameParser[ConfigurableElementValues] {
    val targetNamespace: Option[String] = Some("http://www.spiritconsortium.org/XMLSchema/SPIRIT/1685-2009")
    
    def parser(node: scala.xml.Node, stack: List[IPXACT2009scalaxb.ElemName]): Parser[ConfigurableElementValues] =
      phrase(safeRep(IPXACT2009scalaxb.ElemName(Some("http://www.spiritconsortium.org/XMLSchema/SPIRIT/1685-2009"), "configurableElementValue")) ^^
      { case p1 =>
      ConfigurableElementValues(p1 map { IPXACT2009scalaxb.fromXML[ConfigurableElementValue](_, IPXACT2009scalaxb.ElemName(node) :: stack) }) })
    
    def writesChildNodes(__obj: ConfigurableElementValues, __scope: scala.xml.NamespaceBinding): Seq[scala.xml.Node] =
      (__obj.configurableElementValue flatMap { IPXACT2009scalaxb.toXML[ConfigurableElementValue](_, Some("http://www.spiritconsortium.org/XMLSchema/SPIRIT/1685-2009"), Some("configurableElementValue"), __scope, false) })
  }
  trait Default_ConfigurableElementValueFormat extends IPXACT2009scalaxb.XMLFormat[ConfigurableElementValue] with IPXACT2009scalaxb.CanWriteChildNodes[ConfigurableElementValue] {
    val targetNamespace: Option[String] = Some("http://www.spiritconsortium.org/XMLSchema/SPIRIT/1685-2009")
    def reads(seq: scala.xml.NodeSeq, stack: List[IPXACT2009scalaxb.ElemName]): Either[String, ConfigurableElementValue] = seq match {
      case node: scala.xml.Node => Right(ConfigurableElementValue(IPXACT2009scalaxb.fromXML[String](node, IPXACT2009scalaxb.ElemName(node) :: stack),
        scala.collection.immutable.ListMap(List(
        (node \ "@{http://www.spiritconsortium.org/XMLSchema/SPIRIT/1685-2009}referenceId").headOption map { x => IPXACT2009scalaxb.DataRecord(x, node, IPXACT2009scalaxb.fromXML[String](x, IPXACT2009scalaxb.ElemName(node) :: stack)) } map { "@referenceId" -> _ }
        ).flatten[(String, IPXACT2009scalaxb.DataRecord[Any])]: _*)))
      case _ => Left("reads failed: seq must be scala.xml.Node")
    }
    
    override def writesAttribute(__obj: ConfigurableElementValue, __scope: scala.xml.NamespaceBinding): scala.xml.MetaData = {
      var attr: scala.xml.MetaData  = scala.xml.Null
      __obj.attributes.toList map {
        case ("@referenceId", _) => attr = scala.xml.Attribute(__scope.getPrefix("http://www.spiritconsortium.org/XMLSchema/SPIRIT/1685-2009"), "referenceId", __obj.referenceId.toString, attr)
        case (key, x) => attr = scala.xml.Attribute((x.namespace map { __scope.getPrefix(_) }).orNull, x.key.orNull, x.value.toString, attr)
      }
      attr
    }

    def writesChildNodes(__obj: ConfigurableElementValue, __scope: scala.xml.NamespaceBinding): Seq[scala.xml.Node] =
      Seq(scala.xml.Text(__obj.value.toString))

  }

  trait Default_ComponentInstanceFormat extends IPXACT2009scalaxb.ElemNameParser[ComponentInstance] {
    val targetNamespace: Option[String] = Some("http://www.spiritconsortium.org/XMLSchema/SPIRIT/1685-2009")
    
    def parser(node: scala.xml.Node, stack: List[IPXACT2009scalaxb.ElemName]): Parser[ComponentInstance] =
      phrase((IPXACT2009scalaxb.ElemName(Some("http://www.spiritconsortium.org/XMLSchema/SPIRIT/1685-2009"), "instanceName")) ~
      opt(IPXACT2009scalaxb.ElemName(Some("http://www.spiritconsortium.org/XMLSchema/SPIRIT/1685-2009"), "displayName")) ~
      opt(IPXACT2009scalaxb.ElemName(Some("http://www.spiritconsortium.org/XMLSchema/SPIRIT/1685-2009"), "description")) ~
      (IPXACT2009scalaxb.ElemName(Some("http://www.spiritconsortium.org/XMLSchema/SPIRIT/1685-2009"), "componentRef")) ~
      opt(IPXACT2009scalaxb.ElemName(Some("http://www.spiritconsortium.org/XMLSchema/SPIRIT/1685-2009"), "configurableElementValues")) ~
      opt(IPXACT2009scalaxb.ElemName(Some("http://www.spiritconsortium.org/XMLSchema/SPIRIT/1685-2009"), "vendorExtensions")) ^^
      { case p1 ~ p2 ~ p3 ~ p4 ~ p5 ~ p6 =>
      ComponentInstance(IPXACT2009scalaxb.fromXML[String](p1, IPXACT2009scalaxb.ElemName(node) :: stack),
        p2.headOption map { IPXACT2009scalaxb.fromXML[String](_, IPXACT2009scalaxb.ElemName(node) :: stack) },
        p3.headOption map { IPXACT2009scalaxb.fromXML[String](_, IPXACT2009scalaxb.ElemName(node) :: stack) },
        IPXACT2009scalaxb.fromXML[LibraryRefType](p4, IPXACT2009scalaxb.ElemName(node) :: stack),
        p5.headOption map { IPXACT2009scalaxb.fromXML[ConfigurableElementValues](_, IPXACT2009scalaxb.ElemName(node) :: stack) },
        p6.headOption map { IPXACT2009scalaxb.fromXML[VendorExtensions](_, IPXACT2009scalaxb.ElemName(node) :: stack) }) })
    
    def writesChildNodes(__obj: ComponentInstance, __scope: scala.xml.NamespaceBinding): Seq[scala.xml.Node] =
      Seq.concat(IPXACT2009scalaxb.toXML[String](__obj.instanceName, Some("http://www.spiritconsortium.org/XMLSchema/SPIRIT/1685-2009"), Some("instanceName"), __scope, false),
        __obj.displayName map { IPXACT2009scalaxb.toXML[String](_, Some("http://www.spiritconsortium.org/XMLSchema/SPIRIT/1685-2009"), Some("displayName"), __scope, false) } getOrElse {Nil},
        __obj.description map { IPXACT2009scalaxb.toXML[String](_, Some("http://www.spiritconsortium.org/XMLSchema/SPIRIT/1685-2009"), Some("description"), __scope, false) } getOrElse {Nil},
        IPXACT2009scalaxb.toXML[LibraryRefType](__obj.componentRef, Some("http://www.spiritconsortium.org/XMLSchema/SPIRIT/1685-2009"), Some("componentRef"), __scope, false),
        __obj.configurableElementValues map { IPXACT2009scalaxb.toXML[ConfigurableElementValues](_, Some("http://www.spiritconsortium.org/XMLSchema/SPIRIT/1685-2009"), Some("configurableElementValues"), __scope, false) } getOrElse {Nil},
        __obj.vendorExtensions map { IPXACT2009scalaxb.toXML[VendorExtensions](_, Some("http://www.spiritconsortium.org/XMLSchema/SPIRIT/1685-2009"), Some("vendorExtensions"), __scope, false) } getOrElse {Nil})

  }

  trait Default_ComponentInstancesFormat extends IPXACT2009scalaxb.ElemNameParser[ComponentInstances] {
    val targetNamespace: Option[String] = Some("http://www.spiritconsortium.org/XMLSchema/SPIRIT/1685-2009")
    
    def parser(node: scala.xml.Node, stack: List[IPXACT2009scalaxb.ElemName]): Parser[ComponentInstances] =
      phrase(safeRep(IPXACT2009scalaxb.ElemName(Some("http://www.spiritconsortium.org/XMLSchema/SPIRIT/1685-2009"), "componentInstance")) ^^
      { case p1 =>
      ComponentInstances(p1 map { IPXACT2009scalaxb.fromXML[ComponentInstance](_, IPXACT2009scalaxb.ElemName(node) :: stack) }) })
    
    def writesChildNodes(__obj: ComponentInstances, __scope: scala.xml.NamespaceBinding): Seq[scala.xml.Node] =
      (__obj.componentInstance flatMap { IPXACT2009scalaxb.toXML[ComponentInstance](_, Some("http://www.spiritconsortium.org/XMLSchema/SPIRIT/1685-2009"), Some("componentInstance"), __scope, false) })
  }
  trait Default_InternalPortReferenceFormat extends IPXACT2009scalaxb.XMLFormat[InternalPortReference] with IPXACT2009scalaxb.CanWriteChildNodes[InternalPortReference] {
    val targetNamespace: Option[String] = Some("http://www.spiritconsortium.org/XMLSchema/SPIRIT/1685-2009")
    def reads(seq: scala.xml.NodeSeq, stack: List[IPXACT2009scalaxb.ElemName]): Either[String, InternalPortReference] = seq match {
      case node: scala.xml.Node => Right(InternalPortReference(scala.collection.immutable.ListMap(List(
        (node \ "@{http://www.spiritconsortium.org/XMLSchema/SPIRIT/1685-2009}componentRef").headOption map { x => IPXACT2009scalaxb.DataRecord(x, node, IPXACT2009scalaxb.fromXML[String](x, IPXACT2009scalaxb.ElemName(node) :: stack)) } map { "@componentRef" -> _ },
        (node \ "@{http://www.spiritconsortium.org/XMLSchema/SPIRIT/1685-2009}portRef").headOption map { x => IPXACT2009scalaxb.DataRecord(x, node, IPXACT2009scalaxb.fromXML[String](x, IPXACT2009scalaxb.ElemName(node) :: stack)) } map { "@portRef" -> _ },
        (node \ "@{http://www.spiritconsortium.org/XMLSchema/SPIRIT/1685-2009}left").headOption map { x => IPXACT2009scalaxb.DataRecord(x, node, IPXACT2009scalaxb.fromXML[BigInt](x, IPXACT2009scalaxb.ElemName(node) :: stack)) } map { "@left" -> _ },
        (node \ "@{http://www.spiritconsortium.org/XMLSchema/SPIRIT/1685-2009}right").headOption map { x => IPXACT2009scalaxb.DataRecord(x, node, IPXACT2009scalaxb.fromXML[BigInt](x, IPXACT2009scalaxb.ElemName(node) :: stack)) } map { "@right" -> _ }
        ).flatten[(String, IPXACT2009scalaxb.DataRecord[Any])]: _*)))
      case _ => Left("reads failed: seq must be scala.xml.Node")
    }
    
    override def writesAttribute(__obj: InternalPortReference, __scope: scala.xml.NamespaceBinding): scala.xml.MetaData = {
      var attr: scala.xml.MetaData  = scala.xml.Null
      __obj.attributes.toList map {
        case ("@componentRef", _) => attr = scala.xml.Attribute(__scope.getPrefix("http://www.spiritconsortium.org/XMLSchema/SPIRIT/1685-2009"), "componentRef", __obj.componentRef.toString, attr)
        case ("@portRef", _) => attr = scala.xml.Attribute(__scope.getPrefix("http://www.spiritconsortium.org/XMLSchema/SPIRIT/1685-2009"), "portRef", __obj.portRef.toString, attr)
        case ("@left", _) => __obj.left foreach { x => attr = scala.xml.Attribute(__scope.getPrefix("http://www.spiritconsortium.org/XMLSchema/SPIRIT/1685-2009"), "left", x.toString, attr) }
        case ("@right", _) => __obj.right foreach { x => attr = scala.xml.Attribute(__scope.getPrefix("http://www.spiritconsortium.org/XMLSchema/SPIRIT/1685-2009"), "right", x.toString, attr) }
        case (key, x) => attr = scala.xml.Attribute((x.namespace map { __scope.getPrefix(_) }).orNull, x.key.orNull, x.value.toString, attr)
      }
      attr
    }

    def writesChildNodes(__obj: InternalPortReference, __scope: scala.xml.NamespaceBinding): Seq[scala.xml.Node] =
      Nil

  }

  trait Default_ExternalPortReferenceFormat extends IPXACT2009scalaxb.XMLFormat[ExternalPortReference] with IPXACT2009scalaxb.CanWriteChildNodes[ExternalPortReference] {
    val targetNamespace: Option[String] = Some("http://www.spiritconsortium.org/XMLSchema/SPIRIT/1685-2009")
    def reads(seq: scala.xml.NodeSeq, stack: List[IPXACT2009scalaxb.ElemName]): Either[String, ExternalPortReference] = seq match {
      case node: scala.xml.Node => Right(ExternalPortReference(scala.collection.immutable.ListMap(List(
        (node \ "@{http://www.spiritconsortium.org/XMLSchema/SPIRIT/1685-2009}portRef").headOption map { x => IPXACT2009scalaxb.DataRecord(x, node, IPXACT2009scalaxb.fromXML[String](x, IPXACT2009scalaxb.ElemName(node) :: stack)) } map { "@portRef" -> _ },
        (node \ "@{http://www.spiritconsortium.org/XMLSchema/SPIRIT/1685-2009}left").headOption map { x => IPXACT2009scalaxb.DataRecord(x, node, IPXACT2009scalaxb.fromXML[BigInt](x, IPXACT2009scalaxb.ElemName(node) :: stack)) } map { "@left" -> _ },
        (node \ "@{http://www.spiritconsortium.org/XMLSchema/SPIRIT/1685-2009}right").headOption map { x => IPXACT2009scalaxb.DataRecord(x, node, IPXACT2009scalaxb.fromXML[BigInt](x, IPXACT2009scalaxb.ElemName(node) :: stack)) } map { "@right" -> _ }
        ).flatten[(String, IPXACT2009scalaxb.DataRecord[Any])]: _*)))
      case _ => Left("reads failed: seq must be scala.xml.Node")
    }
    
    override def writesAttribute(__obj: ExternalPortReference, __scope: scala.xml.NamespaceBinding): scala.xml.MetaData = {
      var attr: scala.xml.MetaData  = scala.xml.Null
      __obj.attributes.toList map {
        case ("@portRef", _) => attr = scala.xml.Attribute(__scope.getPrefix("http://www.spiritconsortium.org/XMLSchema/SPIRIT/1685-2009"), "portRef", __obj.portRef.toString, attr)
        case ("@left", _) => __obj.left foreach { x => attr = scala.xml.Attribute(__scope.getPrefix("http://www.spiritconsortium.org/XMLSchema/SPIRIT/1685-2009"), "left", x.toString, attr) }
        case ("@right", _) => __obj.right foreach { x => attr = scala.xml.Attribute(__scope.getPrefix("http://www.spiritconsortium.org/XMLSchema/SPIRIT/1685-2009"), "right", x.toString, attr) }
        case (key, x) => attr = scala.xml.Attribute((x.namespace map { __scope.getPrefix(_) }).orNull, x.key.orNull, x.value.toString, attr)
      }
      attr
    }

    def writesChildNodes(__obj: ExternalPortReference, __scope: scala.xml.NamespaceBinding): Seq[scala.xml.Node] =
      Nil

  }

  trait Default_AdHocConnectionFormat extends IPXACT2009scalaxb.ElemNameParser[AdHocConnection] with _NameGroupPortGroupFormat {
    val targetNamespace: Option[String] = Some("http://www.spiritconsortium.org/XMLSchema/SPIRIT/1685-2009")
    
    def parser(node: scala.xml.Node, stack: List[IPXACT2009scalaxb.ElemName]): Parser[AdHocConnection] =
      phrase((parseNameGroupPortGroup(node, IPXACT2009scalaxb.ElemName(node) :: stack)) ~
      safeRep(IPXACT2009scalaxb.ElemName(Some("http://www.spiritconsortium.org/XMLSchema/SPIRIT/1685-2009"), "internalPortReference")) ~
      safeRep(IPXACT2009scalaxb.ElemName(Some("http://www.spiritconsortium.org/XMLSchema/SPIRIT/1685-2009"), "externalPortReference")) ^^
      { case p1 ~ p2 ~ p3 =>
      AdHocConnection(p1,
        p2 map { IPXACT2009scalaxb.fromXML[InternalPortReference](_, IPXACT2009scalaxb.ElemName(node) :: stack) },
        p3 map { IPXACT2009scalaxb.fromXML[ExternalPortReference](_, IPXACT2009scalaxb.ElemName(node) :: stack) },
        scala.collection.immutable.ListMap(List(
        (node \ "@{http://www.spiritconsortium.org/XMLSchema/SPIRIT/1685-2009}tiedValue").headOption map { x => IPXACT2009scalaxb.DataRecord(x, node, IPXACT2009scalaxb.fromXML[String](x, IPXACT2009scalaxb.ElemName(node) :: stack)) } map { "@tiedValue" -> _ }
        ).flatten[(String, IPXACT2009scalaxb.DataRecord[Any])]: _*)) })
    
    override def writesAttribute(__obj: AdHocConnection, __scope: scala.xml.NamespaceBinding): scala.xml.MetaData = {
      var attr: scala.xml.MetaData  = scala.xml.Null
      __obj.attributes.toList map {
        case ("@tiedValue", _) => __obj.tiedValue foreach { x => attr = scala.xml.Attribute(__scope.getPrefix("http://www.spiritconsortium.org/XMLSchema/SPIRIT/1685-2009"), "tiedValue", x.toString, attr) }
        case (key, x) => attr = scala.xml.Attribute((x.namespace map { __scope.getPrefix(_) }).orNull, x.key.orNull, x.value.toString, attr)
      }
      attr
    }

    def writesChildNodes(__obj: AdHocConnection, __scope: scala.xml.NamespaceBinding): Seq[scala.xml.Node] =
      Seq.concat(IPXACT2009scalaxb.toXML[NameGroupPortSequence](__obj.nameGroupPortSequence1, None, Some("nameGroupPortSequence1"), __scope, false),
        __obj.internalPortReference flatMap { IPXACT2009scalaxb.toXML[InternalPortReference](_, Some("http://www.spiritconsortium.org/XMLSchema/SPIRIT/1685-2009"), Some("internalPortReference"), __scope, false) },
        __obj.externalPortReference flatMap { IPXACT2009scalaxb.toXML[ExternalPortReference](_, Some("http://www.spiritconsortium.org/XMLSchema/SPIRIT/1685-2009"), Some("externalPortReference"), __scope, false) })

  }

  trait Default_AdHocConnectionsFormat extends IPXACT2009scalaxb.ElemNameParser[AdHocConnections] {
    val targetNamespace: Option[String] = Some("http://www.spiritconsortium.org/XMLSchema/SPIRIT/1685-2009")
    
    def parser(node: scala.xml.Node, stack: List[IPXACT2009scalaxb.ElemName]): Parser[AdHocConnections] =
      phrase(safeRep(IPXACT2009scalaxb.ElemName(Some("http://www.spiritconsortium.org/XMLSchema/SPIRIT/1685-2009"), "adHocConnection")) ^^
      { case p1 =>
      AdHocConnections(p1 map { IPXACT2009scalaxb.fromXML[AdHocConnection](_, IPXACT2009scalaxb.ElemName(node) :: stack) }) })
    
    def writesChildNodes(__obj: AdHocConnections, __scope: scala.xml.NamespaceBinding): Seq[scala.xml.Node] =
      (__obj.adHocConnection flatMap { IPXACT2009scalaxb.toXML[AdHocConnection](_, Some("http://www.spiritconsortium.org/XMLSchema/SPIRIT/1685-2009"), Some("adHocConnection"), __scope, false) })
  }
  trait Default_InterconnectionFormat extends IPXACT2009scalaxb.ElemNameParser[Interconnection] with _NameGroupGroupFormat {
    val targetNamespace: Option[String] = Some("http://www.spiritconsortium.org/XMLSchema/SPIRIT/1685-2009")
    
    def parser(node: scala.xml.Node, stack: List[IPXACT2009scalaxb.ElemName]): Parser[Interconnection] =
      phrase((parseNameGroupGroup(node, IPXACT2009scalaxb.ElemName(node) :: stack)) ~
      safeRep(IPXACT2009scalaxb.ElemName(Some("http://www.spiritconsortium.org/XMLSchema/SPIRIT/1685-2009"), "activeInterface")) ^^
      { case p1 ~ p2 =>
      Interconnection(p1,
        p2 map { IPXACT2009scalaxb.fromXML[Interfacable](_, IPXACT2009scalaxb.ElemName(node) :: stack) }) })
    
    def writesChildNodes(__obj: Interconnection, __scope: scala.xml.NamespaceBinding): Seq[scala.xml.Node] =
      Seq.concat(IPXACT2009scalaxb.toXML[NameGroupSequence](__obj.nameGroupSequence1, None, Some("nameGroupSequence1"), __scope, false),
        __obj.activeInterface flatMap { IPXACT2009scalaxb.toXML[Interfacable](_, Some("http://www.spiritconsortium.org/XMLSchema/SPIRIT/1685-2009"), Some("activeInterface"), __scope, false) })

  }

  trait Default_InterconnectionsFormat extends IPXACT2009scalaxb.ElemNameParser[Interconnections] {
    val targetNamespace: Option[String] = Some("http://www.spiritconsortium.org/XMLSchema/SPIRIT/1685-2009")
    
    def parser(node: scala.xml.Node, stack: List[IPXACT2009scalaxb.ElemName]): Parser[Interconnections] =
      phrase(safeRep(IPXACT2009scalaxb.ElemName(Some("http://www.spiritconsortium.org/XMLSchema/SPIRIT/1685-2009"), "interconnection")) ~
      safeRep(IPXACT2009scalaxb.ElemName(Some("http://www.spiritconsortium.org/XMLSchema/SPIRIT/1685-2009"), "monitorInterconnection")) ^^
      { case p1 ~ p2 =>
      Interconnections(p1 map { IPXACT2009scalaxb.fromXML[Interconnection](_, IPXACT2009scalaxb.ElemName(node) :: stack) },
        p2 map { IPXACT2009scalaxb.fromXML[MonitorInterconnection](_, IPXACT2009scalaxb.ElemName(node) :: stack) }) })
    
    def writesChildNodes(__obj: Interconnections, __scope: scala.xml.NamespaceBinding): Seq[scala.xml.Node] =
      Seq.concat(__obj.interconnection flatMap { IPXACT2009scalaxb.toXML[Interconnection](_, Some("http://www.spiritconsortium.org/XMLSchema/SPIRIT/1685-2009"), Some("interconnection"), __scope, false) },
        __obj.monitorInterconnection flatMap { IPXACT2009scalaxb.toXML[MonitorInterconnection](_, Some("http://www.spiritconsortium.org/XMLSchema/SPIRIT/1685-2009"), Some("monitorInterconnection"), __scope, false) })

  }

  trait Default_InterfacableFormat extends IPXACT2009scalaxb.XMLFormat[Interfacable] {
    def reads(seq: scala.xml.NodeSeq, stack: List[IPXACT2009scalaxb.ElemName]): Either[String, Interfacable] = seq match {
      case node: scala.xml.Node =>     
        IPXACT2009scalaxb.Helper.instanceType(node) match {
          case (Some("http://www.spiritconsortium.org/XMLSchema/SPIRIT/1685-2009"), Some("hierInterface")) => Right(IPXACT2009scalaxb.fromXML[HierInterface](node, stack))
          case _ => Right(IPXACT2009scalaxb.fromXML[InterfaceType](node, stack))
        }
      case _ => Left("reads failed: seq must be scala.xml.Node")  
    }
    
    def writes(__obj: Interfacable, __namespace: Option[String], __elementLabel: Option[String],
        __scope: scala.xml.NamespaceBinding, __typeAttribute: Boolean): scala.xml.NodeSeq = __obj match {
      case x: HierInterface => IPXACT2009scalaxb.toXML[HierInterface](x, __namespace, __elementLabel, __scope, true)
      case x: InterfaceType => IPXACT2009scalaxb.toXML[InterfaceType](x, __namespace, __elementLabel, __scope, __typeAttribute)
    }
  }
  trait Default_InterfaceTypeFormat extends IPXACT2009scalaxb.XMLFormat[InterfaceType] with IPXACT2009scalaxb.CanWriteChildNodes[InterfaceType] {
    val targetNamespace: Option[String] = Some("http://www.spiritconsortium.org/XMLSchema/SPIRIT/1685-2009")
    def reads(seq: scala.xml.NodeSeq, stack: List[IPXACT2009scalaxb.ElemName]): Either[String, InterfaceType] = seq match {
      case node: scala.xml.Node => Right(InterfaceType(scala.collection.immutable.ListMap(List(
        (node \ "@{http://www.spiritconsortium.org/XMLSchema/SPIRIT/1685-2009}componentRef").headOption map { x => IPXACT2009scalaxb.DataRecord(x, node, IPXACT2009scalaxb.fromXML[String](x, IPXACT2009scalaxb.ElemName(node) :: stack)) } map { "@componentRef" -> _ },
        (node \ "@{http://www.spiritconsortium.org/XMLSchema/SPIRIT/1685-2009}busRef").headOption map { x => IPXACT2009scalaxb.DataRecord(x, node, IPXACT2009scalaxb.fromXML[String](x, IPXACT2009scalaxb.ElemName(node) :: stack)) } map { "@busRef" -> _ }
        ).flatten[(String, IPXACT2009scalaxb.DataRecord[Any])]: _*)))
      case _ => Left("reads failed: seq must be scala.xml.Node")
    }
    
    override def writesAttribute(__obj: InterfaceType, __scope: scala.xml.NamespaceBinding): scala.xml.MetaData = {
      var attr: scala.xml.MetaData  = scala.xml.Null
      __obj.attributes.toList map {
        case ("@componentRef", _) => attr = scala.xml.Attribute(__scope.getPrefix("http://www.spiritconsortium.org/XMLSchema/SPIRIT/1685-2009"), "componentRef", __obj.componentRef.toString, attr)
        case ("@busRef", _) => attr = scala.xml.Attribute(__scope.getPrefix("http://www.spiritconsortium.org/XMLSchema/SPIRIT/1685-2009"), "busRef", __obj.busRef.toString, attr)
        case (key, x) => attr = scala.xml.Attribute((x.namespace map { __scope.getPrefix(_) }).orNull, x.key.orNull, x.value.toString, attr)
      }
      attr
    }

    def writesChildNodes(__obj: InterfaceType, __scope: scala.xml.NamespaceBinding): Seq[scala.xml.Node] =
      Nil

  }

  trait Default_MonitorInterconnectionFormat extends IPXACT2009scalaxb.ElemNameParser[MonitorInterconnection] with _NameGroupGroupFormat {
    val targetNamespace: Option[String] = Some("http://www.spiritconsortium.org/XMLSchema/SPIRIT/1685-2009")
    
    def parser(node: scala.xml.Node, stack: List[IPXACT2009scalaxb.ElemName]): Parser[MonitorInterconnection] =
      phrase((parseNameGroupGroup(node, IPXACT2009scalaxb.ElemName(node) :: stack)) ~
      (IPXACT2009scalaxb.ElemName(Some("http://www.spiritconsortium.org/XMLSchema/SPIRIT/1685-2009"), "monitoredActiveInterface")) ~
      safeRep(IPXACT2009scalaxb.ElemName(Some("http://www.spiritconsortium.org/XMLSchema/SPIRIT/1685-2009"), "monitorInterface")) ^^
      { case p1 ~ p2 ~ p3 =>
      MonitorInterconnection(p1,
        IPXACT2009scalaxb.fromXML[HierInterface](p2, IPXACT2009scalaxb.ElemName(node) :: stack),
        p3 map { IPXACT2009scalaxb.fromXML[HierInterface](_, IPXACT2009scalaxb.ElemName(node) :: stack) }) })
    
    def writesChildNodes(__obj: MonitorInterconnection, __scope: scala.xml.NamespaceBinding): Seq[scala.xml.Node] =
      Seq.concat(IPXACT2009scalaxb.toXML[NameGroupSequence](__obj.nameGroupSequence1, None, Some("nameGroupSequence1"), __scope, false),
        IPXACT2009scalaxb.toXML[HierInterface](__obj.monitoredActiveInterface, Some("http://www.spiritconsortium.org/XMLSchema/SPIRIT/1685-2009"), Some("monitoredActiveInterface"), __scope, false),
        __obj.monitorInterface flatMap { IPXACT2009scalaxb.toXML[HierInterface](_, Some("http://www.spiritconsortium.org/XMLSchema/SPIRIT/1685-2009"), Some("monitorInterface"), __scope, false) })

  }

  trait Default_HierInterfaceFormat extends IPXACT2009scalaxb.XMLFormat[HierInterface] with IPXACT2009scalaxb.CanWriteChildNodes[HierInterface] {
    val targetNamespace: Option[String] = Some("http://www.spiritconsortium.org/XMLSchema/SPIRIT/1685-2009")
    def reads(seq: scala.xml.NodeSeq, stack: List[IPXACT2009scalaxb.ElemName]): Either[String, HierInterface] = seq match {
      case node: scala.xml.Node => Right(HierInterface(scala.collection.immutable.ListMap(List(
        (node \ "@{http://www.spiritconsortium.org/XMLSchema/SPIRIT/1685-2009}componentRef").headOption map { x => IPXACT2009scalaxb.DataRecord(x, node, IPXACT2009scalaxb.fromXML[String](x, IPXACT2009scalaxb.ElemName(node) :: stack)) } map { "@componentRef" -> _ },
        (node \ "@{http://www.spiritconsortium.org/XMLSchema/SPIRIT/1685-2009}busRef").headOption map { x => IPXACT2009scalaxb.DataRecord(x, node, IPXACT2009scalaxb.fromXML[String](x, IPXACT2009scalaxb.ElemName(node) :: stack)) } map { "@busRef" -> _ },
        (node \ "@{http://www.spiritconsortium.org/XMLSchema/SPIRIT/1685-2009}path").headOption map { x => IPXACT2009scalaxb.DataRecord(x, node, IPXACT2009scalaxb.fromXML[String](x, IPXACT2009scalaxb.ElemName(node) :: stack)) } map { "@path" -> _ }
        ).flatten[(String, IPXACT2009scalaxb.DataRecord[Any])]: _*)))
      case _ => Left("reads failed: seq must be scala.xml.Node")
    }
    
    override def writesAttribute(__obj: HierInterface, __scope: scala.xml.NamespaceBinding): scala.xml.MetaData = {
      var attr: scala.xml.MetaData  = scala.xml.Null
      __obj.attributes.toList map {
        case ("@componentRef", _) => attr = scala.xml.Attribute(__scope.getPrefix("http://www.spiritconsortium.org/XMLSchema/SPIRIT/1685-2009"), "componentRef", __obj.componentRef.toString, attr)
        case ("@busRef", _) => attr = scala.xml.Attribute(__scope.getPrefix("http://www.spiritconsortium.org/XMLSchema/SPIRIT/1685-2009"), "busRef", __obj.busRef.toString, attr)
        case ("@path", _) => __obj.path foreach { x => attr = scala.xml.Attribute(__scope.getPrefix("http://www.spiritconsortium.org/XMLSchema/SPIRIT/1685-2009"), "path", x.toString, attr) }
        case (key, x) => attr = scala.xml.Attribute((x.namespace map { __scope.getPrefix(_) }).orNull, x.key.orNull, x.value.toString, attr)
      }
      attr
    }

    def writesChildNodes(__obj: HierInterface, __scope: scala.xml.NamespaceBinding): Seq[scala.xml.Node] =
      Nil

  }


}


package IPXACT2009ScalaCases

// Generated by <a href="http://IPXACT2009scalaxb.org/">IPXACT2009scalaxb</a>.

sealed trait AccessType

object AccessType {
  def fromString(value: String, scope: scala.xml.NamespaceBinding)(implicit fmt: IPXACT2009scalaxb.XMLFormat[AccessType]): AccessType = fmt.reads(scala.xml.Text(value), Nil) match {
    case Right(x: AccessType) => x
    case x => throw new RuntimeException(s"fromString returned unexpected value $x for input $value")
  }
  lazy val values: Seq[AccessType] = Seq(Readu45only, Writeu45only, Readu45write, WriteOnce, Readu45writeOnce)
}

case object Readu45only extends AccessType { override def toString = "read-only" }
case object Writeu45only extends AccessType { override def toString = "write-only" }
case object Readu45write extends AccessType { override def toString = "read-write" }
case object WriteOnce extends AccessType { override def toString = "writeOnce" }
case object Readu45writeOnce extends AccessType { override def toString = "read-writeOnce" }

sealed trait BankAlignmentType

object BankAlignmentType {
  def fromString(value: String, scope: scala.xml.NamespaceBinding)(implicit fmt: IPXACT2009scalaxb.XMLFormat[BankAlignmentType]): BankAlignmentType = fmt.reads(scala.xml.Text(value), Nil) match {
    case Right(x: BankAlignmentType) => x
    case x => throw new RuntimeException(s"fromString returned unexpected value $x for input $value")
  }
  lazy val values: Seq[BankAlignmentType] = Seq(Serial, Parallel)
}

case object Serial extends BankAlignmentType { override def toString = "serial" }
case object Parallel extends BankAlignmentType { override def toString = "parallel" }

sealed trait UsageType

object UsageType {
  def fromString(value: String, scope: scala.xml.NamespaceBinding)(implicit fmt: IPXACT2009scalaxb.XMLFormat[UsageType]): UsageType = fmt.reads(scala.xml.Text(value), Nil) match {
    case Right(x: UsageType) => x
    case x => throw new RuntimeException(s"fromString returned unexpected value $x for input $value")
  }
  lazy val values: Seq[UsageType] = Seq(Memory, RegisterValue, Reserved)
}

case object Memory extends UsageType { override def toString = "memory" }
case object RegisterValue extends UsageType { override def toString = "register" }
case object Reserved extends UsageType { override def toString = "reserved" }


/** Top level bank the specify an address
*/
case class AddressBankType(nameGroupSequence1: NameGroupSequence,
  addressSpecifierSequence2: AddressSpecifierSequence,
  bankBaseSequence3: BankBaseSequence,
  attributes: Map[String, IPXACT2009scalaxb.DataRecord[Any]] = Map.empty) extends MemoryMapOption {
  lazy val spiritbankAlignment = attributes("@{http://www.spiritconsortium.org/XMLSchema/SPIRIT/1685-2009}bankAlignment").as[BankAlignmentType]
}

      
      


/** Top level address block that specify an address
*/
case class AddressBlockType(nameGroupSequence1: NameGroupSequence,
  addressSpecifierSequence2: AddressSpecifierSequence,
  addressBlockDefinitionGroupSequence3: AddressBlockDefinitionGroupSequence,
  vendorExtensions: Option[VendorExtensions] = None,
  attributes: Map[String, IPXACT2009scalaxb.DataRecord[Any]] = Map.empty) extends MemoryMapOption {
  lazy val spiritid = attributes.get("@{http://www.spiritconsortium.org/XMLSchema/SPIRIT/1685-2009}id") map { _.as[String]}
}

      
      


/** Base type for an element which references an address space.  Reference is kept in an attribute rather than the text value, so that the type may be extended with child elements if necessary.
*/
trait AddrSpaceRefTypable {
  def spiritaddressSpaceRef: String
}


/** Base type for an element which references an address space.  Reference is kept in an attribute rather than the text value, so that the type may be extended with child elements if necessary.
*/
case class AddrSpaceRefType(attributes: Map[String, IPXACT2009scalaxb.DataRecord[Any]] = Map.empty) extends AddrSpaceRefTypable {
  lazy val spiritaddressSpaceRef = attributes("@{http://www.spiritconsortium.org/XMLSchema/SPIRIT/1685-2009}addressSpaceRef").as[String]
}

      
      


/** Base type for an element which references an memory map.  Reference is kept in an attribute rather than the text value, so that the type may be extended with child elements if necessary.
*/
case class MemoryMapRefType(attributes: Map[String, IPXACT2009scalaxb.DataRecord[Any]] = Map.empty) {
  lazy val spiritmemoryMapRef = attributes("@{http://www.spiritconsortium.org/XMLSchema/SPIRIT/1685-2009}memoryMapRef").as[String]
}

      
      


/** Banks nested inside a bank do not specify address.
*/
case class BankedBankType(nameGroupSequence1: NameGroupSequence,
  bankBaseSequence2: BankBaseSequence,
  attributes: Map[String, IPXACT2009scalaxb.DataRecord[Any]] = Map.empty) extends BankBaseOption1 {
  lazy val spiritbankAlignment = attributes("@{http://www.spiritconsortium.org/XMLSchema/SPIRIT/1685-2009}bankAlignment").as[BankAlignmentType]
}

      
      


/** Address blocks inside a bank do not specify address.
*/
case class BankedBlockType(nameGroupSequence1: NameGroupSequence,
  blockSizeSequence2: BlockSizeSequence,
  addressBlockExtensionsSequence3: AddressBlockExtensionsSequence,
  vendorExtensions: Option[VendorExtensions] = None,
  attributes: Map[String, IPXACT2009scalaxb.DataRecord[Any]] = Map.empty) extends BankBaseOption1 {
  lazy val spiritid = attributes.get("@{http://www.spiritconsortium.org/XMLSchema/SPIRIT/1685-2009}id") map { _.as[String]}
}

      
      


/** Subspace references inside banks do not specify an address.
*/
case class BankedSubspaceType(nameGroupOptionalSequence1: NameGroupOptionalSequence,
  parameters: Option[Parameters] = None,
  vendorExtensions: Option[VendorExtensions] = None,
  attributes: Map[String, IPXACT2009scalaxb.DataRecord[Any]] = Map.empty) extends BankBaseOption1 {
  lazy val spiritmasterRef = attributes("@{http://www.spiritconsortium.org/XMLSchema/SPIRIT/1685-2009}masterRef").as[String]
}

      
      


/** A field within a register
*/
case class FieldType(nameGroupSequence1: NameGroupSequence,
  bitOffset: BigInt,
  fieldDefinitionGroupSequence3: FieldDefinitionGroupSequence,
  parameters: Option[Parameters] = None,
  vendorExtensions: Option[VendorExtensions] = None,
  attributes: Map[String, IPXACT2009scalaxb.DataRecord[Any]] = Map.empty) {
  lazy val spiritid = attributes.get("@{http://www.spiritconsortium.org/XMLSchema/SPIRIT/1685-2009}id") map { _.as[String]}
}

      
      


/** Map of address space blocks on slave slave bus interface.
*/
case class MemoryMapType(nameGroupSequence1: NameGroupSequence,
  memoryMapOption2: Seq[IPXACT2009scalaxb.DataRecord[MemoryMapOption]] = Nil,
  memoryRemap: Seq[MemoryRemapType] = Nil,
  addressUnitBits: Option[BigInt] = None,
  vendorExtensions: Option[VendorExtensions] = None,
  attributes: Map[String, IPXACT2009scalaxb.DataRecord[Any]] = Map.empty) {
  lazy val spiritid = attributes.get("@{http://www.spiritconsortium.org/XMLSchema/SPIRIT/1685-2009}id") map { _.as[String]}
}

      
      


/** Map of address space blocks on a slave bus interface in a specific remap state.
*/
case class MemoryRemapType(nameGroupSequence1: NameGroupSequence,
  memoryMapOption2: Seq[IPXACT2009scalaxb.DataRecord[MemoryMapOption]] = Nil,
  attributes: Map[String, IPXACT2009scalaxb.DataRecord[Any]] = Map.empty) {
  lazy val state = attributes("@state").as[String]
  lazy val spiritid = attributes.get("@{http://www.spiritconsortium.org/XMLSchema/SPIRIT/1685-2009}id") map { _.as[String]}
}

      
      


/** Map of address space blocks on the local memory map of a master bus interface.
*/
case class LocalMemoryMapType(nameGroupSequence1: NameGroupSequence,
  memoryMapOption2: Seq[IPXACT2009scalaxb.DataRecord[MemoryMapOption]] = Nil,
  attributes: Map[String, IPXACT2009scalaxb.DataRecord[Any]] = Map.empty) {
  lazy val spiritid = attributes.get("@{http://www.spiritconsortium.org/XMLSchema/SPIRIT/1685-2009}id") map { _.as[String]}
}

      
      


/** Address subspace type.  Its subspaceReference attribute references the subspace from which the dimensions are taken.
*/
case class SubspaceRefType(nameGroupSequence1: NameGroupSequence,
  addressSpecifierSequence2: AddressSpecifierSequence,
  parameters: Option[Parameters] = None,
  vendorExtensions: Option[VendorExtensions] = None,
  attributes: Map[String, IPXACT2009scalaxb.DataRecord[Any]] = Map.empty) extends MemoryMapOption {
  lazy val spiritmasterRef = attributes("@{http://www.spiritconsortium.org/XMLSchema/SPIRIT/1685-2009}masterRef").as[String]
  lazy val spiritsegmentRef = attributes.get("@{http://www.spiritconsortium.org/XMLSchema/SPIRIT/1685-2009}segmentRef") map { _.as[String]}
}

      
      


case class AddressOffset(value: String,
  attributes: Map[String, IPXACT2009scalaxb.DataRecord[Any]] = Map.empty) {
  lazy val spiritformat = attributes("@{http://www.spiritconsortium.org/XMLSchema/SPIRIT/1685-2009}format").as[FormatType]
  lazy val spiritresolve = attributes.get("@{http://www.spiritconsortium.org/XMLSchema/SPIRIT/1685-2009}resolve") map { _.as[ResolveType]}
  lazy val spiritid = attributes.get("@{http://www.spiritconsortium.org/XMLSchema/SPIRIT/1685-2009}id") map { _.as[String]}
  lazy val spiritdependency = attributes.get("@{http://www.spiritconsortium.org/XMLSchema/SPIRIT/1685-2009}dependency") map { _.as[String]}
  lazy val spiritchoiceRef = attributes.get("@{http://www.spiritconsortium.org/XMLSchema/SPIRIT/1685-2009}choiceRef") map { _.as[String]}
  lazy val spiritorder = attributes.get("@{http://www.spiritconsortium.org/XMLSchema/SPIRIT/1685-2009}order") map { _.as[Float]}
  lazy val spiritconfigGroups = attributes.get("@{http://www.spiritconsortium.org/XMLSchema/SPIRIT/1685-2009}configGroups") map { _.as[Seq[String]]}
  lazy val spiritbitStringLength = attributes.get("@{http://www.spiritconsortium.org/XMLSchema/SPIRIT/1685-2009}bitStringLength") map { _.as[BigInt]}
  lazy val spiritminimum = attributes.get("@{http://www.spiritconsortium.org/XMLSchema/SPIRIT/1685-2009}minimum") map { _.as[String]}
  lazy val spiritmaximum = attributes.get("@{http://www.spiritconsortium.org/XMLSchema/SPIRIT/1685-2009}maximum") map { _.as[String]}
  lazy val spiritrangeType = attributes("@{http://www.spiritconsortium.org/XMLSchema/SPIRIT/1685-2009}rangeType").as[RangeTypeType]
  lazy val spiritprompt = attributes.get("@{http://www.spiritconsortium.org/XMLSchema/SPIRIT/1685-2009}prompt") map { _.as[String]}
}

      
      


case class RangeType2(value: String,
  attributes: Map[String, IPXACT2009scalaxb.DataRecord[Any]] = Map.empty) {
  lazy val spiritformat = attributes("@{http://www.spiritconsortium.org/XMLSchema/SPIRIT/1685-2009}format").as[FormatType]
  lazy val spiritresolve = attributes.get("@{http://www.spiritconsortium.org/XMLSchema/SPIRIT/1685-2009}resolve") map { _.as[ResolveType]}
  lazy val spiritid = attributes.get("@{http://www.spiritconsortium.org/XMLSchema/SPIRIT/1685-2009}id") map { _.as[String]}
  lazy val spiritdependency = attributes.get("@{http://www.spiritconsortium.org/XMLSchema/SPIRIT/1685-2009}dependency") map { _.as[String]}
  lazy val spiritchoiceRef = attributes.get("@{http://www.spiritconsortium.org/XMLSchema/SPIRIT/1685-2009}choiceRef") map { _.as[String]}
  lazy val spiritorder = attributes.get("@{http://www.spiritconsortium.org/XMLSchema/SPIRIT/1685-2009}order") map { _.as[Float]}
  lazy val spiritconfigGroups = attributes.get("@{http://www.spiritconsortium.org/XMLSchema/SPIRIT/1685-2009}configGroups") map { _.as[Seq[String]]}
  lazy val spiritbitStringLength = attributes.get("@{http://www.spiritconsortium.org/XMLSchema/SPIRIT/1685-2009}bitStringLength") map { _.as[BigInt]}
  lazy val spiritminimum = attributes.get("@{http://www.spiritconsortium.org/XMLSchema/SPIRIT/1685-2009}minimum") map { _.as[String]}
  lazy val spiritmaximum = attributes.get("@{http://www.spiritconsortium.org/XMLSchema/SPIRIT/1685-2009}maximum") map { _.as[String]}
  lazy val spiritrangeType = attributes("@{http://www.spiritconsortium.org/XMLSchema/SPIRIT/1685-2009}rangeType").as[RangeTypeType]
  lazy val spiritprompt = attributes.get("@{http://www.spiritconsortium.org/XMLSchema/SPIRIT/1685-2009}prompt") map { _.as[String]}
}

      
      


case class Segment(nameGroupSequence1: NameGroupSequence,
  addressOffset: AddressOffset,
  range: RangeType2,
  vendorExtensions: Option[VendorExtensions] = None)
      
      


case class Segments(segment: Seq[Segment] = Nil)
      
      


case class AddressSpace(nameGroupSequence1: NameGroupSequence,
  blockSizeSequence2: BlockSizeSequence,
  segments: Option[Segments] = None,
  addressUnitBits: Option[BigInt] = None,
  executableImage: Seq[ExecutableImage] = Nil,
  localMemoryMap: Option[LocalMemoryMapType] = None,
  parameters: Option[Parameters] = None,
  vendorExtensions: Option[VendorExtensions] = None)
      
      


case class AddressSpaces(addressSpace: Seq[AddressSpace] = Nil)
      
      


case class MemoryMaps(memoryMap: Seq[MemoryMapType] = Nil)
      
      


case class BaseAddress2(value: String,
  attributes: Map[String, IPXACT2009scalaxb.DataRecord[Any]] = Map.empty) {
  lazy val spiritformat = attributes("@{http://www.spiritconsortium.org/XMLSchema/SPIRIT/1685-2009}format").as[FormatType]
  lazy val spiritresolve = attributes.get("@{http://www.spiritconsortium.org/XMLSchema/SPIRIT/1685-2009}resolve") map { _.as[ResolveType]}
  lazy val spiritid = attributes.get("@{http://www.spiritconsortium.org/XMLSchema/SPIRIT/1685-2009}id") map { _.as[String]}
  lazy val spiritdependency = attributes.get("@{http://www.spiritconsortium.org/XMLSchema/SPIRIT/1685-2009}dependency") map { _.as[String]}
  lazy val spiritchoiceRef = attributes.get("@{http://www.spiritconsortium.org/XMLSchema/SPIRIT/1685-2009}choiceRef") map { _.as[String]}
  lazy val spiritorder = attributes.get("@{http://www.spiritconsortium.org/XMLSchema/SPIRIT/1685-2009}order") map { _.as[Float]}
  lazy val spiritconfigGroups = attributes.get("@{http://www.spiritconsortium.org/XMLSchema/SPIRIT/1685-2009}configGroups") map { _.as[Seq[String]]}
  lazy val spiritbitStringLength = attributes.get("@{http://www.spiritconsortium.org/XMLSchema/SPIRIT/1685-2009}bitStringLength") map { _.as[BigInt]}
  lazy val spiritminimum = attributes.get("@{http://www.spiritconsortium.org/XMLSchema/SPIRIT/1685-2009}minimum") map { _.as[String]}
  lazy val spiritmaximum = attributes.get("@{http://www.spiritconsortium.org/XMLSchema/SPIRIT/1685-2009}maximum") map { _.as[String]}
  lazy val spiritrangeType = attributes("@{http://www.spiritconsortium.org/XMLSchema/SPIRIT/1685-2009}rangeType").as[RangeTypeType]
  lazy val spiritprompt = attributes("@{http://www.spiritconsortium.org/XMLSchema/SPIRIT/1685-2009}prompt").as[String]
}

      
      


case class RangeType3(value: String,
  attributes: Map[String, IPXACT2009scalaxb.DataRecord[Any]] = Map.empty) {
  lazy val spiritformat = attributes("@{http://www.spiritconsortium.org/XMLSchema/SPIRIT/1685-2009}format").as[FormatType]
  lazy val spiritresolve = attributes.get("@{http://www.spiritconsortium.org/XMLSchema/SPIRIT/1685-2009}resolve") map { _.as[ResolveType]}
  lazy val spiritid = attributes.get("@{http://www.spiritconsortium.org/XMLSchema/SPIRIT/1685-2009}id") map { _.as[String]}
  lazy val spiritdependency = attributes.get("@{http://www.spiritconsortium.org/XMLSchema/SPIRIT/1685-2009}dependency") map { _.as[String]}
  lazy val spiritchoiceRef = attributes.get("@{http://www.spiritconsortium.org/XMLSchema/SPIRIT/1685-2009}choiceRef") map { _.as[String]}
  lazy val spiritorder = attributes.get("@{http://www.spiritconsortium.org/XMLSchema/SPIRIT/1685-2009}order") map { _.as[Float]}
  lazy val spiritconfigGroups = attributes.get("@{http://www.spiritconsortium.org/XMLSchema/SPIRIT/1685-2009}configGroups") map { _.as[Seq[String]]}
  lazy val spiritbitStringLength = attributes.get("@{http://www.spiritconsortium.org/XMLSchema/SPIRIT/1685-2009}bitStringLength") map { _.as[BigInt]}
  lazy val spiritminimum = attributes.get("@{http://www.spiritconsortium.org/XMLSchema/SPIRIT/1685-2009}minimum") map { _.as[String]}
  lazy val spiritmaximum = attributes.get("@{http://www.spiritconsortium.org/XMLSchema/SPIRIT/1685-2009}maximum") map { _.as[String]}
  lazy val spiritrangeType = attributes("@{http://www.spiritconsortium.org/XMLSchema/SPIRIT/1685-2009}rangeType").as[RangeTypeType]
  lazy val spiritprompt = attributes.get("@{http://www.spiritconsortium.org/XMLSchema/SPIRIT/1685-2009}prompt") map { _.as[String]}
}

      
      


case class Width(value: BigInt,
  attributes: Map[String, IPXACT2009scalaxb.DataRecord[Any]] = Map.empty) {
  lazy val spiritformat = attributes("@{http://www.spiritconsortium.org/XMLSchema/SPIRIT/1685-2009}format").as[FormatType]
  lazy val spiritresolve = attributes.get("@{http://www.spiritconsortium.org/XMLSchema/SPIRIT/1685-2009}resolve") map { _.as[ResolveType]}
  lazy val spiritid = attributes.get("@{http://www.spiritconsortium.org/XMLSchema/SPIRIT/1685-2009}id") map { _.as[String]}
  lazy val spiritdependency = attributes.get("@{http://www.spiritconsortium.org/XMLSchema/SPIRIT/1685-2009}dependency") map { _.as[String]}
  lazy val spiritchoiceRef = attributes.get("@{http://www.spiritconsortium.org/XMLSchema/SPIRIT/1685-2009}choiceRef") map { _.as[String]}
  lazy val spiritorder = attributes.get("@{http://www.spiritconsortium.org/XMLSchema/SPIRIT/1685-2009}order") map { _.as[Float]}
  lazy val spiritconfigGroups = attributes.get("@{http://www.spiritconsortium.org/XMLSchema/SPIRIT/1685-2009}configGroups") map { _.as[Seq[String]]}
  lazy val spiritbitStringLength = attributes.get("@{http://www.spiritconsortium.org/XMLSchema/SPIRIT/1685-2009}bitStringLength") map { _.as[BigInt]}
  lazy val spiritminimum = attributes.get("@{http://www.spiritconsortium.org/XMLSchema/SPIRIT/1685-2009}minimum") map { _.as[String]}
  lazy val spiritmaximum = attributes.get("@{http://www.spiritconsortium.org/XMLSchema/SPIRIT/1685-2009}maximum") map { _.as[String]}
  lazy val spiritrangeType = attributes("@{http://www.spiritconsortium.org/XMLSchema/SPIRIT/1685-2009}rangeType").as[RangeTypeType]
  lazy val spiritprompt = attributes.get("@{http://www.spiritconsortium.org/XMLSchema/SPIRIT/1685-2009}prompt") map { _.as[String]}
}

      
      


case class AlternateGroups(alternateGroup: Seq[String] = Nil)
      
      


case class AlternateRegister(nameGroupSequence1: NameGroupSequence,
  alternateGroups: AlternateGroups,
  alternateRegisterDefinitionGroupSequence3: AlternateRegisterDefinitionGroupSequence,
  parameters: Option[Parameters] = None,
  vendorExtensions: Option[VendorExtensions] = None,
  attributes: Map[String, IPXACT2009scalaxb.DataRecord[Any]] = Map.empty) {
  lazy val spiritid = attributes.get("@{http://www.spiritconsortium.org/XMLSchema/SPIRIT/1685-2009}id") map { _.as[String]}
}

      
      


case class AlternateRegisters(alternateRegister: Seq[AlternateRegister] = Nil)
      
      


case class Register(nameGroupSequence1: NameGroupSequence,
  dim: Seq[BigInt] = Nil,
  addressOffset: String,
  registerDefinitionGroupSequence4: RegisterDefinitionGroupSequence,
  alternateRegisters: Option[AlternateRegisters] = None,
  parameters: Option[Parameters] = None,
  vendorExtensions: Option[VendorExtensions] = None,
  attributes: Map[String, IPXACT2009scalaxb.DataRecord[Any]] = Map.empty) {
  lazy val spiritid = attributes.get("@{http://www.spiritconsortium.org/XMLSchema/SPIRIT/1685-2009}id") map { _.as[String]}
}

      
      

sealed trait Usage

object Usage {
  def fromString(value: String, scope: scala.xml.NamespaceBinding)(implicit fmt: IPXACT2009scalaxb.XMLFormat[Usage]): Usage = fmt.reads(scala.xml.Text(value), Nil) match {
    case Right(x: Usage) => x
    case x => throw new RuntimeException(s"fromString returned unexpected value $x for input $value")
  }
  lazy val values: Seq[Usage] = Seq(Read, Write, Readu45writeValue)
}

case object Read extends Usage { override def toString = "read" }
case object Write extends Usage { override def toString = "write" }
case object Readu45writeValue extends Usage { override def toString = "read-write" }


case class EnumeratedValue(nameGroupSequence1: NameGroupSequence,
  value: String,
  vendorExtensions: Option[VendorExtensions] = None,
  attributes: Map[String, IPXACT2009scalaxb.DataRecord[Any]] = Map.empty) {
  lazy val usage = attributes("@usage").as[Usage]
}

      
      


case class EnumeratedValues(enumeratedValue: Seq[EnumeratedValue] = Nil)
      
      


/** This type is used to specify a value and optional mask that are configurable
*/
case class ValueMaskConfigType()
      
      

sealed trait ModifiedWriteValue

object ModifiedWriteValue {
  def fromString(value: String, scope: scala.xml.NamespaceBinding)(implicit fmt: IPXACT2009scalaxb.XMLFormat[ModifiedWriteValue]): ModifiedWriteValue = fmt.reads(scala.xml.Text(value), Nil) match {
    case Right(x: ModifiedWriteValue) => x
    case x => throw new RuntimeException(s"fromString returned unexpected value $x for input $value")
  }
  lazy val values: Seq[ModifiedWriteValue] = Seq(OneToClear, OneToSet, OneToToggle, ZeroToClear, ZeroToSet, ZeroToToggle, Clear, SetType, Modify)
}

case object OneToClear extends ModifiedWriteValue { override def toString = "oneToClear" }
case object OneToSet extends ModifiedWriteValue { override def toString = "oneToSet" }
case object OneToToggle extends ModifiedWriteValue { override def toString = "oneToToggle" }
case object ZeroToClear extends ModifiedWriteValue { override def toString = "zeroToClear" }
case object ZeroToSet extends ModifiedWriteValue { override def toString = "zeroToSet" }
case object ZeroToToggle extends ModifiedWriteValue { override def toString = "zeroToToggle" }
case object Clear extends ModifiedWriteValue { override def toString = "clear" }
case object SetType extends ModifiedWriteValue { override def toString = "set" }
case object Modify extends ModifiedWriteValue { override def toString = "modify" }

sealed trait ReadAction

object ReadAction {
  def fromString(value: String, scope: scala.xml.NamespaceBinding)(implicit fmt: IPXACT2009scalaxb.XMLFormat[ReadAction]): ReadAction = fmt.reads(scala.xml.Text(value), Nil) match {
    case Right(x: ReadAction) => x
    case x => throw new RuntimeException(s"fromString returned unexpected value $x for input $value")
  }
  lazy val values: Seq[ReadAction] = Seq(ClearValue, SetTypeValue, ModifyValue)
}

case object ClearValue extends ReadAction { override def toString = "clear" }
case object SetTypeValue extends ReadAction { override def toString = "set" }
case object ModifyValue extends ReadAction { override def toString = "modify" }

sealed trait TestConstraint

object TestConstraint {
  def fromString(value: String, scope: scala.xml.NamespaceBinding)(implicit fmt: IPXACT2009scalaxb.XMLFormat[TestConstraint]): TestConstraint = fmt.reads(scala.xml.Text(value), Nil) match {
    case Right(x: TestConstraint) => x
    case x => throw new RuntimeException(s"fromString returned unexpected value $x for input $value")
  }
  lazy val values: Seq[TestConstraint] = Seq(Unconstrained, Restore, WriteAsRead, ReadOnly)
}

case object Unconstrained extends TestConstraint { override def toString = "unconstrained" }
case object Restore extends TestConstraint { override def toString = "restore" }
case object WriteAsRead extends TestConstraint { override def toString = "writeAsRead" }
case object ReadOnly extends TestConstraint { override def toString = "readOnly" }


case class Testable(value: Boolean,
  attributes: Map[String, IPXACT2009scalaxb.DataRecord[Any]] = Map.empty) {
  lazy val testConstraint = attributes("@testConstraint").as[TestConstraint]
}

      
      


case class Minimum(value: String,
  attributes: Map[String, IPXACT2009scalaxb.DataRecord[Any]] = Map.empty) {
  lazy val spiritformat = attributes("@{http://www.spiritconsortium.org/XMLSchema/SPIRIT/1685-2009}format").as[FormatType]
  lazy val spiritresolve = attributes.get("@{http://www.spiritconsortium.org/XMLSchema/SPIRIT/1685-2009}resolve") map { _.as[ResolveType]}
  lazy val spiritid = attributes.get("@{http://www.spiritconsortium.org/XMLSchema/SPIRIT/1685-2009}id") map { _.as[String]}
  lazy val spiritdependency = attributes.get("@{http://www.spiritconsortium.org/XMLSchema/SPIRIT/1685-2009}dependency") map { _.as[String]}
  lazy val spiritchoiceRef = attributes.get("@{http://www.spiritconsortium.org/XMLSchema/SPIRIT/1685-2009}choiceRef") map { _.as[String]}
  lazy val spiritorder = attributes.get("@{http://www.spiritconsortium.org/XMLSchema/SPIRIT/1685-2009}order") map { _.as[Float]}
  lazy val spiritconfigGroups = attributes.get("@{http://www.spiritconsortium.org/XMLSchema/SPIRIT/1685-2009}configGroups") map { _.as[Seq[String]]}
  lazy val spiritbitStringLength = attributes.get("@{http://www.spiritconsortium.org/XMLSchema/SPIRIT/1685-2009}bitStringLength") map { _.as[BigInt]}
  lazy val spiritminimum = attributes.get("@{http://www.spiritconsortium.org/XMLSchema/SPIRIT/1685-2009}minimum") map { _.as[String]}
  lazy val spiritmaximum = attributes.get("@{http://www.spiritconsortium.org/XMLSchema/SPIRIT/1685-2009}maximum") map { _.as[String]}
  lazy val spiritrangeType = attributes("@{http://www.spiritconsortium.org/XMLSchema/SPIRIT/1685-2009}rangeType").as[RangeTypeType]
  lazy val spiritprompt = attributes.get("@{http://www.spiritconsortium.org/XMLSchema/SPIRIT/1685-2009}prompt") map { _.as[String]}
}

      
      


case class Maximum(value: String,
  attributes: Map[String, IPXACT2009scalaxb.DataRecord[Any]] = Map.empty) {
  lazy val spiritformat = attributes("@{http://www.spiritconsortium.org/XMLSchema/SPIRIT/1685-2009}format").as[FormatType]
  lazy val spiritresolve = attributes.get("@{http://www.spiritconsortium.org/XMLSchema/SPIRIT/1685-2009}resolve") map { _.as[ResolveType]}
  lazy val spiritid = attributes.get("@{http://www.spiritconsortium.org/XMLSchema/SPIRIT/1685-2009}id") map { _.as[String]}
  lazy val spiritdependency = attributes.get("@{http://www.spiritconsortium.org/XMLSchema/SPIRIT/1685-2009}dependency") map { _.as[String]}
  lazy val spiritchoiceRef = attributes.get("@{http://www.spiritconsortium.org/XMLSchema/SPIRIT/1685-2009}choiceRef") map { _.as[String]}
  lazy val spiritorder = attributes.get("@{http://www.spiritconsortium.org/XMLSchema/SPIRIT/1685-2009}order") map { _.as[Float]}
  lazy val spiritconfigGroups = attributes.get("@{http://www.spiritconsortium.org/XMLSchema/SPIRIT/1685-2009}configGroups") map { _.as[Seq[String]]}
  lazy val spiritbitStringLength = attributes.get("@{http://www.spiritconsortium.org/XMLSchema/SPIRIT/1685-2009}bitStringLength") map { _.as[BigInt]}
  lazy val spiritminimum = attributes.get("@{http://www.spiritconsortium.org/XMLSchema/SPIRIT/1685-2009}minimum") map { _.as[String]}
  lazy val spiritmaximum = attributes.get("@{http://www.spiritconsortium.org/XMLSchema/SPIRIT/1685-2009}maximum") map { _.as[String]}
  lazy val spiritrangeType = attributes("@{http://www.spiritconsortium.org/XMLSchema/SPIRIT/1685-2009}rangeType").as[RangeTypeType]
  lazy val spiritprompt = attributes.get("@{http://www.spiritconsortium.org/XMLSchema/SPIRIT/1685-2009}prompt") map { _.as[String]}
}

      
      


/** A constraint on the values that can be written to this field. Absence of this element implies that any value that fits can be written to it.
*/
case class WriteValueConstraintType(writevalueconstrainttypeoption: IPXACT2009scalaxb.DataRecord[Any])
      
      

case class WriteValueConstraintTypeSequence1(minimum: Minimum,
  maximum: Maximum)
      

trait WriteValueConstraintTypeOption

case class RegisterFile(nameGroupSequence1: NameGroupSequence,
  dim: Seq[BigInt] = Nil,
  addressOffset: String,
  registerFileDefinitionGroupSequence4: RegisterFileDefinitionGroupSequence,
  parameters: Option[Parameters] = None,
  vendorExtensions: Option[VendorExtensions] = None,
  attributes: Map[String, IPXACT2009scalaxb.DataRecord[Any]] = Map.empty) {
  lazy val spiritid = attributes.get("@{http://www.spiritconsortium.org/XMLSchema/SPIRIT/1685-2009}id") map { _.as[String]}
}

      
      


case class BitWidth(value: BigInt,
  attributes: Map[String, IPXACT2009scalaxb.DataRecord[Any]] = Map.empty) {
  lazy val spiritformat = attributes("@{http://www.spiritconsortium.org/XMLSchema/SPIRIT/1685-2009}format").as[FormatType]
  lazy val spiritresolve = attributes.get("@{http://www.spiritconsortium.org/XMLSchema/SPIRIT/1685-2009}resolve") map { _.as[ResolveType]}
  lazy val spiritid = attributes.get("@{http://www.spiritconsortium.org/XMLSchema/SPIRIT/1685-2009}id") map { _.as[String]}
  lazy val spiritdependency = attributes.get("@{http://www.spiritconsortium.org/XMLSchema/SPIRIT/1685-2009}dependency") map { _.as[String]}
  lazy val spiritchoiceRef = attributes.get("@{http://www.spiritconsortium.org/XMLSchema/SPIRIT/1685-2009}choiceRef") map { _.as[String]}
  lazy val spiritorder = attributes.get("@{http://www.spiritconsortium.org/XMLSchema/SPIRIT/1685-2009}order") map { _.as[Float]}
  lazy val spiritconfigGroups = attributes.get("@{http://www.spiritconsortium.org/XMLSchema/SPIRIT/1685-2009}configGroups") map { _.as[Seq[String]]}
  lazy val spiritbitStringLength = attributes.get("@{http://www.spiritconsortium.org/XMLSchema/SPIRIT/1685-2009}bitStringLength") map { _.as[BigInt]}
  lazy val spiritminimum = attributes.get("@{http://www.spiritconsortium.org/XMLSchema/SPIRIT/1685-2009}minimum") map { _.as[String]}
  lazy val spiritmaximum = attributes.get("@{http://www.spiritconsortium.org/XMLSchema/SPIRIT/1685-2009}maximum") map { _.as[String]}
  lazy val spiritrangeType = attributes("@{http://www.spiritconsortium.org/XMLSchema/SPIRIT/1685-2009}rangeType").as[RangeTypeType]
  lazy val spiritprompt = attributes.get("@{http://www.spiritconsortium.org/XMLSchema/SPIRIT/1685-2009}prompt") map { _.as[String]}
}

      
      


case class RangeType4(value: String,
  attributes: Map[String, IPXACT2009scalaxb.DataRecord[Any]] = Map.empty) {
  lazy val spiritformat = attributes("@{http://www.spiritconsortium.org/XMLSchema/SPIRIT/1685-2009}format").as[FormatType]
  lazy val spiritresolve = attributes.get("@{http://www.spiritconsortium.org/XMLSchema/SPIRIT/1685-2009}resolve") map { _.as[ResolveType]}
  lazy val spiritid = attributes.get("@{http://www.spiritconsortium.org/XMLSchema/SPIRIT/1685-2009}id") map { _.as[String]}
  lazy val spiritdependency = attributes.get("@{http://www.spiritconsortium.org/XMLSchema/SPIRIT/1685-2009}dependency") map { _.as[String]}
  lazy val spiritchoiceRef = attributes.get("@{http://www.spiritconsortium.org/XMLSchema/SPIRIT/1685-2009}choiceRef") map { _.as[String]}
  lazy val spiritorder = attributes.get("@{http://www.spiritconsortium.org/XMLSchema/SPIRIT/1685-2009}order") map { _.as[Float]}
  lazy val spiritconfigGroups = attributes.get("@{http://www.spiritconsortium.org/XMLSchema/SPIRIT/1685-2009}configGroups") map { _.as[Seq[String]]}
  lazy val spiritbitStringLength = attributes.get("@{http://www.spiritconsortium.org/XMLSchema/SPIRIT/1685-2009}bitStringLength") map { _.as[BigInt]}
  lazy val spiritminimum = attributes.get("@{http://www.spiritconsortium.org/XMLSchema/SPIRIT/1685-2009}minimum") map { _.as[String]}
  lazy val spiritmaximum = attributes.get("@{http://www.spiritconsortium.org/XMLSchema/SPIRIT/1685-2009}maximum") map { _.as[String]}
  lazy val spiritrangeType = attributes("@{http://www.spiritconsortium.org/XMLSchema/SPIRIT/1685-2009}rangeType").as[RangeTypeType]
  lazy val spiritprompt = attributes.get("@{http://www.spiritconsortium.org/XMLSchema/SPIRIT/1685-2009}prompt") map { _.as[String]}
}

      
      


case class Size(value: BigInt,
  attributes: Map[String, IPXACT2009scalaxb.DataRecord[Any]] = Map.empty) {
  lazy val spiritformat = attributes("@{http://www.spiritconsortium.org/XMLSchema/SPIRIT/1685-2009}format").as[FormatType]
  lazy val spiritresolve = attributes.get("@{http://www.spiritconsortium.org/XMLSchema/SPIRIT/1685-2009}resolve") map { _.as[ResolveType]}
  lazy val spiritid = attributes.get("@{http://www.spiritconsortium.org/XMLSchema/SPIRIT/1685-2009}id") map { _.as[String]}
  lazy val spiritdependency = attributes.get("@{http://www.spiritconsortium.org/XMLSchema/SPIRIT/1685-2009}dependency") map { _.as[String]}
  lazy val spiritchoiceRef = attributes.get("@{http://www.spiritconsortium.org/XMLSchema/SPIRIT/1685-2009}choiceRef") map { _.as[String]}
  lazy val spiritorder = attributes.get("@{http://www.spiritconsortium.org/XMLSchema/SPIRIT/1685-2009}order") map { _.as[Float]}
  lazy val spiritconfigGroups = attributes.get("@{http://www.spiritconsortium.org/XMLSchema/SPIRIT/1685-2009}configGroups") map { _.as[Seq[String]]}
  lazy val spiritbitStringLength = attributes.get("@{http://www.spiritconsortium.org/XMLSchema/SPIRIT/1685-2009}bitStringLength") map { _.as[BigInt]}
  lazy val spiritminimum = attributes.get("@{http://www.spiritconsortium.org/XMLSchema/SPIRIT/1685-2009}minimum") map { _.as[String]}
  lazy val spiritmaximum = attributes.get("@{http://www.spiritconsortium.org/XMLSchema/SPIRIT/1685-2009}maximum") map { _.as[String]}
  lazy val spiritrangeType = attributes("@{http://www.spiritconsortium.org/XMLSchema/SPIRIT/1685-2009}rangeType").as[RangeTypeType]
  lazy val spiritprompt = attributes.get("@{http://www.spiritconsortium.org/XMLSchema/SPIRIT/1685-2009}prompt") map { _.as[String]}
}

      
      


case class Value2(value: String,
  attributes: Map[String, IPXACT2009scalaxb.DataRecord[Any]] = Map.empty) {
  lazy val spiritformat = attributes("@{http://www.spiritconsortium.org/XMLSchema/SPIRIT/1685-2009}format").as[FormatType]
  lazy val spiritresolve = attributes.get("@{http://www.spiritconsortium.org/XMLSchema/SPIRIT/1685-2009}resolve") map { _.as[ResolveType]}
  lazy val spiritid = attributes.get("@{http://www.spiritconsortium.org/XMLSchema/SPIRIT/1685-2009}id") map { _.as[String]}
  lazy val spiritdependency = attributes.get("@{http://www.spiritconsortium.org/XMLSchema/SPIRIT/1685-2009}dependency") map { _.as[String]}
  lazy val spiritchoiceRef = attributes.get("@{http://www.spiritconsortium.org/XMLSchema/SPIRIT/1685-2009}choiceRef") map { _.as[String]}
  lazy val spiritorder = attributes.get("@{http://www.spiritconsortium.org/XMLSchema/SPIRIT/1685-2009}order") map { _.as[Float]}
  lazy val spiritconfigGroups = attributes.get("@{http://www.spiritconsortium.org/XMLSchema/SPIRIT/1685-2009}configGroups") map { _.as[Seq[String]]}
  lazy val spiritbitStringLength = attributes.get("@{http://www.spiritconsortium.org/XMLSchema/SPIRIT/1685-2009}bitStringLength") map { _.as[BigInt]}
  lazy val spiritminimum = attributes.get("@{http://www.spiritconsortium.org/XMLSchema/SPIRIT/1685-2009}minimum") map { _.as[String]}
  lazy val spiritmaximum = attributes.get("@{http://www.spiritconsortium.org/XMLSchema/SPIRIT/1685-2009}maximum") map { _.as[String]}
  lazy val spiritrangeType = attributes("@{http://www.spiritconsortium.org/XMLSchema/SPIRIT/1685-2009}rangeType").as[RangeTypeType]
  lazy val spiritprompt = attributes.get("@{http://www.spiritconsortium.org/XMLSchema/SPIRIT/1685-2009}prompt") map { _.as[String]}
}

      
      


case class Mask(value: String,
  attributes: Map[String, IPXACT2009scalaxb.DataRecord[Any]] = Map.empty) {
  lazy val spiritformat = attributes("@{http://www.spiritconsortium.org/XMLSchema/SPIRIT/1685-2009}format").as[FormatType]
  lazy val spiritresolve = attributes.get("@{http://www.spiritconsortium.org/XMLSchema/SPIRIT/1685-2009}resolve") map { _.as[ResolveType]}
  lazy val spiritid = attributes.get("@{http://www.spiritconsortium.org/XMLSchema/SPIRIT/1685-2009}id") map { _.as[String]}
  lazy val spiritdependency = attributes.get("@{http://www.spiritconsortium.org/XMLSchema/SPIRIT/1685-2009}dependency") map { _.as[String]}
  lazy val spiritchoiceRef = attributes.get("@{http://www.spiritconsortium.org/XMLSchema/SPIRIT/1685-2009}choiceRef") map { _.as[String]}
  lazy val spiritorder = attributes.get("@{http://www.spiritconsortium.org/XMLSchema/SPIRIT/1685-2009}order") map { _.as[Float]}
  lazy val spiritconfigGroups = attributes.get("@{http://www.spiritconsortium.org/XMLSchema/SPIRIT/1685-2009}configGroups") map { _.as[Seq[String]]}
  lazy val spiritbitStringLength = attributes.get("@{http://www.spiritconsortium.org/XMLSchema/SPIRIT/1685-2009}bitStringLength") map { _.as[BigInt]}
  lazy val spiritminimum = attributes.get("@{http://www.spiritconsortium.org/XMLSchema/SPIRIT/1685-2009}minimum") map { _.as[String]}
  lazy val spiritmaximum = attributes.get("@{http://www.spiritconsortium.org/XMLSchema/SPIRIT/1685-2009}maximum") map { _.as[String]}
  lazy val spiritrangeType = attributes("@{http://www.spiritconsortium.org/XMLSchema/SPIRIT/1685-2009}rangeType").as[RangeTypeType]
  lazy val spiritprompt = attributes.get("@{http://www.spiritconsortium.org/XMLSchema/SPIRIT/1685-2009}prompt") map { _.as[String]}
}

      
      


case class Reset(value: Value2,
  mask: Option[Mask] = None)
      
      


case class Value3(value: String,
  attributes: Map[String, IPXACT2009scalaxb.DataRecord[Any]] = Map.empty) {
  lazy val spiritformat = attributes("@{http://www.spiritconsortium.org/XMLSchema/SPIRIT/1685-2009}format").as[FormatType]
  lazy val spiritresolve = attributes.get("@{http://www.spiritconsortium.org/XMLSchema/SPIRIT/1685-2009}resolve") map { _.as[ResolveType]}
  lazy val spiritid = attributes.get("@{http://www.spiritconsortium.org/XMLSchema/SPIRIT/1685-2009}id") map { _.as[String]}
  lazy val spiritdependency = attributes.get("@{http://www.spiritconsortium.org/XMLSchema/SPIRIT/1685-2009}dependency") map { _.as[String]}
  lazy val spiritchoiceRef = attributes.get("@{http://www.spiritconsortium.org/XMLSchema/SPIRIT/1685-2009}choiceRef") map { _.as[String]}
  lazy val spiritorder = attributes.get("@{http://www.spiritconsortium.org/XMLSchema/SPIRIT/1685-2009}order") map { _.as[Float]}
  lazy val spiritconfigGroups = attributes.get("@{http://www.spiritconsortium.org/XMLSchema/SPIRIT/1685-2009}configGroups") map { _.as[Seq[String]]}
  lazy val spiritbitStringLength = attributes.get("@{http://www.spiritconsortium.org/XMLSchema/SPIRIT/1685-2009}bitStringLength") map { _.as[BigInt]}
  lazy val spiritminimum = attributes.get("@{http://www.spiritconsortium.org/XMLSchema/SPIRIT/1685-2009}minimum") map { _.as[String]}
  lazy val spiritmaximum = attributes.get("@{http://www.spiritconsortium.org/XMLSchema/SPIRIT/1685-2009}maximum") map { _.as[String]}
  lazy val spiritrangeType = attributes("@{http://www.spiritconsortium.org/XMLSchema/SPIRIT/1685-2009}rangeType").as[RangeTypeType]
  lazy val spiritprompt = attributes.get("@{http://www.spiritconsortium.org/XMLSchema/SPIRIT/1685-2009}prompt") map { _.as[String]}
}

      
      


case class Mask2(value: String,
  attributes: Map[String, IPXACT2009scalaxb.DataRecord[Any]] = Map.empty) {
  lazy val spiritformat = attributes("@{http://www.spiritconsortium.org/XMLSchema/SPIRIT/1685-2009}format").as[FormatType]
  lazy val spiritresolve = attributes.get("@{http://www.spiritconsortium.org/XMLSchema/SPIRIT/1685-2009}resolve") map { _.as[ResolveType]}
  lazy val spiritid = attributes.get("@{http://www.spiritconsortium.org/XMLSchema/SPIRIT/1685-2009}id") map { _.as[String]}
  lazy val spiritdependency = attributes.get("@{http://www.spiritconsortium.org/XMLSchema/SPIRIT/1685-2009}dependency") map { _.as[String]}
  lazy val spiritchoiceRef = attributes.get("@{http://www.spiritconsortium.org/XMLSchema/SPIRIT/1685-2009}choiceRef") map { _.as[String]}
  lazy val spiritorder = attributes.get("@{http://www.spiritconsortium.org/XMLSchema/SPIRIT/1685-2009}order") map { _.as[Float]}
  lazy val spiritconfigGroups = attributes.get("@{http://www.spiritconsortium.org/XMLSchema/SPIRIT/1685-2009}configGroups") map { _.as[Seq[String]]}
  lazy val spiritbitStringLength = attributes.get("@{http://www.spiritconsortium.org/XMLSchema/SPIRIT/1685-2009}bitStringLength") map { _.as[BigInt]}
  lazy val spiritminimum = attributes.get("@{http://www.spiritconsortium.org/XMLSchema/SPIRIT/1685-2009}minimum") map { _.as[String]}
  lazy val spiritmaximum = attributes.get("@{http://www.spiritconsortium.org/XMLSchema/SPIRIT/1685-2009}maximum") map { _.as[String]}
  lazy val spiritrangeType = attributes("@{http://www.spiritconsortium.org/XMLSchema/SPIRIT/1685-2009}rangeType").as[RangeTypeType]
  lazy val spiritprompt = attributes.get("@{http://www.spiritconsortium.org/XMLSchema/SPIRIT/1685-2009}prompt") map { _.as[String]}
}

      
      


case class Reset2(value: Value3,
  mask: Option[Mask2] = None)
      
      

case class AlternateRegisterDefinitionGroupSequence(typeIdentifier: Option[String] = None,
  volatile: Option[Boolean] = None,
  access: Option[AccessType] = None,
  reset: Option[Reset2] = None,
  field: Seq[FieldType] = Nil)
      

case class AddressBlockDefinitionGroupSequence(typeIdentifier: Option[String] = None,
  blockSizeSequence2: BlockSizeSequence,
  memoryBlockDataSequence3: MemoryBlockDataSequence,
  registerDataSequence4: RegisterDataSequence)
      

case class FieldDefinitionGroupSequence(typeIdentifier: Option[String] = None,
  bitWidth: BitWidth,
  fieldDataSequence3: FieldDataSequence)
      

case class RegisterDataSequence(register: Seq[Register] = Nil,
  registerFile: Seq[RegisterFile] = Nil)
      

case class BlockSizeSequence(range: RangeType3,
  width: Width)
      

case class AddressSpecifierSequence(baseAddress: BaseAddress2)
      
trait MemoryMapOption
case class AddressBlockExtensionsSequence(memoryBlockDataSequence1: MemoryBlockDataSequence,
  registerDataSequence2: RegisterDataSequence)
      

case class BankBaseSequence(bankbaseoption1: Seq[IPXACT2009scalaxb.DataRecord[BankBaseOption1]] = Nil,
  memoryBlockDataSequence2: MemoryBlockDataSequence,
  vendorExtensions: Option[VendorExtensions] = None)
      

trait BankBaseOption1
case class MemoryBlockDataSequence(usage: Option[UsageType] = None,
  volatile: Option[Boolean] = None,
  access: Option[AccessType] = None,
  parameters: Option[Parameters] = None)
      

case class FieldDataSequence(volatile: Option[Boolean] = None,
  access: Option[AccessType] = None,
  enumeratedValues: Option[EnumeratedValues] = None,
  modifiedWriteValue: Option[ModifiedWriteValue] = None,
  writeValueConstraint: Option[WriteValueConstraintType] = None,
  readAction: Option[ReadAction] = None,
  testable: Option[Testable] = None)
      

case class RegisterFileDefinitionGroupSequence(typeIdentifier: Option[String] = None,
  range: RangeType4,
  registerDataSequence3: RegisterDataSequence)
      

case class RegisterDefinitionGroupSequence(typeIdentifier: Option[String] = None,
  size: Size,
  volatile: Option[Boolean] = None,
  access: Option[AccessType] = None,
  reset: Option[Reset] = None,
  field: Seq[FieldType] = Nil)
      


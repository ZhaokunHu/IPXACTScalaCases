// Generated by <a href="http://IPXACT2022scalaxb.org/">IPXACT2022scalaxb</a>.
package IPXACT2022ScalaCases

sealed trait ComponentPortDirectionType

object ComponentPortDirectionType {
  def fromString(value: String, scope: scala.xml.NamespaceBinding)(implicit fmt: IPXACT2022scalaxb.XMLFormat[IPXACT2022ScalaCases.ComponentPortDirectionType]): ComponentPortDirectionType = fmt.reads(scala.xml.Text(value), Nil) match {
    case Right(x: ComponentPortDirectionType) => x
    case x => throw new RuntimeException(s"fromString returned unexpected value $x for input $value")
  }
  lazy val values: Seq[ComponentPortDirectionType] = Seq(InValue, OutValue, InoutValue, Phantom)
}

case object InValue extends ComponentPortDirectionType { override def toString = "in" }
case object OutValue extends ComponentPortDirectionType { override def toString = "out" }
case object InoutValue extends ComponentPortDirectionType { override def toString = "inout" }
case object Phantom extends ComponentPortDirectionType { override def toString = "phantom" }


/** A port description, giving a name and an access type for high level ports. 
*/
trait PortTypable {
  def nameGroupPortSequence1: IPXACT2022ScalaCases.NameGroupPortSequence
  def porttypableoption: IPXACT2022scalaxb.DataRecord[IPXACT2022ScalaCases.PortTypableOption]
  def fieldMaps: Option[IPXACT2022ScalaCases.FieldMaps]
  def arrays: Option[IPXACT2022ScalaCases.Arrays]
  def access: Option[IPXACT2022ScalaCases.PortAccessType]
  def parameters: Option[IPXACT2022ScalaCases.Parameters]
  def vendorExtensions: Option[IPXACT2022ScalaCases.VendorExtensions]
  def xmlid: Option[String]
}


/** A port description, giving a name and an access type for high level ports. 
*/
case class PortType(nameGroupPortSequence1: IPXACT2022ScalaCases.NameGroupPortSequence,
  porttypableoption: IPXACT2022scalaxb.DataRecord[IPXACT2022ScalaCases.PortTypableOption],
  fieldMaps: Option[IPXACT2022ScalaCases.FieldMaps] = None,
  arrays: Option[IPXACT2022ScalaCases.Arrays] = None,
  access: Option[IPXACT2022ScalaCases.PortAccessType] = None,
  parameters: Option[IPXACT2022ScalaCases.Parameters] = None,
  vendorExtensions: Option[IPXACT2022ScalaCases.VendorExtensions] = None,
  attributes: Map[String, IPXACT2022scalaxb.DataRecord[Any]] = Map.empty) extends PortTypable {
  lazy val xmlid = attributes.get("@{http://www.w3.org/XML/1998/namespace}id") map { _.as[String]}
}

      
      

trait PortTypableOption

/** A port description, giving a name and an access type for high level ports. 
*/
case class AbstractorPortType(nameGroupPortSequence1: IPXACT2022ScalaCases.NameGroupPortSequence,
  abstractorporttypeoption: IPXACT2022scalaxb.DataRecord[IPXACT2022ScalaCases.AbstractorPortTypeOption],
  arrays: Option[IPXACT2022ScalaCases.Arrays] = None,
  access: Option[IPXACT2022ScalaCases.PortAccessType] = None,
  parameters: Option[IPXACT2022ScalaCases.Parameters] = None,
  vendorExtensions: Option[IPXACT2022ScalaCases.VendorExtensions] = None,
  attributes: Map[String, IPXACT2022scalaxb.DataRecord[Any]] = Map.empty) {
  lazy val xmlid = attributes.get("@{http://www.w3.org/XML/1998/namespace}id") map { _.as[String]}
}

      
      

trait AbstractorPortTypeOption
sealed trait InitiativeType

object InitiativeType {
  def fromString(value: String, scope: scala.xml.NamespaceBinding)(implicit fmt: IPXACT2022scalaxb.XMLFormat[IPXACT2022ScalaCases.InitiativeType]): InitiativeType = fmt.reads(scala.xml.Text(value), Nil) match {
    case Right(x: InitiativeType) => x
    case x => throw new RuntimeException(s"fromString returned unexpected value $x for input $value")
  }
  lazy val values: Seq[InitiativeType] = Seq(Requires, Provides, Both, PhantomValue)
}

case object Requires extends InitiativeType { override def toString = "requires" }
case object Provides extends InitiativeType { override def toString = "provides" }
case object Both extends InitiativeType { override def toString = "both" }
case object PhantomValue extends InitiativeType { override def toString = "phantom" }


case class ProtocolType(value: IPXACT2022ScalaCases.ProtocolTypeType,
  attributes: Map[String, IPXACT2022scalaxb.DataRecord[Any]] = Map.empty) {
  lazy val custom = attributes.get("@custom") map { _.as[String]}
}

      
      


case class Protocol(protocolType: IPXACT2022ScalaCases.ProtocolType,
  payload: Option[IPXACT2022ScalaCases.Payload] = None)
      
      

sealed trait ProtocolTypeType

object ProtocolTypeType {
  def fromString(value: String, scope: scala.xml.NamespaceBinding)(implicit fmt: IPXACT2022scalaxb.XMLFormat[IPXACT2022ScalaCases.ProtocolTypeType]): ProtocolTypeType = fmt.reads(scala.xml.Text(value), Nil) match {
    case Right(x: ProtocolTypeType) => x
    case x => throw new RuntimeException(s"fromString returned unexpected value $x for input $value")
  }
  lazy val values: Seq[ProtocolTypeType] = Seq(Tlm, Custom)
}

case object Tlm extends ProtocolTypeType { override def toString = "tlm" }
case object Custom extends ProtocolTypeType { override def toString = "custom" }

sealed trait KindType

object KindType {
  def fromString(value: String, scope: scala.xml.NamespaceBinding)(implicit fmt: IPXACT2022scalaxb.XMLFormat[IPXACT2022ScalaCases.KindType]): KindType = fmt.reads(scala.xml.Text(value), Nil) match {
    case Right(x: KindType) => x
    case x => throw new RuntimeException(s"fromString returned unexpected value $x for input $value")
  }
  lazy val values: Seq[KindType] = Seq(Tlm_port, Tlm_socket, Simple_socket, Multi_socket, CustomValue)
}

case object Tlm_port extends KindType { override def toString = "tlm_port" }
case object Tlm_socket extends KindType { override def toString = "tlm_socket" }
case object Simple_socket extends KindType { override def toString = "simple_socket" }
case object Multi_socket extends KindType { override def toString = "multi_socket" }
case object CustomValue extends KindType { override def toString = "custom" }


case class Kind(value: IPXACT2022ScalaCases.KindType,
  attributes: Map[String, IPXACT2022scalaxb.DataRecord[Any]] = Map.empty) {
  lazy val custom = attributes.get("@custom") map { _.as[String]}
}

      
      

sealed trait SimplePortAccessType

object SimplePortAccessType {
  def fromString(value: String, scope: scala.xml.NamespaceBinding)(implicit fmt: IPXACT2022scalaxb.XMLFormat[IPXACT2022ScalaCases.SimplePortAccessType]): SimplePortAccessType = fmt.reads(scala.xml.Text(value), Nil) match {
    case Right(x: SimplePortAccessType) => x
    case x => throw new RuntimeException(s"fromString returned unexpected value $x for input $value")
  }
  lazy val values: Seq[SimplePortAccessType] = Seq(Ref, Ptr)
}

case object Ref extends SimplePortAccessType { override def toString = "ref" }
case object Ptr extends SimplePortAccessType { override def toString = "ptr" }

sealed trait Type

object Type {
  def fromString(value: String, scope: scala.xml.NamespaceBinding)(implicit fmt: IPXACT2022scalaxb.XMLFormat[IPXACT2022ScalaCases.Type]): Type = fmt.reads(scala.xml.Text(value), Nil) match {
    case Right(x: Type) => x
    case x => throw new RuntimeException(s"fromString returned unexpected value $x for input $value")
  }
  lazy val values: Seq[Type] = Seq(Generic, Specific)
}

case object Generic extends Type { override def toString = "generic" }
case object Specific extends Type { override def toString = "specific" }


case class Extension(value: String,
  attributes: Map[String, IPXACT2022scalaxb.DataRecord[Any]] = Map.empty) {
  lazy val mandatory = attributes("@mandatory").as[Boolean]
}

      
      


case class Payload(name: Option[String] = None,
  typeValue: IPXACT2022ScalaCases.Type,
  extension: Option[IPXACT2022ScalaCases.Extension] = None,
  vendorExtensions: Option[IPXACT2022ScalaCases.VendorExtensions] = None)
      
      


case class TypeParameters(typeParameter: Seq[IPXACT2022ScalaCases.ModuleParameterType] = Nil,
  serviceTypeDef: Seq[IPXACT2022ScalaCases.ServiceTypeDef] = Nil)
      
      


case class TypeName(value: String,
  attributes: Map[String, IPXACT2022scalaxb.DataRecord[Any]] = Map.empty) {
  lazy val exact = attributes("@exact").as[Boolean]
}

      
      


case class TypeDefinition(value: String,
  attributes: Map[String, IPXACT2022scalaxb.DataRecord[Any]] = Map.empty) {
  lazy val xmlid = attributes.get("@{http://www.w3.org/XML/1998/namespace}id") map { _.as[String]}
}

      
      


case class ViewRef6(value: String,
  attributes: Map[String, IPXACT2022scalaxb.DataRecord[Any]] = Map.empty) {
  lazy val xmlid = attributes.get("@{http://www.w3.org/XML/1998/namespace}id") map { _.as[String]}
}

      
      


case class TransTypeDef(typeName: Option[IPXACT2022ScalaCases.TypeName] = None,
  typeDefinition: Seq[IPXACT2022ScalaCases.TypeDefinition] = Nil,
  typeParameters: Option[IPXACT2022ScalaCases.TypeParameters] = None,
  viewRef: Seq[IPXACT2022ScalaCases.ViewRef6] = Nil,
  attributes: Map[String, IPXACT2022scalaxb.DataRecord[Any]] = Map.empty) {
  lazy val xmlid = attributes.get("@{http://www.w3.org/XML/1998/namespace}id") map { _.as[String]}
}

      
      


case class TypeName2(value: String,
  attributes: Map[String, IPXACT2022scalaxb.DataRecord[Any]] = Map.empty) {
  lazy val implicitValue = attributes("@implicit").as[Boolean]
}

      
      


case class TypeDefinition2(value: String,
  attributes: Map[String, IPXACT2022scalaxb.DataRecord[Any]] = Map.empty) {
  lazy val xmlid = attributes.get("@{http://www.w3.org/XML/1998/namespace}id") map { _.as[String]}
}

      
      


case class ServiceTypeDef(typeName: IPXACT2022ScalaCases.TypeName2,
  typeDefinition: Seq[IPXACT2022ScalaCases.TypeDefinition2] = Nil,
  typeParameters: Option[IPXACT2022ScalaCases.TypeParameters] = None,
  attributes: Map[String, IPXACT2022scalaxb.DataRecord[Any]] = Map.empty) {
  lazy val xmlid = attributes.get("@{http://www.w3.org/XML/1998/namespace}id") map { _.as[String]}
}

      
      


case class TypeName3(value: String,
  attributes: Map[String, IPXACT2022scalaxb.DataRecord[Any]] = Map.empty) {
  lazy val constrained = attributes.get("@constrained") map { _.as[Seq[String]]}
}

      
      


case class TypeDefinition3(value: String,
  attributes: Map[String, IPXACT2022scalaxb.DataRecord[Any]] = Map.empty) {
  lazy val xmlid = attributes.get("@{http://www.w3.org/XML/1998/namespace}id") map { _.as[String]}
}

      
      


case class ViewRef7(value: String,
  attributes: Map[String, IPXACT2022scalaxb.DataRecord[Any]] = Map.empty) {
  lazy val xmlid = attributes.get("@{http://www.w3.org/XML/1998/namespace}id") map { _.as[String]}
}

      
      


case class WireTypeDef(typeName: Option[IPXACT2022ScalaCases.TypeName3] = None,
  typeDefinition: Seq[IPXACT2022ScalaCases.TypeDefinition3] = Nil,
  viewRef: Seq[IPXACT2022ScalaCases.ViewRef7] = Nil,
  attributes: Map[String, IPXACT2022scalaxb.DataRecord[Any]] = Map.empty) {
  lazy val xmlid = attributes.get("@{http://www.w3.org/XML/1998/namespace}id") map { _.as[String]}
}

      
      


case class WireTypeDefs(wireTypeDef: Seq[IPXACT2022ScalaCases.WireTypeDef] = Nil)
      
      


case class TransTypeDefs(transTypeDef: Seq[IPXACT2022ScalaCases.TransTypeDef] = Nil)
      
      


case class Port2(nameGroupPortSequence1: IPXACT2022ScalaCases.NameGroupPortSequence,
  porttypableoption: IPXACT2022scalaxb.DataRecord[IPXACT2022ScalaCases.PortTypableOption],
  fieldMaps: Option[IPXACT2022ScalaCases.FieldMaps] = None,
  arrays: Option[IPXACT2022ScalaCases.Arrays] = None,
  access: Option[IPXACT2022ScalaCases.PortAccessType] = None,
  parameters: Option[IPXACT2022ScalaCases.Parameters] = None,
  vendorExtensions: Option[IPXACT2022ScalaCases.VendorExtensions] = None,
  attributes: Map[String, IPXACT2022scalaxb.DataRecord[Any]] = Map.empty) extends PortTypable {
  lazy val xmlid = attributes.get("@{http://www.w3.org/XML/1998/namespace}id") map { _.as[String]}
}

      
      


case class FieldSlice2(fieldSliceReferenceGroupSequence1: IPXACT2022ScalaCases.FieldSliceReferenceGroupSequence)
      
      


case class ModeRef4(value: String,
  attributes: Map[String, IPXACT2022scalaxb.DataRecord[Any]] = Map.empty) {
  lazy val priority = attributes("@priority").as[BigInt]
  lazy val xmlid = attributes.get("@{http://www.w3.org/XML/1998/namespace}id") map { _.as[String]}
}

      
      


case class FieldMap(fieldSlice: IPXACT2022ScalaCases.FieldSlice2,
  subPortReference: Seq[IPXACT2022ScalaCases.SubPortReference] = Nil,
  partSelect: Option[IPXACT2022ScalaCases.PartSelect] = None,
  modeRef: Seq[IPXACT2022ScalaCases.ModeRef4] = Nil,
  attributes: Map[String, IPXACT2022scalaxb.DataRecord[Any]] = Map.empty) {
  lazy val xmlid = attributes.get("@{http://www.w3.org/XML/1998/namespace}id") map { _.as[String]}
}

      
      


case class FieldMaps(fieldMap: Seq[IPXACT2022ScalaCases.FieldMap] = Nil)
      
      


case class PowerConstraints(powerConstraint: Seq[IPXACT2022ScalaCases.WirePowerConstraintType] = Nil)
      
      


/** Wire port type for a component.
*/
trait PortWireTypable extends PortTypableOption with SubPortTypeOption {
  def direction: IPXACT2022ScalaCases.ComponentPortDirectionType
  def qualifier: Option[IPXACT2022ScalaCases.QualifierType]
  def vectors: Option[IPXACT2022ScalaCases.ExtendedVectorsType]
  def wireTypeDefs: Option[IPXACT2022ScalaCases.WireTypeDefs]
  def domainTypeDefs: Option[IPXACT2022ScalaCases.DomainTypeDefs]
  def signalTypeDefs: Option[IPXACT2022ScalaCases.SignalTypeDefs]
  def drivers: Option[IPXACT2022ScalaCases.Drivers]
  def constraintSets: Option[IPXACT2022ScalaCases.ConstraintSets]
  def powerConstraints: Option[IPXACT2022ScalaCases.PowerConstraints]
  def allLogicalDirectionsAllowed: Boolean
}


/** Wire port type for a component.
*/
case class PortWireType(direction: IPXACT2022ScalaCases.ComponentPortDirectionType,
  qualifier: Option[IPXACT2022ScalaCases.QualifierType] = None,
  vectors: Option[IPXACT2022ScalaCases.ExtendedVectorsType] = None,
  wireTypeDefs: Option[IPXACT2022ScalaCases.WireTypeDefs] = None,
  domainTypeDefs: Option[IPXACT2022ScalaCases.DomainTypeDefs] = None,
  signalTypeDefs: Option[IPXACT2022ScalaCases.SignalTypeDefs] = None,
  drivers: Option[IPXACT2022ScalaCases.Drivers] = None,
  constraintSets: Option[IPXACT2022ScalaCases.ConstraintSets] = None,
  powerConstraints: Option[IPXACT2022ScalaCases.PowerConstraints] = None,
  attributes: Map[String, IPXACT2022scalaxb.DataRecord[Any]] = Map.empty) extends PortWireTypable {
  lazy val allLogicalDirectionsAllowed = attributes("@allLogicalDirectionsAllowed").as[Boolean]
}

      
      


case class Connection(maxConnections: Option[IPXACT2022ScalaCases.UnsignedIntExpressionable] = None,
  minConnections: Option[IPXACT2022ScalaCases.UnsignedIntExpressionable] = None)
      
      


case class PowerConstraints2(powerConstraint: Seq[IPXACT2022ScalaCases.TransactionalPowerConstraintType] = Nil)
      
      


/** Transactional port type.
*/
case class PortTransactionalType(initiative: IPXACT2022ScalaCases.InitiativeType,
  kind: Option[IPXACT2022ScalaCases.Kind] = None,
  busWidth: Option[IPXACT2022ScalaCases.UnsignedIntExpressionable] = None,
  qualifier: Option[IPXACT2022ScalaCases.QualifierType] = None,
  protocol: Option[IPXACT2022ScalaCases.Protocol] = None,
  transTypeDefs: Option[IPXACT2022ScalaCases.TransTypeDefs] = None,
  connection: Option[IPXACT2022ScalaCases.Connection] = None,
  powerConstraints: Option[IPXACT2022ScalaCases.PowerConstraints2] = None,
  attributes: Map[String, IPXACT2022scalaxb.DataRecord[Any]] = Map.empty) extends PortTypableOption {
  lazy val allLogicalInitiativesAllowed = attributes("@allLogicalInitiativesAllowed").as[Boolean]
}

      
      


case class Connection2(maxConnections: Option[IPXACT2022ScalaCases.UnsignedIntExpressionable] = None,
  minConnections: Option[IPXACT2022ScalaCases.UnsignedIntExpressionable] = None)
      
      


/** Transactional port type.
*/
case class AbstractorPortTransactionalType(initiative: IPXACT2022ScalaCases.InitiativeType,
  kind: Option[IPXACT2022ScalaCases.Kind] = None,
  busWidth: Option[IPXACT2022ScalaCases.UnsignedIntExpressionable] = None,
  qualifier: Option[IPXACT2022ScalaCases.QualifierType] = None,
  protocol: Option[IPXACT2022ScalaCases.Protocol] = None,
  transTypeDefs: Option[IPXACT2022ScalaCases.TransTypeDefs] = None,
  connection: Option[IPXACT2022ScalaCases.Connection2] = None,
  attributes: Map[String, IPXACT2022scalaxb.DataRecord[Any]] = Map.empty) extends AbstractorPortTypeOption {
  lazy val allLogicalInitiativesAllowed = attributes("@allLogicalInitiativesAllowed").as[Boolean]
}

      
      


/** Wire port type for an abstractor.
*/
case class AbstractorPortWireType(direction: IPXACT2022ScalaCases.ComponentPortDirectionType,
  qualifier: Option[IPXACT2022ScalaCases.QualifierType] = None,
  vectors: Option[IPXACT2022ScalaCases.ExtendedVectorsType] = None,
  wireTypeDefs: Option[IPXACT2022ScalaCases.WireTypeDefs] = None,
  domainTypeDefs: Option[IPXACT2022ScalaCases.DomainTypeDefs] = None,
  signalTypeDefs: Option[IPXACT2022ScalaCases.SignalTypeDefs] = None,
  drivers: Option[IPXACT2022ScalaCases.Drivers] = None,
  constraintSets: Option[IPXACT2022ScalaCases.ConstraintSets] = None,
  powerConstraints: Option[IPXACT2022ScalaCases.PowerConstraints] = None,
  attributes: Map[String, IPXACT2022scalaxb.DataRecord[Any]] = Map.empty) extends PortWireTypable with AbstractorPortTypeOption with AbstractorSubPortTypeOption {
  lazy val allLogicalDirectionsAllowed = attributes("@allLogicalDirectionsAllowed").as[Boolean]
}

      
      


case class Vector4(left: IPXACT2022ScalaCases.UnsignedIntExpressionable,
  right: IPXACT2022ScalaCases.UnsignedIntExpressionable,
  attributes: Map[String, IPXACT2022scalaxb.DataRecord[Any]] = Map.empty) {
  lazy val vectorId = attributes.get("@vectorId") map { _.as[String]}
  lazy val xmlid = attributes.get("@{http://www.w3.org/XML/1998/namespace}id") map { _.as[String]}
}

      
      


case class ExtendedVectorsType(vector: Seq[IPXACT2022ScalaCases.Vector4] = Nil)
      
      


case class AccessHandles13(accesshandles13sequence1: Seq[IPXACT2022ScalaCases.AccessHandles13Sequence1] = Nil)
      
      

case class AccessHandles13Sequence1(accessHandle: IPXACT2022ScalaCases.PortAccessHandle)
      

case class PortAccessType(portAccessType: Option[IPXACT2022ScalaCases.SimplePortAccessType] = None,
  accessHandles: Option[IPXACT2022ScalaCases.AccessHandles13] = None)
      
      

sealed trait SignalType

object SignalType {
  def fromString(value: String, scope: scala.xml.NamespaceBinding)(implicit fmt: IPXACT2022scalaxb.XMLFormat[IPXACT2022ScalaCases.SignalType]): SignalType = fmt.reads(scala.xml.Text(value), Nil) match {
    case Right(x: SignalType) => x
    case x => throw new RuntimeException(s"fromString returned unexpected value $x for input $value")
  }
  lazy val values: Seq[SignalType] = Seq(Continuousu45conservative, Continuousu45nonu45conservative, Discrete, Digital)
}

case object Continuousu45conservative extends SignalType { override def toString = "continuous-conservative" }
case object Continuousu45nonu45conservative extends SignalType { override def toString = "continuous-non-conservative" }
case object Discrete extends SignalType { override def toString = "discrete" }
case object Digital extends SignalType { override def toString = "digital" }


case class ViewRef8(value: String,
  attributes: Map[String, IPXACT2022scalaxb.DataRecord[Any]] = Map.empty) {
  lazy val xmlid = attributes.get("@{http://www.w3.org/XML/1998/namespace}id") map { _.as[String]}
}

      
      


case class SignalTypeDef(signalType: IPXACT2022ScalaCases.SignalType,
  viewRef: Seq[IPXACT2022ScalaCases.ViewRef8] = Nil,
  attributes: Map[String, IPXACT2022scalaxb.DataRecord[Any]] = Map.empty) {
  lazy val xmlid = attributes.get("@{http://www.w3.org/XML/1998/namespace}id") map { _.as[String]}
}

      
      


case class TypeName4(value: String,
  attributes: Map[String, IPXACT2022scalaxb.DataRecord[Any]] = Map.empty) {
  lazy val xmlid = attributes.get("@{http://www.w3.org/XML/1998/namespace}id") map { _.as[String]}
}

      
      


case class TypeDefinition4(value: String,
  attributes: Map[String, IPXACT2022scalaxb.DataRecord[Any]] = Map.empty) {
  lazy val xmlid = attributes.get("@{http://www.w3.org/XML/1998/namespace}id") map { _.as[String]}
}

      
      


case class ViewRef9(value: String,
  attributes: Map[String, IPXACT2022scalaxb.DataRecord[Any]] = Map.empty) {
  lazy val xmlid = attributes.get("@{http://www.w3.org/XML/1998/namespace}id") map { _.as[String]}
}

      
      


case class DomainTypeDef(typeName: Option[IPXACT2022ScalaCases.TypeName4] = None,
  typeDefinition: Seq[IPXACT2022ScalaCases.TypeDefinition4] = Nil,
  viewRef: Seq[IPXACT2022ScalaCases.ViewRef9] = Nil,
  attributes: Map[String, IPXACT2022scalaxb.DataRecord[Any]] = Map.empty) {
  lazy val xmlid = attributes.get("@{http://www.w3.org/XML/1998/namespace}id") map { _.as[String]}
}

      
      


case class DomainTypeDefs(domainTypeDef: Seq[IPXACT2022ScalaCases.DomainTypeDef] = Nil)
      
      


case class SignalTypeDefs(signalTypeDef: Seq[IPXACT2022ScalaCases.SignalTypeDef] = Nil)
      
      


case class PortPacketsType(packet: Seq[IPXACT2022ScalaCases.PortPacketType] = Nil)
      
      


case class PortPacketType(nameGroupSequence1: IPXACT2022ScalaCases.NameGroupSequence,
  endianness: Option[IPXACT2022ScalaCases.EndianessType] = None,
  packetFields: IPXACT2022ScalaCases.PortPacketFieldsType,
  vendorExtensions: Option[IPXACT2022ScalaCases.VendorExtensions] = None,
  attributes: Map[String, IPXACT2022scalaxb.DataRecord[Any]] = Map.empty) {
  lazy val xmlid = attributes.get("@{http://www.w3.org/XML/1998/namespace}id") map { _.as[String]}
}

      
      


case class PortPacketFieldsType(packetField: Seq[IPXACT2022ScalaCases.PortPacketFieldType] = Nil)
      
      


case class PortPacketFieldType(nameGroupSequence1: IPXACT2022ScalaCases.NameGroupSequence,
  width: IPXACT2022ScalaCases.UnresolvedUnsignedPositiveIntExpression,
  value: Option[IPXACT2022ScalaCases.UnsignedBitVectorExpressionable] = None,
  endianness: Option[IPXACT2022ScalaCases.EndianessType] = None,
  qualifier: Option[IPXACT2022ScalaCases.QualifierType] = None,
  vendorExtensions: Option[IPXACT2022ScalaCases.VendorExtensions] = None,
  attributes: Map[String, IPXACT2022scalaxb.DataRecord[Any]] = Map.empty) {
  lazy val xmlid = attributes.get("@{http://www.w3.org/XML/1998/namespace}id") map { _.as[String]}
}

      
      


case class ArrayType5(left: IPXACT2022ScalaCases.UnsignedIntExpressionable,
  right: IPXACT2022ScalaCases.UnsignedIntExpressionable,
  attributes: Map[String, IPXACT2022scalaxb.DataRecord[Any]] = Map.empty) {
  lazy val arrayId = attributes.get("@arrayId") map { _.as[String]}
  lazy val xmlid = attributes.get("@{http://www.w3.org/XML/1998/namespace}id") map { _.as[String]}
}

      
      


case class Arrays(array: Seq[IPXACT2022ScalaCases.ArrayType5] = Nil)
      
      


case class TypeName5(value: String,
  attributes: Map[String, IPXACT2022scalaxb.DataRecord[Any]] = Map.empty) {
  lazy val constrained = attributes.get("@constrained") map { _.as[Seq[String]]}
}

      
      


case class TypeDefinition5(value: String,
  attributes: Map[String, IPXACT2022scalaxb.DataRecord[Any]] = Map.empty) {
  lazy val xmlid = attributes.get("@{http://www.w3.org/XML/1998/namespace}id") map { _.as[String]}
}

      
      


case class TypeParameters2(typeParameter: Seq[IPXACT2022ScalaCases.ModuleParameterType] = Nil)
      
      


case class ViewRef10(value: String,
  attributes: Map[String, IPXACT2022scalaxb.DataRecord[Any]] = Map.empty) {
  lazy val xmlid = attributes.get("@{http://www.w3.org/XML/1998/namespace}id") map { _.as[String]}
}

      
      


case class StructPortTypeDef(typeName: IPXACT2022ScalaCases.TypeName5,
  typeDefinition: Seq[IPXACT2022ScalaCases.TypeDefinition5] = Nil,
  typeParameters: Option[IPXACT2022ScalaCases.TypeParameters2] = None,
  role: Option[String] = None,
  viewRef: Seq[IPXACT2022ScalaCases.ViewRef10] = Nil,
  attributes: Map[String, IPXACT2022scalaxb.DataRecord[Any]] = Map.empty) {
  lazy val xmlid = attributes.get("@{http://www.w3.org/XML/1998/namespace}id") map { _.as[String]}
}

      
      


case class StructPortTypeDefs(structPortTypeDef: Seq[IPXACT2022ScalaCases.StructPortTypeDef] = Nil)
      
      


/** A port description, giving a name and an access type for high level ports. 
*/
case class SubPortType(nameGroupPortSequence1: IPXACT2022ScalaCases.NameGroupPortSequence,
  subporttypeoption: IPXACT2022scalaxb.DataRecord[IPXACT2022ScalaCases.SubPortTypeOption],
  arrays: Option[IPXACT2022ScalaCases.Arrays] = None,
  access: Option[IPXACT2022ScalaCases.PortAccessType] = None,
  vendorExtensions: Option[IPXACT2022ScalaCases.VendorExtensions] = None,
  attributes: Map[String, IPXACT2022scalaxb.DataRecord[Any]] = Map.empty) {
  lazy val xmlid = attributes.get("@{http://www.w3.org/XML/1998/namespace}id") map { _.as[String]}
  lazy val isIO = attributes.get("@isIO") map { _.as[Boolean]}
}

      
      

trait SubPortTypeOption

/** A port description, giving a name and an access type for high level ports. 
*/
case class AbstractorSubPortType(nameGroupPortSequence1: IPXACT2022ScalaCases.NameGroupPortSequence,
  abstractorsubporttypeoption: IPXACT2022scalaxb.DataRecord[IPXACT2022ScalaCases.AbstractorSubPortTypeOption],
  arrays: Option[IPXACT2022ScalaCases.Arrays] = None,
  access: Option[IPXACT2022ScalaCases.PortAccessType] = None,
  vendorExtensions: Option[IPXACT2022ScalaCases.VendorExtensions] = None,
  attributes: Map[String, IPXACT2022scalaxb.DataRecord[Any]] = Map.empty) {
  lazy val xmlid = attributes.get("@{http://www.w3.org/XML/1998/namespace}id") map { _.as[String]}
  lazy val isIO = attributes.get("@isIO") map { _.as[Boolean]}
}

      
      

trait AbstractorSubPortTypeOption

case class SubPorts(subPort: Seq[IPXACT2022ScalaCases.SubPortType] = Nil)
      
      


case class PortStructuredType(structTypeGroupOption1: IPXACT2022scalaxb.DataRecord[IPXACT2022ScalaCases.StructTypeGroupOption],
  vectors: Option[IPXACT2022ScalaCases.ExtendedVectorsType] = None,
  subPorts: Option[IPXACT2022ScalaCases.SubPorts] = None,
  structPortTypeDefs: IPXACT2022ScalaCases.StructPortTypeDefs,
  attributes: Map[String, IPXACT2022scalaxb.DataRecord[Any]] = Map.empty) extends PortTypableOption with SubPortTypeOption {
  lazy val packed = attributes("@packed").as[Boolean]
}

      
      


case class SubPorts2(subPort: Seq[IPXACT2022ScalaCases.AbstractorSubPortType] = Nil)
      
      


case class AbstractorPortStructuredType(structTypeGroupOption1: IPXACT2022scalaxb.DataRecord[IPXACT2022ScalaCases.StructTypeGroupOption],
  vectors: Option[IPXACT2022ScalaCases.ExtendedVectorsType] = None,
  subPorts: IPXACT2022ScalaCases.SubPorts2,
  structPortTypeDefs: IPXACT2022ScalaCases.StructPortTypeDefs,
  attributes: Map[String, IPXACT2022scalaxb.DataRecord[Any]] = Map.empty) extends AbstractorPortTypeOption with AbstractorSubPortTypeOption {
  lazy val packed = attributes("@packed").as[Boolean]
}

      
      


case class WirePowerConstraintType(powerDomainRef: String,
  range: Option[IPXACT2022ScalaCases.RangeType] = None,
  vendorExtensions: Option[IPXACT2022ScalaCases.VendorExtensions] = None,
  attributes: Map[String, IPXACT2022scalaxb.DataRecord[Any]] = Map.empty) {
  lazy val xmlid = attributes.get("@{http://www.w3.org/XML/1998/namespace}id") map { _.as[String]}
}

      
      


case class TransactionalPowerConstraintType(powerDomainRef: String,
  vendorExtensions: Option[IPXACT2022ScalaCases.VendorExtensions] = None,
  attributes: Map[String, IPXACT2022scalaxb.DataRecord[Any]] = Map.empty) {
  lazy val xmlid = attributes.get("@{http://www.w3.org/XML/1998/namespace}id") map { _.as[String]}
}

      
      


case class Struct(attributes: Map[String, IPXACT2022scalaxb.DataRecord[Any]] = Map.empty) extends StructTypeGroupOption {
  lazy val direction = attributes.get("@direction") map { _.as[ComponentPortDirectionType]}
}

      
      


case class Union(attributes: Map[String, IPXACT2022scalaxb.DataRecord[Any]] = Map.empty) extends StructTypeGroupOption {
  lazy val direction = attributes.get("@direction") map { _.as[ComponentPortDirectionType]}
}

      
      


case class Interface(attributes: Map[String, IPXACT2022scalaxb.DataRecord[Any]] = Map.empty) extends StructTypeGroupOption {
  lazy val phantom = attributes.get("@phantom") map { _.as[Boolean]}
}

      
      

trait StructTypeGroupOption

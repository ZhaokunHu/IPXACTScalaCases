// Generated by <a href="http://IPXACT2022scalaxb.org/">IPXACT2022scalaxb</a>.
package IPXACT2022ScalaCases

sealed trait CellFunctionValueType

object CellFunctionValueType {
  def fromString(value: String, scope: scala.xml.NamespaceBinding)(implicit fmt: IPXACT2022scalaxb.XMLFormat[IPXACT2022ScalaCases.CellFunctionValueType]): CellFunctionValueType = fmt.reads(scala.xml.Text(value), Nil) match {
    case Right(x: CellFunctionValueType) => x
    case x => throw new RuntimeException(s"fromString returned unexpected value $x for input $value")
  }
  lazy val values: Seq[CellFunctionValueType] = Seq(Nand2, Buf, Inv, Mux21, Dff, Latch, Xor2, Other)
}

case object Nand2 extends CellFunctionValueType { override def toString = "nand2" }
case object Buf extends CellFunctionValueType { override def toString = "buf" }
case object Inv extends CellFunctionValueType { override def toString = "inv" }
case object Mux21 extends CellFunctionValueType { override def toString = "mux21" }
case object Dff extends CellFunctionValueType { override def toString = "dff" }
case object Latch extends CellFunctionValueType { override def toString = "latch" }
case object Xor2 extends CellFunctionValueType { override def toString = "xor2" }
case object Other extends CellFunctionValueType { override def toString = "other" }

sealed trait CellClassValueType

object CellClassValueType {
  def fromString(value: String, scope: scala.xml.NamespaceBinding)(implicit fmt: IPXACT2022scalaxb.XMLFormat[IPXACT2022ScalaCases.CellClassValueType]): CellClassValueType = fmt.reads(scala.xml.Text(value), Nil) match {
    case Right(x: CellClassValueType) => x
    case x => throw new RuntimeException(s"fromString returned unexpected value $x for input $value")
  }
  lazy val values: Seq[CellClassValueType] = Seq(Combinational, Sequential)
}

case object Combinational extends CellClassValueType { override def toString = "combinational" }
case object Sequential extends CellClassValueType { override def toString = "sequential" }

sealed trait CellStrengthValueType

object CellStrengthValueType {
  def fromString(value: String, scope: scala.xml.NamespaceBinding)(implicit fmt: IPXACT2022scalaxb.XMLFormat[IPXACT2022ScalaCases.CellStrengthValueType]): CellStrengthValueType = fmt.reads(scala.xml.Text(value), Nil) match {
    case Right(x: CellStrengthValueType) => x
    case x => throw new RuntimeException(s"fromString returned unexpected value $x for input $value")
  }
  lazy val values: Seq[CellStrengthValueType] = Seq(Low, Median, High)
}

case object Low extends CellStrengthValueType { override def toString = "low" }
case object Median extends CellStrengthValueType { override def toString = "median" }
case object High extends CellStrengthValueType { override def toString = "high" }

sealed trait EdgeValueType

object EdgeValueType {
  def fromString(value: String, scope: scala.xml.NamespaceBinding)(implicit fmt: IPXACT2022scalaxb.XMLFormat[IPXACT2022ScalaCases.EdgeValueType]): EdgeValueType = fmt.reads(scala.xml.Text(value), Nil) match {
    case Right(x: EdgeValueType) => x
    case x => throw new RuntimeException(s"fromString returned unexpected value $x for input $value")
  }
  lazy val values: Seq[EdgeValueType] = Seq(Rise, Fall)
}

case object Rise extends EdgeValueType { override def toString = "rise" }
case object Fall extends EdgeValueType { override def toString = "fall" }

sealed trait DelayValueType

object DelayValueType {
  def fromString(value: String, scope: scala.xml.NamespaceBinding)(implicit fmt: IPXACT2022scalaxb.XMLFormat[IPXACT2022ScalaCases.DelayValueType]): DelayValueType = fmt.reads(scala.xml.Text(value), Nil) match {
    case Right(x: DelayValueType) => x
    case x => throw new RuntimeException(s"fromString returned unexpected value $x for input $value")
  }
  lazy val values: Seq[DelayValueType] = Seq(Min, Max)
}

case object Min extends DelayValueType { override def toString = "min" }
case object Max extends DelayValueType { override def toString = "max" }


/** List of clocks associated with the component that are not associated with ports. Set the clockSource attribute on the clockDriver to indicate the source of a clock not associated with a particular component port.
*/
case class OtherClocks(otherClockDriver: Seq[IPXACT2022ScalaCases.OtherClockDriver] = Nil)
      
      


case class CellFunction(value: IPXACT2022ScalaCases.CellFunctionValueType,
  attributes: Map[String, IPXACT2022scalaxb.DataRecord[Any]] = Map.empty) extends CellSpecificationOption {
  lazy val other = attributes.get("@other") map { _.as[String]}
}

      
      


case class CellSpecification(cellspecificationoption: IPXACT2022scalaxb.DataRecord[Any],
  attributes: Map[String, IPXACT2022scalaxb.DataRecord[Any]] = Map.empty) {
  lazy val cellStrength = attributes.get("@cellStrength") map { _.as[CellStrengthValueType]}
}

      
      

trait CellSpecificationOption

case class TimingConstraint(value: Float,
  attributes: Map[String, IPXACT2022scalaxb.DataRecord[Any]] = Map.empty) {
  lazy val clockEdge = attributes.get("@clockEdge") map { _.as[EdgeValueType]}
  lazy val delayType = attributes.get("@delayType") map { _.as[DelayValueType]}
  lazy val clockName = attributes("@clockName").as[String]
  lazy val xmlid = attributes.get("@{http://www.w3.org/XML/1998/namespace}id") map { _.as[String]}
}

      
      


case class DriveConstraint(cellSpecification: IPXACT2022ScalaCases.CellSpecification)
      
      


case class LoadConstraint(cellSpecification: IPXACT2022ScalaCases.CellSpecification,
  count: Option[IPXACT2022ScalaCases.UnsignedPositiveIntExpressionable] = None)
      
      


case class Vector3(left: IPXACT2022ScalaCases.UnsignedIntExpressionable,
  right: IPXACT2022ScalaCases.UnsignedIntExpressionable)
      
      


case class ConstraintSet(nameGroupOptionalSequence1: IPXACT2022ScalaCases.NameGroupOptionalSequence,
  vector: Option[IPXACT2022ScalaCases.Vector3] = None,
  driveConstraint: Option[IPXACT2022ScalaCases.DriveConstraint] = None,
  loadConstraint: Option[IPXACT2022ScalaCases.LoadConstraint] = None,
  timingConstraint: Seq[IPXACT2022ScalaCases.TimingConstraint] = Nil,
  attributes: Map[String, IPXACT2022scalaxb.DataRecord[Any]] = Map.empty) {
  lazy val constraintSetId = attributes("@constraintSetId").as[String]
  lazy val xmlid = attributes.get("@{http://www.w3.org/XML/1998/namespace}id") map { _.as[String]}
}

      
      


case class ConstraintSets(constraintSet: Seq[IPXACT2022ScalaCases.ConstraintSet] = Nil)
      
      


case class ConstraintSetRef(localName: String,
  vendorExtensions: Option[IPXACT2022ScalaCases.VendorExtensions] = None,
  attributes: Map[String, IPXACT2022scalaxb.DataRecord[Any]] = Map.empty) {
  lazy val xmlid = attributes.get("@{http://www.w3.org/XML/1998/namespace}id") map { _.as[String]}
}

      
      


/** Defines constraints that apply to a wire type port in an abstraction definition. 
*/
case class AbstractionDefPortConstraintsType(abstractiondefportconstraintstypeoption: IPXACT2022scalaxb.DataRecord[IPXACT2022ScalaCases.AbstractionDefPortConstraintsTypeOption])
      
      

case class AbstractionDefPortConstraintsTypeSequence3(loadConstraint: IPXACT2022ScalaCases.LoadConstraint) extends AbstractionDefPortConstraintsTypeOption
      
trait AbstractionDefPortConstraintsTypeOption
case class AbstractionDefPortConstraintsTypeSequence2(driveConstraint: IPXACT2022ScalaCases.DriveConstraint,
  loadConstraint: Option[IPXACT2022ScalaCases.LoadConstraint] = None) extends AbstractionDefPortConstraintsTypeOption
      

case class AbstractionDefPortConstraintsTypeSequence1(timingConstraint: Seq[IPXACT2022ScalaCases.TimingConstraint] = Nil,
  driveConstraint: Option[IPXACT2022ScalaCases.DriveConstraint] = None,
  loadConstraint: Option[IPXACT2022ScalaCases.LoadConstraint] = None) extends AbstractionDefPortConstraintsTypeOption
      


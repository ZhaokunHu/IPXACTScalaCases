// Generated by <a href="http://IPXACT2022scalaxb.org/">IPXACT2022scalaxb</a>.
package IPXACT2022ScalaCases

case class TypeDefinitions(typedefinitionssequence1: Option[IPXACT2022ScalaCases.TypeDefinitionsSequence1] = None)
      
      

case class TypeDefinitionsSequence1(externalTypeDefinitions: IPXACT2022ScalaCases.ExternalTypeDefinitions*)
      

case class PowerDomain(nameGroupSequence1: IPXACT2022ScalaCases.NameGroupSequence,
  alwaysOn: Option[IPXACT2022ScalaCases.UnsignedBitExpression] = None,
  subDomainOf: Option[String] = None,
  parameters: Option[IPXACT2022ScalaCases.Parameters] = None,
  vendorExtensions: Option[IPXACT2022ScalaCases.VendorExtensions] = None,
  attributes: Map[String, IPXACT2022scalaxb.DataRecord[Any]] = Map.empty) {
  lazy val xmlid = attributes.get("@{http://www.w3.org/XML/1998/namespace}id") map { _.as[String]}
}

      
      


case class PowerDomains(powerDomain: Seq[IPXACT2022ScalaCases.PowerDomain] = Nil)
      
      


case class PortRef(attributes: Map[String, IPXACT2022scalaxb.DataRecord[Any]] = Map.empty) {
  lazy val portRef = attributes("@portRef").as[String]
}

      
      


case class PortSlice(nameGroupSequence1: IPXACT2022ScalaCases.NameGroupSequence,
  portRef: IPXACT2022ScalaCases.PortRef,
  subPortReference: Seq[IPXACT2022ScalaCases.SubPortReference] = Nil,
  partSelect: Option[IPXACT2022ScalaCases.PartSelect] = None,
  attributes: Map[String, IPXACT2022scalaxb.DataRecord[Any]] = Map.empty) {
  lazy val xmlid = attributes.get("@{http://www.w3.org/XML/1998/namespace}id") map { _.as[String]}
}

      
      


case class FieldSlice(nameGroupSequence1: IPXACT2022ScalaCases.NameGroupSequence,
  fieldSliceReferenceGroupSequence2: IPXACT2022ScalaCases.FieldSliceReferenceGroupSequence,
  attributes: Map[String, IPXACT2022scalaxb.DataRecord[Any]] = Map.empty) {
  lazy val xmlid = attributes.get("@{http://www.w3.org/XML/1998/namespace}id") map { _.as[String]}
}

      
      


case class Mode(nameGroupSequence1: IPXACT2022ScalaCases.NameGroupSequence,
  portSlice: Seq[IPXACT2022ScalaCases.PortSlice] = Nil,
  fieldSlice: Seq[IPXACT2022ScalaCases.FieldSlice] = Nil,
  condition: Option[IPXACT2022ScalaCases.UnresolvedUnsignedBitExpression] = None,
  vendorExtensions: Option[IPXACT2022ScalaCases.VendorExtensions] = None,
  attributes: Map[String, IPXACT2022scalaxb.DataRecord[Any]] = Map.empty) {
  lazy val xmlid = attributes.get("@{http://www.w3.org/XML/1998/namespace}id") map { _.as[String]}
}

      
      


case class Modes(mode: Seq[IPXACT2022ScalaCases.Mode] = Nil)
      
      


case class ClearboxElements(clearboxElement: Seq[IPXACT2022ScalaCases.ClearboxElementType] = Nil)
      
      


case class Region(nameGroupSequence1: IPXACT2022ScalaCases.NameGroupSequence,
  addressOffset: IPXACT2022ScalaCases.UnsignedLongintExpressionable,
  range: IPXACT2022ScalaCases.UnsignedPositiveLongintExpressionable,
  vendorExtensions: Option[IPXACT2022ScalaCases.VendorExtensions] = None,
  attributes: Map[String, IPXACT2022scalaxb.DataRecord[Any]] = Map.empty) {
  lazy val xmlid = attributes.get("@{http://www.w3.org/XML/1998/namespace}id") map { _.as[String]}
}

      
      


case class Regions(region: Seq[IPXACT2022ScalaCases.Region] = Nil)
      
      


case class Cpu(nameGroupSequence1: IPXACT2022ScalaCases.NameGroupSequence,
  blockSizeSequence2: IPXACT2022ScalaCases.BlockSizeSequence,
  regions: Option[IPXACT2022ScalaCases.Regions] = None,
  addressUnitBits: Option[IPXACT2022ScalaCases.UnsignedPositiveLongintExpressionable] = None,
  executableImage: Seq[IPXACT2022ScalaCases.ExecutableImage] = Nil,
  memoryMapRef: String,
  parameters: Option[IPXACT2022ScalaCases.Parameters] = None,
  vendorExtensions: Option[IPXACT2022ScalaCases.VendorExtensions] = None,
  attributes: Map[String, IPXACT2022scalaxb.DataRecord[Any]] = Map.empty) {
  lazy val xmlid = attributes.get("@{http://www.w3.org/XML/1998/namespace}id") map { _.as[String]}
}

      
      


case class Cpus(cpu: Seq[IPXACT2022ScalaCases.Cpu] = Nil)
      
      


case class ResetType(nameGroupSequence1: IPXACT2022ScalaCases.NameGroupSequence,
  vendorExtensions: Option[IPXACT2022ScalaCases.VendorExtensions] = None,
  attributes: Map[String, IPXACT2022scalaxb.DataRecord[Any]] = Map.empty) {
  lazy val xmlid = attributes.get("@{http://www.w3.org/XML/1998/namespace}id") map { _.as[String]}
}

      
      


case class ResetTypes(resetType: Seq[IPXACT2022ScalaCases.ResetType] = Nil)
      
      


/** Component-specific extension to componentType
*/
case class ComponentType(documentNameGroupSequence1: IPXACT2022ScalaCases.DocumentNameGroupSequence,
  typeDefinitions: Option[IPXACT2022ScalaCases.TypeDefinitions] = None,
  powerDomains: Option[IPXACT2022ScalaCases.PowerDomains] = None,
  busInterfaces: Option[IPXACT2022ScalaCases.BusInterfaces] = None,
  indirectInterfaces: Option[IPXACT2022ScalaCases.IndirectInterfaces] = None,
  channels: Option[IPXACT2022ScalaCases.Channels] = None,
  modes: Option[IPXACT2022ScalaCases.Modes] = None,
  addressSpaces: Option[IPXACT2022ScalaCases.AddressSpaces] = None,
  memoryMaps: Option[IPXACT2022ScalaCases.MemoryMaps] = None,
  model: Option[IPXACT2022ScalaCases.ModelType] = None,
  componentGenerators: Option[IPXACT2022ScalaCases.ComponentGenerators] = None,
  choices: Option[IPXACT2022ScalaCases.Choices] = None,
  fileSets: Option[IPXACT2022ScalaCases.FileSets] = None,
  clearboxElements: Option[IPXACT2022ScalaCases.ClearboxElements] = None,
  cpus: Option[IPXACT2022ScalaCases.Cpus] = None,
  otherClockDrivers: Option[IPXACT2022ScalaCases.OtherClocks] = None,
  resetTypes: Option[IPXACT2022ScalaCases.ResetTypes] = None,
  parameters: Option[IPXACT2022ScalaCases.Parameters] = None,
  assertions: Option[IPXACT2022ScalaCases.Assertions] = None,
  vendorExtensions: Option[IPXACT2022ScalaCases.VendorExtensions] = None,
  attributes: Map[String, IPXACT2022scalaxb.DataRecord[Any]] = Map.empty) extends IPXACTDocumentTypesOption {
  lazy val xmlid = attributes.get("@{http://www.w3.org/XML/1998/namespace}id") map { _.as[String]}
}

      
      

sealed trait SimpleClearboxType

object SimpleClearboxType {
  def fromString(value: String, scope: scala.xml.NamespaceBinding)(implicit fmt: IPXACT2022scalaxb.XMLFormat[IPXACT2022ScalaCases.SimpleClearboxType]): SimpleClearboxType = fmt.reads(scala.xml.Text(value), Nil) match {
    case Right(x: SimpleClearboxType) => x
    case x => throw new RuntimeException(s"fromString returned unexpected value $x for input $value")
  }
  lazy val values: Seq[SimpleClearboxType] = Seq(Signal, Pin, InterfaceValue)
}

case object Signal extends SimpleClearboxType { override def toString = "signal" }
case object Pin extends SimpleClearboxType { override def toString = "pin" }
case object InterfaceValue extends SimpleClearboxType { override def toString = "interface" }


/** Defines a clear box reference point within the component.
*/
case class ClearboxElementType(nameGroupSequence1: IPXACT2022ScalaCases.NameGroupSequence,
  clearboxType: IPXACT2022ScalaCases.SimpleClearboxType,
  driveable: Option[Boolean] = None,
  parameters: Option[IPXACT2022ScalaCases.Parameters] = None,
  vendorExtensions: Option[IPXACT2022ScalaCases.VendorExtensions] = None,
  attributes: Map[String, IPXACT2022scalaxb.DataRecord[Any]] = Map.empty) {
  lazy val xmlid = attributes.get("@{http://www.w3.org/XML/1998/namespace}id") map { _.as[String]}
}

      
      


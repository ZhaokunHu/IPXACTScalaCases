// Generated by <a href="http://IPXACT2022scalaxb.org/">IPXACT2022scalaxb</a>.
package IPXACT2022ScalaCases

sealed trait PresenceType

object PresenceType {
  def fromString(value: String, scope: scala.xml.NamespaceBinding)(implicit fmt: IPXACT2022scalaxb.XMLFormat[IPXACT2022ScalaCases.PresenceType]): PresenceType = fmt.reads(scala.xml.Text(value), Nil) match {
    case Right(x: PresenceType) => x
    case x => throw new RuntimeException(s"fromString returned unexpected value $x for input $value")
  }
  lazy val values: Seq[PresenceType] = Seq(Required, Illegal, Optional)
}

case object Required extends PresenceType { override def toString = "required" }
case object Illegal extends PresenceType { override def toString = "illegal" }
case object Optional extends PresenceType { override def toString = "optional" }

sealed trait Direction

object Direction {
  def fromString(value: String, scope: scala.xml.NamespaceBinding)(implicit fmt: IPXACT2022scalaxb.XMLFormat[IPXACT2022ScalaCases.Direction]): Direction = fmt.reads(scala.xml.Text(value), Nil) match {
    case Right(x: Direction) => x
    case x => throw new RuntimeException(s"fromString returned unexpected value $x for input $value")
  }
  lazy val values: Seq[Direction] = Seq(In, Out, Inout)
}

case object In extends Direction { override def toString = "in" }
case object Out extends Direction { override def toString = "out" }
case object Inout extends Direction { override def toString = "inout" }

sealed trait Initiative

object Initiative {
  def fromString(value: String, scope: scala.xml.NamespaceBinding)(implicit fmt: IPXACT2022scalaxb.XMLFormat[IPXACT2022ScalaCases.Initiative]): Initiative = fmt.reads(scala.xml.Text(value), Nil) match {
    case Right(x: Initiative) => x
    case x => throw new RuntimeException(s"fromString returned unexpected value $x for input $value")
  }
  lazy val values: Seq[Initiative] = Seq(RequiresValue, ProvidesValue, BothValue)
}

case object RequiresValue extends Initiative { override def toString = "requires" }
case object ProvidesValue extends Initiative { override def toString = "provides" }
case object BothValue extends Initiative { override def toString = "both" }


case class Width(value: String,
  attributes: Map[String, IPXACT2022scalaxb.DataRecord[Any]] = Map.empty) extends UnsignedPositiveIntExpressionable {
  lazy val minimum = attributes.get("@minimum") map { _.as[Int]}
  lazy val maximum = attributes.get("@maximum") map { _.as[Int]}
  lazy val allBits = attributes("@allBits").as[Boolean]
}

      
      


case class OnSystem(group: String,
  transactionalPortSequence2: IPXACT2022ScalaCases.TransactionalPortSequence,
  attributes: Map[String, IPXACT2022scalaxb.DataRecord[Any]] = Map.empty) {
  lazy val xmlid = attributes.get("@{http://www.w3.org/XML/1998/namespace}id") map { _.as[String]}
}

      
      


case class OnInitiator(transactionalPortSequence1: IPXACT2022ScalaCases.TransactionalPortSequence)
      
      


case class OnTarget(transactionalPortSequence1: IPXACT2022ScalaCases.TransactionalPortSequence)
      
      


case class Transactional(qualifier: Option[IPXACT2022ScalaCases.QualifierType] = None,
  onSystem: Seq[IPXACT2022ScalaCases.OnSystem] = Nil,
  onInitiator: Option[IPXACT2022ScalaCases.OnInitiator] = None,
  onTarget: Option[IPXACT2022ScalaCases.OnTarget] = None) extends PortOption
      
      


case class Port(logicalName: String,
  displayName: Option[String] = None,
  shortDescription: Option[String] = None,
  description: Option[String] = None,
  matchValue: Option[Boolean] = None,
  portsequence1: IPXACT2022ScalaCases.PortSequence1,
  vendorExtensions: Option[IPXACT2022ScalaCases.VendorExtensions] = None,
  attributes: Map[String, IPXACT2022scalaxb.DataRecord[Any]] = Map.empty) {
  lazy val xmlid = attributes.get("@{http://www.w3.org/XML/1998/namespace}id") map { _.as[String]}
}

      
      

case class PortSequence1(portoption: IPXACT2022scalaxb.DataRecord[IPXACT2022ScalaCases.PortOption],
  packets: Option[IPXACT2022ScalaCases.PortPacketsType] = None)
      

trait PortOption

case class Ports3(port: Seq[IPXACT2022ScalaCases.Port] = Nil)
      
      


case class AbstractionDefinition(documentNameGroupSequence1: IPXACT2022ScalaCases.DocumentNameGroupSequence,
  busType: IPXACT2022ScalaCases.LibraryRefType,
  extendsValue: Option[IPXACT2022ScalaCases.LibraryRefType] = None,
  ports: IPXACT2022ScalaCases.Ports3,
  choices: Option[IPXACT2022ScalaCases.Choices] = None,
  parameters: Option[IPXACT2022ScalaCases.Parameters] = None,
  assertions: Option[IPXACT2022ScalaCases.Assertions] = None,
  vendorExtensions: Option[IPXACT2022ScalaCases.VendorExtensions] = None,
  attributes: Map[String, IPXACT2022scalaxb.DataRecord[Any]] = Map.empty) extends IPXACTDocumentTypesOption {
  lazy val xmlid = attributes.get("@{http://www.w3.org/XML/1998/namespace}id") map { _.as[String]}
}

      
      


case class OnSystem2(group: String,
  wirePortSequence2: IPXACT2022ScalaCases.WirePortSequence,
  attributes: Map[String, IPXACT2022scalaxb.DataRecord[Any]] = Map.empty) {
  lazy val xmlid = attributes.get("@{http://www.w3.org/XML/1998/namespace}id") map { _.as[String]}
}

      
      


case class OnInitiator2(wirePortSequence1: IPXACT2022ScalaCases.WirePortSequence)
      
      


case class OnTarget2(wirePortSequence1: IPXACT2022ScalaCases.WirePortSequence)
      
      


case class Wire(qualifier: Option[IPXACT2022ScalaCases.QualifierType] = None,
  onSystem: Seq[IPXACT2022ScalaCases.OnSystem2] = Nil,
  onInitiator: Option[IPXACT2022ScalaCases.OnInitiator2] = None,
  onTarget: Option[IPXACT2022ScalaCases.OnTarget2] = None,
  wireoption: Option[IPXACT2022scalaxb.DataRecord[IPXACT2022ScalaCases.WireOption]] = None) extends PortOption
      
      

trait WireOption
case class WirePortSequence2(modeConstraints: IPXACT2022ScalaCases.AbstractionDefPortConstraintsType,
  mirroredModeConstraints: Option[IPXACT2022ScalaCases.AbstractionDefPortConstraintsType] = None)
      

case class WirePortSequence(presence: Option[IPXACT2022ScalaCases.PresenceType] = None,
  width: Option[String] = None,
  direction: Option[IPXACT2022ScalaCases.Direction] = None,
  wireportsequence2: Option[IPXACT2022ScalaCases.WirePortSequence2] = None)
      

case class TransactionalPortSequence(presence: Option[IPXACT2022ScalaCases.PresenceType] = None,
  initiative: Option[IPXACT2022ScalaCases.Initiative] = None,
  kind: Option[IPXACT2022ScalaCases.Kind] = None,
  busWidth: Option[IPXACT2022ScalaCases.UnsignedPositiveIntExpressionable] = None,
  protocol: Option[IPXACT2022ScalaCases.Protocol] = None)
      


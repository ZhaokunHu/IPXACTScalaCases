package IPXACT2009ScalaCases

// Generated by <a href="http://IPXACT2009scalaxb.org/">IPXACT2009scalaxb</a>.

sealed trait Presence

object Presence {
  def fromString(value: String, scope: scala.xml.NamespaceBinding)(implicit fmt: IPXACT2009scalaxb.XMLFormat[Presence]): Presence = fmt.reads(scala.xml.Text(value), Nil) match {
    case Right(x: Presence) => x
    case x => throw new RuntimeException(s"fromString returned unexpected value $x for input $value")
  }
  lazy val values: Seq[Presence] = Seq(Required, Illegal, Optional)
}

case object Required extends Presence { override def toString = "required" }
case object Illegal extends Presence { override def toString = "illegal" }
case object Optional extends Presence { override def toString = "optional" }

sealed trait Initiative

object Initiative {
  def fromString(value: String, scope: scala.xml.NamespaceBinding)(implicit fmt: IPXACT2009scalaxb.XMLFormat[Initiative]): Initiative = fmt.reads(scala.xml.Text(value), Nil) match {
    case Right(x: Initiative) => x
    case x => throw new RuntimeException(s"fromString returned unexpected value $x for input $value")
  }
  lazy val values: Seq[Initiative] = Seq(Requires, Provides, Both)
}

case object Requires extends Initiative { override def toString = "requires" }
case object Provides extends Initiative { override def toString = "provides" }
case object Both extends Initiative { override def toString = "both" }


case class TypeName(value: String,
  attributes: Map[String, IPXACT2009scalaxb.DataRecord[Any]] = Map.empty) {
  lazy val implicitValue = attributes("@implicit").as[Boolean]
}

      
      


/** The service that this transactional port can provide or requires.
*/
case class ServiceType(initiative: Initiative,
  typeName: Seq[TypeName] = Nil,
  vendorExtensions: Option[VendorExtensions] = None)
      
      

sealed trait Direction

object Direction {
  def fromString(value: String, scope: scala.xml.NamespaceBinding)(implicit fmt: IPXACT2009scalaxb.XMLFormat[Direction]): Direction = fmt.reads(scala.xml.Text(value), Nil) match {
    case Right(x: Direction) => x
    case x => throw new RuntimeException(s"fromString returned unexpected value $x for input $value")
  }
  lazy val values: Seq[Direction] = Seq(InValue, OutValue, InoutValue)
}

case object InValue extends Direction { override def toString = "in" }
case object OutValue extends Direction { override def toString = "out" }
case object InoutValue extends Direction { override def toString = "inout" }


case class Qualifier(qualifieroption: Option[IPXACT2009scalaxb.DataRecord[Any]] = None)
      
      

trait QualifierOption
case class QualifierSequence1(isAddress: Option[Boolean] = None,
  isData: Option[Boolean] = None)
      


case class OnSystem(group: String,
  wirePortSequence2: WirePortSequence)
      
      


case class OnMaster(wirePortSequence1: WirePortSequence)
      
      


case class OnSlave(wirePortSequence1: WirePortSequence)
      
      


case class Wire(qualifier: Option[Qualifier] = None,
  onSystem: Seq[OnSystem] = Nil,
  onMaster: Option[OnMaster] = None,
  onSlave: Option[OnSlave] = None,
  wireoption: Option[IPXACT2009scalaxb.DataRecord[Any]] = None) extends PortOption
      
      

trait WireOption

case class Qualifier2(isAddress: Option[Boolean] = None,
  isData: Option[Boolean] = None)
      
      


case class OnSystem2(group: String,
  transactionalPortSequence2: TransactionalPortSequence)
      
      


case class OnMaster2(transactionalPortSequence1: TransactionalPortSequence)
      
      


case class OnSlave2(transactionalPortSequence1: TransactionalPortSequence)
      
      


case class Transactional(qualifier: Option[Qualifier2] = None,
  onSystem: Seq[OnSystem2] = Nil,
  onMaster: Option[OnMaster2] = None,
  onSlave: Option[OnSlave2] = None) extends PortOption
      
      


case class Port(logicalName: String,
  displayName: Option[String] = None,
  description: Option[String] = None,
  portoption: IPXACT2009scalaxb.DataRecord[PortOption],
  vendorExtensions: Option[VendorExtensions] = None)
      
      

trait PortOption

case class Ports3(port: Seq[Port] = Nil)
      
      


case class AbstractionDefinition(versionedIdentifierSequence1: VersionedIdentifierSequence,
  busType: LibraryRefType,
  extendsValue: Option[LibraryRefType] = None,
  ports: Ports3,
  description: Option[String] = None,
  vendorExtensions: Option[VendorExtensions] = None) extends IPXACTDocumentTypesOption
      
      

case class WirePortSequence(presence: Option[Presence] = None,
  width: Option[BigInt] = None,
  direction: Option[Direction] = None,
  wireportsequence2: Option[WirePortSequence2] = None)
      

case class WirePortSequence2(modeConstraints: AbstractionDefPortConstraintsType,
  mirroredModeConstraints: Option[AbstractionDefPortConstraintsType] = None)
      

case class TransactionalPortSequence(presence: Option[Presence] = None,
  service: ServiceType)
      

